/************************************************************************/
/*      Copyright (C) 1996 - 1998 Foundry Networks                                                      */
/*      Unpublished - rights reserved under the Copyright Laws of the           */
/*      United States.  Use, duplication, or disclosure by the                          */
/*      Government is subject to restrictions as set forth in                           */
/*      subparagraph (c)(1)(ii) of the Rights in Technical Data and             */
/*      Computer Software clause at 252.227-7013.                                                       */
/*      Cmds.c                                                              */
/*              Switch CLI (Command Line Interface) main program.               */
/*              For configure-gen, for any long keyword, we will only write     */
/*              shorter unique keyword to the flash (32k flash for Router,      */
/*              16k flash for Switch).                                                                                  */
/************************************************************************/

#ifndef DISABLED_4_NI_L3
#define c_ip_l2mcast_age_int                               cmds_c_ip_l2mcast_age_int
#define c_ip_l2mcast_boundary                              cmds_c_ip_l2mcast_boundary
#define c_ip_l2mcast_boundary_portlist                     cmds_c_ip_l2mcast_boundary_portlist
#define c_ip_l2mcast_global_version                        cmds_c_ip_l2mcast_global_version
#define c_ip_l2mcast_igmp                                  cmds_c_ip_l2mcast_igmp
#define c_ip_l2mcast_pim_proxy_int                         cmds_c_ip_l2mcast_pim_proxy_int
#define c_ip_l2mcast_policy_map                            cmds_c_ip_l2mcast_policy_map
#define c_ip_l2mcast_profile_acl                           cmds_c_ip_l2mcast_profile_acl
#define c_ip_l2mcast_query_int                             cmds_c_ip_l2mcast_query_int
#define c_ip_l2mcast_static_exclude                        cmds_c_ip_l2mcast_static_exclude
#define c_ip_l2mcast_static_exclude_options                cmds_c_ip_l2mcast_static_exclude_options
#define c_ip_l2mcast_static_group                          cmds_c_ip_l2mcast_static_group
#define c_ip_l2mcast_static_group_options                  cmds_c_ip_l2mcast_static_group_options
#define c_ip_l2mcast_static_include                        cmds_c_ip_l2mcast_static_include
#define c_ip_l2mcast_static_include_options                cmds_c_ip_l2mcast_static_include_options
#define c_vlan_l2mcast                                     cmds_c_vlan_l2mcast
#define c_vpls_l2mcast_policy_map                          cmds_c_vpls_l2mcast_policy_map
#define c_vpls_l2mcast_profile_acl                         cmds_c_vpls_l2mcast_profile_acl
#define e_clear_l2mcast                                    cmds_e_clear_l2mcast
#define e_clear_l2mcast_vlan                               cmds_e_clear_l2mcast_vlan
#define e_clear_l2mcast_vlan_grp                           cmds_e_clear_l2mcast_vlan_grp
#define e_clear_l2mcast_vlan_grp_addr                      cmds_e_clear_l2mcast_vlan_grp_addr
#define e_clear_l2mcast_vpls                               cmds_e_clear_l2mcast_vpls
#define e_clear_l2mcast_vpls_grp                           cmds_e_clear_l2mcast_vpls_grp
#define e_clear_l2mcast_vpls_grp_addr                      cmds_e_clear_l2mcast_vpls_grp_addr
#define e_l2mcast_show_igmp                                cmds_e_l2mcast_show_igmp
#define e_l2mcast_show_igmpv3_tracking_vlan                cmds_e_l2mcast_show_igmpv3_tracking_vlan
#define e_l2mcast_show_igmpv3_tracking_vlan_grp            cmds_e_l2mcast_show_igmpv3_tracking_vlan_grp
#define e_l2mcast_show_igmpv3_tracking_vlan_vpls           cmds_e_l2mcast_show_igmpv3_tracking_vlan_vpls
#define e_l2mcast_show_igmpv3_tracking_vpls                cmds_e_l2mcast_show_igmpv3_tracking_vpls
#define e_l2mcast_show_igmpv3_tracking_vpls_grp            cmds_e_l2mcast_show_igmpv3_tracking_vpls_grp
#define e_l2mcast_show_igmpv3_vlan                         cmds_e_l2mcast_show_igmpv3_vlan
#define e_l2mcast_show_igmpv3_vlan_grp                     cmds_e_l2mcast_show_igmpv3_vlan_grp
#define e_l2mcast_show_igmpv3_vlan_vpls                    cmds_e_l2mcast_show_igmpv3_vlan_vpls
#define e_l2mcast_show_igmpv3_vpls                         cmds_e_l2mcast_show_igmpv3_vpls
#define e_l2mcast_show_igmpv3_vpls_grp                     cmds_e_l2mcast_show_igmpv3_vpls_grp
#define e_l2mcast_show_mdb_vlan                            cmds_e_l2mcast_show_mdb_vlan
#define e_l2mcast_show_mdb_vlan_grp                        cmds_e_l2mcast_show_mdb_vlan_grp
#define e_l2mcast_show_pim_vlan                            cmds_e_l2mcast_show_pim_vlan
#define e_l2mcast_show_pim_vlan_grp                        cmds_e_l2mcast_show_pim_vlan_grp
#define e_l2mcast_show_pim_vlan_vpls                       cmds_e_l2mcast_show_pim_vlan_vpls
#define e_l2mcast_show_pim_vpls                            cmds_e_l2mcast_show_pim_vpls
#define e_l2mcast_show_pim_vpls_grp                        cmds_e_l2mcast_show_pim_vpls_grp
#define e_l2mcast_show_static_entries                      cmds_e_l2mcast_show_static_entries
#define e_l2mcast_show_stats_vlan                          cmds_e_l2mcast_show_stats_vlan
#define e_l2mcast_show_stats_vlan_vpls                     cmds_e_l2mcast_show_stats_vlan_vpls
#define e_l2mcast_show_stats_vpls                          cmds_e_l2mcast_show_stats_vpls
#define e_l2mcast_show_vlan_static_entries                 cmds_e_l2mcast_show_vlan_static_entries

#define e_ssh_display_encrypt                                                                                           cmds_e_ssh_display_encrypt
#define c_ssh_key_conf                                                                                                  cmds_c_ssh_key_conf
//#define crypto_conf                                                                                                     cmds_crypto_conf
#define c_ip_ssh_source_interface_physical                                                                              cmds_c_ip_ssh_source_interface_physical
#define c_ip_ssh_source_interface_ve_or_lb                                                                              cmds_c_ip_ssh_source_interface_ve_or_lb
#define c_ip_ssh_source_interface                                                                                       cmds_c_ip_ssh_source_interface
#define c_ssh_scp                                                                                                       cmds_c_ssh_scp
#define c_ssh_key_auth                                                                                                  cmds_c_ssh_key_auth
#define c_ssh_authentication_retries                                                                                    cmds_c_ssh_authentication_retries
#define c_ssh_port                                                                                                      cmds_c_ssh_port
#define c_ssh_password_authentication                                                                                   cmds_c_ssh_password_authentication
#define c_ssh_permit_empty_passwd                                                                                       cmds_c_ssh_permit_empty_passwd
#define c_import_dss_pub_key_from_tftp_ip                                                                               cmds_c_import_dss_pub_key_from_tftp_ip
#define c_import_dss_pub_key_from_tftp_ipv6                                                                             cmds_c_import_dss_pub_key_from_tftp_ipv6
#define c_import_dss_pub_key_from_tftp                                                                                  cmds_c_import_dss_pub_key_from_tftp
#define c_ssh_import_pub_key                                                                                            cmds_c_ssh_import_pub_key
#define c_ssh_idle_time                                                                                                 cmds_c_ssh_idle_time
#define c_ssh_login_timeout                                                                                             cmds_c_ssh_login_timeout
#define c_ssh_client_mac                                                                                                cmds_c_ssh_client_mac
#define c_ssh_client                                                                                                    cmds_c_ssh_client
//#define c_ssh_server                                                                                                    cmds_c_ssh_server
#define i_ipv6_mld_port_version_port_list                                                                               cmds_i_ipv6_mld_port_version_port_list
#define i_ipv6_mld_port_version                                                                                         cmds_i_ipv6_mld_port_version
#define e_show_ipv6_mld_group_detail                                                                                    cmds_e_show_ipv6_mld_group_detail
#define         mstp_pim_set_reselect           cmd_mstp_pim_set_reselect
#define         mstp_pim_gate           cmd_mstp_pim_gate
#define         mstp_pim_init           cmd_mstp_pim_init

#define c_ssh_client_keys_gen_modulus_size                                  cmds_c_ssh_client_keys_gen_modulus_size
#define c_ssh_client_keys_gen_modulus                                       cmds_cc_ssh_client_keys_gen_modulus
#define c_ssh_client_keys_gen                                               cmds_cc_ssh_client_keys_gen
#define c_ssh_client_keys_del                                               cmds_cc_ssh_client_keys_del
#define c_ssh_client_key_conf                                               cmds_cc_ssh_client_key_conf
#define c_ssh_key_conf_hostkeys_gen_modulus_size                            cmds_cc_ssh_key_conf_hostkeys_gen_modulus_size
#define c_ssh_key_conf_hostkeys_gen_modulus                                 cmds_cc_ssh_key_conf_hostkeys_gen_modulus
#define c_ssh_key_conf_hostkeys_gen                                         cmds_cc_ssh_key_conf_hostkeys_gen
#define c_ssh_key_conf_hostkeys_del                                         cmds_cc_ssh_key_conf_hostkeys_del
#define e_ssh_port                                                          cmds_ce_ssh_port
#define e_ssh_auth_key                                                      cmds_ce_ssh_auth_key
#define e_ssh_auth                                                          cmds_ce_ssh_auth
#define e_ssh_addr6_int_enet                                                cmds_ce_ssh_addr6_int_enet
#define e_ssh_addr6_int_ve                                                  cmds_ce_ssh_addr6_int_ve
#define e_ssh_addr6_int                                                     cmds_ce_ssh_addr6_int
#define e_ssh_addr6                                                         cmds_ce_ssh_addr6
#define e_ssh_addr6_auth_key                                                cmds_ce_ssh_addr6_auth_key
#define e_ssh_addr6_auth                                                    cmds_ce_ssh_addr6_auth
#define e_ipv6_ssh                                                          cmds_ce_ipv6_ssh
//#define e_ssh_client                                                        cmds_ce_ssh_client
#define i_poe_power_class                                                   cmds_ci_poe_power_class
#define i_poe_power_limit                                                   cmds_ci_poe_power_limit
#define i_poe_power_spec                                                    cmds_ci_poe_power_spec
#define i_poe_priority                                                      cmds_ci_poe_priority
#define i_poe_spec                                                          cmds_ci_poe_spec
#define i_poe                                                               cmds_ci_poe
#define i_mif_poe_power_class                                               cmds_ci_mif_poe_power_class
#define i_mif_poe_power_limit                                               cmds_ci_mif_poe_power_limit
#define i_mif_poe_power_spec                                                cmds_ci_mif_poe_power_spec
#define i_mif_poe_priority                                                  cmds_ci_mif_poe_priority
#define i_mif_poe_spec                                                      cmds_ci_mif_poe_spec
#define i_mif_poe                                                           cmds_ci_mif_poe
#define c_legacy_inline_power                                               cmds_cc_legacy_inline_power
#define e_show_poe_stack_debug_info                                         cmds_ce_show_poe_stack_debug_info
#define e_show_poe_detail_stack_debug_info                                  cmds_ce_show_poe_detail_stack_debug_info
#define e_show_poe_detail_stack                                             cmds_ce_show_poe_detail_stack
#define e_show_poe_detail                                                   cmds_ce_show_poe_detail
#define e_show_poe                                                          cmds_ce_show_poe


#endif DISABLED_4_NI_L3
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#ifndef FINI_LINUX
#include <stdlib.h>
#endif

#ifdef SIDEWINDER_LINUX
#define HITLESS_USR_ENABLE
#include "cpld.h"
#include "acl_PBR_Itc_Msg_Objects.h"
#endif

#include "kstart.h"

#include "vstacking.h"
#include "KHWDEF.H"
#include "ktftp.h"
#include "vflash.h"
#include "vchar_io.h"
#include "vsvint.h"
#include "vintuart.h"

#include "kmalloc.h"
#include "parser.h"

//NIL3
#include "snmp_func.h"
#include "cu_snmp.h"

#include "cmds.h"
#include "sha.h"
#include "kmd.h"
#include "tftpitc.h"
#include "lag_api.h"

#include "arpinspec_cmds.h"
#include "dhcpsnoop_cmds.h"
#include "dhcpsnooptable.h"
#include "sourceguard_cmds.h"
#include "vipsecstr.h"
#include "brcd_crypto.h"
#include "sw_pp_route.h"
#include "cu_access.h"
#include "vipdns6st.h"

#include "debugstruct.h"
extern DEBUG_GLOBAL debugGlobal;
#include "sw_pp_link.h"
#include "show_cam_cmds.h"

#include "sw_gi_extern.h"

#ifdef __OSPF__
#include "ospf.h"
#endif /* __OSPF__ */
#ifdef __OSPFV3__
#include "ospf6.h"
#endif /*__OSPFV3__*/

#include "sw_pp_extern.h"
#include "sw_mport.h"
#include "monitor.h"

#ifdef __GVRP_SUPPORT__
#include "gvrp_cmds.h"
#endif __GVRP_SUPPORT__

#ifndef NO_L4_NAME_ACL
#include "acl_cmd1.h"
#endif NO_L4_NAME_ACL

#include "ext.h"
#include "sw.h"
#include "sw_pp_link.h"
#include "ip.h"
#include "vsvint.h"
#include "vipdnsst.h"
#include "vsntpst.h"
#include "install.h"
#ifdef NETFLOW
#include "netflow.h"
#endif NETFLOW

#include "vipport.h"
#include "snmpdefs.h"
#include "sw_sxr_red.h"
//#include "sw_pp_route.h"
#define PP_MAX_PCL_ACTION       1024
#include <dirent.h>
#include <errno.h>

#include "Stacking_dnld.h"
#include "rconsole.h"
#include "chassis.h"
#include "stacking_util.h"
#include "stacking_ssur.h"

#include "vflash.h"
#include "sw_mac_auth.h"

#ifdef FI_LINUX
#include "sil_external.h"
#include <sys/stat.h>

#endif /* FI_LINUX */

// Needed for Jumbo Mode related checks
#include "sw_inf_fi_cpu_bm_wrapper_lib.h"
#include "acl_include.h"
#include "syslog.h"

#include "ntp_cmds.h" /* NTP commands */
#include "ipv6_funcs.h"
#include "lag.h"
#include "rip.h"
//#include "mac_notification_trap.h"
#ifdef SIDEWINDER_LINUX
#include "chassis_stk_SW.h"
extern UINT8 g_pfc_global_status;
#ifdef SIDEWINDER_BREAKOUT
extern int get_subport_fourth_tuple (PORT_ID port);
extern PORT_ID get_breakoutPort_from_swport(PORT_ID port);
extern int is_phy_84328_chip_A0(PORT_ID port);
int g_show_breakout_running;
int g_breakout_startup_done = NULL;
extern void startup_breakout_init_check(UINT8 *line, UINT32 ui_port);
#endif
#endif 

#ifndef FI_EEE_MGMT 
#include "sw_pp_eeemgmt.h"
#endif 

#ifdef FIOFL_INCLUDE
#include "openflow_ofm_config.h"
#endif FIOFL_INCLUDE

#include "erlb_include.h"

#ifdef SR_SWITCH_ROUTER 
#ifdef SIDEWINDER_LINUX
#include "sw_pp_mirror.h"
#endif SIDEWINDER_LINUX
#endif SR_SWITCH_ROUTER 

extern GT_BOOL show_tech_in_progress;
extern void show_tech_time_stamp_header(GT_BOOL header,char * cmd,char * context,int ui_port);
extern int SET_TRUNK_FI_CLI_ONLY;
extern MAC_ADDRESS                              tunnel_group_address;
#include "varpstr.h"

extern ARP_CLASS arp;

#ifdef FI_LINUX
extern void parse_input(int session, enum CMD_LINE_STATUS help_request, enum BOOLEAN invoked_by_aaa);
extern void set_if_speed_and_duplex_to_default_value(struct cdb* sptr_cdb);
#endif /* ifdef FI_LINUX */

#if defined(SIDEWINDER_LINUX)
extern int sil_populate_usb_info(void);
extern int g_internal_usb_id;
extern int g_external_usb_id;
extern USB_DEVICES g_usb_devices;
#endif /* SIDEWINDER_LINUX*/

extern UINT8 dot1x_flag_for_use_parse_configBuf;
int is_platform_got_port_pair_limitation(void);

#ifdef __PORT_EXTENSION__
extern void csp_show_all(struct cdb* sptr_cdb);
extern void csp_show_specific(struct cdb* sptr_cdb);
extern void csp_show_events(struct cdb* sptr_cdb);
extern UINT32 is_port_spx_configured(PORT_ID port);
#endif 

#ifdef FIPS_PASSWD_MASK
extern UINT8 okay_to_accept_password ();
#endif

#ifndef __NO_TIMERS_BASIC__
#define TB_IN_USE        0xa
#define TB_NOT_IN_USE    0xb
#endif /* __NO_TIMERS_BASIC__ */

#ifndef NO_DELAY_PARSE_ACL
extern void l4_acl_delay_init1(UINT32 ui_port);
extern void l4_acl_delay_filter_proc(UINT32 ui_port);
extern void *delay_filter_timer_id;
extern UINT16 rebind_acl_ids[];
extern UINT16 rebind_acl_count;         /* 0 based */
extern UINT16 rebind_acl_index;
extern UINT8 acl_batch_mode;
#endif NO_DELAY_PARSE_ACL
UINT8   g_copy_tftp_acl;
extern UINT32 g_ntp_startup_time;
extern int sys_rtc_synced_up;
extern UINT8 g_active_enable_acl_per_port_per_vlan;
extern int debug_port_ctrl;
extern int PORTCTRL_DEBUG_PORTS(UINT16 port_id);
extern int maximum_ip_ports;
#ifdef FIPS_PASSWD_MASK
extern struct node c_sntp_server_host_auth[];
extern struct node c_sntp_server_mode_auth_key[];
extern struct node c_sntp_server_ip_auth[];
#endif

#define CB_STATE 16
void cu_set_tech_cb_state(int, int);
#ifdef SR_SWITCH_ROUTER
extern void cu_show_tech_l3_support(struct cdb* );
#endif
#ifdef SR_SWITCH_ROUTER
void cu_show_tech_ip_traffic(void);
#endif
#ifdef SR_SWITCH_ROUTER
#ifndef __BASE_L3__
#ifndef __NO_VRRPE__

void show_tech_ipv4_vrrp_brief(struct cdb*);
void show_tech_ipv6_vrrp_brief(struct cdb*);
#endif
#endif
#endif
//NIL3
extern int maximum_ip_ports;
extern void ip_show_routing_table(UINT32 lines_to_skip);

#ifndef OFFICIAL_RELEASE
extern unsigned char fl_access_set_tracebuf[];
#endif

#ifdef SR_SWITCH_ROUTER
#include "static_cmds.h"
#include "fpip.h"
#include "ipfilter.h"
#ifndef FINI_LINUX
#include "ip_cu.h"
#endif
#ifdef __FSRP__
#include "fsrp.h"
#include "fsrp_cu.h"
#endif /* __FSRP__ */
#include "vrrpcmds.h"
#include "ve_map.h"
#else
#ifndef NO_VSRRP
#include "vrrpcmds.h"
#endif NO_VSRRP
#ifndef L3_NO_FILTER
#include "ipfilter.h"
#endif  /* L3_NO_FILTER */
#endif  /* SR_SWITCH_ROUTER */

#ifdef INCLUDE_MCT
#include "cluster.h"
#include "cluster_externs.h"
extern CLUSTER_ENTRY* clusterlib_get_entry_from_id(UINT16 cluster_id);
extern CLUSTER_ENTRY* clusterlib_get_entry_from_name(UINT8 *input_name);
#endif INCLUDE_MCT
#include "telnet.h"
#include "bootp.h"
#include "tftp.h"
#include "tftp_cl.h"
#include "mibleaf.h"
#include "agntree.h"
#include "vicmpstr.h"
#include "snmptrap.h"
#include "http.h"

#include "aghlst.h"
#include "tcp.h"
#include "hw_cmds.h"

#include "cu_aaa.h"
#include        "tacacs.h"

#ifdef __LLDP__
#include "lldp_cmds.h"
#endif __LLDP__
#ifdef __FDP__
#include "fdp_cmds.h"
#endif /* __FDP__ */
#include "kmd.h"
#include "poe_cmds.h"

#ifdef FI_LOAM
#include "link_oam_lp.h"
#endif

#ifdef LINK_REFACTORING
#include "features_capabilities_external.h"
#endif

/*********************************************************************************************
***** ACTD-Transaction-Manager's CLI DM Commands are Platform Agnostic                   *****
***** These CLI Commands are required to work on all Platforms                           *****
***** These Commands would work for All Topologies [Stacking, Port-Extender, Standalone] *****
**********************************************************************************************/
#include "adm_ParseNode_Cli_AllTM_Cmds.h"

/*********************************************************************************************
***** ACL-PEHS-Manager's CLI DM Commands are Platform Agnostic                           *****
***** These CLI Commands are required to work on all Platforms                           *****
***** These Commands would work for All Topologies [Stacking, Port-Extender, Standalone] *****
**********************************************************************************************/
#include "ghm_PEHS_PN_Cli_All_Cmds.h"
#include "acl_PBRouting_Validation_API.h"


const char                      *g_startup_config_legacy = "startup-config.legacy";
int downgrade_cli_issued = 0;


#define SYS_BM_IOCTL_MAC_HASH_SET               0xa
extern struct node c_logging_port[];
extern struct node c_logging_name_port[];
extern struct node c_logging_port_ip6[];
extern struct node c_telnet_acl[];
extern struct node c_web_acl[];
extern struct node c_acl[];
extern struct node i_ip_access[];
extern struct node i_ip_dscp_remark[];
extern struct node i_ip_pcp_remark[];
extern struct node e_show_ip_acl[];
extern struct node e_show_poe_detail[];
extern struct node execute[];
extern struct node g_fi_config[], c_snmp_trap[];
extern struct node      c_router[];
extern struct node      e_show_ip[];
extern struct node      i_ip [];
extern struct node      e_clear [];
extern struct node	e_spxmon[];

extern UINT32 sys_tftp_disabled;
extern UINT8 g_ip6_dns_aaaa;
#include "vrrpcmds.h"
extern UINT32  g_AutoCopy_BitMask_homogenous;
extern UINT32  g_AutoCopy_BitMask_katara;

extern UINT16 ip_access_vlan_id;

//extern DNS6_CLASS dns6;

extern void show_system_memory_info(int);
void cli_show_tech_l2(struct cdb* sptr_cdb);
#ifdef INCLUDE_MCT
void cli_show_tech_cluster(struct cdb* sptr_cdb);
#endif //INCLUDE_MCT
void cli_show_tech_vlan(void);
void cli_show_tech_pvlan(void);
void show_tech_flash(struct cdb* sptr_cdb);
void cli_show_tech_memory(struct cdb* sptr_cdb);
void cli_show_tech_license(struct cdb * sptr_cdb);
void show_interfaces_brief_wide(struct cdb * sptr_cdb);
void cli_show_tech_multicast(struct cdb* sptr_cdb);
void cli_show_tech_stack(struct cdb* sptr_cdb);
void cli_show_tech_cpu(struct cdb* sptr_cdb);
void cli_show_tech_packet_loss(struct cdb* sptr_cdb);
void cli_show_tech_la(struct cdb* sptr_cdb);
void dm_set_poe_save_config(struct cdb *sptr_cdb);
void dm_set_poe_auto_recovery(struct cdb *sptr_cdb);
void dm_get_poe_sw_version(struct cdb *sptr_cdb);
void cli_set_fan_speed_threshold_stack(struct cdb *sptr_cdb);
void cli_set_fan_speed_threshold(struct cdb *sptr_cdb);
void cli_set_ignore_temp_shutdown_unit(struct cdb *sptr_cdb);
void cli_set_ignore_temp_shutdown_global(struct cdb *sptr_cdb);
extern struct node e_clock[], e_sntp[], c_clock[], c_sntp[], e_whois[], c_enable[], c_logging[], c_telnet[], c_telnet1[];
extern struct node c_all_client[], c_snmp_client[], c_telnet_client[], c_tftp_client[], c_sntp_server[], e_clear_logging[];
extern struct node c_sntp_poll_interval[], e_show_sntp[], e_sntp_show_clock[], c_enable_level_encrypted_password[];
extern struct node c_restrict_password_change[];

extern void pbr_clear_config_on_interface(UINT16 port_id);
extern void pbr_apply_global_pbr_after_vrf_change(UINT16 port_id);
extern void cli_ip_access_list(struct cdb* sptr_cdb);

void red_packet_unit_conversion(UINT64 red_packet,UINT32 *converted_value,char **unit);
static enum BOOLEAN sw_BUM_update_port_shutdown_list(int bum_type,PORT_ID port_id);
enum BOOLEAN sw_get_BUM_limit_status (PORT_ID port_id, UINT8 bum_type, UINT32 *cli_limit);
void sw_port_dampening_disable(UINT16 port,int bum_type,enum BOOLEAN trunk_oper);
void sw_BUM_configure_port_dampening(UINT16 port,int type,UINT32 limit,UINT32 thres,UINT32 shut_period, 
	                                 UINT8 enable, UINT8 trunk_oper);
void sw_BUM_clear_all_counter_by_port (PORT_ID port_id);

extern int check_is_virtual(PORT_ID port,char* str);
#ifdef SR_SWITCH_ROUTER
extern struct node i_ip_use[];
extern void cli_show_ip_arp_acl(struct cdb* sptr_cdb);
extern void cli_clear_acl_on_arp_stat(struct cdb* sptr_cdb);
#endif SR_SWITCH_ROUTER

#include "AsTarget.h"
#include "AsConfig.h"
#include "AsProtos.h"

extern char _etext[], _edata[], _end[];

#include "vsave.h"

#include "flexauth.h"
UINT32 is_crash_freeze = 0;
UINT32  ip_filter_sys_set = 0;
UINT32  ip_filter_port_set = 0;
static UINT8 flw_ctl_print;
static struct node *old_radius_key_ptr;

extern char *config_buffer_ptr[];
extern CONFIG_FILE   g_config_file;
extern void init_vlan_group(void);
int g_macAuth_toggle_hw_drop_NA = 0;
UINT8 g_stk_sync_lock_cli = FALSE;
UINT8 standby_finish_parsing_in_one_shot;
extern int g_fs_k_image;
int g_fs_sig_katara_h = FALSE;
int g_fs_sig_chow = FALSE;
int is_stk_clean_cfg(void);
enum FLASH_DATA_TYPE g_file_type;
SV_TIMER_TOKEN_T sync_lock_cli_timer; // protection, always turn it off in 30 seconds

#ifdef __GRE_IP_TUNNEL__
extern enum BOOLEAN is_GRE_IPv4_over_IPv4_tunnel_Mode_Configured();
#endif __GRE_IP_TUNNEL__
void   parse_boot_config_command(char *config_buf);
void   e_extern_config_refresh(struct cdb* sptr_cdb);
int    release_in_cb_flag = 0;
UINT8 g_base_module_no_match; // CHEETAH_STACKING
extern STK_AUTH_INFO g_stk_auth_info;
unsigned int g_dist_parse_ui_port = 0;
extern void dnld_send_boot_env_update_msg(UINT8 stack_id, UINT32 boot_source, UINT32 tftp_server_ip, UINT8 *tftp_file_name);

extern UINT8 trunk_init_in_progress;

static enum BOOLEAN is_reload_required = FALSE;

char g_copy_image_name[32];
/******* Fan Trunk enhancement ********/
UINT32  g_mirror_list[MAX_MIRRORS];

#ifdef RATE_LIMIT_VLAN
#include "vlan_rl.h"
#endif RATE_LIMIT_VLAN

#ifdef RATE_LIMIT_VLAN
extern VLAN_ACCESS_TABLE **vlan_access_table;
#endif RATE_LIMIT_VLAN

#ifdef MPLS
#include "mpls_cmds.h"
extern void ip_route_print_mpls_tnnl(UINT16 myport, UINT8 *sptr_buf);
#endif MPLS

extern enum BOOLEAN hal_brd_show_bytes_error(UINT16 port);
extern enum BOOLEAN hal_unknown_unicast_show_bytes_error(UINT16 port);
extern void fpip_show_route_cache(UINT32);
extern void fpip_show_route_cache_resource (void);

void parse_decimal_list(struct cdb* sptr_cdb, void (*call_back)(struct cdb *), char *help_string);
void cli_log_config_changed(UINT32 ui_port, UINT8 startup_config);

enum BOOLEAN cu_is_reload_required();
void cu_set_is_reload_required(enum BOOLEAN val);
static int cli_check_mode_conflict_for_protocol(struct cdb* sptr_other_cdb, enum parser_mode this_mode, struct cdb*sptr_this_cdb);
int cli_is_mode_conflict_found(struct cdb* sptr_cdb, enum parser_mode mode);

extern int boot_ReadFileHeader(VHEADER *header, char *cp);
extern int is_diag_on();
extern int is_alt_diag_on();

/******* Fan Trunk enhancement ********/
extern void set_trunk_mon_port(PORT_ID port_id, PORT_ID mir_port, UINT8 dir, UINT8 no);
extern void trunk_init_check_mirror(UINT8 *line, UINT32 ui_port);

#ifdef NOT_USED
void security_parser(UINT8 root_node, UINT8 action);
#endif NOT_USED


/* command table */
/* following for dump memory */
#ifdef MANU_DIAG
extern void stopdiag();
extern void switchmode();
extern void p_startdiag(struct cdb *cdb);
extern void p_startdiag1(struct cdb *cdb);
extern void p_startdiag2(struct cdb *cdb);
extern void p_startdiag3(struct cdb *cdb);
#endif

extern UINT8 is_stack(void);

static UINT8 default_encrypted_level4_password[CU_MAX_LENGTH_OF_PASSWORD+1];
static UINT8 default_encrypted_level5_password[CU_MAX_LENGTH_OF_PASSWORD+1];
static UINT8 tftp_run_parser_mode=0;

int g_show_password = 0;
int g_min_password_length = CU_MIN_LENGTH_OF_PASSWORD;

SYSMON_INFO sm;  //define sytem monitor struct;
// SYSMON_INFO sm_default = {TRUE,TRUE,3,NULL};
extern UINT8 sw_get_phy_mode(PORT_ID port_id);
extern void sw_set_phy_mode(PORT_ID port_id, UINT8 mode);
extern void change_boot_name();
extern void cancel_command_line(int);
extern void dump_memory(struct cdb *cdb);
extern void p_dset(struct cdb *cdb);
extern void dm_save_area();
extern void dm_list_save_areas(unsigned char n);
extern UINT8 print_port_type[MAX_IO_CB];
extern void cu_show_enet_interface_header(UINT8 print_to_buf);
extern void cu_show_ethernet_interface(UINT16 port_index, UINT8 print_to_buf);
extern void cu_show_ip_l3cache(UINT32 *addr, UINT32 *mask);
int valid_integer1_value_range(struct cdb* sptr_cdb, UINT32 min, UINT32 max);
int valid_integer_any_value_range(UINT32 integer, UINT32 min, UINT32 max);
void clear_ip_cache_all(struct cdb* sptr_cdb);
extern void l3_show_ip_filter_cache(UINT32 *addr, UINT32 *mask);
extern void l3_show_ip_traffic();
void    set_tag_type(struct cdb *cdb);
void    set_tag_profile(struct cdb *cdb); // CHEETAH_STACKING, BUGID:81495
#ifdef SR_SWITCH_ROUTER
void    cli_set_trap_bad_checksum(struct cdb *cdb);
#endif SR_SWITCH_ROUTER

extern UINT32 tftp_buffer;
extern struct flash_control_block *sptr_flash_cb; /* flash of the current operation */
extern int data_watch_crash;
extern int dm_cpu;

extern int is_fluffy_supported(PORT_ID port);

/* #ifdef SR_SWITCH_ROUTER
extern void  l3mcast_cleanup_hitless_func ();
#endif SR_SWITCH_ROUTER*/

char g_mcrep_range_string[15];

#include "test_cmd.h"


#ifdef SM_COMMON
#include "fmp.h"

#ifdef SM_MASTER
#include "smhdr.h"
#include "fmpmast.h"
#include "smcmds.h"
extern FMP_DATA_CACHE_T fmp;
extern SM_SLAVE_DATA    g_sm_slave[];
void cli_report_slave_flash_hw(int slave_index);
#else
#include "fmpslave.h"
#include "smcmds.h"
#endif SM_MASTER
#endif SM_COMMON



#include "port_cmds.h"
#include "ac_cmds.h"
#ifdef SR_SWITCH_ROUTER
#ifdef __TUNNEL_INTERFACE__
#include "tunnel_cmds.h"
#endif __TUNNEL_INTERFACE__
//NIL3, commenting FI of_cmds.h
//#include "of_cmds.h"
//#include "..\..\mucho\mp\cmds\of_cmds.h"
//#include "..\..\mucho\mp\cmds\rip_cmds.h"
#include "../../mucho/mp/cmds/rip_cmds_func.h"

#ifdef __FSRP__
#include "fsrp_cmds.h"
#endif __FSRP__
#ifdef __FOUNDRY_BGP__
#include "bgp.h"
#include "bgp_func.h"

// NIL3 commented to solve linker warnings
//#include "bgp_cmds.h"

#endif /*__FOUNDRY_BGP__*/
#ifdef __ISIS__
#include "isis.h"
#include "is_cmds.h"
#endif /*__ISIS__*/
#include "cmd11.h"
#include "cmd10.h"
#include "cmd9.h"
#else
#ifndef L3_NO_FILTER
#include "cmd11.h"
#include "cmd10.h"
#include "cmd9.h"
#endif L3_NO_FILTER
#endif /* SR_SWITCH_ROUTER */

void cli_show_ssh(struct cdb *sptr_cdb);
void cli_ssh_clear_dss_pub_key(struct cdb* sptr_cdb);
void cli_ssh_show_dss_pub_key(struct cdb* sptr_cdb);

#include "ssh_PA_Cli_All_API.h"

#ifdef NI_SLB
#include "ni_slb_cmds.h"
#endif

#ifdef POLICY_MAP
#include "policy_cmds.h"
#endif

#ifdef __L4MON__
extern struct node c_l4monHistoryIndex[];
extern struct node c_rserver_history_group[];
extern struct node c_vserver_history_group[];
#endif  /* __L4MON__ */

#ifdef SLAVE_SUPPORT
#include "rel_msg_cmds.h"
extern UINT32 wait_for_bps_before_enable;
#endif SLAVE_SUPPORT

//#ifdef __QOS__
#include "qos_cmds.h"
//#endif        /* __QOS__ */

//#ifdef __FAST_SPAN__
#include "fastspan_cmds.h"
extern void     sw_vlan_update_fast_span(UINT8 fast_span);
//#endif /* __FAST_SPAN__ */

//#ifdef __FAST_UPLINK__
#include "fastuplink_cmds.h"
//#endif /* __FAST_UPLINK__ */

#ifdef __GSLB__
#include "gslb_cmds.h"
#endif __GSLB__

#ifdef PIM_SM
#include "pimsm.h"
#endif

#ifdef FN_MSDP
//#include "msdp_cmds.h"
#endif /* FN_MSDP */

#ifdef __PIM__
//#include "pimsm_cmds.h"
#endif


// IGMPV3_SNOOP, keep this as marker for easy porting
#include "igmp_cmds.h"
#include "mstp_cmds.h"
#ifdef INCLUDE_MCT
#include "cluster_cmds.h"
#endif //INCLUDE_MCT
#include "vlan_cmds.h"
#include "trunk_cmds.h"

#ifdef __IPSEC__
#include "ipsec_func.h"
#include "ipsec_cmds.h"
#endif /*__IPSEC__*/

#ifdef __IPV6__
#ifdef __NAT_PT__
#include "natpt_func.h"
#include "natpt_cmds.h"
#endif /*__NAT_PT__*/
#ifdef __IPV6_ACL_EXT__
#include "acl_IPv6_PA_Cli_Config_Cmds.h"
#include "acl_IPv6_PN_Cli_Config_Cmds.h"
#endif /*__IPV6_ACL_EXT__*/
#ifdef __OSPFV3__
#include "ipv6_ospf6_func.h"
#include "ipv6_ospf6_cmds.h"
#endif /*__OSPFV3__*/
#include "mcast6_cmds_func.h"

#include "ipv6_funcs.h"
#include "acl_RAG_PN_Cli_Cmds.h"
#include "ipv6_cmds.h"
#endif __IPV6__
#include "stacking_cmds.h" // CHEETAH_STACKING
#ifdef SR_SWITCH_ROUTER
#include "l3_unicast_sync.h"
#endif SR_SWITCH_ROUTER

#include "acl_MAC_PN_Cli_All_Cmds.h"
#include "acl_DSCP_PN_Cli_All_Cmds.h"
#include "acl_PCP_PN_Cli_All_Cmds.h"
#include "acl_TPD_PN_Cli_All_Cmds.h"
#include "acl_IPv4_PN_Cli_All_Cmds.h"
#include "ssh_TPF_PN_Cli_Show_Cmds.h"
#include "ssh_TPF_PN_Cli_Clear_Cmds.h"

#ifdef FI_AMPP
#ifdef CHEETAH3_FAMILY_PLATFORM
/* for now VAL supported in FCX switch image only */
#ifndef SR_SWITCH_ROUTER
#include "val_cmds.h"
#endif
#endif
#endif FI_AMPP

UINT32 g_stk_clean_cfg = 0;

#include "cmd8.h"
#include "cmd7.h"
#include "cmd6.h"
#include "cmd5.h"
#include "cmd4.h"
#include "cmd3.h"
#include "cmd2.h"
#include "cmd1.h"

UINT8 g_display_startup_config;

GT_BOOL print_port_name_wide[MAX_IO_CB];

#ifdef FIOFL_INCLUDE
int print_openflow_port[MAX_IO_CB];
#endif FIOFL_INCLUDE


volatile enum BOOLEAN copy_flash_flash_file_callback_status = FALSE;

/* This sting is used to generate the interface MTU help string during run time */
UINT8 ip_mtu_help_string[80];

/*To validate the day for the corresponding month and year */
#define JANUARY 1
#define FEBRUARY        2
#define MARCH   3
#define APRIL   4
#define MAY             5
#define JUNE            6
#define JULY            7
#define AUGUST  8
#define SEPTEMBER       9
#define OCTOBER 10
#define NOVEMBER        11
#define DECEMBER        12
#define THIRTYONE_DAY 31
#define THIRTY_DAY 30
#define FEB_LEAPYEAR_DAY 29
#define FEB_NONLEAPYEAR_DAY 28

static MSG_RATE_LIMIT cmd_complain_rate_limit;

#ifdef SR_SWITCH_ROUTER
/* need to be after the other includes for some reason */
//#include "fpipx.h"
extern int set_group_ve_follow[MAX_IO_CB];


extern void
ip_get_rip_import_table_entry(enum BOOLEAN next_boot_flag,
                              int index,
                              UINT32 *ip_address,
                              UINT32 *subnet_mask,
                              UINT8 *protocol,
                              UINT32 *match_metric,
                              UINT8  *rip_metric,
                              UINT8 *action);

extern int
ip_add_rip_import_table_entry(int index,
                              UINT32 ip_address,
                              UINT32 subnet_mask,
                              UINT8 protocol,
                              UINT32 match_metric,
                              UINT8  rip_metric,
                              UINT8 action);

extern void fpip_flush_cache(void);


extern UINT8 init_in_progress;
#endif /* SR_SWITCH_ROUTER */

extern void set_snmp_server_enable( enum BOOLEAN enable_flag );
unsigned long   digestLen;// = fips_getHashLength(fips_AlgMD5);  /*fips*/

extern int      nt_read_config_file(unsigned char *buffer, int buffer_length);
extern void     nt_write_config_file(unsigned char *buffer, int buffer_length);
extern void gig_chk_blink(int value);
extern void sw_set_auto_buffer_reclaim (UINT8 enable);
extern int is_auto_buffer_reclaim_enabled(void);

#ifdef SR_SWITCH_ONLY
#define NUM_OF_INTERFACES 4
unsigned int if_ip_addr[NUM_OF_INTERFACES];
unsigned int if_ip_mask[NUM_OF_INTERFACES];
#ifdef SYSTEM_TEST
extern void l3_test_new_address_range(UINT16 low, UINT16 high);
extern void l3_test_new_subnet(UINT32 src_subnet, UINT32 dest_subnet, UINT8 *rmac);
extern void l3_traffic_mode(UINT32 cnt);
extern void l3_traffic_go(UINT8 enable);
#endif  /* SYSTEM_TEST */
#ifdef MCAST_SNOOP_PORT_FILTER        //Prashanth
void    set_sw_ip_multicast_if_disable(struct cdb* sptr_cdb);
#endif
#endif /* SR_SWITCH_ONLY */

#ifdef NO_FDRY_HW
extern void dm_display_stack(int size);
#else
extern void dm_display_stack(int size, halt_area_t      *sptr_halt, int remote, UINT32 module_base);
#endif

UINT32 gi_cut_through_enable = 1;
UINT32 gi_cut_through_hw_status = 1;

#define FIRST_HITLESS_VER_NUM_STR "05.0.00"

/* Note - Though below array size is 4, for Katara only 1st element of this
 * array is valid. For rest of the platforms all elements of this array are
 * valid
 */
unsigned char boot_seq[MAX_BOOT_SEQ_ARRSZ];

UINT8   skip_copy_check = 0;    /* check before copy to/from flash */

VHEADER  header;
unsigned int boot_ip;
char boot_file[PARSER_STRING_LEN];
UINT8 katara_fips_boot_env_updated = 0;
unsigned int katara_boot_env_updated = 0;
unsigned int linux_boot_env_updated = 0;


UINT8 no_int_eth_flag = FALSE;  /* use temporary flag to get rid of "incomplete command" log for "no int eth ** eth **" command */

int g_show_realver = 0;
GT_BOOL show_media_in_progress = GT_FALSE;//439356 : Variable is used to exclude vendor specific information in show media command

GT_BOOL show_media_valid_in_progress = GT_FALSE;
extern unsigned int show_media_valid_port_counter;

static void cli_parser_cmd_sys_boot_param(unsigned char *line);

#ifndef NO_SYS_PAR
void cli_parser_cmd_sys_max_param(unsigned char *line);
#endif NO_SYS_PAR

#ifndef FIXED_RESERVE_VLAN_ID
int global_cpu_vlan_id = DEFAULT_CPU_VLAN_ID; // 72032
int global_all_ports_vlan_id = DEFAULT_ALL_PORTS_VLAN_ID; // 72032
void cli_parser_cmd_reserved_vlan_map(unsigned char *line);
#endif  FIXED_RESERVE_VLAN_ID

//unsigned char if_string[PARSER_STRING_LEN]; // 75991, could overwrite.

#ifdef NO_CLIENT_IP
void set_client_ip(UINT8 client, struct cdb* sptr_cdb);
#endif NO_CLIENT_IP

void clear_if_counter(struct cdb* sptr_cdb);

/* configuration data */
unsigned char *config_buffer;

void ping_callback(UINT32 reply_count, UINT32 param);
unsigned char  *ucptr_config_buffer( void );  /* share with Agent -- rkwong */
INT32 agt_prepare_write_mem(UINT8 **buffer ,UINT32 user);  /* share with Agent -- rkwong */
void show_config_callback(UINT32 rcode, struct cdb* sptr_cdb, unsigned char* cp);

static CU_MAC_STATION static_station;
static void set_if_speed_and_duplex(struct cdb* sptr_cdb);
/* only one session is allowed to be in "conf term" mode */
UINT8 config_term_user_count = 0; /* count of users in config mode. */
#ifdef EXCLUSIVE_BUF
/* only one session is allowed to use config_buffer */
int config_buffer_user = -1; /* current "config_buffer" user, -1 means no one is in it */
#endif

#ifndef NO_FDRY_HW
void report_flash_hw();
extern char build_ver[];
extern char boot_name;
#endif

UINT8 optics_sim_event = 0xff;
int optics_simulation = 0;
int optics_sim_stat[8] = {0};

extern UINT8 *boot_copy_buffer;         /* buffer for boot image copy */
extern UINT8 *pos_copy_buffer;          /* buffer for pos image copy */
extern void copy_fslot_to_bootbuf_cb(int session, int error);

extern int dm_slot;
extern int diag_on;
extern int alt_diag_on;
extern UINT32 emi_on;
extern int options_printed[];

char e_telnet_passwd[] = "enable telnet password ";
char e_superuser_passwd[] = "enable super-user-password ";
char e_portconfig_passwd[] = "enable port-config-password ";
char e_readonly_passwd[] = "enable read-only-password ";
char e_community[] = "snmp-server community ";
char e_trap[] = "snmp-server host";

void aaa_save_privilege_level_in_cdb(UINT32 context);
#define PW_USER_REQUEST         1  /* from radius.h */
#define PW_ADMIN_RESET          6  /* from radius.h */
#define PW_USER_ERROR           17 /* from radius.h */
extern void print_ui_port(UINT8 context, char *string);
extern char *get_primary_command(struct cdb* sptr_cdb);
extern AAA_CLASS       aaa;
enum BOOLEAN cli_request_exec_authorization(UINT32 a_ui_port);
enum BOOLEAN cli_request_system_accounting(UINT32 a_ui_port, enum BOOLEAN start_flag);
enum BOOLEAN cli_request_exec_accounting_stop_all(UINT32 a_ui_port);
void cli_aaa_accounting_exec_stop_all_callback(UINT32 rc, UINT32 ui_port);
void console_aaa_exec_accounting_callback(UINT32 rc, UINT32 which_session);
extern char *aaa_get_next_cli_command_from_buffer(UINT8 context);
extern void aaa_free_cli_command_buffer(UINT8 context);
extern UINT32 aaa_get_next_active_session(UINT32 current_session);
void print_prelogin_message_on_console(int ui_port);
enum BOOLEAN sw_BUM_get_drop_count_trunk (PORT_ID port_id, UINT8 bum_type, UINT64 *dropped_pkt_count);
void sw_BUM_update_drop_count_trunk (PORT_ID port_id, UINT8 bum_type, UINT64 dropped_pkt_count);

#ifdef SR_SWITCH_ROUTER
void show_tech_l3_uc_ip(struct cdb*);
void show_tech_l3_uc_bgp(struct cdb*);
void show_tech_l3_uc_v6_ip(struct cdb*);
void show_tech_l3_uc_v6_ospf(struct cdb*);
void show_tech_l3_uc_v6_rip(struct cdb*);
void show_tech_l3_mc(struct cdb*);

#ifdef FIOFL_INCLUDE
void show_tech_of(struct cdb* sptr_cdb);
#endif

void show_tech_l3_uc_ospf(struct cdb*);
void show_tech_l3_uc_rip(struct cdb*);
void show_tech_l3_uc_vrrp(struct cdb*);
#endif
UINT8 g_copy_tftp_runCfg = FALSE;
extern UINT32  tftp_server_ip ;

#ifdef FIPS_PASSWD_MASK
UINT8 g_copy_tftp_runCfg_parse = FALSE;
#endif

/* arp trace particular ip address or port. */
UINT32 g_trace_arp_ipaddr;
USHORT g_trace_arp_port;

UINT8 g_trap_bad_checksum_all_devices = 0;
PP_DEVICE_MASK g_trap_bad_checksum_device_mask = {{0,0}};

extern UINT32 calc_current_secs();
extern int cu_sntp_set_server(UINT32 server_ip, UINT8 version, UINT8 remove_f);
extern void sntp_initiate_request();
extern SNTP_CLASS sntp;
extern SNTP_BCAST_CLASS sntp_bcast;
//extern UINT32 g_sntp_set_clock;
//extern UINT32 g_ntp_time_counter;     /* last g_time_count sync with NTP */
//extern struct tm g_ntp_tmst;
extern struct server g_ntp_srvst;
extern UINT8 *zonename[];

/* dns sntp parameters */
UINT32 g_sntp_caller_parameter;
static UINT8 l_hr, l_min, l_sec, l_mon, l_day;
static UINT16 l_yr;
UINT32 reload_secs = 0;
UINT32 reload_config_secs = 0;
UINT32 reload_location = 0;
UINT8  reload_config_string[32];
SV_TIMER_TOKEN_T g_reboot_timer = (SV_TIMER_TOKEN_T)0;

UINT8  bcast_curr_filter_id=0;

UINT32  last_dm_addr = DRAM_REG;
UINT32  last_dm_len = 0x40;
extern UINT32 dm_debug_mask;
extern UINT32 dm_hs_mask;
extern UINT32 dm_hs_delay;

extern UINT32 l2_hw_age_off;    /* configured hw ageing for l2 */
extern UINT32 l3_hw_age_off;    /* configured hw ageing for l3 */
extern UINT32 bm1_qd_100;               /* default value for version 1 10/100 ICBM */
extern UINT32 bm1_qd_1000;              /* default value for version 1 GIG ICBM */
extern UINT32 bm2_qd_100;               /* default value for version 2 10/100 ICBM */
extern UINT32 bm2_qd_1000;              /* default value for version 2 GIG ICBM */
extern UINT32 config_qd_100;                    /* value set thru config for next boot */
extern UINT32 config_qd_100_set;                /* 1: config_qd_100 value is valid */
extern UINT32 config_qd_1000;                   /* value set thru config for next boot */
extern UINT32 config_qd_1000_set;               /* 1: config_qd_1000 value is valid */
int is_ok_to_copy_code(char *buf, UINT8 remote_type, int *len);
void special_reload(UINT32 ui_port);
void scheduled_reset(UINT32 typeNSession);
extern char *generate_md5_salt();

 #define MAX_PATHNAME_SIZE 128
 UINT32  tftp_server_ip_auto_copy ;
 int tftp_server_configured = 0;
 char   g_image_pathname[MAX_PATHNAME_SIZE] = {0};

/*dhcp client*/
#ifdef __DHCP_CLIENT__
extern enum TEST initialize_dhcpc (void);
extern enum BOOLEAN is_dhcpc_enabled(void);
extern enum TEST dhcpc_set_protocol_state (enum BOOLEAN state);
#define DHCP_CLIENT_HOSTNAME_SIZE  128
#define DHCP_CLIENT_CONFIG_GEN_BUFFER  256
extern enum TEST dhcpc_set_hostname (char* ptr_hostname, size_t hostname_length);
extern enum TEST dhcpc_get_hostname (char* ptr_hostname, size_t hostname_length);
extern enum TEST dhcpc_set_configured_hostname_state (enum BOOLEAN state);
extern enum BOOLEAN is_hostname_configured (void);
extern enum BOOLEAN dhcpc_have_port_lease_time (size_t port_number);
extern enum TEST dhcpc_set_port_lease_time (size_t port_number, size_t lease_time);
extern enum TEST dhcpc_get_port_lease_time (size_t port_number, size_t* ptr_lease_time);
extern enum TEST dhcpc_set_port_protocol_state (size_t port_number, enum BOOLEAN state, enum BOOLEAN by_user);
extern enum BOOLEAN     is_dhcpc_port_disabled_by_user (size_t port_number);
extern enum TEST dhcpc_get_port_lease_time (size_t port_number, size_t* ptr_lease_time);
extern enum TEST dhcpc_get_user_disable_flag();
extern void dhcpc_set_user_disable_flag(enum BOOLEAN flag);
extern void dhcpc_delete_ip_address_on_new_active(size_t port_number);
extern void dhcpc_min_retry_interval(size_t port_number, size_t retry_val);
enum BOOLEAN dhcp_client_disabled_by_user = FALSE;
#endif __DHCP_CLIENT__
UINT8 ip_address_entry_dynamic; // klin, mport_cmds.c also use this one. I am not quite sure, so move this out.
//#ifdef HOT_SWAP
static void cli_find_module_type(unsigned char *line);
//#endif HOT_SWAP

#ifdef SR_SWITCH_ROUTER
#ifdef __IP_MULTICAST__
extern void cu_set_pim_debug_mask(UINT32 mask);
#endif __IP_MULTICAST__
#endif SR_SWITCH_ROUTER

PORT_MASK snmp_port_mask[MAX_SLOT];
PORT_MASK web_port_mask[MAX_SLOT];

char g_version[32];
char *g_ptr_version;
int g_major_version;
int g_minor_version;
int g_maintenance_version = 0;
int g_startup_major_version = 0;
int g_startup_minor_version = 0;
int g_startup_maintenance_version = 0;

#ifdef TOS_BASED_QOS
UINT32  sw_l4_tos_total_port = 0;
UINT8   tos_based_qos_init = 0;
UINT32  total_qos_interf = 0;
#endif

extern void print_exec_banner(void);
extern UINT32 g_dhcp_snoop_data_file_done ;
extern UINT8 read_dhcp_snoop_file_on_clock_update;
extern void show_arp_inspec_entries(struct cdb* sptr_cdb, VRF_INDEX vrf_index, int *config_written);
extern void static_arp_inspect_print_table(UINT32 rv, UINT32 data_ptr, UINT32 total_lines);

void do_write_running_config_to_terminal( 
        struct cdb *sptr_cdb,
        int (*retrieve_running_config_func)(struct cdb*),
        char *title);
extern void retrieve_running_config_version(struct cdb *sptr_cdb);
extern void retrieve_running_config_FES_high_peroformance(struct cdb *sptr_cdb);
extern void retrieve_running_config_pref_mode(struct cdb *sptr_cdb);

extern void retrieve_running_congfig_portext_cb(struct cdb* sptr_cdb);
extern void retrieve_running_config_portexten(struct cdb *sptr_cdb);
extern void retrieve_running_config_global_config(struct cdb* sptr_cdb);

//void cli_config_gen_interface_breakout(struct cdb*);
#ifdef RESILIENT_LINK
extern void config_gen_resilient_groups(struct cdb *sptr_cdb);
#endif RESILIENT_LINK
#ifdef SIDEWINDER_LINUX
extern void config_gen_monitor_profile(struct cdb *sptr_cdb);
#endif SIDEWINDER_LINUX
extern void cli_config_gen_xtrace(struct cdb *sptr_cdb);
extern void retrieve_running_config_debug(struct cdb* sptr_cdb);
extern void link_cfg_gen(struct cdb *sptr_cdb);
extern void retrieve_running_config_tftp_disable_cfg_gen(struct cdb *sptr_cdb);
extern void retrieve_running_config_max_vlan(struct cdb *sptr_cdb);
extern void retrieve_running_config_global_stp(struct cdb *sptr_cdb);
#ifdef ARP_RATE_LIMIT
extern void cli_write_rate_limit_arp(struct cdb*);
#endif

#ifdef WEBAUTH_2_0
extern void cli_config_gen_captive_portal(struct cdb*);
#endif WEBAUTH_2_0

extern void retrieve_config_store_and_forward(struct cdb *sptr_cdb);
extern void retrieve_config_load_balance_symmetric(struct cdb *sptr_cdb);
extern void retrieve_running_config_trunk_cli(struct cdb *sptr_cdb);
#ifdef SR_SWITCH_ROUTER
extern void retrieve_running_config_rarp_bgp_msdp(struct cdb *sptr_cdb);
extern void retrieve_running_config_ip_vrf(struct cdb *sptr_cdb);
#endif /* SR_SWITCH_ROUTER */
extern void ni_server_config_gen(struct cdb *sptr_cdb);
extern void retrieve_running_congfig_spanning_tree(struct cdb *sptr_cdb);
extern void retrieve_running_config_global_config(struct cdb*);
extern void mac_move_notify_config_gen(struct cdb *sptr_cdb);
extern void mac_notification_config_gen(struct cdb *sptr_cdb);
#ifdef FI_LOAM
extern void link_oam_config_gen(struct cdb *sptr_cdb);
#endif 
extern void pms_config_gen(struct cdb *sptr_cdb);
//#endif FI_LOAM
#ifndef NO_PROTO_VLANS
extern void retrieve_running_congfig_No_proto_VLANS(struct cdb *sptr_cdb);
#endif NO_PROTO_VLANS 
#ifdef SINGLE_SPAN
extern void retrieve_running_config_vlan_stp(struct cdb *sptr_cdb);
#endif SINGLE_SPAN
extern void retrieve_running_config_mstpcmds(struct cdb *sptr_cdb);
extern void config_gen_flexauth(struct cdb *sptr_cdb);
#ifdef MPLS
extern void retieve_running_config_MPLS(struct cdb*);
#endif MPLS
#if !defined(NO_SYS_PAR)
extern void cli_config_gen_system_max(struct cdb* sptr_cdb);
#endif !defined(NO_SYS_PAR)
#ifdef __IPV6__
extern void wr_config_ip6_acl(struct cdb* sptr_cdb);
#endif

extern void retrieve_running_config_IPV6_multicast(struct cdb *sptr_cdb);
extern void retrieve_running_config_router_mode(struct cdb *sptr_cdb);
extern void retrieve_running_config_mangagement_interface(struct cdb* sptr_cdb);
extern void retrieve_running_config_cpu_port_interface(struct cdb* sptr_cdb);
extern void retrieve_running_config_phy_interface(struct cdb* sptr_cdb);
extern void do_retrieve_running_config_vlan(struct cdb* sptr_cdb);

#ifdef FIOFL_INCLUDE
       extern void  openflow_config_gen(struct cdb *sptr_cdb);
#endif FIOFL_INCLUDE
#ifndef NO_STP_GROUP
extern void topo_conf_show_all(struct cdb* sptr_cdb);
#endif NO_STP_GROUP
extern void retrieve_running_config_vif_tunnel(struct cdb *sptr_cdb);
#ifndef TURBOIRON
extern void sysmon_config_gen(struct cdb *sptr_cdb);
#endif TURBOIRON
#ifdef __GVRP_SUPPORT__
extern void config_gen_gvrp(struct cdb* sptr_cdb);
#endif __GVRP_SUPPORT__

#ifdef __IPV6__
#ifdef __IPV6_ACL_EXT__
extern void wr_config_ip6_acl(struct cdb* sptr_cdb);
#endif
#endif
#ifndef NO_L4_AC
extern void retrieve_running_congif_acl_std(struct cdb* sptr_cdb);
#endif
extern void retrieve_running_congif_ip_source_gaurd(struct cdb* sptr_cdb);
extern void retrieve_running_config_route_map(struct cdb* sptr_cdb);
#ifdef INCLUDE_MCT
extern void do_retrieve_running_config_cluster(struct cdb* sptr_cdb);
#endif
#if defined(NETFLOW)
extern void retrieve_running_config_netflow(struct cdb* sptr_cdb);
#endif 
//#if (defined(SFLOW) || defined(IPC_SFLOW))
extern void retrieve_running_config_sflow(struct cdb* sptr_cdb);

extern void retrieve_running_config_lldp(struct cdb* sptr_cdb);

extern void retrieve_running_config_ssh(struct cdb* sptr_cdb);
extern void cli_alias_config_gen(struct cdb* sptr_cdb);
extern	void cu_config_gen_localdb(struct cdb* sptr_cdb);

#ifdef SR_SWITCH_ROUTER
extern void retrieve_running_config_rarp_bgp_msdp(struct cdb *sptr_cdb);
extern void retrieve_running_config_ip_vrf(struct cdb *sptr_cdb);
#endif /* SR_SWITCH_ROUTER */
#ifdef __ISIS_HOST_NAME__
extern void isis_set_local_host_name(char *sptr_host_name);
#endif /*__ISIS_HOST_NAME__*/

UINT32 use_local_management_mac = 0;

/* String displayed for config commands requiring a reboot. */
char *SaveAndReloadString = "Reload required.  Please write memory and then reload or power cycle.\n";
extern SYS_BOOT_INFO *g_bootinfo_sptr;

#ifdef __PROC_CPU_UTIL__
#include "proc_cpu_util.h"
extern void show_proc_cpu_util();
extern void show_proc_cpu_util_hist(UINT32 sec);
#endif

extern int validate_tdr_performable(PORT_ID port);

/* Fanless mode */
extern void chassisSetFanlessMode(int stackId, int enable);
extern int is_fanless_mode_enabled_globally(void);
extern int g_fanless_mode_enable[MAX_SYS_UNIT_NUM + 1];


#ifdef FI_USR_PROFILE_SECURITY
/***************************************************************************
 *  Name:    dm_local_user_modify
 * 
 *  Description: This function removes the local user account, without asking for any prompt on CLI.
 *  !!Warning!! This command is only for Admin. 
 *  For any other users, a no version of username to be used to delete local user account.
 * 
 *  Parameters: pointer to cdb[session Id]
 * 
 *  Return: void
 * 
 * ***************************************************************************/

void dm_local_user_modify(struct cdb* sptr_cdb)
{
    USER_PROFILE_ENTRY *sptr_user_profile;
    if(end_of_token(sptr_cdb->token) != '\0')
        return;
    sptr_cdb->dont_go_next = 1;

    sptr_user_profile = cu_find_user_profile(sptr_cdb->string1);

    if(cu_remove_user_profile(sptr_user_profile,sptr_cdb->string1,sptr_cdb->ui_port) != CU_OK)
        return;
}
#endif FI_USR_PROFILE_SECURITY
int is_tftp_busy(void)
{
        return (tftp.current_operation != TFTP_IDLE)?1:0;
}

void reload_confirm_callback(UINT32 yes, UINT32 ui_port, UINT32 param3);

UINT8 g_default_vlan_id_in_transition = FALSE;

#ifdef INCLUDE_802_1W
#include "fdry/Common/RSTP/vmacbrstp.h"
#endif INCLUDE_802_1W

UINT8 g_cli_module_disable = 0;
int g_flash_copy_slaves = 0;
UINT8 *g_stby_runningConfig_buf;

int debug_static_mac_ctrl=0;

extern int gridiron_initialization_done;
/* Added below macro for TR000377625 backward compatibility */
#define SYS_MAX_SPAN_INSTANCE_BEFORE_7_4_RELEASE  255
#define SYS_MAX_SPAN_INSTANCE_AFTER_7_4_RELEASE  254

#define MAX_DOM_INTERVAL 65535
#define MIN_DOM_INTERVAL g_min_dom_interval
#define DEFAULT_DOM_INTERVAL g_default_dom_interval
/* In normal the minimum and default values are  3 minutes */
int g_min_dom_interval = 3;
int g_default_dom_interval = 3;

void print_require_reload()
{
        if(!STACK_AM_I_SLAVE)
        {
                uprintf("%s", SaveAndReloadString);
                cu_set_is_reload_required(TRUE);
        }
}
void print_hold_and_reboot()
{
	uprintf("T=%s: Halt and reboot\n", get_current_stk_time_str());
}

void print_reboot_and_cold_reset_now()
{

#ifdef FI_LOAM
	/* Sending dying gasp on LOAM enabled local ports
	 * to indicate peer about this Units reload
	 */
	link_oam_send_link_down_event_all_ports(LOAM_DYING_GASP_EVENT);
	delay_ms(1000);
#endif

	print_hold_and_reboot();
	sys_sleep(2); // 1 tick is 25ms
	flush_output();
	cu_cold_reset_now(TRUE);
}
#ifdef __DHCP_SERVER__
/*
** DHCPS
*/
extern enum BOOLEAN is_dhcps_running (void);
extern enum TEST dhcps_remove_lease_binding_database_from_flash(void);
#endif /*__DHCP_SERVER__*/

#ifdef __DHCP_CLIENT__

void set_if_ip_address_dynamic(struct cdb* sptr_cdb)
{
        ip_address_entry_dynamic = 1;
#ifdef SR_SWITCH_ONLY
        set_global_ip(sptr_cdb);
        ip_address_entry_dynamic = 0;
#else
        /* if replace option given with ospf-ignore then 
         * interface ip will set in set_if_ip_replace
         */
        if(sptr_cdb->token && (end_of_token(sptr_cdb->token) == '\0')) {
            set_if_ip(sptr_cdb);
            ip_address_entry_dynamic = 0;
        }

#endif
}
#endif __DHCP_CLIENT__

enum BOOLEAN is_mac_address_mask_valid (unsigned char *mac)
{
        int i;
        for (i=0; i<6; i++)
        {
                if ((mac[i] != 0xff) && (mac[i] != 0x0F) &&
                        (mac[i] != 0xF0) && (mac[i] != 0x00))
                {
                        return FALSE;
                }
        }
        return TRUE;
}

#ifdef FI_LINUX
#define FILE_NAME_LENGTH FLASH_FILE_NAME_LENGTH_EXT
#else
#define FILE_NAME_LENGTH FLASH_FILE_NAME_LENGTH
#endif
enum BOOLEAN cu_is_illegal_flash_file_name(char *string)
{

#ifdef FI_LINUX
      /* Account for /fast_iron/disk0/ string as well */
    if (strlen(string) > (FILE_NAME_LENGTH-25))
#else
    if (strlen(string) > FILE_NAME_LENGTH)
#endif  
    {
        uprintf("Error - flash file name too long\n");
        return TRUE;
    }
    if( !strcmp("primary.bin", string) || !strcmp("secondary.bin", string) || !strcmp("bootrom.bin", string) || !strcmp("boot.bin", string) ||     
         !strcmp("primary", string) || !strcmp("secondary", string) || !strcmp("bootrom", string) || !strcmp("boot", string))        
    {
        /*TODO:We should have macro for pri/sec/boot image names based upon platforms in a common header file*/                          
        uprintf("Error- Not allowed for Primary/Secondary/Bootrom images: %s\n", string);
        return TRUE;
    }
    return FALSE;
}
void config_buffer_init()
{
#ifdef DEBUG
    if((config_buffer = sv_malloc(max_config_buffer_size)) == NULL)
        kprintf("Error - cannot allocate config buffer\n");
#else
        /* always has memory for it */
    config_buffer = sv_malloc(max_config_buffer_size);
#endif DEBUG
}

unsigned char *get_config_buffer(UINT32 user)
{
        memset(config_buffer, 0, max_config_buffer_size); /*40643*/
        return config_buffer;
}

void free_config_buffer(unsigned char *buf_addr)
{
}


/*list of the config to be displayed. Maintain the proper order*/
void cu_end_printing_config(struct cdb *sptr_cdb);
modu module[]=
{
        retrieve_running_config_version,
        retrieve_running_config_FES_high_peroformance,
        retrieve_running_config_pref_mode,
        retrieve_running_config_portexten,
#ifdef SIDEWINDER_BREAKOUT
       cli_config_gen_interface_breakout,
#endif SIDEWINDER_BREAKOUT
       retrieve_running_congfig_portext_cb,
#ifdef SR_SWITCH_ROUTER
#ifdef SIDEWINDER_LINUX
        config_gen_monitor_profile,
#endif SIDEWINDER_LINUX
#endif SR_SWITCH_ROUTER
#ifdef RESILIENT_LINK
        config_gen_resilient_groups,
#endif RESILIENT_LINK
#ifndef OFFICIAL_RELEASE
        cli_config_gen_xtrace,
        retrieve_running_config_debug,
#endif
#ifndef NO_LINK_CFG
        link_cfg_gen,
#endif
        retrieve_running_config_tftp_disable_cfg_gen,
        retrieve_running_config_max_vlan,
        retrieve_running_config_global_stp,
#ifdef ARP_RATE_LIMIT
        cli_write_rate_limit_arp,
#endif
        retrieve_config_store_and_forward,
	retrieve_config_load_balance_symmetric,       	
        retrieve_running_config_trunk_cli,
#ifdef WEBAUTH_2_0 //Generate cp profile before VLAN since webauth is at VLAN level.
       cli_config_gen_captive_portal,
#endif WEBAUTH_2_0

#ifdef NI_SLB
        ni_server_config_gen,
#endif
        retrieve_running_congfig_spanning_tree,
        mac_move_notify_config_gen,
        mac_notification_config_gen,
#ifdef FI_LOAM
        link_oam_config_gen,
#endif
        pms_config_gen,
#ifndef NO_PROTO_VLANS
        retrieve_running_congfig_No_proto_VLANS,
#endif NO_PROTO_VLANS
        do_retrieve_running_config_vlan,
#ifdef SINGLE_SPAN
        retrieve_running_config_vlan_stp,
#endif SINGLE_SPAN
        retrieve_running_config_mstpcmds,
#ifdef FIOFL_INCLUDE
        openflow_config_gen,
#endif FIOFL_INCLUDE
        config_gen_flexauth,
#ifdef __GVRP_SUPPORT__
        config_gen_gvrp,
#endif __GVRP_SUPPORT__
#ifdef MPLS
   retieve_running_config_MPLS,
#endif MPLS
#if !defined(NO_SYS_PAR)
	cli_config_gen_system_max,
#endif !defined(NO_SYS_PAR)
#ifdef SR_SWITCH_ROUTER
        retrieve_running_config_ip_vrf,
#endif SR_SWITCH_ROUTER
        acl_CLI_TPD_Gen_Config,
#ifdef IP_POLICY_ROUTING
        config_gen_ip_policy,
#endif IP_POLICY_ROUTING 
        retrieve_running_config_global_config,
        retrieve_running_config_IPV6_multicast,
#ifdef SR_SWITCH_ROUTER  
        retrieve_running_config_router_mode,
#endif SR_SWITCH_ROUTER
		/*retrieve_running_config_mangagement_interface,*/
		retrieve_running_config_cpu_port_interface,
        retrieve_running_config_phy_interface,
#ifndef NO_STP_GROUP
	topo_conf_config_gen_all, /*BUG: 6413*/
#endif NO_STP_GROUP
   retrieve_running_config_vif_tunnel,
#ifndef TURBOIRON
        sysmon_config_gen,
#endif     
#ifdef SR_SWITCH_ROUTER  
      retrieve_running_config_rarp_bgp_msdp,
#endif SR_SWITCH_ROUTER
#ifdef __IPV6__
#ifdef __IPV6_ACL_EXT__
	wr_config_ip6_acl,
#endif __IPV6_ACL_EXT__
#endif __IPV6__
#ifndef NO_L4_AC
      retrieve_running_congif_acl_std,
#endif 
   retrieve_running_congif_ip_source_gaurd,
   retrieve_running_config_route_map,
#ifdef INCLUDE_MCT
      do_retrieve_running_config_cluster,
#endif 
#if defined(NETFLOW)
	retrieve_running_config_netflow,
#endif 
#if (defined(SFLOW) || defined(IPC_SFLOW))
	retrieve_running_config_sflow,
#endif
#ifdef __LLDP__
	retrieve_running_config_lldp,
#endif
	retrieve_running_config_ssh,
#ifndef _NO_ALIAS_
	cli_alias_config_gen,
#endif
	cu_config_gen_localdb,
	
	/*Always these two should be at last in this order*/
	cu_end_printing_config,
	(modu)NULL
};  

sh_run_module_data module_dat[MAX_IO_CB];
int retrieve_module_config(struct cdb * sptr_cdb)
{
    int saved_cdb_mode= sptr_cdb->mode;
    sptr_cdb->config_gen = 1;
    sptr_cdb->mode = CONFIG;
    sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
    memset(cu_line_buf,0,sizeof(cu_line_buf));
    sptr_cdb->buffer_space_left = max_config_buffer_size - 4;
    /*invoke next module*/
    module[module_dat[sptr_cdb->ui_port].module_ind](sptr_cdb);

    sptr_cdb->config_gen = 0;
    sptr_cdb->mode= saved_cdb_mode;
    return(sptr_cdb->buffer_space_left);
}

void cli_show_run_cb(struct cdb* sptr_cdb)
{
        do_write_running_config_to_terminal(sptr_cdb,retrieve_module_config, module_dat[sptr_cdb->ui_port].module_ind ? NULL : "Current configuration:\n!\n");
}
void cu_reset_show_run(unsigned int ui_port)
{
        module_dat[ui_port].module_ind = 0;
        module_dat[ui_port].sh_run_in_progress = 0;
        module_dat[ui_port].saved = 0;
        module_dat[ui_port].mgmt_config_done = 0;

}
void cu_init_show_run(unsigned int ui_port)
{
        module_dat[ui_port].module_ind = 0;
        module_dat[ui_port].sh_run_in_progress = 1;
        module_dat[ui_port].saved = 0;
		module_dat[ui_port].mgmt_config_done = 0;
		cdbs[ui_port].walk_stack_top = NULL;

}
int retrieve_all_module_config(struct cdb * sptr_cdb)
{
    UINT32 elapsed, start, end;
    int saved_cdb_mode= sptr_cdb->mode;
    sptr_cdb->mode = CONFIG;
    sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
    sptr_cdb->config_gen = 1;

    memset(cu_line_buf,0,sizeof(cu_line_buf));
    sptr_cdb->buffer_space_left = max_config_buffer_size - 4;
    while(module[module_dat[sptr_cdb->ui_port].module_ind])
    {
        start = read_tb_usec();
        module[module_dat[sptr_cdb->ui_port].module_ind](sptr_cdb);
        end = read_tb_usec();
        elapsed += (end - start);

        if(elapsed >= 50000) /*0.05 sec*/
        {
            elapsed = 0;
            //kprintf("dbg: yeild at mod = %d \t elapsed t= %u\n",module_dat[sptr_cdb->ui_port].module_ind,elapsed);
            sys_yield_unconditional();
        }
        //kprintf("dbg: module = %u \t time = %u\n",module_dat[sptr_cdb->ui_port].module_ind,end - start);
        module_dat[sptr_cdb->ui_port].module_ind++;
    }


    sptr_cdb->config_gen = 0;
    sptr_cdb->mode= saved_cdb_mode;


    return(sptr_cdb->buffer_space_left);
}
int retrieve_all_module_config_new(struct cdb * sptr_cdb)
{
	int ret_value = 0;
	cu_init_show_run(sptr_cdb->ui_port);
	ret_value = retrieve_all_module_config(sptr_cdb);
	cu_reset_show_run(sptr_cdb->ui_port);
	return ret_value;
}
static struct cdb s_write_mem_cdb;
static BOOLEAN s_write_mem_skip_check_cfg = FALSE;
static void callback_write_mem_remove_stack_cfg(int yes, UINT32 param2, UINT32 param3)
{
	s_write_mem_skip_check_cfg = TRUE;
	if (yes) stack_remove_config();
	copy_runConfig_startConfig_new(&s_write_mem_cdb);
	if (yes) stack_remove_stacking_boot();
	s_write_mem_skip_check_cfg = FALSE;
	release_confirm_mode();
}

extern const char		*g_startup_config_backup ;
extern const char		*g_startup_config_filename;
void copy_runConfig_startConfig_new(struct cdb * sptr_cdb)
{
	if (!s_write_mem_skip_check_cfg &&
		!stack_allow_write_cfg() &&
		stack_exists_cfg())
	{
		memcpy(&s_write_mem_cdb, sptr_cdb, sizeof(struct cdb));
		uprintf("Rear module operates in uplink mode, Would you like to remove the stacking configurations ? ");
		set_confirm_mode(callback_write_mem_remove_stack_cfg,0, 0);
		return;
	}

#if 0
	char *temp[2];
	temp[0] = g_startup_config_backup;
	temp[1] = g_startup_config_filename;

	g_startup_config_filename = "test_config.txt";
	g_startup_config_backup = "test_bkp.txt";
#endif

	cu_init_show_run(sptr_cdb->ui_port);

	copy_runConfig_startConfig(sptr_cdb);

	cu_reset_show_run(sptr_cdb->ui_port);

#if 0
	g_startup_config_backup = temp[0];
	g_startup_config_filename = temp[1];
#endif
}

void cu_end_printing_config(struct cdb *sptr_cdb)
{
	int count = 0;

	count = sizeof(module) / sizeof(module[0]);
	module_dat[sptr_cdb->ui_port].module_ind = (count - 2); /*pointing to last but one*/
	if (sptr_cdb->gen_to != GEN_TO_INTERNAL_USE)
		wr_config(sptr_cdb, "end\n");
	wr_config(sptr_cdb, "\0\0");
}

void cli_show_run(struct cdb* sptr_cdb)
{
	if (sptr_cdb->no)
			return;
	
	if (end_of_token(sptr_cdb->token) != '\0')
			return;
	
	sptr_cdb->dont_go_next = 1;
	
	g_vlan_group_cmd = 0;

        cu_init_show_run(sptr_cdb->ui_port);
        cli_show_run_cb(sptr_cdb);
}
void cu_show_run(int ui_port)
{
        struct cdb* sptr_cdb = &cdbs[ui_port];
        if(module_dat[sptr_cdb->ui_port].sh_run_in_progress)
        {
                module_dat[sptr_cdb->ui_port].module_ind++;
                if(module[module_dat[sptr_cdb->ui_port].module_ind])
                        cli_show_run_cb(sptr_cdb);
                else
                {
                        cu_reset_show_run(sptr_cdb->ui_port);
                }
        }
}
void cu_get_loop_count_for_module(int ui_port, int *interim_min, int *interim_max, int begin, int end, int loop_count)
{
	if(module_dat[ui_port].sh_run_in_progress)
	{
	        if (!module_dat[ui_port].saved)
            {  
			    *interim_min = begin;
            }
            else
            {
                *interim_min = module_dat[ui_port].saved;
            }
			*interim_max = *interim_min + loop_count; 
			if(*interim_max > end)
			{
					*interim_max = end;
					module_dat[ui_port].saved = 0;
			}
			else
			{
					module_dat[ui_port].module_ind--;
					module_dat[ui_port].saved = *interim_max;
			}
	}
	else
	{
			*interim_min = begin;
			*interim_max = end;
	}
}

int get_ip(UINT8 *cp, UINT32 *ip)
{
        int i, j, len, temp, num_of_dot = 0;
        UINT8 ip_string[16], digit_strings[17], ip_b[4];

        SKIP_WHITE_SPACE(cp);

        if (*cp == '\0')
                return(-1);

        for (len=0; len < 16; len++)
        {
                if (cp[len] == '\0' || cp[len] == ' ')
                {
                        ip_string[len] = '\0';
                        break;
                }
                else
                {
                        /* last char but still not end */
                        if (len == 15)
                                return(-1);
                        ip_string[len] = cp[len];
                }
        }

        digit_strings[0] = '\0';
        for (i=0; i < len; i++)
        {
                if (isdigit(ip_string[i]))
                {
                        /* it's a digit */
                        digit_strings[i+1] = ip_string[i];
                }
                else
                if (ip_string[i] == '.')
                {
                        /* before and after the dot should be a digit */
                        if (!(isdigit(ip_string[i-1]) && isdigit(ip_string[i+1])))
                                return(-1);
                        digit_strings[i+1] = '\0';
                        num_of_dot++;
                }
                else
                        return(-1);
        }

        digit_strings[i+1] = '\0';      /* null terminated */

        if (num_of_dot != 3)
                return(-1);

        for (i=0, j=0; i < (len+1); i++)
        {
                if (digit_strings[i] == '\0')
                {
                        temp = atoi(&digit_strings[i+1]);
                        if (j < 4)
                        {
                                if (temp < 0 || temp > 255)
                                        return(-1);
                                ip_b[j] = (UINT8) temp;
                                j++;
                        }
                }
        }
        *ip = ip_string2int(ip_b);
        return(0);
}

int cli_get_int(char *cp, int check_for_space, int *cnt)
{
        unsigned char uc;
        UINT32 t, stop;
        char *saved_cp = cp;
        int firstuc = 0;

        *cnt = 0; /* number of bytes processes */
        t = 0;
        stop = 0;
        SKIP_WHITE_SPACE(cp);
        *cnt += cp - saved_cp;

        if (*cp == '\0')
                return(-1);
        firstuc=(*cp)-'0';
        /* process the contiguous digital characters */
        while (uc = *cp++)
        {
                *cnt += 1;
                if (uc >= '0' && uc <= '9')
                        t = t*10 + (uc - '0');
                else
                {
                        stop = 1;
                        break;
                }
        }
        /*verify the read in int t is correct between (1-4294967295) */
        if (((*cnt>10)&&(!stop))||((*cnt>11)&&(stop)))
                return(-1);
        if ((((*cnt==10)&&(!stop))||((*cnt==11)&&(stop)))&&((t<1000000000)||(firstuc>4)))
                return(-1);

        if (check_for_space)
        {
        if ((stop) && (uc != ' '))
        {
                return(-1);
        }
        }
        DPRINTF1(DB_KERN, "get_int() returns %d\n", t);
        return(t);
}
UINT32 cli_get_hex(char *cp, int *byte)
{
        unsigned char uc;
        UINT32 t, stop;
        int digits;

        t = 0;
        stop = 0;
        digits = 0;
        SKIP_WHITE_SPACE(cp);
        if (*cp == '\0')
        {
                *byte = 0;
                return(0);
        }
        /* process the contiguous digital characters */
        while (uc = *cp++)
        {
#ifdef NOT_USED
                switch (uc)
                {
                        case '0': case '1': case '2': case '3': case '4':
                        case '5': case '6': case '7': case '8': case '9':
                                t = t*16 + (uc - '0');
                                digits++;
                                break;
                        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
                                t = t*16 + (uc - 'a' + 10);
                                digits++;
                                break;
                        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
                                t = t*16 + (uc - 'A' + 10);
                                digits++;
                                break;
                        default:
                                stop = 1;
                                break;
                }
#endif NOT_USED
                if (uc >= '0' && uc <= '9')
                {
                        t = t*16 + (uc - '0');
                        digits++;
                }
                else
                if (uc >= 'a' && uc <= 'f')
                {
                        t = t*16 + (uc - 'a' + 10);
                        digits++;
                }
                else
                if (uc >= 'A' && uc <= 'F')
                {
                        t = t*16 + (uc - 'A' + 10);
                        digits++;
                }
                else
                {
                        stop = 1;
                        break;
                }
        }

        if (digits&1)
                digits++;
        digits /= 2;

        /* count the bytes */
    if (((stop) && (uc != ' ')) || (digits > 4))
    {
                *byte = 0;
    } else
    {
                *byte = digits;
    }

        return(t);
}

void set_physical_view(struct cdb* sptr_cdb)
{
        sptr_cdb->physical_view = 1;
}

void clear_physical_view(struct cdb* sptr_cdb)
{
        sptr_cdb->physical_view = 0;
}

UINT32 cu_range2mask(int f, int t)
{
        UINT32 mask;

        mask = 0;

/* Assuming 1 port based */
        if (f <= t) {
                for (; f <= t; f++)
                        mask = mask | (1 << (f-1));
        } else {
                for (; t <= f; t++)
                        mask = mask | (1 << (t-1));
        }
        return mask;
}

void cu_mask2range(int* f, int* t, UINT32 mask)
{
        int i;
        for (i = 0; i < 32; i++, mask = mask >> 1) {
                if ((mask  & 1) == 0)
                        continue;
                *f = i + 1; /* start from 1 not 0 */
                break;
        }

        for (; i < 32; i++, mask = mask >> 1) {
                if ((mask  & 1) == 1)
                        continue;
                *t = i; /* last one, don't add 1 */
                break;
        }
}

// NIL3  - following function imported from NI
/*
 * Caller has cached the CLI node, simply sets the command filter flag.
 */
void
set_cmd_filter_flag3(struct node *sptr_node, unsigned int flag, unsigned int enable)
{
    if (enable)
    {
        sptr_node->type |=  flag;
    }
    else
    {
        sptr_node->type &= ~flag;
    }
}

/***************************************************************************
 * Name:
 *
 * Description:
 *
 * Parameters:
 *
 * Return:
 *
 * Method:
 *
***************************************************************************/
void set_cmd_filter_flag(
        struct node *sptr_node,
        char *keyword,
        unsigned int type,
        unsigned int flag,
        unsigned int enable)
{
        if (((sptr_node->type & ~(PARSER_NODE_MASK_BITS)) == type)
        &&  (strcmp(sptr_node->keyword, keyword) == 0))
        {
                if (enable)
                        sptr_node->type |=  flag;
                else
                        sptr_node->type &= ~flag;
        }
}

void set_cmd_filter_type_flag(
        struct node *sptr_node,
        unsigned int type,
        unsigned int flag,
        unsigned int enable)
{
        if (((sptr_node->type & ~(PARSER_NODE_MASK_BITS)) == type)
        &&  (sptr_node->keyword == NULL || sptr_node->keyword[0] == 0 ))
        {
                if (enable)
                        sptr_node->type |=  flag;
                else
                        sptr_node->type &= ~flag;
        }
}

UINT32 get_cli_mode(struct cdb* sptr_cdb)
{
        return sptr_cdb->mode;
}


/***************************************************************************
 * Name:
 *
 * Description:
 *
 * Parameters:
 *
 * Return:
 *
 * Method:
 *
***************************************************************************/
void set_cli_mode(struct cdb* sptr_cdb, int mode)
{
    int           i;
    struct node*  sptr_node;
#ifdef SR_SWITCH_ROUTER
    UINT16        port_id;
    INT32         enableIpv6 = CU_OK;
    INT32         enableIpv4 = CU_OK;
    UINT16        vid;
    UINT16        vlan_id = SW_DFLT_VLAN_ID;
    VLAN_INDEX    vlan_index;
#endif SR_SWITCH_ROUTER
    extern UINT32 galtis_cmds_allowed;

#ifdef SR_SWITCH_ROUTER
    /*
       * Clean up the VRF menus when moving from CONFIG_IP_VRF mode to any
       * other mode.  This is a no-op during boot up when we read the
       * startup-config from flash.
       */
    if ((sptr_cdb->mode != mode) && 
        ((sptr_cdb->mode == CONFIG_IP_VRF) || (sptr_cdb->mode == CONFIG_IPV4_VRF) || (sptr_cdb->mode == CONFIG_IPV6_VRF)))
    {
        vrf_set_address_family_mode(sptr_cdb, 0);
    }
#endif SR_SWITCH_ROUTER

    /* bug 9481
     * this has to do with the L3 protocol vlan name not getting cleaned
     * out if the L3 vlan was not created. Reset vlan_name when moving from
     * protocol vlan mode to any other.
     */
    if ((sptr_cdb->mode != mode) &&
        ((sptr_cdb->mode == CONFIG_VLAN_PROTO) ||
         (sptr_cdb->mode == CONFIG_VLAN_NR_PROTO)))
    {
        sptr_cdb->vlan_name[0] = 0;
    }
    if (mode == CONSOLE_LOGIN)
    {
        /* initialize (reset) the console banner_read flag */
        set_console_banner_read(0, sptr_cdb->ui_port);
    }

    /* set cli mode */
    sptr_cdb->mode = mode;

    if (sptr_cdb->config_gen)
        return;

    if (mode == PRIV_EXEC)
    {
        galtis_cmds_allowed = 0;
    }
    else if (mode == USER_EXEC)
    {
        galtis_cmds_allowed = 0;
    }

    /* permit parsing */
    for (i=0; ;i++)
    {
        sptr_node = &g_fi_config[i];
        set_cmd_filter_flag(sptr_node, "tagged",   VLAN_KEYWORD, DONT_PARSE, DISABLE);
        set_cmd_filter_flag(sptr_node, "untagged", VLAN_KEYWORD, DONT_PARSE, DISABLE);
#ifdef SR_SWITCH_ROUTER
        set_cmd_filter_flag(sptr_node, "ip",  IF_KEYWORD, DONT_PARSE, DISABLE);
        set_cmd_filter_flag(sptr_node, "ip", VIF_KEYWORD, DONT_PARSE, DISABLE);

#ifdef __IPV6__
        set_cmd_filter_flag(sptr_node, "ipv6",  IF_KEYWORD, DONT_PARSE, DISABLE);
        set_cmd_filter_flag(sptr_node, "ipv6", VIF_KEYWORD, DONT_PARSE, DISABLE);
#endif __IPV6__

#endif /* SR_SWITCH_ROUTER */

        if ((sptr_node->type & LAST_ENTRY) == LAST_ENTRY)
            break;
    }
    //103661: When one single port is tagged in more than 3000 vlan, soft check will timeout. So I add sys_yield()
    //sys_true_yield();

        reset_config_tree_node_flag("vrf", VIF_KEYWORD, DONT_PARSE);

    if(sptr_cdb->vlan_group_id)
    {
        // Bug: 344086 We don't remove to sync to standby
        if (free_configured_vlan_group_entry(sptr_cdb->vlan_group_id, FALSE))
            exit_vlan_group_cli(sptr_cdb);
    }

    /* reset vrrp handle */
    if ((mode != CONFIG_VRRPE6_ROUTER_ID) &&
        (mode != CONFIG_VRRP6_ROUTER_ID)  &&
        (mode != CONFIG_VRRPE_ROUTER_ID)  &&
        (mode != CONFIG_VRRP_ROUTER_ID))
    {
        sptr_cdb->vrtr_index = VSRP_INDEX_INVALID;
        sptr_cdb->vrid = 0;
    }

    /* deny parsing */
    switch (mode)
    {
        case CONFIG_VLAN:
#ifndef NO_PROTO_VLANS
        case CONFIG_VLAN_PROTO:
        case CONFIG_VLAN_NR_PROTO:
#endif
        {
            if (sptr_cdb->vlan_id == SW_DFLT_VLAN_ID
            &&  cu_get_switch_oper_mode() == PORT_VLAN)
            {
                set_config_tree_node_flag("tagged", VLAN_KEYWORD, DONT_PARSE);
                set_config_tree_node_flag("untagged", VLAN_KEYWORD, DONT_PARSE);
            }
            if (sptr_cdb->vlan_group_id) {
                enter_vlan_group_cli();
            }
            break;
        }

#ifdef SR_SWITCH_ROUTER
        case CONFIG_IF:
		case CONFIG_IF_LAG:
        {
            exit_vlan_group_cli(sptr_cdb);
            port_id = (UINT16)INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
#ifdef INCLUDE_MCT
            /* permit parsing */
            for (i=0; ;i++)
            {
                sptr_node = &i_ip[i];
                set_cmd_filter_flag (sptr_node, "dvmrp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "follow", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "igmp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "irdp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "local-proxy-arp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "metric", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "multicast-boundary", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "ospf", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "pim", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "pim-sparse", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "policy", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "proxy-arp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "redirect", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "rip", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "tunnel", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "vrrp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "vrrp-extended", KEYWORD, DONT_PARSE, DISABLE);

                if ((sptr_node->type & LAST_ENTRY) == LAST_ENTRY)
                    break;
            }
#endif INCLUDE_MCT

#if !defined(NO_IPV6_PROTO_VLAN) && defined(__IPV6__)
            if (cu_check_interface(port_id, IPV6_PROTO_INDEX) != CU_OK)
                set_config_tree_node_flag("ipv6", IF_KEYWORD, DONT_PARSE);
#endif  NO_IPV6_PROTO_VLAN
            if (cu_check_interface(port_id, IP_PROTO_INDEX) != CU_OK)
            {
                set_config_tree_node_flag("ip", IF_KEYWORD, DONT_PARSE);
                                set_config_tree_node_flag("vrf", IF_KEYWORD, DONT_PARSE);
            }
            else
                reset_config_tree_node_flag("vrf", IF_KEYWORD, DONT_PARSE);
            break;
        }

        case CONFIG_VIF:
        {
            exit_vlan_group_cli (sptr_cdb);
            port_id = (UINT16)INTERFACE_TO_PORT_ID (sptr_cdb->if_num);

#ifdef INCLUDE_MCT
            /* permit parsing */
            for (i=0; ;i++)
            {
                sptr_node = &i_ip[i];
                set_cmd_filter_flag (sptr_node, "dvmrp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "follow", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "igmp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "irdp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "local-proxy-arp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "metric", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "multicast-boundary", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "ospf", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "pim", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "pim-sparse", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "policy", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "proxy-arp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "redirect", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "rip", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "tunnel", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "vrrp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "vrrp-extended", KEYWORD, DONT_PARSE, DISABLE);

                if ((sptr_node->type & LAST_ENTRY) == LAST_ENTRY)
                    break;
            }

            if (IS_PORT_IN_VIRTUAL_PORT (port_id))
            {
                /* Get the VLAN identifiers */
                vid = (UINT16)ROUTER_INT_TO_VID (port_id);

                vlan_index = g_sw_sys.vid_table[vid].vlan_index;

                if (vlan_index == VLAN_INDEX_INVALID)
                {
                    break;
                }
                else
                {
                    vlan_id = VLAN_ID_FROM_IDX (vlan_index);
                }
            }
#endif INCLUDE_MCT

#if !defined (NO_IPV6_PROTO_VLAN) && defined (__IPV6__)
            if ((enableIpv6 = cu_check_interface (port_id, IPV6_PROTO_INDEX)) != CU_OK)
                set_config_tree_node_flag ("ipv6", IF_KEYWORD, DONT_PARSE);
#endif  NO_IPV6_PROTO_VLAN
            if ((enableIpv4 = cu_check_interface (port_id, IP_PROTO_INDEX)) != CU_OK)
                set_config_tree_node_flag ("ip", VIF_KEYWORD, DONT_PARSE);
#ifdef INCLUDE_MCT
            if (IS_PORT_IN_VIRTUAL_PORT (port_id) &&
                     clusterlib_is_vlan_cluster_member_vlan_or_session_vlan (vlan_id))
            {
                /* remove all irrelevant nodes */
                if (CU_OK == enableIpv6)
                {
                    set_config_tree_node_flag ("ipv6", VIF_KEYWORD, DONT_PARSE);
                }
                set_config_tree_node_flag ("ip-multicast-disable", VIF_KEYWORD, DONT_PARSE);
                set_config_tree_node_flag ("vrf", VIF_KEYWORD, DONT_PARSE);

                /* deny parsing */
                if (CU_OK == enableIpv4)
                {
                    for (i=0; ;i++)
                    {
                        sptr_node = &i_ip[i];
                        set_cmd_filter_flag (sptr_node, "dvmrp", KEYWORD, DONT_PARSE, ENABLE);
                        set_cmd_filter_flag (sptr_node, "igmp", KEYWORD, DONT_PARSE, ENABLE);
                        set_cmd_filter_flag (sptr_node, "multicast-boundary", KEYWORD, DONT_PARSE, ENABLE);
                        set_cmd_filter_flag (sptr_node, "tunnel", KEYWORD, DONT_PARSE, ENABLE);
                        if (clusterlib_is_vlan_cluster_session_vlan (vlan_id))
                        {
                            set_cmd_filter_flag (sptr_node, "follow", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "irdp", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "local-proxy-arp", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "metric", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "ospf", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "pim", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "pim-sparse", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "policy", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "proxy-arp", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "redirect", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "rip", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "vrrp", KEYWORD, DONT_PARSE, ENABLE);
                            set_cmd_filter_flag (sptr_node, "vrrp-extended", KEYWORD, DONT_PARSE, ENABLE);
                        }
                        if ((sptr_node->type & LAST_ENTRY) == LAST_ENTRY)
                            break;
                    }
                }
            }
#endif INCLUDE_MCT

            break;
        }

        case CONFIG_LBIF:
        {
            
#ifdef INCLUDE_MCT
            /* permit parsing */
            for (i=0; ;i++)
            {
                sptr_node = &i_ip[i];
                set_cmd_filter_flag (sptr_node, "dvmrp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "follow", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "igmp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "irdp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "local-proxy-arp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "metric", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "multicast-boundary", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "ospf", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "pim", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "pim-sparse", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "policy", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "proxy-arp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "redirect", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "rip", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "tunnel", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "vrrp", KEYWORD, DONT_PARSE, DISABLE);
                set_cmd_filter_flag (sptr_node, "vrrp-extended", KEYWORD, DONT_PARSE, DISABLE);
            
                if ((sptr_node->type & LAST_ENTRY) == LAST_ENTRY)
                    break;
            }
#endif INCLUDE_MCT
            break;
        }
#endif /* SR_SWITCH_ROUTER */

        case CONFIG_IP_VRF:
        case CONFIG_IPV4_VRF:
        case CONFIG_IPV6_VRF:
                exit_vlan_group_cli(sptr_cdb);
                break;

        default:
                exit_vlan_group_cli(sptr_cdb);
                break;
    }
    if (is_mgmt_active() && is_standby_up())
    {
        if (mode == PRIV_EXEC)
            stk_sync_one_cdb(sptr_cdb->ui_port);
    }
}

/***************************************************************************
 * Name:
 *
 * Description:
 *
 * Parameters:
 *
 * Return:
 *
 * Method:
 *
***************************************************************************/
int validate_string_length(struct cdb* sptr_cdb, int string_num, int min_len, int max_len)
{
        UINT8 *sptr_string;
        int len;

        switch (string_num)
        {
        case 1:
        sptr_string = sptr_cdb->string1;
        break;
        case 2:
        sptr_string = sptr_cdb->string2;
        break;
        case 3:
        sptr_string = sptr_cdb->string3;
        break;
        case 4:
        sptr_string = sptr_cdb->string4;
        break;
        default:
        return 0;
        }

        len = strlen(sptr_string);

        if (len < min_len)
        {
                sptr_cdb->dont_go_next = 1;
                uprintf("Error - string %s had too few characters, need minimum %d characters\n", sptr_string, min_len);
                return 0;
        }

        if (len > max_len)
        {
                sptr_cdb->dont_go_next = 1;
                uprintf("Error - string %s exceeds maximum %d characters\n", sptr_string, max_len);
                return 0;
        }

        return 1;
}

// 73208 remove the need for sptr_cdb
int validate_interface_value_sub(int interface, int interface_type, int physical_view, int dont_complain)
{
        int slot, port;
        int number_of_ports;
        int module_interface_type;
        enum BOOLEAN module_exist_f;
        char port_string[32] = {0,};
        int stack;

        stack = INTERFACE_STACK(interface);

        slot = INTERFACE_SLOT(interface);
        port = INTERFACE_PORT(interface);
        if (physical_view == 0)
        {
                /* user configured module */
                module_exist_f = CONFIG_MODULE_EXIST(slot-1) || MODULE_IS_CONFIGURED(slot-1);
                number_of_ports = CONFIG_MODULE_NUMBER_OF_PORTS(slot-1);
                module_interface_type = CONFIG_MODULE_INTERFACE_TYPE(slot-1);
        }
        else
        {
                /* physical module */
                // TR275207 module must be non-empty
                module_exist_f = ((MODULE_EXIST(slot-1) || MODULE_IS_CONFIGURED(slot-1)) & !MODULE_IS_EMPTY(slot-1));
                number_of_ports = MODULE_NUMBER_OF_PORTS(slot-1);
                module_interface_type = MODULE_INTERFACE_TYPE(slot-1);
        }
        /* we cannot use %p in here because %p does display
         * invalid port number correctly
         */
        ksprintf(port_string, "%d/%d/%d", stack, MODULE_TO_STACK_MODULE(slot-1)+1, port); 
        if (interface_type == ANY_INTERFACE
        ||  interface_type == module_interface_type)
        {
                if ((slot >= 1 && slot <= g_hw_info.max_mod)
                &&  (module_exist_f)
                &&  (port >= 1 && port <= number_of_ports))
 		{
			if (IS_LAG_AP(interface))
			{
				if (/*(IS_LAG_CONFIGURED_AP(INTERFACE_TO_PORT_ID(interface))) ||*/ (IS_LAG_OPERATIONAL_AP(INTERFACE_TO_PORT_ID(interface))) )
					return 1;
			}
			else 
                        return 1;
		}
                if(dont_complain == 0) // 73205
                {
                                if (module_exist_f)
                                {
					if (IS_LAG_AP(interface))
					{
						uprintf ("Error - invalid interface %p\n", INTERFACE_TO_PORT_ID(interface));
					}
					else
                                         uprintf("Error - invalid interface %s\n", port_string);
                                }
				else    /*Display Error MSG if interface is from Non existing module */
                                                        uprintf("Error - invalid module for interface %s\n", port_string);
                }
        }
        else if(dont_complain == 0) // 73205
        {
                if      (interface_type == ENET_INTERFACE)
                        uprintf("Error - interface %s is not an ETHERNET interface\n", port_string);
                else
                        uprintf("Error - invalid interface type\n");

        }
        return 0;
}

/***************************************************************************
 * Name:
 *
 * Description:
 *
 * Parameters:
 *
 * Return:
 *
 * Method:
 *
***************************************************************************/
int validate_interface_value(struct cdb* sptr_cdb, int if_num, int interface_type)
{
        unsigned int interface;

        if(sptr_cdb->debug == DEBUG_SHOW)
                return 0;
        /* support 2 interface parameters in each command line */
        switch (if_num)
        {
        case 1:
        interface = sptr_cdb->if1;
        break;
        case 2:
        interface = sptr_cdb->if2;
        break;
        default:
        return 0;
        }

        if ( 0 == interface ) {
                if ( 0 == sptr_cdb->no ) {

                                                //don't print it during clean config
                                        if (is_stk_clean_cfg())
                                                return 0;

                    uprintf("Uninitialized interface number in config.\n");

                                        if(pp_system_rate_limit_test_always())
                                        {
#ifndef OFFICIAL_RELEASE
                                debug_uprintf("Intrf: 0, no: 0, if_num: %d, intrf. type: %d\n",
                                        if_num, interface_type);
                                debug_print_current_stack_trace();
#endif OFFICIAL_RELEASE
                                        }
                }
                return 0;
        }
        return validate_interface_value_sub(interface, interface_type, sptr_cdb->physical_view, 0);
}

#ifdef NOT_CURRENTLY_USED
int validate_wildcard_interface_value(struct cdb* sptr_cdb, int if_num, int interface_type)
{
        unsigned int interface;
        int slot;
        int module_interface_type;
        enum BOOLEAN module_exist_f;
        char port_string[32];

        if(sptr_cdb->debug == DEBUG_SHOW)
                return 0;
        /* support 2 interface parameters in each command line */
        switch (if_num)
        {
        case 1:
        interface = sptr_cdb->if1;
        break;
        case 2:
        interface = sptr_cdb->if2;
        break;
        default:
        return 0;
        }
        slot = INTERFACE_SLOT(interface);
        if (sptr_cdb->physical_view == 0)
        {
                module_exist_f = CONFIG_MODULE_EXIST(slot-1);
                module_interface_type = CONFIG_MODULE_INTERFACE_TYPE(slot-1);
        }
        else
        {
                module_exist_f = MODULE_EXIST(slot-1) || MODULE_IS_CONFIGURED(slot-1);
                module_interface_type = MODULE_INTERFACE_TYPE(slot-1);
        }
        ksprintf(port_string, "%d/*", slot);
        if (interface_type == ANY_INTERFACE
        ||  interface_type == module_interface_type)
        {
                if (module_exist_f)
                        return 1;
                uprintf("Error - invalid interface %s\n", port_string);
        }
        else
        {
                if (interface_type == ENET_INTERFACE)
                        uprintf("Error - interface %s is not an ETHERNET interface\n", port_string);
                else
                if (interface_type == POS_INTERFACE)
                        uprintf("Error - interface %s is not a POS interface\n", port_string);
                else
                        uprintf("Error - invalid interface type\n");
        }
        return 0;
}
#endif NOT_CURRENTLY_USED


int valid_integer_any_value_range (UINT32 integer, UINT32 min, UINT32 max)
{
        if (integer < min || integer > max)
        {
                uprintf("Error - Invalid input %u. Valid range is between %d and %d\n", integer, min, max);
                return FALSE;
        }
        return TRUE;
}

int valid_integer1_value_range (struct cdb* sptr_cdb, UINT32 min, UINT32 max)
{
        if (sptr_cdb->integer1 < min || sptr_cdb->integer1 > max)
        {
                uprintf("Error - Invalid input %u. Valid range is between %d and %d\n", sptr_cdb->integer1, min, max);
                return FALSE;
        }
        return TRUE;
}

int cu_valid_value_range (UINT32 val, UINT32 min, UINT32 max)
{
        if (val < min || val > max)
        {
                return FALSE;
        }
        return TRUE;
}

int valid_integer2_value_range (struct cdb* sptr_cdb, UINT32 min, UINT32 max)
{
        if (sptr_cdb->integer2 < min || sptr_cdb->integer2 > max)
        {
                uprintf("Error - Invalid input %u. Valid range is between %d and %d\n", sptr_cdb->integer2, min, max);
                return FALSE;
        }
        return TRUE;
}

/***********************************************************
 * byte order sensitive routines
 ***********************************************************/

unsigned long ip_string2int(unsigned char* ip)
{
        int i;
        union ip_addr_t {
                unsigned char ip_b[4];
                unsigned long ip_int;
                        } ip_addr;

#ifndef BIG_ENDIAN
        for (i = 0; i < 4; i++)
                (ip_addr.ip_b)[3-i] = ip[i];
#else
        for (i = 0; i < 4; i++)
                (ip_addr.ip_b)[i] = ip[i];
#endif

        return ip_addr.ip_int;
}

char* ip_int2string(unsigned long ip)
{
        int i;
        static char ip_ascii_string[16];
        char* temp = ip_ascii_string;
        union ip_addr_t {
                unsigned char ip_b[4];
                unsigned long ip_int;
                        } ip_addr;

        ip_addr.ip_int = ip;

#ifndef BIG_ENDIAN
        for (i = 1,
                ksprintf(temp, "%d\0",(ip_addr.ip_b)[3]),
                temp = ip_ascii_string + strlen(ip_ascii_string);
                i < 4; i++)
        {
                ksprintf(temp, ".");
                temp++;
                ksprintf(temp, "%d\0",(ip_addr.ip_b)[3-i]);
                temp = ip_ascii_string + strlen(ip_ascii_string);
        }
#else
        for (i = 1,
                ksprintf(temp, "%d\0",(ip_addr.ip_b)[0]),
                temp = ip_ascii_string + strlen(ip_ascii_string);
                i < 4; i++)
        {
                ksprintf(temp, ".");
                temp++;
                ksprintf(temp, "%d\0",(ip_addr.ip_b)[i]);
                temp = ip_ascii_string + strlen(ip_ascii_string);
        }
#endif

        return ip_ascii_string;
}

/* ToDo. If we need to do a special for MAC, then it should be implemented
in printf. Also true for IP and IPX */
char* mac2string(unsigned char* mac)
{
        int i;
        static char mac_ascii_string[15];
        union ushort_t {
        unsigned char b[2];
        unsigned short int si;
                        } ushort;

        for (i = 0; i < 3; i++) {
#ifndef BIG_ENDIAN
/*
                ushort.b[0] = mac[i*2+1];
                ushort.b[1] = mac[i*2];

        */
                ushort.b[0] = mac[i*2];
                ushort.b[1] = mac[i*2+1];

#else
                ushort.b[0] = mac[i*2];
                ushort.b[1] = mac[i*2+1];
#endif
                ksprintf(&mac_ascii_string[i*5], "%4x.", ushort.si);
        }
        mac_ascii_string[14] = '\0'; /* null terminated */
        return mac_ascii_string;
}

char *g_No_Yes_str_ary[2] = {"No", "Yes"};

extern int cu_get_multi_port_type_error();

/* While configuring port range,if cu_range2maskLong function returns failure case,this function will handle the error scenario */
void cu_range2maskLongError(struct cdb* sptr_cdb)
{
#ifdef SIDEWINDER_BREAKOUT
    if(!cu_get_multi_port_type_error())
                uprintf("Error - Breakout status of atleast one port is not correct\n");
#endif SIDEWINDER_BREAKOUT
        cu_set_multi_port_type_error(FALSE);
                sptr_cdb->dont_go_next = 1;
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
}
#ifdef SIDEWINDER_BREAKOUT

#define SW_MAX_BREAKOUT_PORTS_MODULE_1 48 //12 * 4 = 48 , ports 5 to 16
#define SW_MAX_BREAKOUT_PORTS_MODULE_2 24 // 6 * 4 = 24
#define SW_MODULE1_BREAKOUT_PORT_BASE 3 /*Since the brakout port starts from 5,for 26Q */ 
#define SW_MODULE2_BREAKOUT_PORT_BASE 63
#define SW_MODULE3_BREAKOUT_PORT_BASE 127
#define SW_PORTS_PER_UNIT 256
#define SW_MAX_NUM_MODULES_PER_UNIT 4

//char g_ports_to_breakout[13 * 5 * 65]; // kklin, should not hardcode this
char  g_ports_to_breakout[MAX_PORT_PER_MODULE * MAX_LOCAL_SLOT * MAX_STACKING_NUM];
char *g_ports_to_breakout_backup = NULL;

int is_breakout_set(PORT_ID sw_port)
{
        int stack_id = PORT_TO_STACK_ID(sw_port);
        if(stack_id > MAX_STACKING_NUM) // KKLIN_8021BR
        	return 0;
		
		if(sw_port >= MAX_BREAKOUT_PORTS) // Coverity 49117
			return 0;
			
        return g_ports_to_breakout[sw_port];
}
void set_breakout(PORT_ID sw_port) // This can be called by others
{
        int stack_id = PORT_TO_STACK_ID(sw_port);
        if(stack_id > MAX_STACKING_NUM) // KKLIN_8021BR, KKLIN_8021BR_TBD PE must use different function
        {
                print_out_of_range_stack_id(stack_id);
                return;
        }
        g_ports_to_breakout[sw_port] = 1;
}
void backup_g_ports_to_breakout()
{
        if(g_ports_to_breakout_backup == 0)
                g_ports_to_breakout_backup = dy_malloc(sizeof(g_ports_to_breakout) + 8);
        if(g_ports_to_breakout_backup)
        memcpy(g_ports_to_breakout_backup, g_ports_to_breakout, sizeof(g_ports_to_breakout));
}
void recover_g_ports_to_breakout()
{
        if(g_ports_to_breakout_backup == 0)
                return;
        memcpy(g_ports_to_breakout, g_ports_to_breakout_backup, sizeof(g_ports_to_breakout));
        dy_free(g_ports_to_breakout_backup);
        g_ports_to_breakout_backup = NULL;
}

void clear_g_ports_to_breakout()
{
        memset(g_ports_to_breakout, 0, sizeof(g_ports_to_breakout));
}
void clear_g_ports_to_breakout_except_myself()
{
        int i;
        for(i = 0; i < MAX_STACKING_NUM; i++)
        {
                if((i + 1) == MY_BOOTUP_STACK_ID)
                        continue;
                memset(g_ports_to_breakout + (i* MAX_PORT_PER_MODULE * MAX_LOCAL_SLOT), 0, (MAX_PORT_PER_MODULE * MAX_LOCAL_SLOT));
        }
}
void set_breakout_interface(PORT_ID port_id,int value)
{
	if(!IS_PORT_DB_VALID(port_id))  // For invalid port, do not set breakout config
    	return;
    SPTR_PORT_DB(port_id)->port_config.breakout_config = value;
}

int get_breakout_interface(PORT_ID port_id)
{
	int value = 0;
	
	if(!IS_PORT_DB_VALID(port_id))  // For invalid port, return as no breakout config
    	return value;
	
    value = SPTR_PORT_DB(port_id)->port_config.breakout_config;
    return value;
}

int get_breakout_interface_operational(PORT_ID port_id)
{
	int value = 0;
	
	if(!IS_PORT_DB_VALID(port_id))  // For invalid port, return as no breakout operationanl
    	return value;
	
    value = SPTR_PORT_DB(port_id)->breakout_operational;
	
    return value;
}
void set_breakout_interface_operational(PORT_ID port_id, int value)
{
	if(!IS_PORT_DB_VALID(port_id))  // For invalid port, do not set breakout operational
    	return;
	
    SPTR_PORT_DB(port_id)->breakout_operational = value;
}

int is_breakout_port_configured()
{
    int i;
    PORT_ID port_id;
    if(IS_SIDEWINDER())
    {
        for (i=0; i < g_hw_info.total_config_ports;i++)
        {
            port_id = sw_config_port_list[i];
            if(!IS_PORT_DB_VALID(port_id))
                continue;
            if(get_breakout_interface(port_id)==1)
                return TRUE;
        }
    }
    return FALSE;
}

int is_breakout_port_operational()
{
    int i;
    PORT_ID port_id;
    if(IS_SIDEWINDER())
    {
        for (i=0; i < g_hw_info.total_config_ports;i++)
        {
            port_id = sw_config_port_list[i];
            if(!IS_PORT_DB_VALID(port_id))
                continue;
            if(get_breakout_interface_operational(port_id)==1)
                return TRUE;
        }
    }
    return FALSE;
}

int set_all_4_subports_to_breakout_operational(PORT_ID port)
{
        int kk;
        if(IS_PORT_DB_VALID(port) && IS_PORT_DB_VALID(port+1) && IS_PORT_DB_VALID(port+2) && IS_PORT_DB_VALID(port+3))
        {
                for(kk = 0; kk < 4; kk ++)
                        set_breakout_interface_operational(port+kk, 1);
                return 1;
//              SPTR_PORT_DB(port)->breakout_operational = 1; 
//              SPTR_PORT_DB(port+1)->breakout_operational = 1;
//              SPTR_PORT_DB(port+2)->breakout_operational = 1;
//              SPTR_PORT_DB(port+3)->breakout_operational = 1;
        }
        return 0;
}
// kklin, I change to that port_id is already SW port
void interface_breakout_state(int stack_id,PORT_ID port_id, int detail)
{
    MODULE_ID base_module;
        int i;
        PORT_ID break_port;
        int ind1, ind2, ind3;
        int yes1, yes2, yes3;
        char str1[32], str2[32], str3[32];
    base_module = STACK_TO_BASE_MODULE(stack_id);
// kklin, need break_port for %p printing because g_show_breakout_running = 1. Otherwise, it shows 0x44 as 1/2/5
        break_port = get_breakoutPort_from_swport(port_id);
        if(detail)
        {
                PORT_ID sw_port = port_id + 1;
                ind1 = 0;
                ind2 = 0;
                ind3 = 0;
                for(i = 0; i < 3; i ++, sw_port++)
                {
                        if(IS_PORT_DB_VALID(sw_port))
                        {
                                if(get_breakout_interface(sw_port))
                                        ind1 += ksprintf(str1 + ind1, "%u* ", i+1);
                                else
                                        ind1 += ksprintf(str1 + ind1, "%u ", i+1);
                                if(get_breakout_interface_operational(sw_port))
                                        ind2 += ksprintf(str2 + ind2, "%u* ", i+1);
                                else
                                        ind2 += ksprintf(str2 + ind2, "%u ", i+1);
                        }
                }
                if(ind1 == 0)
                        strcpy(str1, "none");
                if(ind2 == 0)
                        strcpy(str2, "none");
                sw_port = port_id;
                for(i = 0; i < 4; i ++, sw_port++)
                {
                        if(is_breakout_set(sw_port) == 1)
                        {
                                ind3 += ksprintf(str3 + ind3, "%u ", i);
                        }
                }
                if(ind3 == 0)
                        strcpy(str3, "NIL");
                yes1 = (get_breakout_interface(port_id) == 1);
                yes2 = (get_breakout_interface_operational(port_id) == 1);
                
            ksprintf(cu_line_buf,"%-9p %3X   %-6s %-11s %-6s %-11s %-9s\n", 
                break_port, port_id, 
                g_No_Yes_str_ary[yes1],
                str1,
                g_No_Yes_str_ary[yes2],
                str2,
                str3
                );
        }
        else
            ksprintf(cu_line_buf,"%-10p %-15s %-15s %-15s %-15s\n",
                        break_port,MODULE_EXIST(base_module)?"Yes":"No",MODULE_IS_CONFIGURED(base_module)?"Yes":"No",
                        (get_breakout_interface(port_id)==1)?"Yes":"No",(get_breakout_interface_operational(port_id)==1)?"Yes":"No");

    sv_buf_write (SHOW_BUF, cu_line_buf);
}


/* The function cli_allow_fourth_tuple will return whether fourth tuple should be accepted or not*/

int cli_allow_fourth_tuple(PORT_ID sw_port)
{  
    if(!g_sw_sys.init_in_progress)
    {
        MODULE_ID base_module = PORT_TO_MODULE_ID(sw_port);
        if(IS_PORT_DB_VALID(sw_port))
        {
            if (MODULE_EXIST(base_module))
            {
// kklin, If this is a member and the port is on itself, just check operation flag because config is not synced.
                if(STACK_AM_I_MEMBER && PORT_TO_STACK_ID(sw_port) == MY_BOOTUP_STACK_ID)
                {
                    if(SPTR_PORT_DB(sw_port)->breakout_operational)
                        return 1;
                    else
                        return 0;
                }
                                /*"show command " should display in four tuple for Breakout ports which is operational and not breakout configured*/
                if((SPTR_PORT_DB(sw_port)->port_config.breakout_config && SPTR_PORT_DB(sw_port)->breakout_operational) ||
                                   (cdbs[g_uprintf_dest].show && SPTR_PORT_DB(sw_port)->breakout_operational))
                    return 1;
                else
                    return 0;
            }
            else if(MODULE_IS_CONFIGURED(base_module))
                return SPTR_PORT_DB(sw_port)->port_config.breakout_config;
            else
                return 0;
        }   
        else
            return 0;
    }
    else
        return is_breakout_set(sw_port);
}


UINT32 get_breakout_board_type (UINT16 stackId)                                                                                                                                                                                                                             
{                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                             
      MODULE_ID base_module = STACK_TO_BASE_MODULE(stackId);  
          UINT32 board_type = 0;
                                                                                                                                                                                                                                                                              
        if (stackId == MY_BOOTUP_STACK_ID)  // for standalone or active unit                                                                                                                                                                                                    
        {                                                                                                                                                                                                                                                                       
                if (gi_board_type)                                                                                                                                                                                                                                                 
                        board_type = gi_board_type;                                                                                                                                                                                                                                   
                else
                //in case need board type from pre-parse before system init        
                // Note: if cfg_stack_board_type==0, it is filled by g_stacking.eeprom_data_bootup.system_type
                        board_type = g_stacking.cfg.pre_parsed_stacking_cfg[stackId].cfg_stack_board_type;     
      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
      
          else //for standby or member unit
          {
                // kklin, If a unit is non-operational. Its module_status is MODULE_COMING_UP. In such case, we should use
                // whateve is configurred.
                  if (g_module && (MODULE_EXIST(base_module) || MODULE_IS_CONFIGURED(base_module)))
                        board_type = g_module[base_module].main_board_type;
//                board_type = G_STACK_SYSTEM_TYPE(stackId);
                  else if(g_sw_sys.init_in_progress) // kklin, the pre_parsed is only good in init_in_progress for other unit.
                        board_type = g_stacking.cfg.pre_parsed_stacking_cfg[stackId].cfg_stack_board_type;
          }
// kklin, in module mismatch, we must use g_module instead of get_system_type_from_stack_id().
        if(board_type == 0 && g_stacking.breakout_use_stby_board_type)
        {
                board_type = g_stacking.breakout_stby_board_type_ary[stackId];
        }
          if(board_type == 0)
                  board_type = get_system_type_from_stack_id(stackId);
          if(board_type == 0)
          {
                  if(rate_control_mini_sec_per_message(1000, &cmd_complain_rate_limit))
                  {
                #ifndef OFFICIAL_RELEASE
                          debug_uprintf("Error! U%u get_bkout_bd_type(u%u) g_bd_type=%u, init=%u, AM_SL=%u, rated %u\n",
                                  MY_BOOTUP_STACK_ID, stackId,
                                  gi_board_type, g_sw_sys.init_in_progress, 
                                  STACK_AM_I_SLAVE, cmd_complain_rate_limit.reject_cnt);
                          debug_print_current_stack_trace();
                #endif 
                          cmd_complain_rate_limit.reject_cnt = 0;
                  }
          }
      return board_type;                                                                                                                                                                                                                                                      

}    

void get_interface_breakout_state(int stack_id, int module, int detail)
{
    int offset=0;
    UINT16 port_id;
    if(module == 1)
    {
        for(offset = 1; offset < SW_MAX_BREAKOUT_PORTS_MODULE_1; offset = offset+4)
        {   
            port_id = STACK_ID_TO_PORT(stack_id) + SW_MODULE1_BREAKOUT_PORT_BASE + offset;
            if (!IS_PORT_DB_VALID(port_id)) 
                continue;
            interface_breakout_state(stack_id,port_id, detail);
        }
    }

    if(module == 2)
    {
        for(offset = 1; offset < SW_MAX_BREAKOUT_PORTS_MODULE_2; offset = offset+4)
        {   
            port_id = STACK_ID_TO_PORT(stack_id) + SW_MODULE2_BREAKOUT_PORT_BASE + offset;
            if (!IS_PORT_DB_VALID(port_id)) 
                continue;
            interface_breakout_state(stack_id,port_id, detail);
        }
    }
    if(module == 3)
    {
        for(offset = 1; offset < SW_MAX_BREAKOUT_PORTS_MODULE_2; offset = offset+4)
        {   
            port_id = STACK_ID_TO_PORT(stack_id) + SW_MODULE3_BREAKOUT_PORT_BASE + offset;
            if (!IS_PORT_DB_VALID(port_id)) 
                continue;
            interface_breakout_state(stack_id,port_id, detail);
        }
    }
}
void show_interface_breakout_stack_unit(int stack_id, int detail)
{
        int module =0;
        PORT_ID port_id;
        UINT32 board_type;

        g_show_breakout_running = 1;    
        ksprintf(cu_line_buf,"\n%-8s %-5d\n","Unit-Id:",stack_id); 
        sv_buf_write (SHOW_BUF, cu_line_buf);
                
        /* Show breakout output has  below columns*/
        if(detail)
        ksprintf(cu_line_buf,"\n%-9s %-3s   %-6s %-11s %-6s %-11s %-9s\n", 
                "Port", "hex", "config", "port_db", "oper", "port_db", "pre-parse");
        else
                ksprintf(cu_line_buf,"\n%-10s %-15s %-15s %-15s %-15s  \n", "Port", "Module Exist","Module Conf", "breakout_conf", "breakout_oper");

        sv_buf_write (SHOW_BUF, cu_line_buf);
    
        if(IS_SIDEWINDER())
        {
                // kklin, always use get_breakout_board_type
                board_type = get_breakout_board_type(stack_id);
#if 0
            if(stack_id == MY_BOOTUP_STACK_ID)
                board_type = gi_board_type;
            else
                board_type = get_system_type_from_stack_id(stack_id);
#endif
            if((board_type == SW_BOARD_TYPE_20QXG))
            {
                for(module=1;module<SW_MAX_NUM_MODULES_PER_UNIT;module++)
                    get_interface_breakout_state(stack_id,module, detail);          
            }
            
            if((board_type == SW_BOARD_TYPE_48XGC) || (board_type == SW_BOARD_TYPE_48XGF))
            {
                for(module=2;module<SW_MAX_NUM_MODULES_PER_UNIT;module++)
                    get_interface_breakout_state(stack_id,module, detail);  
            }
        }   
                g_show_breakout_running = 0;
        return;
}

void show_interface_breakout(struct cdb *sptr_cdb)
{
    int stack_id;

    sptr_cdb->dont_go_next = 1;

    if ((SHOW_BUF = sv_buf_alloc()) == NULL)
        return; 

    stack_id = sptr_cdb->integer1 ;


    if (stack_id != MY_BOOTUP_STACK_ID)
    {
        if(STACK_AM_I_MEMBER)
	{
	    sv_buf_release();
            return;
	}
    }
         if (is_stack_base_module_exist(stack_id))
        show_interface_breakout_stack_unit(stack_id, 0);
    else
                uprintf("\nUnit %u does not exist.\n", stack_id);
    sv_buf_write(SHOW_BUF, "\n");
    sv_buf_display();
}

void show_interface_breakout_all(struct cdb *sptr_cdb)
{
        int stack_id,j;

        /* show breakout should be blcoked for Stacking devices */
        if(is_stacking_enabled())
    {
                sptr_cdb->dont_go_next = 1;
        uprintf("Error: This CLI operation is not applicable when stack is enabled \n");
        return;
    }

 
    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;
   
    if ((SHOW_BUF = sv_buf_alloc()) == NULL)
        return;

    for (stack_id = 1; stack_id <= MAX_STACKING_NUM  ; stack_id ++)
    {
        if (is_stack_base_module_exist(stack_id))
            show_interface_breakout_stack_unit(stack_id, 0);
    }

    sv_buf_write(SHOW_BUF, "\n");
    sv_buf_display();
    
    return;
}
#endif

extern void runtime_remove_commands_from_stp_node();    /* in vlan_cmds.c */
void pre_parse_config_file(void);
void stacking_mode_parser_nodes_update(void)
{
#if 0
        traverse_parser_nodes(
                user_execute, stacking_mode_update_node_flags_callback, NULL, FALSE);
        traverse_parser_nodes(
                execute, stacking_mode_update_node_flags_callback, NULL, FALSE);
        traverse_parser_nodes(
                config, stacking_mode_update_node_flags_callback, NULL, FALSE);
#endif
}

#ifdef SR_SWITCH_ROUTER
#ifdef __IP_MULTICAST__
extern struct node efx_debug_ip[];
extern struct node efx_debug_ipv6[];
void multicast_disable_routing_commands()
{
                /* Disable V4 L3MC routing commands. */
                update_tree_node_flag(c_ip, TRUE, 1, "multicast-routing", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                
                update_tree_node_flag(c_router, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ip, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(i_ip, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(i_ip, TRUE, 1, "pim-sparse", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_clear_ip, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(i_ip, TRUE, 1, "igmp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ip, TRUE, 1, "igmp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ip, TRUE, 1, "igmp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_clear_ip, TRUE, 1, "igmp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(c_ip, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ip_vrf_ip, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ip, TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ip_vrf_ip, TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_static, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ip, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_clear_ip, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(c_router, TRUE, 1, "msdp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(i_ip, TRUE, 1, "multicast-boundary", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(efx_debug_ip, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(efx_debug_ip, TRUE, 1, "igmp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                /* Disable V6 L3MC routing commands. */
                update_tree_node_flag(c_ipv6, TRUE, 1, "multicast-routing", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ipv6_router, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ipv6, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(i_ipv6, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(i_ipv6, TRUE, 1, "pim-sparse", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_clear_ipv6, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(i_ipv6, TRUE, 1, "mld", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ipv6, TRUE, 1, "mld", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ipv6, TRUE, 1, "mld", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_clear_ipv6, TRUE, 1, "mld", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(c_ipv6, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ipv6_vrf_ipv6, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ipv6, TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(c_ipv6_vrf_ipv6, TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ipv6_static, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_show_ipv6, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(e_clear_ipv6, TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(i_ipv6, TRUE, 1, "multicast-boundary", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

                update_tree_node_flag(efx_debug_ipv6, TRUE, 1, "pim", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
                update_tree_node_flag(efx_debug_ipv6, TRUE, 1, "mld", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
}
#endif __IP_MULTICAST__
#endif
  
extern struct node c_mcast_optim_oif_list[];
extern struct node c_mcast6_optim_oif_list[];
extern struct node e_show_ip_pim_counter[];
extern struct node e_show_ipv6_pim_counter[];
void multicast_update_tree_node_flag()
{ 
        /* Static mroute disable */ 
#ifdef SR_SWITCH_ROUTER
#ifdef __IP_MULTICAST__
        update_tree_node_flag(c_multicast_routing,  TRUE, 1, "statistics", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_multicast_routing,      TRUE, 1, "lag", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_multicast_routing,      TRUE, 1, "policy-map", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_multicast_routing,      TRUE, !IS_FI_BCM(), "optimization", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_mcast_optim_oif_list,   TRUE, 1, "ports", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_mcast_optim_oif_list,   TRUE, 1, "lag", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

        update_tree_node_flag(c_multicast6_routing,     TRUE, 1, "statistics", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_multicast6_routing,     TRUE, 1, "lag", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_multicast6_routing,     TRUE, 1, "policy-map", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_multicast6_routing,     TRUE, !IS_FI_BCM(), "optimization", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_mcast6_optim_oif_list,  TRUE, 1, "ports", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_mcast6_optim_oif_list,  TRUE, 1, "lag", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

        update_tree_node_flag(c_ip, TRUE, 1, "multicast-max-all-vrf-cam", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_ipv6, TRUE, 1, "multicast-max-all-vrf-cam", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

        update_tree_node_flag(e_show_ip_pim_counter, TRUE, 1, "lag", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(e_show_ipv6_pim_counter, TRUE, 1, "lag", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#endif __IP_MULTICAST__
#ifdef NO_STATIC_MROUTE_SUPPORT
        // IPv4 commands 
        update_tree_node_flag(c_ip,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_ip,  TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_ip_vrf_ip,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_ip_vrf_ip,  TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(e_show_static,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(e_show_ip,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(e_clear_ip,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#ifdef __PIM__
        update_tree_node_flag(g_fi_config,  TRUE, 1, "route-precedence", ROUTER_PIM_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
#endif 
        // IPv6 commands 
        update_tree_node_flag(c_ipv6,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_ipv6,  TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_ipv6_vrf_ipv6,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_ipv6_vrf_ipv6,  TRUE, 1, "max-mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);       
        update_tree_node_flag(e_show_ipv6_static,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(e_show_ipv6,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);  
        update_tree_node_flag(e_clear_ipv6,  TRUE, 1, "mroute", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(g_fi_config,      TRUE, 1, "route-precedence", ROUTER_IPV6_PIM_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
#endif NO_STATIC_MROUTE_SUPPORT

#ifdef __IP_MULTICAST__  
#ifndef FI_PIM_WG_FWDING_SUPPORT
        update_tree_node_flag(c_ip_pim_sptThreshold,    TRUE, 1, "infinity", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
        update_tree_node_flag(c_ipv6_pim_sptThreshold,  TRUE, 1, "infinity", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN); 
#endif FI_PIM_WG_FWDING_SUPPORT
#endif __IP_MULTICAST__  

#endif /* SR_SWITCH_ROUTER */
#ifdef SIDEWINDER_LINUX
        update_tree_node_flag(g_fi_config,  TRUE, 1, "ip-hash", GLOBAL_CONFIG_KEYWORD, DONT_SHOW);
        update_tree_node_flag(e_clear,  TRUE, 1, "ip-hash", KEYWORD, DONT_SHOW);
        update_tree_node_flag(e_show,  TRUE, 1, "ip-hash", KEYWORD, DONT_SHOW);
#endif SIDEWINDER_LINUX

#ifdef SR_SWITCH_ROUTER
        // Disable DVMRP cli.
        update_tree_node_flag(c_router, TRUE, 1, "dvmrp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
        update_tree_node_flag(e_show_ip, TRUE, 1, "dvmrp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
        update_tree_node_flag(i_ip, TRUE, 1, "dvmrp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
        update_tree_node_flag(e_clear, TRUE, 1, "dvmrp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
        
        update_tree_node_flag(execute, TRUE, 1, "mtraceroute", PRIV_EXEC_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );

#ifdef __IP_MULTICAST__
        if (IS_SICA_L_24GC()) // Disable  Multicast routing for Sica-L
        {
                multicast_disable_routing_commands();
        }
		else if (IS_SICA())
		{
			update_tree_node_flag(c_router, TRUE, 1, "msdp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN );
		}
#endif __IP_MULTICAST__ 
#endif

        // v4 unregistered multicast disable-flooding feature supported only on Reaper and all BCM platforms
        if (!IS_FI_BCM())
        {
                update_tree_node_flag(c_ip_l2mcast,  TRUE, 1, "disable-flooding", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);      
        }
        // v6 unregistered multicast disable-flooding feature supported only on Reaper and Sidewinder
        if (!IS_SIDEWINDER() || !IS_TANTO())
        {
                update_tree_node_flag(c_ipv6_l2mld,  TRUE, 1, "disable-flooding", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);        
        }       
} 

/* cmd init */
extern void cu_verify_fndry_system_parameters_range( void );
void cmd_init(void)
{
    int numFanSpeeds;

#ifdef DEBUG_DNLD_STK
extern int my_dbg_code;
#endif
        config_term_user_count = 0; /* ditto */

        /* initialize level4 and level5 passwords to default values. */
        strcpy(g_access_control.level_password[CU_SECURITY_LEVEL4], CU_DEFAULT_LEVEL4_PASSWORD);
        strcpy(g_access_control.level_password[CU_SECURITY_LEVEL5], CU_DEFAULT_LEVEL5_PASSWORD);
        g_access_control.min_password_length=CU_MIN_LENGTH_OF_PASSWORD;
        memset(boot_seq, 0, MAX_BOOT_SEQ);


        max_config_buffer_size = max_config_size = MAX_CONFIG_SIZE;

        /* bug 9658 */
        /* Remove those commands from the c_vlan_stp node that should not be
         * in there.
         */
        runtime_remove_commands_from_stp_node();

        g_copy_tftp_acl = 0;

                g_copy_tftp_acl_in_progress = 0 ;

        config_buffer_init();

#ifndef SIDEWINDER_LINUX  // SW_TODO
        /* BUG: 8348 Fan  */
        if (MODULE_IS_IPC_CLASS(g_hw_info.cpu_module))
        {
                #ifdef SR_SWITCH_ROUTER
                update_tree_node_flag(g_fi_config, TRUE, 1, "rate-limit", VLAN_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(g_fi_config, TRUE, 1, "rate-limit", VIF_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                #endif

                update_tree_node_flag(c_acl, TRUE, 1, "rate-limit", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show, TRUE, 1, "rate-limit", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        }
        else
        {
#if (defined(BASIC_RATE_LIMITING))
                /* BUG: 6585 Fan */
                update_tree_node_flag(i_show_rate_limit, TRUE, 1, "hardware-rate-limit-status", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
#endif
        }

        // rakesh: to take care of different fan speeds on different systems
        numFanSpeeds = chassisGetNumFanSpeeds(MY_BOOTUP_STACK_ID);
        if (numFanSpeeds > 0) {
                char speed_x[8] = "speed-1";

                while (numFanSpeeds++ < CH_MAX_NUM_FAN_SPEEDS) {
                        speed_x[strlen(speed_x)-1] = '0' + numFanSpeeds;
                        update_tree_node_flag(c_fan_threshold_values, TRUE, 1, speed_x, KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                }
        }
#endif

                multicast_update_tree_node_flag(); 
        sw_cu_update_tree_node_flag(); //Maocheng++: disable un-necessary tree node at runtime.  104701

                update_tree_node_flag(c_fan_threshold, TRUE, 1, "sfp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        // Dont know wht the equivalent function to know its a FESX. So added as NOT_SXR
        if  (!is_system_mct_support()){
                // cluster configurations
                update_tree_node_flag(g_fi_config, TRUE, 1, "cluster", GLOBAL_CONFIG_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(g_fi_config, TRUE, 1, "cluster-l2protocol-forward", GLOBAL_CONFIG_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                //configuring cluster-l2protocol-forward at an Interface level
                update_tree_node_flag(g_fi_config, TRUE, 1, "cluster-l2protocol-forward", IF_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                //cluster related show commands
                update_tree_node_flag(e_show, TRUE, 1, "cluster", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show, TRUE, 1, "ccp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_station, TRUE, 1, "cluster", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_station, TRUE, 1, "mdup-stats", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_station, TRUE, 1, "mdb", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                //cluster related debug commands
                update_tree_node_flag(efx_debug, TRUE, 1, "cluster", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                //cluster related dm commands
                update_tree_node_flag(e_mem, TRUE, 1, "cluster", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_mem, TRUE, 1, "ccp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        }

        {
                update_tree_node_flag(c_fan_threshold, TRUE, 1, "lp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_pid_prom, TRUE, 1, "module-id", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_pid_prom, TRUE, 1, "backplane", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_pid_prom, TRUE, 1, "slot", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                /* Don't support "hw pid clear-sw-license-id" on FCX */
                update_tree_node_flag(e_pid_prom, TRUE, 1, "clear-sw-license-id", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                update_tree_node_flag(e_show_poe_detail, TRUE, 1, "SLOT", DECIMAL, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

        }
        /* TR000343170 : Removing fips command for TURBOIRON*/
        if(IS_TURBOIRON ())
        {
                update_tree_node_flag(execute, TRUE, 1, "fips", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(g_fi_config, TRUE, 1, "fips", GLOBAL_CONFIG_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        }

     //Web management commands are blocked in 7.5. Reverting back the blocked commands for 8.0.01

#ifdef SR_SWITCH_ROUTER
        if (pp_check_is_ipv6_hw())
        {
                update_tree_node_flag(c_system_max,TRUE, 1,"hw-ip-next-hop", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"hw-logical-interface", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"hw-ip-mcast-mll", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                /*if(!get_isV6EnabledByEEPROM())
                {
                        update_tree_node_flag(c_system_max,TRUE, 1,"ip6-route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                        update_tree_node_flag(c_system_max,TRUE, 1,"ip6-static-route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                        update_tree_node_flag(c_system_max,TRUE, 1,"ip6-cache", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                }*/

        }
        else
        {
                update_tree_node_flag(g_fi_config,TRUE, 1,"ipv6", LBIF_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#if (defined (__GRE_IP_TUNNEL__) || defined (__TUNNEL_INTERFACE__))
                update_tree_node_flag(g_fi_config,TRUE, 1,"ipv6", TNIF_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#endif
                update_tree_node_flag(c_ipv6,TRUE, 1,"load-sharing", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"debug", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"hop-limit", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"icmp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"prefix-list", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"unicast-routing", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"router", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_ipv6,TRUE, 1,"nd-ns-priority", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                update_tree_node_flag(i_ipv6,TRUE, 1,"mtu", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"nat", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"ospf", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"rip", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                #ifdef __DHCP6_AGENT__
                update_tree_node_flag(i_ipv6,TRUE, 1,"dhcp-relay", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                #endif __DHCP6_AGENT__
                update_tree_node_flag(i_ipv6,TRUE, 1,"redirects ", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"router", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"traffic-filter ", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"unnumbered ", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(i_ipv6,TRUE, 1,"nd", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                update_tree_node_flag(e_show_ipv6_route,TRUE, 1,"bgp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6_route,TRUE, 1,"ospf", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6_route,TRUE, 1,"rip", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6_route,TRUE, 1,"static", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6_route,TRUE, 1,"summary", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"nd-ns-priority-macs", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"prefix-lists", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"bgp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"ospf", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                #ifdef __DHCP6_AGENT__
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"dhcp-relay", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                #endif __DHCP6_AGENT__
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"rip", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                update_tree_node_flag(e_clear_ipv6,TRUE, 1,"bgp", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_clear_ipv6,TRUE, 1,"rip", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_clear_ipv6,TRUE, 1,"ospf", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_clear_ipv6,TRUE, 1,"route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

#if  (defined(__TUNNEL_INTERFACE__) && defined (__OSPFV3__))
                update_tree_node_flag(e_clear_ospf6_counts_neighbor_interface,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_clear_ospf6_neighbor_interface,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#endif (defined(__TUNNEL_INTERFACE__) && defined (__OSPFV3__))

#ifndef __IPV6_HOST_ONLY__
                update_tree_node_flag(c_privilege,TRUE, 1,"ripng-router", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#endif __IPV6_HOST_ONLY__
#ifdef __OSPFV3__
                update_tree_node_flag(c_privilege,TRUE, 1,"ospf6-router", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#endif __OSPFV3__
                update_tree_node_flag(c_if,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_int_brief,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_int,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ip,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ip_int,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6_int,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6_cache,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show_ipv6,TRUE, 1,"route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

                update_tree_node_flag(e_clear_ip,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_clear_ipv6_cache,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_clear_ipv6,TRUE, 1,"tunnel", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

//#ifdef SR_SWITCH_ROUTER, 107787, no matter router or not, those command should not be available under ipv4 platform.
                update_tree_node_flag(c_system_max,TRUE, 1,"ip6-route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"ip6-static-route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"ip6-cache", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"gre-tunnels", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
//#endif


#ifdef __FOUNDRY_BGP__
                update_tree_node_flag(bgp_addressFamily,TRUE, 1,"ipv6", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
#endif __FOUNDRY_BGP__
/*              update_tree_node_flag(config,TRUE, 1,"distribute-list", ROUTER_IPV6_RIP_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(config,TRUE, 1,"distance", ROUTER_IPV6_RIP_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(config,TRUE, 1,"redistribute", ROUTER_IPV6_RIP_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(config,TRUE, 1,"poison-local-routes", ROUTER_IPV6_RIP_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(config,TRUE, 1,"poison-reverse", ROUTER_IPV6_RIP_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(config,TRUE, 1,"timers", ROUTER_IPV6_RIP_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
*/
        }
#else  //SR_SWITCH_ROUTER
//107787, no matter router or not, those command should not be available under ipv4 platform.
                update_tree_node_flag(c_system_max,TRUE, 1,"ip6-route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"ip6-static-route", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"ip6-cache", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_system_max,TRUE, 1,"gre-tunnels", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

#endif  SR_SWITCH_ROUTER

        update_tree_node_flag(g_fi_config, TRUE, 1, "delay-link-event", GLOBAL_CONFIG_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);


        update_tree_node_flag(c_logging_port, TRUE, 1, "ssl-port", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_logging_port_ip6, TRUE, 1, "ssl-port", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        update_tree_node_flag(c_logging_name_port, TRUE, 1, "ssl-port", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
        //update_tree_node_flag(c_ssh_server, TRUE, 1, "sha", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);

        /* disabling bypass-test node if FIPS EEPROM bit is not set */          
    if(!is_fips_bypass_test_required())
                update_tree_node_flag(c_fips, TRUE, 1, "bypass-test", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
        
        switch (g_hw_info.prod_type)
        {
          case BI_NI:
          {
                if (!is_stack())
                {
//                      if (!g_hw_info.is_bigiron)
                        {
                                #ifdef NOT_USED
                                if (g_hw_info.backplane_type == CHASSIS_4000)
                                        /* FastIronII Switch */
                                else
                                        /* FastIronII+ Switch */
                                #endif NOT_USED

                                if (!MODULE_IS_IPC_CLASS(g_hw_info.cpu_module))
                                {
                                        #ifdef NO_ACL_FOR_FASTIRON_II
                                        /* 1/8/01 WHC Turned on ACL for FastIronII per Lee's request */
                                        #ifdef SR_SWITCH_ONLY
                                        set_config_tree_node_flag("ip", IF_KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                                        #endif SR_SWITCH_ONLY
                                        update_tree_node_flag(i_ip, TRUE, 1, "access-group", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                                        update_tree_node_flag(g_fi_config, TRUE, 1, "rate-limit", VLAN_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                                        update_tree_node_flag(g_fi_config, TRUE, 1, "rate-limit", IF_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                                        #endif NO_ACL_FOR_FASTIRON_II
                                }
                        }
                }
          }
          break;

          case BI_BB:
          {
                if (!is_stack())
                {
//                      if (!g_hw_info.is_bigiron)
                        {
                                #ifdef NOT_USED
                                if (g_hw_info.backplane_type == CHASSIS_4000)
                                        /* FastIronII Switch */
                                else
                                        /* FastIronII+ Switch */
                                #endif NOT_USED

                                if (!MODULE_IS_IPC_CLASS(g_hw_info.cpu_module))
                                {
                                        #ifdef NO_ACL_FOR_FASTIRON_II
                                        /* 1/8/01 WHC Turned on ACL for FastIronII per Lee's request */
                                        #ifdef SR_SWITCH_ONLY
                                        set_config_tree_node_flag("ip", IF_KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                                        #endif SR_SWITCH_ONLY
                                        update_tree_node_flag(i_ip, TRUE, 1, "access-group", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                                        update_tree_node_flag(g_fi_config, TRUE, 1, "rate-limit", VLAN_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                                        update_tree_node_flag(g_fi_config, TRUE, 1, "rate-limit", IF_KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                                        #endif NO_ACL_FOR_FASTIRON_II
                                        /* Bug 9092 */

                                }
                        }
                }
          }
          break;
        }

//#ifdef HOT_SWAP
        /* for stackable switches, we don't support the "module" command */
        if (is_stack())
        {
                set_config_tree_node_flag("module", GLOBAL_CONFIG_KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(e_show, TRUE, 1, "module", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_snmp_trap, TRUE, 1, "module-inserted", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_snmp_trap, TRUE, 1, "module-removed", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN);
        }
//#endif HOT_SWAP


        switch (g_hw_info.backplane_type)
        {
        case STACK_1:
                update_tree_node_flag(c_chassis_mask, TRUE, 1, "ps3", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_chassis_mask, TRUE, 1, "ps4", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_chassis_mask, TRUE, 1, "fan3", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_chassis_mask, TRUE, 1, "fan4", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                break;
        case CHASSIS_4000:
                update_tree_node_flag(c_chassis_mask, TRUE, 1, "ps3", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                update_tree_node_flag(c_chassis_mask, TRUE, 1, "ps4", KEYWORD, DONT_SHOW | DONT_PARSE | DONT_CONFIG_GEN);
                break;
        }
#ifndef NO_FIPS_XCAT_LINUX_BRINGUP
        strcpy(default_encrypted_level4_password, aaa_crypt(CU_DEFAULT_LEVEL4_PASSWORD, generate_md5_salt()));
        strcpy(default_encrypted_level5_password, aaa_crypt(CU_DEFAULT_LEVEL5_PASSWORD, generate_md5_salt()));
#endif /* NO_FIPS_XCAT_LINUX_BRINGUP */

#ifdef __FDP__
#ifndef __FDP_CMDS_H__
        /* call to remove pnp command from unsupported fastiron unit */
        //remove all pnp/ztp from 8.0.30
        //{
                update_tree_node_flag(g_fi_config, TRUE, 1, "pnp", GLOBAL_CONFIG_KEYWORD, DONT_PARSE | DONT_CONFIG_GEN | DONT_SHOW);
                update_tree_node_flag(e_clear, TRUE, 1, "pnp", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN | DONT_SHOW);
                update_tree_node_flag(e_show, TRUE, 1, "pnp", KEYWORD, DONT_PARSE | DONT_CONFIG_GEN | DONT_SHOW);
        //}
#endif
#endif

#ifndef NO_GIG_ANA_SWITCH
        g_ptr_version = (char *)NULL;
        g_gig_auto = NEG_FULL_AUTO;
#endif NO_GIG_ANA_SWITCH

        stacking_mode_parser_nodes_update();

        cu_init_sys_param();

#ifdef SR_SWITCH_ROUTER
#ifdef FI_URPF
        cu_adjust_system_max_min_default_val_based_if_urpf_configured(); 
#endif
#endif
        pre_parse_config_file();        /* For #71585, but is this the right place ?? **TODO** */
        
        /* varify the variables, if any variable found wrong then reset all variable
         * to default because dependancy may exists between different variables */
         cu_verify_fndry_system_parameters_range();


}

/***************************************************************************
 * Name:
 *
 * Description:
 *
 * Parameters:
 *
 * Return:
 *
 * Method:
 *
***************************************************************************/
void set_port_list_num(struct cdb* sptr_cdb, void (*callback)(struct cdb*))
{
        UINT8 next_token, match_char;
        int if_type;
        
        switch (sptr_cdb->if_type)
        {
        case ETHERNET:
                match_char = 'e';
                if_type = ENET_INTERFACE;
                break;
        case VLAG:
                match_char = 'l';
                if_type = LAG_INTERFACE;
                break;
        case POS:
                match_char = 'p';
                if_type = POS_INTERFACE;
                break;
        default:
                sptr_cdb->dont_go_next = 1;
                return;
        }

        next_token = tolower(end_of_token(sptr_cdb->token));

        /* if next token is "to" or "?", command is not for us */
        if (next_token != match_char && next_token != 0)
        {
            if(!(next_token == 'e' || next_token == 'l'))
                return;
        }

        /* next token is either "ethernet" or null */
        if (!validate_interface_value(sptr_cdb, 1, if_type))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        /* reset sptr_cdb->num_of_if to 0 so that the parser always
         * puts port number to sptr_cdb->if1
         */
        sptr_cdb->num_of_if = 0;
        set_mask_bit(sptr_cdb->port_mask1, INTERFACE_TO_PORT_ID(sptr_cdb->if1));

        if (next_token == 0)
        {
                sptr_cdb->dont_go_next = 1;
                (*callback)(sptr_cdb);
        }
}

/***************************************************************************
 * Name:
 *
 * Description:
 *
 * Parameters:
 *
 * Return:
 *
 * Method:
 *
***************************************************************************/
void set_port_list_num_num(struct cdb* sptr_cdb, void (*callback)(struct cdb*))
{
        UINT8 next_token, match_char;
        int fslot, fport, tslot, tport;
        PORT_MASK port_mask[MAX_SLOT];
        int if_type;

        switch (sptr_cdb->if_type)
        {
        case ETHERNET:
                match_char = 'e';
                if_type = ENET_INTERFACE;
                break;
        case VLAG:
                match_char = 'l';
                if_type = LAG_INTERFACE;
                break;
        case POS:
                match_char = 'p';
                if_type = POS_INTERFACE;
                break;
        default:
                sptr_cdb->dont_go_next = 1;
                return;
        }

        next_token = tolower(end_of_token(sptr_cdb->token));

        /* if next token is "?", command is not for us */
#ifndef NO_STATIC_MMAC
#ifdef OLD
        /* Bug 8464
         * A check whether sptr_cdb->help is TRUE or not is made in the
         * calling function: set_static_Mac_portList_enet_Num_Num() itself.
         * Thus if sptr_cdb->help is TRUE, we will not reach here in anycase.
         */
        if (sptr_cdb->help || next_token != 0)
#endif OLD
#else NO_STATIC_MMAC
        if (sptr_cdb->help || (next_token != match_char && next_token != 0))
        {
            if(!(next_token == 'e' || next_token == 'l'))
                return;
        }
#endif NO_STATIC_MMAC

        /* next token is either "ethernet" or null */
        if (!validate_interface_value(sptr_cdb, 1, if_type)
        ||  !validate_interface_value(sptr_cdb, 2, if_type))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        /* reset sptr_cdb->num_of_if to 0 so that the parser always
         * puts port number to sptr_cdb->if1 and sptr_cdb->if2
         */
        sptr_cdb->num_of_if = 0;
        fslot = INTERFACE_SLOT(sptr_cdb->if1);
        fport = INTERFACE_PORT(sptr_cdb->if1);
        tslot = INTERFACE_SLOT(sptr_cdb->if2);
        tport = INTERFACE_PORT(sptr_cdb->if2);
#ifdef SIDEWINDER_BREAKOUT
                if(cu_range2maskLong(fslot, fport, tslot, tport, port_mask) == CU_ERROR)
        {
            cu_range2maskLongError(sptr_cdb);
                        return;
        }
#else
                cu_range2maskLong(fslot, fport, tslot, tport, port_mask);
#endif
        or_masks(sptr_cdb->port_mask1, sptr_cdb->port_mask1, port_mask);

        if (next_token == 0)
        {
                sptr_cdb->dont_go_next = 1;
                (*callback)(sptr_cdb);
        }
}

void sw_span_clock(struct cdb* sptr_cdb)
{
int             yes_no = 1;
UINT32  span_clock;

        if (sptr_cdb->config_gen) {
                if (span_clock = sw_get_span_clock()) {
                        ksprintf(cu_line_buf, "spn-clock %d\n", span_clock);
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (sptr_cdb->no) {
                yes_no = 0;
        }
        sw_set_span_clock(yes_no,sptr_cdb->integer1);
}

void set_afi_ipv4(struct cdb* sptr_cdb)
{
        if (!sptr_cdb->config_gen)
        {
                sptr_cdb->afi = IPV4_AFI_TYPE;
                sptr_cdb->vrf_idx = IPVRF_DEFAULT_VRF_IDX;
        }
}

#ifdef __IPV6__
void set_afi_ipv6(struct cdb* sptr_cdb)
{
        if (!sptr_cdb->config_gen)
        {
                sptr_cdb->afi = IPV6_AFI_TYPE;
        }
}
#endif __IPV6__

  /* BUG: 69017 */
static UINT8 hex_digits[] = "0123456789abcdef";
int hex2string(UINT8 *hex, int length, UINT8 *str)
{
int i;

        for (i=0; i<length; i++)
        {
                *str++ = hex_digits[high_nibble_of_byte(*hex)];
                *str++ = hex_digits[low_nibble_of_byte(*hex)];
                hex++;
        }
        *str = '\0';
        return(0);
}
int string2hex(UINT8 *str,  UINT8 *hex)
{
        int lo_nibble, hi_nibble;

        while (*str)
        {
                if (isdigit(*str))
                        hi_nibble = *str - '0';
                else
                {
                        if (tolower(*str) >= 'a' &&  tolower(*str) <= 'f')
                                hi_nibble = tolower(*str) - 'a' + 10;
                        else
                                return(-1);
                }
                str++;
                if (*str == '\0')
                        break;
                if (isdigit(*str))
                        lo_nibble = *str - '0';
                else
                {
                        if (tolower(*str) >= 'a' &&  tolower(*str) <= 'f')
                                lo_nibble = tolower(*str) - 'a' + 10;
                        else
                                return(-1);
                }
                str++;
                *hex++ = two_nibbles_to_byte(hi_nibble, lo_nibble);
        }
        *hex = '\0';
        return(0);
}

//#define MD5_FILE_BUFFER_SIZE 8192
#define MD5_FILE_BUFFER_SIZE	0x2000

#ifdef FI_LINUX

 long long md5_pflash_offset=0;
 long long md5_pfile_offset=0;

int md5_flash_offset_local_copy_p(long long dest , long long src)
{
        md5_pflash_offset=dest;
        md5_pfile_offset=src;
        return 0 ;
}


int md5_update_flash_pointers_p(int fd , long long dest , long long src)
{
        return sys_prepare_for_flash_transfer(fd,dest,src,md5_flash_offset_local_copy_p);
}

#endif

typedef struct hash_function_info
{
    int f;
        char hash_file_name[32];
        enum HASH_IMAGE_TYPE hash_file_type;
        int hash_file_length;
        SV_TIMER_TOKEN_T hash_timer_id;
        enum HASH_ALGORITHM checksum_type;
        union {
                //MD5_CTX md5_ctx;
                FIPS_CONTEXT md5_ctx; /* Using Fips context*/
                FIPS_CONTEXT sha_ctx;
                UINT32 crc;             /* accumulative crc32*/
        }ctx;
        char digist_output[FIPS_SHA1_LENGTH+1];
        char digist_match[FIPS_SHA1_LENGTH*2+1];
        int current_size;
        int number_of_blocks;
        int current_block;
        char *buf;
        UINT32 hash_uprintf_dest;       /* g_uprintf_dest */
} HASH_FUNCTION_INFO, *pHASH_FUNCTION_INFO;
HASH_FUNCTION_INFO g_hash_cb;

/*
 * Output = MD5( file contents )
 */
void verify_hash_file_callback( HASH_FUNCTION_INFO *hash_cb )
{
                size_t n;
                int i, ret = 0;
                char hex[FIPS_SHA1_LENGTH+1];
                UINT32 old_uprintf_dest;

        old_uprintf_dest = g_uprintf_dest;
        g_uprintf_dest = hash_cb->hash_uprintf_dest;

        for (i=hash_cb->current_block; i < hash_cb->number_of_blocks; i++)
        {
                if (is_linux_based_system())
                {
                        if( ((i+1) * MD5_FILE_BUFFER_SIZE) >= hash_cb->hash_file_length)
                        {
                                n=sys_flash_fread(hash_cb->f, hash_cb->buf, (hash_cb->hash_file_length - (i) *MD5_FILE_BUFFER_SIZE));
                                /*Since we reached the end of the file . wrap around to the start fo the file for the next command*/
                                flash_fseek(hash_cb->f,0,FLASH_FILE_SEEK_SET);
#ifdef FI_LINUX
				md5_update_flash_pointers_p(hash_cb->f,0,0);
#endif
                                reset_flash_use_in_progress();
                        }
                        else
                        {
                                n=sys_flash_fread(hash_cb->f, hash_cb->buf,MD5_FILE_BUFFER_SIZE );
                        }
                }
                else
                        n = sys_flash_fread(hash_cb->f, hash_cb->buf,  MD5_FILE_BUFFER_SIZE );

                if (n <= 0)
                {
                        if(is_linux_based_system())
                        {
                            /*Since we reached the end of the file . wrap around to the start fo the file for the next command*/
                             flash_fseek(hash_cb->f,0,FLASH_FILE_SEEK_SET);
#ifdef FI_LINUX
				md5_update_flash_pointers_p(hash_cb->f,0,0);
#endif
                             reset_flash_use_in_progress();
                        }
                        break;
                }
#ifdef FI_LINUX
		md5_update_flash_pointers_p(hash_cb->f,md5_pflash_offset+n,md5_pfile_offset+n);
#endif
		++hash_cb->current_block;

                hash_cb->current_size += n;
                if (hash_cb->checksum_type)
                {
                        if (hash_cb->checksum_type == HASH_MD5)
                        {
//                              MD_update( &hash_cb->ctx.md5_ctx, hash_cb->buf, n, hash_cb->checksum_type);
                                ret = fips_Hash_Update(hash_cb->ctx.md5_ctx,hash_cb->buf, n);
                                if (ret < 0)
                                        {
                                                uprintf("\n fips_Hash_Update failed for MD5. ret: %d", ret);
                                                return;
                                       }
                        }
                        else
                        {
                                //sha_update( &hash_cb->ctx.sha_ctx, hash_cb->buf, n);
//                              fips_SHA1_Update( (acSHA1Context *) &hash_cb->ctx.sha_ctx, hash_cb->buf, n);
                                ret = fips_Hash_Update(hash_cb->ctx.sha_ctx, hash_cb->buf, n);
                                if (ret < 0)
                                {
                                        uprintf("\n fips_Hash_Update failed for SHA1. ret: %d", ret);
                                        return;
                                }
                        }
                }
                else
                {
                        hash_cb->ctx.crc = calculate_block_crc32(n, hash_cb->ctx.crc, hash_cb->buf);
                }
                if ((hash_cb->current_size & 0xffff) == 0)
                {
                        uprintf(".");
                        g_uprintf_dest = old_uprintf_dest;
                        return;
                }
        }
        uprintf("Done\n");
        if (hash_cb->checksum_type)
        {
                if (hash_cb->checksum_type == HASH_MD5)
                {   digestLen = fips_getHashLength(fips_AlgMD5);  /*fips*/
                        //MD_final(hash_cb->digist_output, &hash_cb->ctx.md5_ctx,  hash_cb->checksum_type);
                        ret = fips_Hash_End(hash_cb->ctx.md5_ctx, hash_cb->digist_output, &digestLen);
                        hash_cb->ctx.md5_ctx = 0;
                        if (ret < 0)
                        {
                                        uprintf("\n fips_Hash_End failed for MD5. ret: %d", ret);
                                        return;
                        }
                        hex2string(hash_cb->digist_output, 16, hash_cb->buf);
                        uprintf("Size = %u, MD5 %s \n", hash_cb->current_size, hash_cb->buf);
                }
                else
                {
                        digestLen = fips_getHashLength(fips_AlgSHA1);  /*fips*/
                        //sha_final(&hash_cb->ctx.sha_ctx);
                        //uprintf("\n Need tp check the functionality ..BIJU");
            //fips_SHA1_End((acSHA1Context *) &hash_cb->ctx.sha_ctx, (unsigned char *) &hash_cb->digist_output,(UINT *) &digestLen,FIPS_SHA1_LENGTH);
                        ret = fips_Hash_End(hash_cb->ctx.sha_ctx, hash_cb->digist_output,&digestLen);
                        hash_cb->ctx.sha_ctx = 0;
                        if (ret < 0)
                        {
                                        uprintf("\n fips_Hash_End failed for SHA1. ret: %d", ret);
                                        return;
                        }
                        //fips_SHA1_End(&hash_cb->ctx.sha_ctx);
                        //hex2string(hash_cb->ctx.sha_ctx.digest, FIPS_SHA1_LENGTH, hash_cb->buf);
                        hex2string((UINT8 *)&hash_cb->digist_output, FIPS_SHA1_LENGTH, hash_cb->buf);
                        //MEMCPY(hash_cb->digist_output,(UINT8 *) &hash_cb->ctx.sha_ctx, FIPS_SHA1_LENGTH);
                        uprintf("Size = %u, SHA1 %s \n", hash_cb->current_size, hash_cb->buf);
                }
        }
        else
        {
                hash_cb->ctx.crc = ~hash_cb->ctx.crc;
                uprintf("Size = %u, CRC32 %08x \n", hash_cb->current_size, hash_cb->ctx.crc );
                ksprintf(hash_cb->buf,"%08x",  hash_cb->ctx.crc);
        }

        if (hash_cb->digist_match[0])
        {
                string2hex(hash_cb->digist_match, hex);
                if (hash_cb->checksum_type != CRC32)
                {
                    /*uprintf("\n calc\t=%s \ninput\t=%s\n", hash_cb->buf,hash_cb->digist_match);*/
                        if (MEMCMP(hash_cb->digist_output, hex, (hash_cb->checksum_type == HASH_SHA1)?FIPS_SHA1_LENGTH:MD_DIGESTSIZE))
                        { /* not match */
                                uprintf("Verification Failed.\n");
                        }
                        else
                        {
                                uprintf("Verification Succeeded.\n");   /* BUG:73790 */
                        }
                }
                else
                {
                        if (MEMCMP(&hash_cb->ctx.crc, hex, 4))
                        { /* not match */
                                uprintf("Verification Failed.\n");
                        }
                        else
                        {
                                uprintf("Verification Succeeded.\n"); /* BUG:73790 */
                        }
                }
        }
        if (hash_cb->buf)
        {
                dy_free(hash_cb->buf);
                hash_cb->buf = NULL;
        }
        if (hash_cb->f)
        {
#ifdef FI_LINUX
		md5_update_flash_pointers_p(hash_cb->f,0,0); // If ,at all , We missed to reset pointers in above mess!
#endif
                sys_flash_fclose( hash_cb->f );
                hash_cb->f = NULL;
        }
        if (hash_cb->hash_timer_id)
        {
                sv_cancel_timer(hash_cb->hash_timer_id);
                hash_cb->hash_timer_id = NULL;
        }
        print_prompt(&cdbs[g_uprintf_dest]);    /* BUG:73789 */
        g_uprintf_dest = old_uprintf_dest;
        return;
}

int verify_hash_file( char *path, enum HASH_IMAGE_TYPE bootimg, enum HASH_ALGORITHM checksum_type, UINT8 *match )
{

    FLASH_FILE_INFO info;
    int ret = 0;

    if (g_hash_cb.f )
    {
            uprintf("Busy...\n");
            return(FAIL);
    }
    /*Check if the firmware upgarde is in progress , if so prevent it */
    /*Only one access is possible for the firmware parition at a time */
    if(is_linux_based_system() && !set_flash_use_in_progress())
    {
        return (FAIL);
    }

    memset((void *)&g_hash_cb, 0, sizeof(HASH_FUNCTION_INFO));

    if( (g_hash_cb.f = sys_flash_fopen( path, "r" ) ) == NULL )
    {
            uprintf("File not found.\n");
            if(is_linux_based_system())
                reset_flash_use_in_progress();
            return( FAIL);
    }

    /* Even though we are supposed to get the file handler
     * pointing to offset 0, but UBOOT may not necessary 
     * start from offset 0. Calling fseek to offset 0 
     * will do the trick of adding the right offset to the 
     * uboot fd. Cheap trick should be a better way to
     * handle it.
     */
    sys_flash_fseek(g_hash_cb.f, 0, FLASH_FILE_SEEK_SET);


    strcpy(g_hash_cb.hash_file_name, path);
    if (match)
    {
            strcpy(g_hash_cb.digist_match, match);
    }
    else
    {
            g_hash_cb.digist_match[0] = '\0';
    }
    g_hash_cb.hash_uprintf_dest = g_uprintf_dest;
    g_hash_cb.checksum_type = checksum_type;
    g_hash_cb.hash_file_type = bootimg;
    sys_flash_get_file_info(g_hash_cb.f, &info);
    if ((info.length % MD5_FILE_BUFFER_SIZE) == 0)
    {
            g_hash_cb.number_of_blocks = info.length / MD5_FILE_BUFFER_SIZE;
    }
    else
    {
            g_hash_cb.number_of_blocks = info.length / MD5_FILE_BUFFER_SIZE + 1;
    }
    g_hash_cb.hash_file_length = info.length;
    if (g_hash_cb.checksum_type)
    {
            if (g_hash_cb.checksum_type == HASH_MD5)
            {
                    //MD_init( &g_hash_cb.ctx.md5_ctx );
                    ret = fips_Hash_Begin(&g_hash_cb.ctx.md5_ctx, fips_AlgMD5);
                    if (ret < 0)
                    {
                            uprintf("\n fips_Hash_Begin failed for MD5. ret: %d", ret);
                            /*Check if Katara if so , Unset the Flag*/
                            if (is_linux_based_system())
                                reset_flash_use_in_progress();
                            return (FAIL);
                    }
            }
            else
            {
                    //sha_init(&g_hash_cb.ctx.sha_ctx );
                    //fips_SHA1_Begin( ( acSHA1Context *) &g_hash_cb.ctx.sha_ctx );
                    ret = fips_Hash_Begin( &g_hash_cb.ctx.sha_ctx, fips_AlgSHA1);
                    if (ret < 0)
                    {
                                    uprintf("\n fips_Hash_Begin failed for SHA1. ret: %d", ret);
                                    /*Check if the Platform is katara , if so  then unset the Flag*/
                                    if (is_linux_based_system())
                                        reset_flash_use_in_progress();
                                    return (FAIL);
                    }
            }
    }
    else
    {
            g_hash_cb.ctx.crc = -1;
            build_crc_table();
    }
    g_hash_cb.buf = dy_malloc(MD5_FILE_BUFFER_SIZE);

#ifdef FI_LINUX
       md5_update_flash_pointers_p( g_hash_cb.f ,0,0);
#endif

    g_hash_cb.hash_timer_id = sv_set_timer_event(1, REPEAT_TIMER, verify_hash_file_callback, (UINT32)&g_hash_cb, "tm-hash");
    return(PASS);
}


void verfy_sha_calc_checksum_file(struct cdb* sptr_cdb)
{

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                verify_hash_file(sptr_cdb->string1, HASH_FILE, HASH_SHA1, NULL);
                sptr_cdb->dont_go_next = 1;
        }
        else
        {
                sptr_cdb->file_checksum_type = 0;
        }

}

#ifdef FI_LINUX
void dm_rtc_gettime(struct cdb* sptr_cdb)
{
        TIME_STRUCT ts;
        sys_get_clock(&ts,0) ;
           
         uprintf( "\n\nCurrent RTC date/time is %d-%d-%d, %02d:%02d:%02d.\n",
                        ts.date, ts.month, ts.year, ts.hour, ts.minute, ts.second);
//      uprintf("\n RTC Time is  %d-%d-%d, %02d:%02d:%02d \n",(ts.year-1900),ts.month-1,ts.date, ts.hour, ts.minute ,ts.second);
        

}
int ifleap(int year)
{
return year % 4 ;

}

/* Calculate day */
int dow(int y, int m, int d)
{
                /* Added check to avoid crash in t[m-1] for invalid month and time */
                if(m < 1 || m > 12 || d < 1 || d > 31)
                        return 0;       

        int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
        y -= m < 3;
        return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
}

int months[]={31 ,28 , 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} ;

int doy(int month , int date ,int year)
{
        int days=0;
        int index=month-1;
        while (index > 0)
        {
                index-- ;
                days += months[index];

        }

        if (!ifleap(year))
                days +=1  ;
                days += date ;

        return days ;

}


/* Returns the day of week (1=Monday, 7=Sunday) for a given date.
 *  */
int  do_rtc_set(unsigned int date, unsigned int time)
{
        char rtc_data[16] = { 0 };
        struct tm  ts; 
        TIME_STRUCT input_time ;
        /*
        0. offset - always set to 0.
        1. Seconds Register - 1 STOP Bit + 3 + 4 bits of BCD Seconds 0-59
        2. Minutes Register - X + 3 + 4 bits of BCD minutes 0-59
        3. Century/Hours Register - Century enable bit + century bit + 2 + 4 bits of BCD hours 0-23
        4. Day Register - 3 bits for day 1-7
        5. Date Register - 2+4 bits of BCD date 1-31
        6. Month Register - 1+4 bits of BCD month 1-12
        7. Years Register - 4+4 bits of BCD years 0-99
        8. Control Register - not used by software`.
        */

        /* date is DDMMYY */
         rtc_data[7] = (date & 0xFF);
        rtc_data[6] = (date & 0xFF00)>>8;
        rtc_data[5] = (date & 0xFF0000)>>16;
          if((date > 0xFFFFFF) || ((rtc_data[7]&0xF) > 9) || ((rtc_data[6]&0xF) > 9) || ((rtc_data[5]&0xF) > 9)
                || (rtc_data[6]> 0x12) || (rtc_data[5]> 0x31))
        /* TODO: Validate if this month has a maximum of 28,29,30 or 31 days */
        {
                uprintf("Invalid Date:%x.\n", date);
                return -1;
        }


        /* Find the day of the week (1 to 7) */ /* Convert BCD to normal */
        rtc_data[4] = dow((2000+ (rtc_data[7]>>4)*10 + (rtc_data[7]&0xf)),      /* year */
                                                ((rtc_data[6]>>4)*10 + (rtc_data[6]&0xf)),              /* month */
                                                ((rtc_data[5]>>4)*10 + (rtc_data[5]&0xf))) + 1;         /* date */

        /* time is HHMMSS */
        rtc_data[1] = (time & 0xFF);
        rtc_data[2] = (time & 0xFF00)>>8;
        rtc_data[3] = (time & 0xFF0000)>>16;

        if((time > 0xFFFFFF) || ((rtc_data[3]&0xF) > 9) || ((rtc_data[2]&0xF) > 9) || ((rtc_data[1]&0xF) > 9)
                || (rtc_data[3]> 0x23) || (rtc_data[2]> 0x59) || (rtc_data[1]> 0x59))
        {
                uprintf("Invalid Time:%x.\n", time);
                return -1;
        }


        ts.tm_hour=sil_bcd2bin(rtc_data[3]);
        ts.tm_min=sil_bcd2bin(rtc_data[2]);
        ts.tm_sec=sil_bcd2bin(rtc_data[1]) ; 
        ts.tm_mon=sil_bcd2bin(rtc_data[6]) ; 
        ts.tm_year=sil_bcd2bin(rtc_data[7]);
        ts.tm_mday=sil_bcd2bin(rtc_data[5]);
        ts.tm_wday=sil_bcd2bin(rtc_data[4]) ;

        //Now converting it to time_t values

        input_time.second = ts.tm_sec ;
        input_time.minute = ts.tm_min ;
        input_time.hour = ts.tm_hour ;
        input_time.date = ts.tm_mday ;
        input_time.month =ts.tm_mon  ;
        input_time.year = ts.tm_year+2000 ;
        input_time.yday = doy(ts.tm_mon,ts.tm_mday,ts.tm_year);


        if(sys_set_clock(&input_time) < 0)
        {
                
                return -1 ;
        } else {
                return 0;
        }

}
void dm_rtc_settime(struct cdb *sptr_cdb)
{


         unsigned int date, time;
        TIME_STRUCT ots;

        if((sptr_cdb->config_gen)||(sptr_cdb->no) || (end_of_token(sptr_cdb->token) != '\0'))
                return;
        sptr_cdb->dont_go_next = 1;

        date = sptr_cdb->integer1;
        time = sptr_cdb->integer2;

        if ( (!date) ||  (!time ))
        {       
                uprintf( "dm rtc_settime DDMMYY HHMMSS \n") ;
                return ;
        }       


        if (do_rtc_set(date, time))
                uprintf("RTC Clock Time is not set \n");
        else
        {
                uprintf ("RTC CLock time is set \n") ;
                sys_get_clock_rtc(&ots,0) ;
        }

        //uprintf( "\n\n[RTC_READ] :Current RTC date/time is %d-%d-%d, %02d:%02d:%02d.\n",
          //              ots.date, ots.month, ots.year, ots.hour, ots.minute, ots.second);
        
}

#endif


#if  defined(SIDEWINDER_LINUX)
//#include <sys/statfs.h>
static unsigned long kscale(unsigned long b, unsigned long bs)
{
    return (b * (unsigned long long) bs + 1024/2) / 1024;
}

unsigned long GetAvailableSpace(const char* path)
{
  struct statfs stat;
  long size;
  if (statfs(path, &stat) != 0) {
        printf("statfs failed \n");
    return -1;
  }
        size= kscale(stat.f_bavail, stat.f_bsize );
  return size;
}

/*This function is used to check the minion platform or not*/
int is_minion_based_tpm_connection()
{
	if (sys_platform_tpm_enabled()) 
		return TRUE;
	else
		return FALSE;
}

/************************************************************************************************************************************** 
 * Name   : cli_dm_read_tpm_key  
 * Desc   : Function will load the tpm key and update the allegro variables for https session.
 * Params : struct cdb* sptr_cdb
 * Return : void
 ***************************************************************************************************************************************/ 
void cli_dm_read_tpm_key(struct cdb* sptr_cdb)
{
	if(sptr_cdb->config_gen)
		return;
	if (end_of_token(sptr_cdb->token) != '\0')
		return;

	sptr_cdb->dont_go_next = 1;

	//if not minion box then do not allow to read the tpm engine key
	if(is_minion_based_tpm_connection() != TRUE)
		return;

	char csErrorMessage[256]={0};
	char ErrorMessage[256]={0};
	int ret = CU_ERROR, fd=-1;

	/*Delete the certificate file from the flash*/
	fd = flash_fopen(SSL_CLIENT_CERT_FILE, "r");
	if( fd != 0 )
	{
		flash_fclose(fd);
		sys_flash_fremove(SSL_CLIENT_CERT_FILE);
	}

	//loading private key and store the decrypted key into temp key file 
	ret = ssl_rsa_private_key_tpm_wrapper(TPM_PRIVATE_KEY_FILE);
	if ( ret != CU_ERROR)
	{
		/*The below two functions will generate "$$sslclientcert.key"*/
		//import private key into switch
		cli_import_ssl_client_rsa_private_key_from_scp(TPM_TEMP_FLASH_PRIVATE_KEY_FILE, sptr_cdb, &csErrorMessage[0]);
		//import public key into switch
		cli_import_ssl_client_rsa_certificate_from_scp(TPM_CERTIFICATE_FILE, sptr_cdb, &ErrorMessage[0]);
	}
    
	//Remove temp private key file from the flash
	fd = -1; 
    fd = flash_fopen(TPM_TEMP_FLASH_PRIVATE_KEY_FILE, "r");
    if( fd != 0 )
    {
        flash_fclose(fd);
        sys_flash_fremove(TPM_TEMP_FLASH_PRIVATE_KEY_FILE);
    }
}
	
/************************************************************************************************************************************** 
 * Name   : read_tpm_private_key 
 * Desc   : Function will load the tpm key and update the allegro variables for https session.
 * Params : void
 * Return : void
 ***************************************************************************************************************************************/ 
void read_tpm_private_key()
{
	struct cdb* sptr_cdb = &cdbs[g_cu_session];

	if(sptr_cdb->config_gen)
		return;
	if (end_of_token(sptr_cdb->token) != '\0')
		return;

	sptr_cdb->dont_go_next = 1;

	//if not minion box then do not allow to read the tpm engine key
	if(is_minion_based_tpm_connection() != TRUE)
		return;

	char csErrorMessage[256]={0};
	char ErrorMessage[256]={0};
	int ret = CU_ERROR, fd=CU_ERROR, key_fd=CU_ERROR, cert_fd=CU_ERROR;

	/*Delete the certificate file from the flash*/
	fd = flash_fopen(SSL_CLIENT_CERT_FILE, "r");
	if( fd != 0 )
	{
		flash_fclose(fd);
		sys_flash_fremove(SSL_CLIENT_CERT_FILE);
	}

	//loading private key and store the decrypted key into temp key file 
	ret = ssl_rsa_private_key_tpm_wrapper(TPM_PRIVATE_KEY_FILE);
	if ( ret == CU_ERROR)
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("ERROR: SSL TPM private key reading is failed..!!\n");
		return;
	}

	key_fd = flash_fopen(TPM_TEMP_FLASH_PRIVATE_KEY_FILE, "r");
	if( key_fd != 0 )
	{
		flash_fclose(key_fd);
	}else
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("ERROR: SSL device private key file is not exists on the device..!!\n");
		return;
	}

	cert_fd = flash_fopen(TPM_CERTIFICATE_FILE, "r");
	if( cert_fd != 0 )
	{
		flash_fclose(cert_fd);
	}else
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("ERROR: SSL device certificate file is not exists on the device..!!\n");
		return;
	}

	/*The below two functions will generate "$$sslclientcert.key"*/
	//import private key into switch
	cli_import_ssl_client_rsa_private_key_from_scp(TPM_TEMP_FLASH_PRIVATE_KEY_FILE, sptr_cdb, &csErrorMessage[0]);
	//import public key into switch
	cli_import_ssl_client_rsa_certificate_from_scp(TPM_CERTIFICATE_FILE, sptr_cdb, &ErrorMessage[0]);

	//Remove temp private key file from the flash 
	key_fd = flash_fopen(TPM_TEMP_FLASH_PRIVATE_KEY_FILE, "r");
	if( key_fd != 0 )
	{
		flash_fclose(key_fd);
		sys_flash_fremove(TPM_TEMP_FLASH_PRIVATE_KEY_FILE);
	}
}

/************************************************************************************************************************************** 
 * Name   : read_non_tpm_private_key 
 * Desc   : Function will load the NON-TPM key and update the allegro variables for https session.
 * Params : void
 * Return : void
 ***************************************************************************************************************************************/ 
void read_non_tpm_private_key()
{
	int ret = CU_ERROR, fd=-1, key_fd=-1, cert_fd=-1;
	struct cdb* sptr_cdb = &cdbs[g_cu_session];
	char key_file[MAXIMUM_SIZE_OF_FILE_NAME]="/fast_iron/";

	char csErrorMessage[256]={0};
	char ErrorMessage[256]={0};

	if(sptr_cdb->config_gen)
		return;
	if (end_of_token(sptr_cdb->token) != '\0')
		return;

	sptr_cdb->dont_go_next = 1;

	//if minion based device then return 
	if(is_minion_based_tpm_connection() == TRUE)
		return;

	/*Delete the certificate file from the flash*/
	fd = flash_fopen(SSL_CLIENT_CERT_FILE, "r");
	if( fd != 0 )
	{
		flash_fclose(fd);
		sys_flash_fremove(SSL_CLIENT_CERT_FILE);
	}

	key_fd = flash_fopen(NON_TPM_SSL_CLIENT_PRIV_KEY_FILE, "r");
	if( key_fd != 0 )
	{
		flash_fclose(key_fd);
	}else
	{
		//TODO Error log to be enabled later
		/*debug_uprintf("ERROR: SSL device private key file is not exists on the device..!!\n");*/
		return;
	}

	cert_fd = flash_fopen(NON_TPM_SSL_CLIENT_CERT_FILE, "r");
	if( cert_fd != 0 )
	{
		flash_fclose(cert_fd);
	}else
	{
		/*debug_uprintf("ERROR: SSL device certificate file is not exists on the device..!!\n");*/
		return;
	}

	strcat(key_file, NON_TPM_SSL_CLIENT_PRIV_KEY_FILE);

	/*The API have intelligent to detect certificate/key which needs conversion and which do not need this.*/
	ret = get_key_type_match_status_in_file(key_file, DEFAULT_SSL_PRIVATE_KEY_TYPE);
	if(ret == CU_OK)
	{
		//Key file conversion is required into RSA format
		convert_non_tpm_mfg_key_into_rsa_key_format(key_file, NON_TPM_SSL_CLIENT_PRIV_KEY_TEMP_FNAME);
	}

	/*The below two functions will generate "$$sslclientcert.key"*/
	//import private key into switch and update the allegro variables
	if(ret == CU_OK)
	{
		cli_import_ssl_client_rsa_private_key_from_scp(NON_TPM_SSL_CLIENT_PRIV_KEY_TEMP_FLASH_PATH, sptr_cdb, &csErrorMessage[0]);

		//Remove the temp key file if craeted 
		sys_fremove(NON_TPM_SSL_CLIENT_PRIV_KEY_TEMP_FLASH_PATH);
	}else{

		cli_import_ssl_client_rsa_private_key_from_scp(NON_TPM_SSL_CLIENT_PRIV_KEY_FILE, sptr_cdb, &csErrorMessage[0]);
	}

	//import public key into switch
	cli_import_ssl_client_rsa_certificate_from_scp(NON_TPM_SSL_CLIENT_CERT_FILE, sptr_cdb, &ErrorMessage[0]);

}

/************************************************************************************************************************************** 
 * Name   : copy_context_from_one_file_to_other 
 * Desc   : Function will copy the data from one file to another file, if the destination file is available on the path the it will return error
 * Params : char *src_file, char *dest_file
 * Return : This function will return 0 on success, otherwise return -1
 ***************************************************************************************************************************************/ 
int copy_context_from_one_file_to_other(char *src_file, char *dest_file)
{
	int i, c;
	int fp1, fp2, fp3;
	char *buffer = NULL;

	if(src_file == NULL || dest_file == NULL)
		return -1;
	
	if (debugGlobal.ip.ssl)
		debug_uprintf("copy_context_from_one_file_to_other,  src_file:%s, dest_file:%s\n",src_file, dest_file);

	fp1 = flash_fopen(src_file, "r");
	if( fp1 == NULL )
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("ERROR: cannot open %s file\n", src_file);
		return -1;
	}

	// If file already exists .we need to overwrite it. so let's remove it first
	fp2 = flash_fopen(dest_file, "r");
	if (fp2 != NULL) 
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("ERROR: Key file already exists. Please zeroize it.\n");
		flash_fclose(fp1);//close fp1, since src_file is already opened
		flash_fclose(fp2);
		return -1;
	}

	fp3 = flash_fcreat(dest_file);
	if (fp3 == NULL)
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("ERROR: Not able to create file %s \n", dest_file);
		flash_fclose(fp1);
		return -1;
	}

	FLASH_FILE_INFO file_info;
	if (flash_get_file_info(fp1, &file_info) != 0)
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("Can't get the file size of privatekey file\n");
		flash_fclose(fp1);
		flash_fclose(fp3);
		return -1;
	}

	buffer = calloc(1, file_info.length+1);
	if( buffer == NULL )
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("copy_context_from_one_file_to_other, buffer allocation is failed..!!\n");
		flash_fclose(fp1);
		flash_fclose(fp3);
		return -1;
	}

	for (i = 0; i < file_info.length; i++)
	{
		if ((c = flash_fgetc(fp1)) == -1) break;
		buffer[i] = c;
	}
	buffer[i] = '\0';//null terminate for better case

	for (i = 0; i < file_info.length; i++)
	{
		if ((c = flash_fputc(fp3, buffer[i])) == -1) break;
	}

	if(fp1)	flash_fclose(fp1);
	if(fp3)	flash_fclose(fp3);
	
	if(buffer)
		free(buffer);

	return 0;
}

/************************************************************************************************************************************** 
 * Name   : get_key_type_match_status_in_file 
 * Desc   : Function will check the given key is in RSA format or not.
 * Params : char *file, char *token
 * Return : If the token is found then it returns CU_OK, otherwise CU_ERROR
 ***************************************************************************************************************************************/ 
int get_key_type_match_status_in_file(char *file, char *token)
{
	FILE *fp;
	int found = 0;
	char temp[512];

	if(file == NULL) {
		if (debugGlobal.ip.ssl)
			debug_uprintf("Error: File ptr is NULL\n");
		return CU_ERROR;
	}

	if((fp = fopen(file, "r")) == NULL) {
		if (debugGlobal.ip.ssl)
			debug_uprintf("Error: Input file %s is not exists..!!\n", file);
		return CU_ERROR;
	}

	while(fgets(temp, 512, fp) != NULL) 
	{
		if((strstr(temp, token)) != NULL)
		{
			if(debugGlobal.ip.ssl)
				debug_uprintf("Token %s is found in input file..!!\n", temp);
			found = 1;
			break;
		}
	}

	if(fp) 
		fclose(fp);

	return (found ? CU_OK : CU_ERROR);
}

/************************************************************************************************************************************** 
 * Name   : ReadPrivateKeyNonTpm 
 * Desc   : Function is used to read the private key from the file and it will return EVP_PKEY structure.
 * Params : const char *keyfile
 * Return : It returns pkey ptr on success, otherwise NULL
 ***************************************************************************************************************************************/ 
EVP_PKEY *ReadPrivateKeyNonTpm(const char *keyfile)
{
	FILE *fp = fopen(keyfile, "r");
	EVP_PKEY *pkey;

	if (!fp)
		return NULL;

	pkey = PEM_read_PrivateKey(fp, NULL, 0, NULL);

	fclose (fp);

	if (pkey == NULL) 
		ERR_print_errors_fp (stderr);   

	return pkey;
}

/************************************************************************************************************************************** 
 * Name   : convert_non_tpm_mfg_key_into_rsa_key_format 
 * Desc   : Function is used to convert the pem key into RSA PEM key format 
 * Params : char *src_file, char *dest_file
 * Return : It returns 0 on success, otherwise -1
 ***************************************************************************************************************************************/ 
int convert_non_tpm_mfg_key_into_rsa_key_format(char *src_file, char *dest_file)
{
	FILE *fp;
	EVP_PKEY *pkey;

	if(src_file == NULL)
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("Error: src_file is NULL\n");
		return -1;
	}
	if(dest_file == NULL)
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("Error: dest_file is NULL\n");
		return -1;
	}

	pkey = ReadPrivateKeyNonTpm(src_file);
	if(!pkey)
	{
		if (debugGlobal.ip.ssl)
			debug_uprintf("Error: can't load private key\n");
		return -1;    
	}

	fp = fopen(dest_file, "w+");
	if(fp)
	{
		RSA *rsa = fill_rsa_st(pkey);
		if(rsa == NULL)
		{
			if (debugGlobal.ip.ssl)
				debug_uprintf("rsa key is NULL..!!\n");
			EVP_PKEY_free(pkey);
                        fclose(fp);
			return -1;
		}

		if(PEM_write_RSAPrivateKey(fp, rsa,NULL,NULL,0,NULL,NULL) == 0) 
		{
			if (debugGlobal.ip.ssl)
				debug_uprintf("PEM_write_RSAPrivateKey failed.\n");
			ERR_print_errors_fp(stderr);
			EVP_PKEY_free(pkey); 
			fclose(fp);
			return -1;
		}else{
			if (debugGlobal.ip.ssl)
				debug_uprintf("PEM_write_RSAPrivateKey success..!!\n");
			EVP_PKEY_free(pkey);
			fflush(fp);
			fclose(fp);
		}
	}

	return 0;
}

void cli_dump_usb_devices_infomation(struct cdb* sptr_cdb)
{
        sil_populate_usb_info();
        sil_dump_usb_info();
}

void cu_show_dir(char *dir)
{
        int block;
        FLASH_FILE_INFO info;
        int num = 0;
                int num_dir = 0;
        unsigned long size = 0;
        FS_STATFS vbuf;
                int i,j;
                int dir_exist = 0;
#ifdef SIDEWINDER_LINUX         
                int is_exusb=0;
#endif
                // remove leading "/" from dir name
                if(dir != NULL) {
                        while(dir[0] == '/') dir++;
#ifdef SIDEWINDER_LINUX
                        if( !strcmp("disk0", dir)) 
                                if(check_disk0())
                                        return;
                                else is_exusb=1;
                        
#endif
                }

                // print files
                block = flash_get_first_file_in_dir(dir, &info);
                dir_exist += block;
        for ( ; block; block = flash_get_next_file_in_dir(block, dir, &info), dir_exist += block)
        {
                if ((info.name[0] == '$') && (info.name[1] == '$')
                         && cu_fips_get_status()){
                         continue;
                }

                uprintf("F %15d %s\n",
                        info.length, info.name);
                num++;
                size += info.length;
        }

                if(dir == NULL) {
                        sil_populate_usb_info();
                }

                KICK_WATCHDOG;

        // print dir
                if(dir != NULL) {
                        block = flash_get_first_dir(dir, &info);
                        dir_exist += block;
                for ( ; block; block = flash_get_next_dir(block, dir, &info), dir_exist += block)
                {
                uprintf("D %15d [----] %s\n", info.length, info.name);
                                num_dir++;
                }

                        if(dir_exist != 0) {
                                uprintf("\n%llu bytes %d File(s) in %s\n\n", size, num, dir);
                        }
                } else {
                uprintf("\n%llu bytes %d File(s) in FI root\n\n", size, num);

                flash_get_free_block_space (&vbuf);
            uprintf("%15d bytes free in FI root\n", vbuf.f_bavail * vbuf.f_bsize);

                        if(g_usb_devices.tot_devices > 0) {
                                i = g_internal_usb_id;
                                if(i >= 0) {
                                        for(j = 0; j < g_usb_devices.usb_dev_info[i].tot_partitions; j++) {
                                                if(g_usb_devices.usb_dev_info[i].partitions[j].is_formatted &&
                                                                g_usb_devices.usb_dev_info[i].partitions[j].is_mounted) {

                                                        flash_get_free_block_space_of_mount_point(
                                                                g_usb_devices.usb_dev_info[i].partitions[j].mount_point, &vbuf);
                                                        uprintf("%15d bytes free in %s\n", vbuf.f_bavail * vbuf.f_bsize,
                                                                g_usb_devices.usb_dev_info[i].partitions[j].mount_point);
                                                }
                                        }
                                }
#if 0
/* Currently we are not supporting external USB in Indus release */
                i = g_external_usb_id;
                if(i >= 0) {
                   for(j = 0; j < g_usb_devices.usb_dev_info[i].tot_partitions; j++) {
                        if(g_usb_devices.usb_dev_info[i].partitions[j].is_formatted) {
                                                        flash_get_free_block_space_of_mount_point(
                                                                g_usb_devices.usb_dev_info[i].partitions[j].mount_point, &vbuf);
                                                        uprintf("%15d bytes free in %s\n", vbuf.f_bavail * vbuf.f_bsize,
                                                                g_usb_devices.usb_dev_info[i].partitions[j].mount_point);
                        }
                   }
               }
#endif
                        }
                        uprintf("\n");
                }

#ifdef SIDEWINDER_LINUX


		unsigned long freesize = 0;
		if( IS_SPATHA() || IS_SICA() || IS_MINIONS())
		{
			/*In arm based toolchains , it works ok*/
			if (is_exusb) {
				char cmd[200];
				snprintf(cmd, 200, "%s", "df -kh \/fast_iron\/disk0 | awk \'{ print \"    \", $4, \"bytes Free in disk0\" }\' | grep -v Available");
				//print_shell_command_output(cmd);
			}

		}else
		{
			/* In PPC based toolchains , it works fine.*/
			if (is_exusb) { 
				freesize = GetAvailableSpace("/fast_iron/disk0");
					printf("\r%lu bytes Free in disk0 \n", freesize);
			}

		}


#endif

}               
#else /* ifndef SIDEWINDER_LINUX*/
void cu_show_dir(char *dir)
{
    int block;
    FLASH_FILE_INFO info;
    int num = 0;
    unsigned long long size = 0;
    FS_STATFS vbuf;
        if(dir != NULL) {
        uprintf("This CLI operation is not supported on this platform.\n");
    } else {
        for (block = flash_get_first_file(&info); block; block = flash_get_next_file(block, &info))
        {
            if ((info.name[0] == '$') && (info.name[1] == '$')
                     && cu_fips_get_status()){
                 continue;
            }
            uprintf("%10d [%04x] %s\n",info.length, info.checksum, info.name);
            num++;
            size += info.length;
        }
        uprintf("%llu bytes %d File(s)\n", size, num);
        flash_get_free_block_space (&vbuf);
        uprintf("%10d bytes free\n", vbuf.f_bavail * vbuf.f_bsize);
    }
}
#endif /* SIDEWINDER_LINUX*/

void cli_show_dir(struct cdb* sptr_cdb)
{
                if (end_of_token(sptr_cdb->token) != '\0')
                return;

                sptr_cdb->dont_go_next = 1;

                if(sptr_cdb->num_of_string == 1) {
                        cu_show_dir(sptr_cdb->string1);
                        return;
                }

                uprintf("Type       Size   Name\n");
                uprintf("----------------------\n");
        cu_show_dir(NULL);
}

void cli_dbg_fl_lock(struct cdb *sptr_cdb)
{
#ifndef OFFICIAL_RELEASE
    if(is_flash_use_in_progress()) {
        uprintf("INFO: Flash Access was set by\n%s", fl_access_set_tracebuf);
    }
#endif
}

#if defined (FI_LINUX)

#ifdef FI_LINUX
int StartsWith(const char *a, const char *b)
{
        if(strncmp(a, b, strlen(b)) == 0) return 1;
        return 0;
}
#endif

void cu_del_flash_file(char *string)
{
        int  flash_file_handle;
#ifdef FI_LINUX         
        struct stat st;
        char fullpath[FILE_NAME_LENGTH];
        if (StartsWith(string,"/"))
        {
                uprintf("Path cannot start with '/' \n");
                return ;
        }else 
        {

                // if path is nor disk0 or / , then it should be /fast_iron regular file . so we need to check whether those files exist or not.
                //  primary/secondary/bootrom all are taken care by illegal_flash_file_name call. 

                snprintf(fullpath,FILE_NAME_LENGTH,"/fast_iron/%s",string) ;

        }

        if (stat(fullpath,&st) )
        {
                uprintf("File does not exist \n");
                return ;
        }
#endif  
       flash_file_handle = sys_flash_fopen(string, "r");
        if (flash_file_handle)
        {
                sys_flash_fclose(flash_file_handle);
                 if (!sys_flash_fremove(string))
                        uprintf("Flash file %s deleted.\n", string);
                 else
                
                        uprintf("Flash file %s not deleted .\n", string);
        }
        else
        {
                uprintf("Flash file %s not found.\n", string);
        }
}
void cli_del_flash_file(struct cdb* sptr_cdb)
{

        if (cu_is_illegal_flash_file_name(sptr_cdb->string1))
        {
                return;
        }
        cu_del_flash_file(sptr_cdb->string1);
}

void cli_del_flash_chk(struct cdb* sptr_cdb)
{
        if (strncmp(sptr_cdb->token, sptr_cdb->current_node->keyword, strlen(sptr_cdb->current_node->keyword)) != 0)
        {
                
                sptr_cdb->dont_go_next = 1;
                return;
        }

}
#endif

void e_ncopy_flash_ps_tftp_Ip_name(struct cdb* sptr_cdb)
{
        if (sptr_cdb->secondary)
                copy_flash_tftp_sec(sptr_cdb);
        else
                copy_flash_tftp_pri(sptr_cdb);
}


#ifdef __IPV6__
void e_boot_sys_tftp_ip6(struct cdb* sptr_cdb)
{
        /* Stub for now, Need change to boot code for change to format */
}

#endif /*__IPV6__*/


#ifdef SR_SWITCH_ROUTER

UINT32 icmp_unreachable_disable_flags = 0;

void set_ip_icmp_unreachable_network(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_NET_UNREACHABLE_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_NET_UNREACHABLE_CODE);
}

void set_ip_icmp_unreachable_host(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_HOST_UNREACHABLE_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_HOST_UNREACHABLE_CODE);
}

void set_ip_icmp_unreachable_protocol(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_PROTOCOL_UNREACHABLE_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_PROTOCOL_UNREACHABLE_CODE);
}

void set_ip_icmp_unreachable_port(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_PORT_UNREACHABLE_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_PORT_UNREACHABLE_CODE);
}

void set_ip_icmp_unreachable_fragment(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_FRAGMENT_NEEDED_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_FRAGMENT_NEEDED_CODE);
}

void set_ip_icmp_unreachable_route_fail(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_ROUTE_FAIL_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_ROUTE_FAIL_CODE);
}

void set_ip_icmp_unreachable_admin(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                uprintf("Error - Too many parameters\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->no)
                icmp_unreachable_disable_flags |= (1 << ICMP_ADMIN_PROHIBIT_CODE);
        else
                icmp_unreachable_disable_flags &= ~(1 << ICMP_ADMIN_PROHIBIT_CODE);
}

void set_ip_icmp_unreachable(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                if (icmp_unreachable_disable_flags == 0)
                        return;
                else if (icmp_unreachable_disable_flags == 0xffffffff)
                {
                        ksprintf(cu_line_buf, "no ip icmp unreachable\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
                else
                {
                        if (icmp_unreachable_disable_flags & (1 << ICMP_NET_UNREACHABLE_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable network\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        if (icmp_unreachable_disable_flags & (1 << ICMP_HOST_UNREACHABLE_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable host\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        if (icmp_unreachable_disable_flags & (1 << ICMP_PROTOCOL_UNREACHABLE_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable protocol\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        if (icmp_unreachable_disable_flags & (1 << ICMP_PORT_UNREACHABLE_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable port\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        if (icmp_unreachable_disable_flags & (1 << ICMP_FRAGMENT_NEEDED_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable fragmentation-needed\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        if (icmp_unreachable_disable_flags & (1 << ICMP_ROUTE_FAIL_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable source-route-fail\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        if (icmp_unreachable_disable_flags & (1 << ICMP_ADMIN_PROHIBIT_CODE))
                        {
                                ksprintf(cu_line_buf, "no ip icmp unreachable administration\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
                return;
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return; /* wait until end of line */
                sptr_cdb->dont_go_next = 1;

                if (sptr_cdb->no)
                {
                        icmp_unreachable_disable_flags = 0xffffffff;
                }
                else
                {
                        icmp_unreachable_disable_flags = 0;
                }
        }
}
#endif SR_SWITCH_ROUTER

void check_no_arp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
        {
                sptr_cdb->dont_go_next = 1;
                delete_arp_inspec_entry(sptr_cdb->ip1, NULL, sptr_cdb->vrf_idx);
        }
}

void set_arp_inspect(struct cdb *sptr_cdb)
{
         UINT16  port_id;
         VRF_INDEX vrf_id;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->config_gen == 0)
        {
                sptr_cdb->flag1 = TRUE;
                vrf_id = sptr_cdb->vrf_idx;
                //set_arp(sptr_cdb);
                //if (!valid_integer1_value_range(sptr_cdb, 1, cu_get_curr_param(STATIC_ARP_ENTRIES_INDEX)))
                //      return;

                // check if an entry with ip and mac exists.
                if( !set_arp_inspect_allowed(sptr_cdb->ip1, sptr_cdb->mode_vrf_idx))
                         return;

                if (sptr_cdb->no)
                {
                        delete_arp_inspec_entry(sptr_cdb->ip1, sptr_cdb->mac1, sptr_cdb->mode_vrf_idx);
                }
                else
                {

                        add_arp_inspec_entry(sptr_cdb->ip1, sptr_cdb->mac1, sptr_cdb->mode_vrf_idx);
                }
        }
/*      else
        {
                config_gen_arp_inspec_entries(sptr_cdb);
        }
*/
}

#ifdef SR_SWITCH_ROUTER
/* config_gen_vrf_arp function will generate config for ANY vrf index passed
 */
void config_gen_vrf_arp(struct cdb* sptr_cdb, VRF_INDEX vrf_index)
{
        int i;
        int config_written = 0;
        UINT32  ip_address;
        UINT8   mac_address[6];
        UINT16  port_id;
        VRF_INDEX arp_vrf_index;

        for (i = 0; i < cu_get_curr_param(STATIC_ARP_ENTRIES_INDEX); i++)
        {
                ip_get_static_arp_vrf(
                        TRUE,
                        i,
                        &ip_address,
                        mac_address,
                        &port_id,
                        &arp_vrf_index
                        );

                if (ip_address == 0 || vrf_index != arp_vrf_index)
                        continue;

                config_written = 1;

                if(port_id == INVALID_PORT_INDEX)
                {
                        ksprintf(cu_line_buf, "%sarp %I %m inspection\n",
                        (vrf_index==IPVRF_DEFAULT_VRF_IDX)?"":" ",
                        ip_address,
                        (unsigned char *)mac_address);
                }
                else
                {
                        ksprintf(cu_line_buf, "%sarp %I %m %s %L\n",
                        (vrf_index==IPVRF_DEFAULT_VRF_IDX)?"":" ",
                        ip_address,
                        (unsigned char *)mac_address,
						get_port_type_str(trunk_primary_port (port_id)),
						get_port_num(trunk_primary_port (port_id)));
                }

                wr_config(sptr_cdb, cu_line_buf);
        }

        // ARP inspect entries are stored in DHCP snoop table and not stored in Static ARP table.
        show_arp_inspec_entries(sptr_cdb, vrf_index, &config_written);

        if (config_written && (vrf_index == IPVRF_DEFAULT_VRF_IDX))
                wr_config(sptr_cdb, "!\n");
}

void set_vrf_name(struct cdb* sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->mode_vrf_idx != IPVRF_DEFAULT_VRF_IDX)
        {
                sptr_cdb->num_of_string = 1 ;
                strncpy(sptr_cdb->string1, sptr_cdb->mode_vrf_name, sizeof(sptr_cdb->mode_vrf_name));
                sptr_cdb->string1[sizeof(sptr_cdb->vrf_name) - 1] = '\0';
        }

}

void arp_process_portmask_set_callback(struct cdb * sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                return;
        }
        if (is_last_token(sptr_cdb))
        {
                set_arp(sptr_cdb);
                return;
        }
        sptr_cdb->port_mask_callback = set_arp;
}

void set_arp(struct cdb* sptr_cdb)
{
        UINT16  port_id;

        if (sptr_cdb->config_gen == 0)
        {
                if (!validate_interface_value(sptr_cdb, 1, ANY_INTERFACE))
                         return;

                port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                // check if an entry with ip and mac exists.
                if( !set_arp_allowed(port_id, sptr_cdb->ip1,sptr_cdb->mac1, FALSE))
                         return;

                //if (!validate_interface_value(sptr_cdb, 1, ANY_INTERFACE))
                //      return;
                
               if (port_id!=trunk_primary_port(port_id))
               {
                    uprintf("Error - port %p is a trunk secondary port, please use a primary port in the configuration\n", port_id);       
                    return;
                }
               
                port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                ip_add_static_arp(INVALID_ARP_INDEX,sptr_cdb->ip1,sptr_cdb->mac1,port_id,sptr_cdb->mode_vrf_idx,!sptr_cdb->no);
        }
}

void check_no_rarp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if ((sptr_cdb->no) && (end_of_token(sptr_cdb->token) == '\0'))
        {
                sptr_cdb->dont_go_next = 1;

                if (!valid_integer1_value_range(sptr_cdb, 1, IP_DEFAULT_NUMBER_OF_RARP_ENTRIES))
                        return;

                ip_add_rarp_entry(sptr_cdb->integer1-1, 0, NULL, FALSE);
        }
}

void config_gen_rarp(struct cdb* sptr_cdb)
{
        int i;
        int config_written = 0;
        UINT32  ip_address;
        UINT8   mac_address[6];

        for (i = 0; i < IP_DEFAULT_NUMBER_OF_RARP_ENTRIES; i++)
        {
                ip_get_rarp_entry(
                        TRUE,
                        i,
                        &ip_address,
                        mac_address
                        );
                if (ip_address == 0)
                        continue;
                config_written = 1;
                ksprintf(cu_line_buf, "rarp %d %m %I\n",
                        i+1,
                        (unsigned char *)mac_address,
                        ip_address
                        );
                wr_config(sptr_cdb, cu_line_buf);
        }
        if (config_written)
                wr_config(sptr_cdb, "!\n");
}

void set_rarp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                if (!valid_integer1_value_range(sptr_cdb, 1, IP_DEFAULT_NUMBER_OF_RARP_ENTRIES))
                        return;

                if (sptr_cdb->no)
                {
                        ip_add_rarp_entry(
                                sptr_cdb->integer1-1,
                                sptr_cdb->ip1,
                                sptr_cdb->mac1,
                                FALSE
                                );
                }
                else
                {
                        ip_add_rarp_entry(
                                sptr_cdb->integer1-1,
                                sptr_cdb->ip1,
                                sptr_cdb->mac1,
                                TRUE
                                );
                }
        }
}
#endif /* SR_SWITCH_ROUTER */

void runConfig2tftpB(UINT32 error,UINT32 ui_port)
{
        int old_ui_port;

        if(config_buffer_ptr[ui_port]!=NULL)
        {
                /*****************************************************/
                /*                  release the buffer               */
                /*****************************************************/
                free_config_buffer(config_buffer_ptr[ui_port]);
                config_buffer_ptr[ui_port] = NULL;
        }

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        /* use error code from Ktftp.h - rlau */
        if (error == TFTP_NO_ERROR)
        {
                uprintf("Upload running-config to TFTP server done.\n");
        }
        else
        {
                uprintf("Error - cannot upload running-config to TFTP server.\n");
        }
        tftp_cli_command_completed();

                print_prompt(&cdbs[g_uprintf_dest]);
                
        g_uprintf_dest = old_ui_port;
}


#ifndef NO_DELAY_PARSE_ACL
static int cli_find_cmd_access_list(unsigned char *line, UINT8 ui_port)
{
        UINT8 keyword[] = "access-list";
        int length = strlen(keyword);
        int acl_id, count=0;

        SKIP_WHITE_SPACE(line);

        /* tftp acl with "no acl ...." Fan BUG 8347 */
        {
                unsigned char *line1;

                if (memcmp(line, "no", 2) == 0)
                {
                        line1 = line+2;
                        SKIP_WHITE_SPACE(line1);
                        if (memcmp(line1, keyword, length) == 0)
                        {
                                NEXT_TOKEN(line1);
                                acl_id = cli_get_int((char *)line1, 0, &count);

                if (end_of_token(line1) != '\0')  /* not for me */
                {
                        return rebind_acl_count;
                }

                                send_itc_delete_entire_ipv4_acl(acl_id, ui_port);
                        }
                        return rebind_acl_count;
                }
        }

        if (memcmp(line, keyword, length) == 0)
        {
                if (rebind_acl_count >= 4096)
                        return rebind_acl_count;

                NEXT_TOKEN(line);
                acl_id = cli_get_int((char *)line, 0, &count);
                /* acl_id can be -1 from cli_get_int() to indicate invalid integer */
                if (acl_id < 1 || acl_id > 199)
                {
                        uprintf("Error - Invalid ACL ID %d in %s\n", acl_id, line);
                        return rebind_acl_count;
                }
                if (rebind_acl_ids[rebind_acl_count])
                {
                        if (rebind_acl_ids[rebind_acl_count] != acl_id)
                        {
                                if (++rebind_acl_count >= 4096)
                                {
                                        uprintf("Warning - Exceeding 4096 ACL IDs when copying running config !!!\n");
                                        return rebind_acl_count;
                                }
                                rebind_acl_ids[rebind_acl_count] = (UINT16)acl_id;
                        }
                }
                else
                {
                        rebind_acl_ids[rebind_acl_count] = (UINT16)acl_id;
                }
        }
        return rebind_acl_count;
}

void parse_access_list_from_buffer(UINT8 *config_buf, UINT32 ui_port)
{
        int i, j;
        int old_ui_port;
        unsigned char *line;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        /* allocate a line buffer */
        if ((line = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE+1)) == NULL)
        {
                uprintf("Error - cannot allocate line buffer\n");
                goto cleanup_parse_access_list_from_buffer; /* free buffers */
        }

        rebind_acl_index = rebind_acl_count = 0;
        memset(rebind_acl_ids, 0, 4096 * sizeof(UINT16));

        for (i = 0, j = 0; config_buf[i] != 0; i++)
        {
                if (j >= CMD_LINE_SIZE)
                {
                        uprintf("Error - the length of the command line exceeds %d characters.\n!!!"
                                        "Stop parsing the configuration data !!!\n",
                                        CMD_LINE_SIZE);
                        goto cleanup_parse_access_list_from_buffer; /* free buffers */
                }

                if (config_buf[i] == '\n')
                {
                        if (j == 0)
                                continue;

                        strncpy(line, &config_buf[i-j], j);
                        line[j] = '\0';
                        if (line[j-1] == '\r')
                                line[j-1] = '\0';

                        cli_find_cmd_access_list(line, ui_port);
                        j = 0;
                }
                else
                        j++;
        }

        if (j != 0)
        {
                /* last line not ended with '\n' */
                strncpy(line, &config_buf[i-j], j);
                line[j] = '\0';
                if (line[j-1] == '\r')
                        line[j-1] = '\0';

                cli_find_cmd_access_list(line, ui_port);
        }

        if (rebind_acl_ids[0])
        {
                /* ACL id list is not empty, prepare to do
                 * batch mode ACL processing
                 */
                l4_acl_delay_init1(ui_port);
        }

cleanup_parse_access_list_from_buffer:
        dy_free(line); /* free line buffer */
        g_uprintf_dest = old_ui_port;
}

void schedule_access_list_process(UINT32 ui_port)
{
        /* BUG: 85155 */
        if((delay_filter_timer_id == NULL) && rebind_acl_ids[0])
        {
                /* ACL id list is not empty, prepare to do
                 * batch mode ACL processing
                 */
                 if(delay_filter_timer_id == NULL)
                    delay_filter_timer_id =
                        sv_set_timer(HUNDRED_MILLISEC, REPEAT_TIMER, l4_acl_delay_filter_proc, ui_port);
        }
}
#endif NO_DELAY_PARSE_ACL


void default_system_ui_port(UINT32 ui_port)
{
        /* save current session cdbs, generate running config */
        if (save_session_cdb(ui_port))
        {
                //debug_uprintf("default_system_ui_port(ui_port=%x) -> default_system\n", ui_port);
                /* set "no" to all config commands */
                default_system(ui_port);
                /* restore current session cdbs */
                restore_session_cdb(ui_port);
        }
        //else
                //debug_uprintf("default_system_ui_port(ui_port=%x) - skip default_system\n", ui_port);
}

#ifdef FI_LINUX
/* FUNCTION
* cli_parser_cmd_fips_status()
*
* RETURN
* 1 - If line contains "fips enable"
* 0 - If line does not contains "fips enable"
*
* SYNOPSIS
* Applicable only for Linux based platform
* Called during phase one of config parsing. This for setting ans resetting
* fips status to uboot from startup-config file since uboot cannot read
* startup-config
*/
static int cli_parser_cmd_fips_status(unsigned char *line) {
    char tempf[] = "fips enable";
    if (memcmp(line, tempf, strlen(tempf)) == 0) {
                if(!sil_get_fips_status()) {
                        sil_set_fips_status(1);
                }
                return 1;
    }
        return 0;
}
#endif

extern UINT8 g_copy_tftp_pvlan;
extern UINT8 g_flexauth_copy_tftp;
void tftp_parse_configBuf(UINT8 *buffer, UINT32 ui_port, UINT32 clear_running_config_enabled)
{
        if (clear_running_config_enabled)
        {
                if (g_copy_tftp_runCfg)
                {
                        // allow only one copy during hitless stacking
                        uprintf("\n A tftp copy session is already in progress, please try later...");
                        return;
                }
                g_copy_tftp_runCfg = TRUE;
#ifdef FIPS_PASSWD_MASK
                g_copy_tftp_runCfg_parse = TRUE;
#endif
                /* save current session cdbs, generate running config */
                if (save_session_cdb(ui_port))
                {
                        /* set "no" to all config commands */
                        default_system(ui_port);
                        /* restore current session cdbs */
                        restore_session_cdb(ui_port);
                }
                g_copy_tftp_runCfg = FALSE;
#ifdef FIPS_PASSWD_MASK
                g_copy_tftp_runCfg_parse = FALSE;
#endif
        }
#ifdef PRIVATE_VLAN
        g_copy_tftp_pvlan = 1;
#endif /*PRIVATE_VLAN*/
		g_flexauth_copy_tftp = TRUE;

#ifndef NO_DELAY_PARSE_ACL
        parse_access_list_from_buffer(buffer, ui_port);

                g_copy_tftp_acl = 1;
#endif NO_DELAY_PARSE_ACL
#ifdef FIPS_PASSWD_MASK
        g_copy_tftp_runCfg_parse = TRUE;
        fips_mask_password_commands(0);
#endif

#ifdef NO_ROUTER_RAPID_FAILOVER
        parse_configBuf(buffer, ui_port);
#else
        if (g_copy_tftp_runCfg)
        {
                // allow only one copy during hitless stacking
                uprintf("\n A tftp copy session is already in progress, please try later...");
                return;
        }
        if (is_mgmt_active() && is_standby_up())
        {
        	// 617780 If the standby_state is SEND_ROLE or less, do not block it
                if (!ok_to_sync_cli() && g_stacking.standby_state >= STANDBY_HOTSWAP_STATE_RECV_ROLE)
                {
                        uprintf("\n CLI is currently locked, please try later...");
                        g_copy_tftp_acl = 0;
                        return;
                }
                g_dist_parse_ui_port = ui_port;
                parse_configBuf_dist(buffer);
                g_dist_parse_ui_port = NULL;
        }
        else
        {
                parse_configBuf(buffer, ui_port);
        }
#endif

        cu_lag_deploy_lacp_cmds();// Maocheng++: FI 8.0
#ifdef FIPS_PASSWD_MASK
        fips_mask_password_commands(1);
        g_copy_tftp_runCfg_parse = FALSE;
#endif

		g_flexauth_copy_tftp = FALSE;
#ifdef PRIVATE_VLAN
        g_copy_tftp_pvlan = 0;
        apply_pending_pvlan_mapping_entry();
        if ((hw_pvlan_support()==HW_PVLAN_SUPPORT_FCX) || ((hw_pvlan_support() == HW_PVLAN_SUPPORT_TI) && IS_FI_BCM()))         
                apply_pending_pvlan_switch_link_entry();
#endif /*PRIVATE_VLAN*/
#ifndef NO_DELAY_PARSE_ACL
        schedule_access_list_process(ui_port);
                g_copy_tftp_acl = 0;
#endif NO_DELAY_PARSE_ACL

}

#ifdef FI_LINUX
/*
* Function:
*  pre_parse_start_config_after_tftp
* Description:
*  To parse the newly downloaded startup-config to fetch fips, boot paramaters
*  related information. So if user reboot unit then also
*  we set proper information to the uboot.
*/
void pre_parse_start_config_after_tftp (void) {
        unsigned char *pre_config_buf=NULL;
        int status;
    int file;
        int fips_flag = 0;
        unsigned char *line;
    int i, j;

        /* Add extra "1", in a case when flash_read will return MAX_CONFIG_SIZE and then 
        pre_config_buf[MAX_CONFIG_SIZE] = '/0' will fail */
        pre_config_buf = (unsigned char*)dy_malloc_zero(MAX_CONFIG_SIZE + 1);

        if (!pre_config_buf) {
                uprintf("Pre-parsing config: Failed to get config buffer\n");
                return;
    }

        file = flash_fopen(g_startup_config_filename, "r");
        if (file == 0) {
                uprintf("INFO: unable to open /%s/\n", g_startup_config_filename);
                dy_free(pre_config_buf);
                return;
        }

	status = flash_fread(file, (char*)pre_config_buf, MAX_CONFIG_SIZE);
    if (status == 0) {
		/*  Read for startup-config.txt return 0 so below INFO message get printed, this is due to delayed callback function 
		* 	copy_flash_flash_file_callback ,function pre_parse_start_config_after_tftp get called first and start reading 
		* 	startup-config.txt file while copy_flash_flash_file_callback still not invoked which result in to having empty 
		* 	startup-config.txt. This message pop-up both in good and bad case , to avoid this message in good case (retry case), 
		* 	we have added flag which get SET only if callback function get called before pre_parse_start_config_after_tftp function.
		*/
		if (copy_flash_flash_file_callback_status) {
        		uprintf("INFO: read /%s/ error\n", g_startup_config_filename);
				copy_flash_flash_file_callback_status = FALSE;
		}
        flash_fclose(file);
		dy_free(pre_config_buf);
        return;
    }

    pre_config_buf[status] = '\0';
    flash_fclose(file);

        /* read config buffer line by line */

    /* allocate a line buffer */
    if ((line = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE+1)) == NULL) {
                uprintf("Pre-parsing config: Failed to allocate line buffer\n");
                dy_free(line); /* free line buffer */
                dy_free(pre_config_buf);
                return;
    }
    
        line[0] = '\0';

    for (i = 0, j = 0; pre_config_buf[i] != 0; i++) {
                if (j >= CMD_LINE_SIZE) {
                        uprintf("INFO: the length of the command line exceeds %d characters\n", CMD_LINE_SIZE);
                        dy_free(line); /* free line buffer */
                        dy_free(pre_config_buf);
                        return;
                }

                if (pre_config_buf[i] == '\n') {
                        strncpy(line, &pre_config_buf[i-j], j);
                        line[j] = '\0';

                        if (j != 0 && line[j-1] == '\r')
                                line[j-1] = '\0';

                        cli_parser_cmd_sys_boot_param(line);
                        fips_flag |= cli_parser_cmd_fips_status(line);

                        j = 0;
                } else
                j++;
        }

        /* fips is not enable in config so reset fips flag */
        if(!fips_flag && sil_get_fips_status()) {
                sil_set_fips_status(0);
        }

    dy_free(line); /* free line buffer */
    dy_free(pre_config_buf);
}
#endif

void tftp2startConfigB(UINT32 error,UINT32 ui_port)
{
    int old_ui_port;
    old_ui_port = g_uprintf_dest;
    g_uprintf_dest = ui_port;

    /* use error code from Ktftp.h - rlau */
    if (error == TFTP_NO_ERROR)
    {
        if(IS_STACKING_ENABLED)
        {
            stacking_write_to_eeprom_due_to_write_mem(0); // KKLIN_8021BR
        }
        uprintf("Download startup-config from TFTP server done.\n");
        cli_log_config_changed(ui_port, TRUE);
    }
    else
    {
        uprintf("Error - cannot download startup-config from TFTP server.\n");
    }
    tftp_cli_command_completed();

    if(is_linux_based_system())
    {
#ifdef FI_LINUX
        pre_parse_start_config_after_tftp();
#endif
    }

    flash2flashBNoPrint();//also does flash use reset
    g_uprintf_dest = old_ui_port;
}

#ifdef BOOTRAM_DEBUG
extern char bootram_pgm[];
void cmp_boot(UINT32 buf)
{
        int i;
        UINT8 *bpt;

        bpt = (UINT8 *)buf;

        uprintf("cmp_boot(%x) with (%x)\n",(UINT32)&bootram_pgm[0],buf );
        for (i=0;i<45088;i++)
        {
                if (bootram_pgm[i] != *bpt)
                {
                        uprintf("cmp_boot failed at (%x) %x and %x\n", i,
                                (UINT32)&bootram_pgm[i], (UINT32)bpt);
                        break;
                }
                bpt++;
        }
}
#endif

/*----------------------------------------------------------------**
**                                                                **
** This function return the version number of the format xx.xx.xx **
**                                                                **
**----------------------------------------------------------------*/
void get_222_ver(char *ver, UINT32 *v1, UINT32 *v2, UINT32 *v3)
{
        int len;

        *v1 = *v2 = *v3 = 0;
        *v1 = cli_get_int(ver, 0, &len);
        ver += len;
        *v2 = cli_get_int(ver, 0, &len);
        ver += len;
        *v3 = cli_get_int(ver, 0, &len);
}

#if 0
void try_copy_boot_code(char *buf, UINT32 ui_port)
{

        int i,n;
        UINT32 sum=0;
        UINT32 *uptr;
        int boot_size;
        UINT32 v1, v2, v3;
        struct manufacture_info tmp_manu_info;

                /* check for magic number that identify this image as a boot image */
                if (*(UINT32 *)buf != MAGIC_BOOT_BI)
                {
                        uprintf("This file does not have the right signature as a boot image for this HW, abort!\n");
                } else
                {
#ifndef NO_BOOT_CKSUM
                        uptr = (UINT32 *)buf;
                        n = uptr[1]/4;
                        if (n > 0)
                        {
                                for (i=52/4; i<n ;i++)
                                {
                                        sum += uptr[i];
                                }
                                if (sum == uptr[2])
                                {
#endif
                                        /* PPC750 requires boot version of 06.00.00 or above */
                                        if ( (g_hw_info.mgmt_module_type == MGMT_MODULE_M3)
                                                )
                                        {
                                                memcpy((void *)&tmp_manu_info, (const void *)(buf+MANU_INFO_OFFSET), sizeof(manu_info));
                                                get_222_ver((char *)&tmp_manu_info.boot_ver[0], &v1, &v2, &v3);
                                                if (v1<6)
                                                {
                                                        uprintf("Warn: M3 module requires boot image be version 06.00.00 or above, abort (%d.%d.%d)!\n",
                                                                                v1,v2,v3);

                                                        return;
                                                }
                                        }
                                        SET_DBAT_TO_DEFAULT;
                                        boot_size = *(int *)(buf+4);
                                        if ((boot_size < 0) || (boot_size > g_hw_info.max_boot_image_size))
                                        {
                                                uprintf("Warn: boot file size (%d) too large for the boot flash of size %d, abort!\n",
                                                boot_size, g_hw_info.max_boot_image_size);
                                                //boot_size = g_hw_info.max_boot_image_size;
                                        } else
                                        {

                                        /* retain the first 52-16 byte */
                                        for(i=16; i < 52; i++)
                                        {
                                                *(char *)(buf+i) = *(volatile char *)(0xff800000+i);
                                        }

                                        if (isalnum(g_copy_image_name[0]))
                                        {
                                                strncpy(buf+boot_size, g_copy_image_name, 32);
                                                g_copy_image_name[0] = '\0';
                                        }
                                        write_boot((UINT32)buf, 0xff800000, boot_size+32);
#ifdef BOOTRAM_DEBUG
                                        /* verify that the data is correct */
                                        cmp_boot(0xff804000);
#endif
                                        }
#ifndef NO_BOOT_CKSUM
                                } else
                                        uprintf("Warn: boot image of size %d bytes has checksum error, abort!\n", uptr[1]);
#endif

                        } else
                                uprintf("Warn: no checksum was found in this boot image, abort!\n");
                }
}

void tftp2bootCodeB(UINT32 error,UINT32 ui_port)
{
        int old_ui_port;

        KICK_WATCHDOG;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        /* use error code from Ktftp.h - rlau */
        if (error == TFTP_NO_ERROR)
        {
#ifdef BOOTRAM_DEBUG
                /* verify that the data is correct */
                cmp_boot(tftp_buffer);
#endif
                try_copy_boot_code(boot_copy_buffer, ui_port);

        }
        else
        {
                uprintf("Error - can't download boot code from TFTP server.\n");
        }


        g_uprintf_dest = old_ui_port;
        KICK_WATCHDOG;
}

void copy_tftp_bootCode(struct cdb* sptr_cdb)
{
#ifdef DEBUG
        uprintf("copy tftp bootCode\n");
        if (IS_IPV4_AFI(sptr_cdb->afi))
        uprintf("ip = %x  filename = %s\n",sptr_cdb->ip1, sptr_cdb->string1);
#ifdef __IPV6__
        else
        {
                uprintf("ipv6 = %s  filename = %s\n",ipv6_address_to_string(&sptr_cdb->ipv6_1, NULL), sptr_cdb->string1);
        }
#endif __IPV6__
#endif DEBUG

        if ( sys_tftp_disable_get() ) {
                uprintf(tftp_disable_str);
                return;
        }

        strncpy(g_copy_image_name, (char *)sptr_cdb->string1, 32);
        g_copy_image_name[31] = '\0';
        tftp_perform_code_data_download(
                tftp2flashB,
                sptr_cdb->ui_port,
                sptr_cdb->ip1,
                (char*)sptr_cdb->string1,
                BOOTFTP
                );
}
#endif


/*----------------------------------------------------------------------------------**
**                                                                                  **
** This function search for code type in the first CMP_FILENAME_MAX(32) characters. **
** It returns 0 if no code type found, otherwise, code type defined below.          **
**                                                                                  **
**----------------------------------------------------------------------------------*/
int get_code_type(char *buf,int *sub_type)
{

        FDRY_IMG_HDR *fhdr;

        int i;
        int rcode = 0;

        fhdr = (FDRY_IMG_HDR *)buf;




        if ((fhdr->e_magic == MUCHO_IMAGE_MAGIC) ||
                (fhdr->e_magic == LINUX_IMAGE_MAGIC)) {

                rcode = fhdr->e_type;
        } else {

        rcode = 0;
    }

        *sub_type = rcode & IMAGE_SUB_TYPE_MASK;
        return((rcode & IMAGE_TYPE_MASK) >> IMAGE_TYPE_SHIFT);

}

int
is_stacking_support_enabled(void)
{
#ifndef EVAL_BOARD
                        if (IS_SICA_L_24GC())
                                return FALSE;
                        else
                                return TRUE; //Please don't change it for sw_stacking - ba
#else
                                return FALSE;
#endif
}

BOOLEAN32 is_stacking_prom_installed(void)
{

        if (IS_FI_BCM())
                return TRUE;
        else
                return FALSE;
}

//On some platforms, hardware support stacking but stacking software
//is not enabled but we still would like to keep unit as 1 so that
//no software upgrade is required when we enable stacking
BOOLEAN32 is_stacking_software_disabled(void)
{

        if (IS_SICA_L_24GC())
                return TRUE;
        else
                return FALSE;
}

BOOLEAN32 is_stacking_bypass(struct cdb* sptr_cdb)
{
        if (strcmp(sptr_cdb->line, "stack unit 1") == 0)
                return TRUE;
        else
                return FALSE;
}

BOOLEAN32 is_l3_premium_prom_installed(void)  // it should be changed premium to avdvance.
{
#ifndef PV_CHANGES
        //return 1 if there is a L3 premium PROM installed, otherwise return 0
        if ((g_hw_info.pal_type & CHEETAH_EDGEIRON_BGP) == CHEETAH_EDGEIRON_BGP)
        {
                return TRUE;
        }
        else
                return FALSE;
#else
        return (FALSE); // set the software license in soft_package_supported_feature()
#endif PV_CHANGES
}

//for FCX
BOOLEAN32 is_l3_advance_license_installed (void)
{
#if 0 //FCX not supported
        UINT32 sw_bitmap=0x0, license;

        if (is_l3_premium_prom_installed())
        {
                return (TRUE);
        }

        sw_bitmap = GetPackageBitmapInfo(0);

        if (sw_bitmap & license)
        {
                return (TRUE);
        }

#ifndef OFFICIAL_RELEASE
        if((debugGlobal.stacking.debug_general & 2))
        {
                return TRUE;
        }
#endif OFFICIAL_RELEASE
#endif
        return (FALSE);
}

//for CHOW
BOOLEAN32 is_chow_premium_license_installed (void)
{
        UINT32 sw_bitmap=0x0;

        sw_bitmap = GetPackageBitmapInfo(0);

        if (sw_bitmap & ICX6610_PREM_LIC_SW) // works for chow premium license
        {
                return (TRUE);
        }

        return (FALSE);
}

//for CHOW
BOOLEAN32 is_chow_advance_license_installed (void)
{
        UINT32 sw_bitmap=0x0;

        sw_bitmap = GetPackageBitmapInfo(0);

        if ((sw_bitmap & ICX6610_ADV_LIC_SW) ||      // works for chow advance license
                (sw_bitmap & ICX6610_ADV_UPG_LIC_SW))
        {
                return (TRUE);
        }

        return (FALSE);
}

// for Spatha
BOOLEAN32 is_spatha_Non_Nodelocked_premium_license_installed(void)
{
    UINT32 sw_bitmap=0x0;

    sw_bitmap = GetPackageBitmapInfo(0);

    if (sw_bitmap & ICX7450_PREM_LIC_SW) // works for Spatha premium license
    {
        return (TRUE);
    }
    return (FALSE);
}
// for SIRIUS 
BOOLEAN32 is_sx_license_installed(void)
{
    return (FALSE);
}


void cli_set_if_deny_logging(struct cdb* sptr_cdb)
{
    UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    UINT32 rc;
    E_L4_ACL_OPERATION acl_op;
    char *acl_name = NULL;

    if(!IS_PORT_DB_VALID(port_id) 
#ifdef SR_SWITCH_ROUTER
      && !IS_IP_PORT_DB_VALID(port_id)
#endif SR_SWITCH_ROUTER
      )
        return;

    if (sptr_cdb->config_gen)
    {
        sptr_cdb->dont_go_next = 1;
        if (ip_access_table(port_id, enable_deny_logging)) wr_config(sptr_cdb, " acl-logging\n");
    } else
    {
        ACL_ID acl_id_in;


#ifdef __CPU_PORT_SUPPORT__ 
        if(is_cpu_port_id(port_id) && (IS_SIDEWINDER_DEV(PORT_TO_DEVICE_ID(port_id))))
        {
            uprintf("acl-logging is not supported on this port\n");
            return;
        }
#endif __CPU_PORT_SUPPORT__ 
        acl_op = L4_ACL_OP_ADD_FEATURE;
        acl_id_in = PORT_VLAN_CFG_ACL_IN(port_id, NULL_VLAN_ID);


        if (IS_MAC_AUTH_ENABLED_ON_PORT(port_id) || IS_DOT1X_PORT_ENABLED(port_id))
        {
            acl_id_in = flexauth_get_dynamic_acl_on_port(port_id);
            if (!acl_id_in)
            {
                acl_id_in = PORT_VLAN_CFG_ACL_IN(port_id, NULL_VLAN_ID);
            }
        }

        if (sptr_cdb->no)
        {
    
            acl_op = L4_ACL_OP_DELETE_FEATURE;
            
        } else
        {
#ifdef SR_SWITCH_ROUTER
            // ACL logging can only be applied to a port that is not member of a VE
            if (is_physical_port(port_id) && is_member(g_vport_member_mask, port_id)) // member of VE
            {
                uprintf("Cannot configure acl-logging on port %P since it is a member of a VE group  - please apply on VE\n", port_id);
                return;
            }

            /* TR000266689: If acl is applied on a group VE then don't allow it
                    as we don't support.
                    Using 2 instead of IS_GROUP_VE_PORT as this is defined in a C file
                    that I cannot include
            */
            if (is_virtual_port(port_id) && (is_puppet_ve_or_group_ve_member(port_id) == 2))
            {
                uprintf("ACL-logging configuration is not allowed on Group VE\n");
                return;
            }
#endif

            acl_op = L4_ACL_OP_ADD_FEATURE;
             
        }
        rc = sw_security_send_itc_feature_add_del(LOG_RULES, 0, acl_id_in, acl_name, port_id,
                                                  NULL_VLAN_ID, IP_ACL_INGRESS_DIR,
                                                  acl_op);

        if (!rc)
        {
            uprintf("ERROR: Failed to enable ACL logging.\n");
        }
    }

    return;
}


void config_gen_if_port_name(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 *sptr_ch;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                sptr_ch = cu_get_port_name(port_id, NULL);
                if (sptr_ch)
                {
                        wr_config(sptr_cdb, " port-name ");
                        wr_config(sptr_cdb, sptr_ch);
                        wr_config(sptr_cdb, "\n");
                }
        }
}

void config_gen_vrf_forwarding(struct cdb* sptr_cdb)
{
#ifdef SR_SWITCH_ROUTER
    if (sptr_cdb->config_gen)
    {
        set_vrf_forwarding(sptr_cdb);
    }
#endif SR_SWITCH_ROUTER
}

#ifdef FIOFL_INCLUDE
void config_gen_if_openflow(struct cdb* sptr_cdb)
{
        PORT_ID port;
        char buf[100];
    OPENFLOW_PROTECTED_VLAN *protected_vlan;

        if (sptr_cdb->config_gen)
        {
                port = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
                if (BAD_PORT_ID == port)
                        return;

                // Generate protected vlans first. This will help in reload for Unprotected configured vlans while applying openflow enable
                if (NBB_IN_LIST(SPTR_PORT_DB(port)->port_config.openflow_protected_vlan_list_root))
                {
                        protected_vlan = NBB_NEXT_IN_LIST(SPTR_PORT_DB(port)->port_config.openflow_protected_vlan_list_root);
                        if(protected_vlan && protected_vlan->vlan_id != 0) 
                        {
                                sprintf(buf, " openflow protected-vlans ");
                                wr_config(sptr_cdb, buf);

                                while (protected_vlan && protected_vlan->vlan_id != 0)
                                {
                                        sprintf(buf, "%d ",protected_vlan->vlan_id);
                                        protected_vlan = NBB_NEXT_IN_LIST(protected_vlan->node_in_protected_vlan_list);
                                        wr_config(sptr_cdb, buf);
                                }
                                sprintf(buf, "\n");
                                wr_config(sptr_cdb, buf);                               
                        }
                }

                if (SPTR_PORT_DB(port)->port_config.openflow_enable)
                {

                        if(!SPTR_PORT_DB(port)->port_config.hybrid_mode_enable)
                        {
                                if(SPTR_PORT_DB(port)->port_config.openflow_superACL)
                                        sprintf(buf, " openflow enable layer23\n");
                                else if(SPTR_PORT_DB(port)->port_config.openflow_type == L3FLOW)
                                        sprintf(buf, " openflow enable layer3\n");
                                else
                                        sprintf(buf, " openflow enable\n");
                        }
                        else
                        {
                                if(SPTR_PORT_DB(port)->port_config.openflow_superACL)
                                        sprintf(buf, " openflow enable layer23 hybrid-mode\n");
                                else if(SPTR_PORT_DB(port)->port_config.openflow_type == L3FLOW)
                                {
                                        sprintf(buf, " openflow enable layer3 hybrid-mode\n");
                                        
                                }
                                else
                                {
                                        sprintf(buf, " openflow enable layer2 hybrid-mode\n");
                                }

                        }

                        wr_config(sptr_cdb, buf);
                }
        }
}
#endif FIOFL_INCLUDE

void preset_if_port_name(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        if (!sptr_cdb->config_gen)
        {
                if (sptr_cdb->no)
                {
                        if (!sptr_cdb->help)
                        {
                                cu_set_port_name(port_id, NULL);
                        }
                }
        }
}

void set_if_port_name(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        sptr_cdb->dont_go_next = 1;

        /* first parse: sptr_cdb->help = FALSE and sptr_cdb->execute = FALSE
         * second parse: sptr_cdb->help = FALSE and sptr_cdb->execute = TRUE */

        /* To avoid two times of parsing of "no port-name", adding sptr_cdb->execute flag
         * for complete function.Hence complete function will be executed only once */
        if ((!sptr_cdb->config_gen) && (sptr_cdb->execute))
        {
#ifdef SIDEWINDER_BREAKOUT
                if (IS_PORT_IN_PHYSICAL_PORT(port_id) && !IS_PORT_DB_VALID(port_id))
                                    return;
#endif
                sptr_cdb->token = trim_whitespace(sptr_cdb->token);
                if (sptr_cdb->no)
                {
                        if (IS_PORT_IN_PHYSICAL_PORT(port_id) && SPTR_PORT_DB(port_id)->port_config.sptr_port_name)
                        {
                                if((strcmp(sptr_cdb->token, SPTR_PORT_DB(port_id)->port_config.sptr_port_name)) != 0)
                                {
                                        uprintf("Port name does not match\n");
                                        return;
                                }
                        }
#ifdef SR_SWITCH_ROUTER
                        else if (!IS_PORT_IN_PHYSICAL_PORT(port_id) && IP_IP_PORT(port_id).config.sptr_port_name)
                        {
                                if((strcmp(sptr_cdb->token, IP_IP_PORT(port_id).config.sptr_port_name)) != 0)
                                {
                                        uprintf("Port name does not match\n");
                                        return;
                                }
                        }
#endif SR_SWITCH_ROUTER
                        else
                        {
                                uprintf("Port name not configured\n");
                                return;
                        }
                        cu_set_port_name(port_id, NULL);
                }
                else
                {
                        cu_set_port_name(port_id, sptr_cdb->token);
                }
        }
}

#ifdef DHCP_ASSIST
static UINT8 cli_number_of_dhcp_gateways;
static UINT32 cli_dhcp_gateways[MAX_GATEWAYS_PER_LIST];

void set_if_dhcp_list(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 list_index;
        int rc;

        if (sptr_cdb->config_gen)
        {
                if (cu_get_if_dhcp_list(port_id, &list_index) != CU_OK)
                        return;

                if (list_index != INVALID_DHCP_LIST_IDX)
                {
                        ksprintf(cu_line_buf, " dhcp-gateway-list %d\n", list_index+1);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        rc = cu_set_if_dhcp_list(port_id, INVALID_DHCP_LIST_IDX);

                        if (rc == CU_ERROR)
                        {
                                uprintf("Error - DHCP Assist could not be disabled on port %p\n", port_id);
                                return;
                        }

                        if (rc == CU_ERROR_OCCUPY_ENTRY)
                        {
                                uprintf("Error - DHCP Assist is not configured on port %p\n", port_id);
                                return;
                        }
                }
                else
                {
#ifdef __DHCP_SERVER__
                        if (is_dhcps_running () == TRUE)
                                {
                                uprintf("Error: cannot enable this feature while the DHCP-Server is enabled\n");
                                return;
                                }
#endif /*__DHCP_SERVER__*/

                        list_index = sptr_cdb->integer1 - 1;
                        if (list_index  >= MAX_DHCP_LISTS)
                        {
                                uprintf("Error - invalid dhcp gateway list id, valid range (1-32)\n");
                                return;
                        }
                        if (g_dhcp_lists[list_index].num_of_entries == 0)
                        {
                                uprintf("Error - non-configured dhcp gateway list\n");
                                return;
                        }
                        rc = cu_set_if_dhcp_list(port_id, list_index);

                        if (rc == CU_ERROR)
                        {
                                uprintf("Error - DHCP Assist could not be enabled on port %p\n", port_id);
                                return;
                        }

                        if (rc == CU_ERROR_OCCUPY_ENTRY)
                        {
                                uprintf("Error - DHCP Assist is already configured on port %p\n", port_id);
                                return;
                        }
                }
        }
}

void check_no_dhcp_list(struct cdb* sptr_cdb)
{
        int i;
        int list_index;
        UINT8 num_of_entries;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                for (list_index=0; list_index<MAX_DHCP_LISTS; list_index++)
                {
                        cu_get_dhcp_gateway_list(list_index, &num_of_entries, cli_dhcp_gateways);
                        if (num_of_entries == 0)
                                continue;
                        ksprintf(cu_line_buf, "dhcp-gateway-list %d", list_index+1);
                        wr_config(sptr_cdb, cu_line_buf);

                        for (i=0; i<num_of_entries; i++)
                        {
                                ksprintf(cu_line_buf, " %I", cli_dhcp_gateways[i]);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                        wr_config(sptr_cdb, "\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        sptr_cdb->dont_go_next = 1;
                        list_index = sptr_cdb->integer1 - 1;
                        if (list_index >= MAX_DHCP_LISTS)
                        {
                                uprintf("Error - invalid dhcp gateway list id, valid range (1-32)\n");
                                return;
                        }
                        cu_set_dhcp_gateway_list(list_index, 0, NULL);
                }
                else
                        cli_number_of_dhcp_gateways = 0;
        }
}

void set_dhcp_list(struct cdb* sptr_cdb)
{
        int list_index;
        int i;

        if (!sptr_cdb->config_gen)
        {
                list_index = sptr_cdb->integer1 - 1;
                if (list_index >= MAX_DHCP_LISTS)
                {
                        uprintf("Error - invalid dhcp gateway list id, valid range (1-32)\n");
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
                if (cli_number_of_dhcp_gateways >= MAX_GATEWAYS_PER_LIST)
                {
                        uprintf("Error - exceeds maximum number of gateways per list (8)\n");
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
                if (sptr_cdb->ip1 == 0 || sptr_cdb->ip1 == 0xFFFFFFFF)
                {
                        uprintf("Error - invalid IP address\n");
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
                for (i=0; i<cli_number_of_dhcp_gateways; i++)
                {
                        if (cli_dhcp_gateways[i] == sptr_cdb->ip1)
                        {
                                uprintf("Error - duplicate gateway address\n");
                                sptr_cdb->dont_go_next = 1;
                                return;
                        }
                }
                cli_dhcp_gateways[cli_number_of_dhcp_gateways++] = sptr_cdb->ip1;
                if (end_of_token(sptr_cdb->token) == '\0')
                {
                        sptr_cdb->dont_go_next = 1;
                        cu_set_dhcp_gateway_list(list_index, cli_number_of_dhcp_gateways, cli_dhcp_gateways);
                }
                else
                        sptr_cdb->num_of_ip = 0;
        }
}
#endif /* DHCP_ASSIST */

/* level 1 used to check for excution mode boot commands
   level 2 used to check for fastboot on/off commands, need 2.0.6
   level 3 used to check for 4M code flash support, need 2.1.2 */
int boot_code_version_ok(int level)
{
        return 1;
}


UINT8 g_boot_sys_from_image = 0;
UINT8 g_boot_sys_flash = FALSE;
UINT8 g_Need_To_Send_boot_Req = FALSE;
UINT8 g_sxr_peer_reset_not_reqd = 0;


SYS_BOOT_LINE_TFTP_INFO g_cli_boot_line;

int user_warned = 0;
extern int downgrade_cli_issued;

void download_check_confirm_callback(UINT32 yes, UINT32 ui_port, UINT32 param3)
{
        int old_ui_port;
        int file;
        UINT32 boot_source = 0;
        
        if (yes)
                
                {

                
                        user_warned = 1;
                        //debug_uprintf("\n PARAM3 is %d",param3);
                        
                        if (param3 ==1) {
                                
               if(dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_BOOT, g_boot_sys_from_image)) // 573019 If return 1, it setup a timer to reload
			   	return;
              
			  print_reboot_and_cold_reset_now();
                           
                        } else if (param3 == 2) {
                                        
                                //debug_uprintf("\n PARAM 3 is 2 ");
                                
                                if (STACK_AM_I_MASTER)
                                {
                                                                        
                                        diag_on = 0; // Goodsell, 11/30/01, fixing bug 5730 -- if diag_on, slave CPUs did not get reset
                                        
                                        if (g_boot_sys_flash)
                                        {
                                                if (g_Need_To_Send_boot_Req)
                                                {
                                                        dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_BOOT, g_boot_sys_from_image);
                                                        g_Need_To_Send_boot_Req = FALSE;
                                                }
                                        }
                                        else
                                        {
                                                boot_source = get_boot_source_from_boot_param();
                                                dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_SPL_RELOAD, boot_source);
                                    }
                                        return;
                                }
                                        
                                cu_cold_reset_now(TRUE);

                        }        
                }

                else {
                                /* Do nothing here */
                         }
                        

        release_confirm_mode();
        //g_uprintf_dest = old_ui_port;
}


 

int download_check (void)
{
        char tmp_ver[CMP_FILENAME_MAX+1];
        int len;
        int is_7x_ver = 0;
        int boot_from = 0;
                
                                                
                                                
        /* get the boot partition from where this will reload */

        /* Reload using b s f p y/b s f s y */
        if ((g_boot_sys_from_image == 1) || (g_boot_sys_from_image ==2))
        {
                
                boot_from = g_boot_sys_from_image ;
        } else {
                if(boot_seq[0] == BOOT_FROM_FLASH_PRI) {
                
                boot_from = 1;
        }
        /* boot prefernce is configured */
        
        else if (boot_seq[0] == BOOT_FROM_FLASH_SEC) {
                
                boot_from = 2;
                                                                }
        else  {
                
                boot_from = 1;
                }
        }
                                                
                
                                                
                /* Get the image in the boot partition */
                                                
                                                
        if (boot_from == 1)
        {       
                get_code_version(FLASH_PRIMARY_IMG, tmp_ver);
                get_code_flash_label(FLASH_PRIMARY_IMG, tmp_ver);
        } else if (boot_from == 2) {
                get_code_version(FLASH_SECONDARY_IMG, tmp_ver);
                get_code_flash_label(FLASH_SECONDARY_IMG, tmp_ver);
        }
                                                        
                                                
                                                        
       if (tmp_ver[5] == '7')
                {
                        
                        is_7x_ver = 1;
                }

                if ((is_7x_ver) && (downgrade_cli_issued == 0))
                {
                        
                        return 0;
                                                                 
                } else {
                        
                        return 1;
                }

}



/*--------------------------------------------------------------------------**
**                                                                                                                                                                                                       **
** This is a "boot sys fla pri" function without interactive confirmation.  **
** Mainly used by test scripts that do not want the confirmation.                                **
**                                                                                                                                                                                                       **
**--------------------------------------------------------------------------*/
void boot_sys_flash_pri_yes(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                boot_sys_flash_pri_sec_yes_sub(1, 0); // 450529: 1 is primary image
        }
}

// If primary_image = 1, it is primary, 2: secondary
int boot_sys_flash_pri_sec_yes_sub(int primary_image, int no_confirm) // 450529-enhance, isolate this so I can call
{
	if(provisional_mode_reload_check() == 0) // kklin, Provisional mode can only reload to PE mode
		return 0;
	
        if(is_flash_use_in_progress()) {
                uprintf("Error : Flash access is in progress. Please try again.\n");
                return 0;
        }
                
        if((sptr_flash_cb))
        {
                uprintf("System is performing a Flash write operation, please try later\n");
                return 0;
        }
        write_log_crc ();
        g_boot_sys_from_image = primary_image;
        g_sxr_peer_reset_not_reqd = 1;
        if ((!download_check()) && (user_warned ==0) && no_confirm == 0)
        {       
                uprintf("\nYou are about to downgrade to a 7.x version, please issue 'downgrade_to 7.x' to avoid errors \n "
                        "enter 'y' to continue, 'n' to abort \n");
        
                set_confirm_mode(download_check_confirm_callback, 0, 1);
                return 0;
        } else {
        
        }

         if(dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_BOOT, g_boot_sys_from_image)) //  573019 If return 1, it setup a timer to reload
            return 1;

		print_reboot_and_cold_reset_now();
        return 1;
}


/*--------------------------------------------------------------------------**
**                                                                                                                                                                                                       **
** This is a "boot sys fla sec" function without interactive confirmation.  **
** Mainly used by test scripts that do not want the confirmation.                                **
**                                                                                                                                                                                                       **
**--------------------------------------------------------------------------*/
void boot_sys_flash_sec_yes(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                boot_sys_flash_pri_sec_yes_sub(2, 0); // 450529: 2 is secondary image
        }
}
void e_boot_sys_flash_pri(struct cdb* sptr_cdb)
{
        SYS_BOOT_LINE_TFTP_INFO cli_boot_line;
        UINT32 *cli_boot = (UINT32*)&cli_boot_line;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        {
#if 0
                {
                UINT32 next_session_id;

                aaa.shutdown_in_progress = TRUE;
                //If system accounting is configured, do it now. After AAA is done, call the function special_reload() again
                if (cli_request_system_accounting(sptr_cdb->ui_port, FALSE))
                        return;
                else
                {
                        //Start EXEC Accnt STOP from the first active console/telnet/ssh session.
                        next_session_id = aaa_get_next_active_session(0xffffffff);
                        if (cli_request_exec_accounting_stop_all(next_session_id))
                                return;
                }
                }

        if (STACK_AM_I_MASTER)
        {
                        dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_BOOT, 1);
                        return;
        }
                cu_shutdown_software_subsystems();
                write_log_crc ();
                sys_reset(1, &cli_boot_line);
#else

		if(provisional_mode_reload_check() == 0) // kklin, Provisional mode can only reload to PE mode
		{
			sptr_cdb->dont_go_next = 1;
			return;
		}
		
        if(is_flash_use_in_progress()) {
            uprintf("Error : Flash access is in progress. Please try again.\n");
            return ;
        }


                g_boot_sys_from_image = 1;
                g_sxr_peer_reset_not_reqd = 1;
                g_boot_sys_flash = TRUE;
                g_Need_To_Send_boot_Req = TRUE;
                sptr_cdb->dont_go_next = 1;
#if 0
                                /*Verify fips signature before reload is fips is enabled
                                warn the user if fips verification fails */
                                if (cu_fips_get_status())
                                {
                                        if(!fips_verify_image_with_signature(PRIMARY))
                                        {
                                                uprintf("FIPS: Fatal-Error: Software load test FAILED; do you want to continue?");
                                                set_confirm_mode(reload_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
                                                return;
                                        }
                                }
#endif
                uprintf("Are you sure? ");
                set_confirm_mode(reload_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
#endif
        }
}

void e_boot_sys_flash_sec(struct cdb* sptr_cdb)
{
        SYS_BOOT_LINE_TFTP_INFO cli_boot_line;
        UINT32 *cli_boot = (UINT32*)&cli_boot_line;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        {
#if 0
                {
                UINT32 next_session_id;

                aaa.shutdown_in_progress = TRUE;
                //If system accounting is configured, do it now. After AAA is done, call the function special_reload() again
                if (cli_request_system_accounting(sptr_cdb->ui_port, FALSE))
                        return;
                else
                {
                        //Start EXEC Accnt STOP from the first active console/telnet/ssh session.
                        next_session_id = aaa_get_next_active_session(0xffffffff);
                        if (cli_request_exec_accounting_stop_all(next_session_id))
                                return;
                }
                }

        if (STACK_AM_I_MASTER)
        {
                        dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_BOOT, 2);
                        return;
        }
                cu_shutdown_software_subsystems();
#ifndef NOCACHE
                DcacheInhibit(DRAM_REG);
#endif NOCACHE
                write_log_crc ();
                sys_reset(2, &cli_boot_line);
#else

		if(provisional_mode_reload_check() == 0) // kklin, Provisional mode can only reload to PE mode
		{
			sptr_cdb->dont_go_next = 1;
			return;
		}
		
                if(is_flash_use_in_progress()) {
                    uprintf("Error : Flash access is in progress. Please try again.\n");
                    return ;
                }

                g_boot_sys_from_image = 2;
                g_sxr_peer_reset_not_reqd = 1;
                g_boot_sys_flash = TRUE;
                g_Need_To_Send_boot_Req = TRUE;
                sptr_cdb->dont_go_next = 1;
#if 0
                                /*Verify fips signature before reload is fips is enabled
                                 warn the user if fips verification fails */
                                if (cu_fips_get_status())
                                {
                                        if(!fips_verify_image_with_signature(SECONDARY))
                                        {
                                                uprintf("FIPS: Fatal-Error: Software load test FAILED; do you want to continue?");
                                                set_confirm_mode(reload_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
                                                return;
                                        }
                                }
#endif
                uprintf("Are you sure? ");
                set_confirm_mode(reload_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
#endif
        }
}
void e_boot_sys_bootp(struct cdb* sptr_cdb)
{
        SYS_BOOT_LINE_TFTP_INFO cli_boot_line;
        UINT32 *cli_boot = (UINT32*)&cli_boot_line;
        {
                {
                UINT32 next_session_id;

                aaa.shutdown_in_progress = TRUE;
                //If system accounting is configured, do it now. After AAA is done, call the function special_reload() again
                if (cli_request_system_accounting(sptr_cdb->ui_port, FALSE))
                        return;
                else
                {
                        //Start EXEC Accnt STOP from the first active console/telnet/ssh session.
                        next_session_id = aaa_get_next_active_session(0xffffffff);
                        if (cli_request_exec_accounting_stop_all(next_session_id))
                                return;
                }
                }
                cu_shutdown_software_subsystems();
                *cli_boot = TRY_BOOT_FROM_BOOTP; /* this command is left for the boot code to read */
                write_log_crc ();
                sys_reset(4, &cli_boot_line);
        }
}

void reset_ip1_ip2(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen) {

        }
        else {
                sptr_cdb->ip1 = 0;
                sptr_cdb->ip2 = 0;
                sptr_cdb->num_of_ip = 2;
        }

}

void reset_ip3_ip4(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen) {

        }
        else {
                sptr_cdb->ip3 = 0;
                sptr_cdb->ip4 = 0;
                sptr_cdb->num_of_ip = 4;
        }

}

/* cmd4.h */

/* exec cmds */
#ifdef SR_SWITCH_ONLY
/* for layer 3 switching */
void clear_ip_cache_all(struct cdb* sptr_cdb)
{
        if (g_ip_switch_enabled)
                free_ip_cache_entries();
        else
        {
                uprintf("This CLI operation is valid only when ip switching is enabled\n");
        }
}
#endif


#ifdef SR_SWITCH_ROUTER
void clear_ip_cache_Ip(struct cdb* sptr_cdb)
{
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        fpip_delete_route(sptr_cdb->ip1,sptr_cdb->vrf_idx, FALSE);
}


void clear_ip_cache_all(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;

        fpip_flush_cache_vrf(sptr_cdb->vrf_idx);
        sptr_cdb->dont_go_next = 1;
}

void clear_ip_flow_all(struct cdb* sptr_cdb)
{
        ip_flow_force_delete(NULL);
}

void clear_ip_route_Ip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        RTM_ipv4_clear_routing_table_specific(sptr_cdb->ip1, 0xFFFFFFFF, sptr_cdb->safi, sptr_cdb->vrf_idx);
}

void clear_ip_traffic(struct cdb* sptr_cdb)
{
        reset_ip_counters();
}

#endif SR_SWITCH_ROUTER

static void show_int_common(struct cdb* sptr_cdb)
{
        cu_show_interface_page(1, sptr_cdb->port_mask1, NEXT_PORT_INDEX_INVALID);
}
#ifdef FIOFL_INCLUDE
void show_int_brief_common(struct cdb* sptr_cdb)
#else FIOFL_INCLUDE
static void show_int_brief_common(struct cdb* sptr_cdb)
#endif FIOFL_INCLUDE
{
        switch (sptr_cdb->port_mask_type)
        {
        case ETHERNET:
        print_port_type[sptr_cdb->ui_port] = BIT(PORT_TYPE_ETHERNET);
        break;

        case VLAG:
        print_port_type[sptr_cdb->ui_port] = BIT(PORT_TYPE_LAG);
        break;

        case POS:
        print_port_type[sptr_cdb->ui_port] = BIT(PORT_TYPE_POS);
        break;

        default:
        sptr_cdb->dont_go_next = 1;
        return;
        }
        cu_show_interface_brief(1, sptr_cdb->port_mask1, PORT_INDEX_INVALID);
}

#ifdef SR_SWITCH_ROUTER
static void show_router_int_common(struct cdb* sptr_cdb)
{
        cu_show_interfaces(sptr_cdb->router_port, 2, TRUE);
}

static void show_router_int_brief_common(struct cdb* sptr_cdb)
{
        cu_show_enet_interface_header(FALSE);
        cu_show_ethernet_interface(sptr_cdb->router_port, FALSE);
}
#endif /*SR_SWITCH_ROUTER*/

#ifdef SR_SWITCH_ROUTER


#endif  /* SR_SWITCH_ROUTER */


/* config cmds */
void boot_sys_bootp(struct cdb* sptr_cdb)
{
        int i;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
#ifdef DEBUG
                        uprintf("no boot system bootp\n");
#endif
                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                        {
                                if (boot_seq[i] == BOOT_FROM_BOOTP)
                                        break;
                        }
                        if (i == MAX_BOOT_SEQ)
                        {
                                uprintf("Error - boot sequence did not exist.\n");
                                return;
                        }
                        for (;i < (MAX_BOOT_SEQ-1); i++)
                        {
                                boot_seq[i] = boot_seq[i+1];
                        }
                        boot_seq[MAX_BOOT_SEQ-1] = BOOT_FROM_NONE;
                }
                else
                {
#ifdef DEBUG
                        uprintf("boot system bootp\n");
#endif
                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                        {
                                if (boot_seq[i] == BOOT_FROM_BOOTP)
                                        return;
                                if (boot_seq[i] == BOOT_FROM_NONE)
                                        break;
                        }
                        if (i == MAX_BOOT_SEQ)
                        {
                                uprintf("Error - boot sequence has reached max %d entries.\n", MAX_BOOT_SEQ);
                                return;
                        }
                        boot_seq[i] = BOOT_FROM_BOOTP;
                }
        }
}


void boot_sys_flash_pri(struct cdb* sptr_cdb)
{
        int i;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
#ifdef DEBUG
                        uprintf("no boot system flash pri\n");
#endif
                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                        {
                                if (boot_seq[i] == BOOT_FROM_FLASH_PRI)
                                        break;
                        }
                        if (i == MAX_BOOT_SEQ)
                        {
                                uprintf("Error - boot sequence did not exist.\n");
                                return;
                        }
                        for (;i < (MAX_BOOT_SEQ-1); i++)
                        {
                                boot_seq[i] = boot_seq[i+1];
                        }
                        boot_seq[MAX_BOOT_SEQ-1] = BOOT_FROM_NONE;
                                                if(is_a_fs())
                                                {
                                                        katara_boot_env_updated = 1;
                                                }

                                                if (is_linux_based_system()) {
                                                        linux_boot_env_updated = 1;
                                                }

                }
                else
                {
#ifdef DEBUG
                        uprintf("boot system flash pri\n");
#endif
                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                        {
                                if (boot_seq[i] == BOOT_FROM_FLASH_PRI)
                                        return;
                                if (boot_seq[i] == BOOT_FROM_NONE)
                                        break;
                        }
                        if (i == MAX_BOOT_SEQ)
                        {
                                uprintf("Error - boot sequence has reached max %d entries.\n", MAX_BOOT_SEQ);
                                return;
                        }
                                                if (is_a_fs() && (boot_seq[0] != BOOT_FROM_FLASH_PRI))
                                                {
                                                        katara_boot_env_updated = 1;
                                                }

                                                if (is_linux_based_system() && (boot_seq[0] != BOOT_FROM_FLASH_PRI)) {
                                                        linux_boot_env_updated = 1;
                                                }


                        boot_seq[i] = BOOT_FROM_FLASH_PRI;
                }
        }
}

void boot_sys_flash_sec(struct cdb* sptr_cdb)
{
        int i;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
#ifdef DEBUG
                        uprintf("no boot system flash sec\n");
#endif
                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                        {
                                if (boot_seq[i] == BOOT_FROM_FLASH_SEC)
                                        break;
                        }
                        if (i == MAX_BOOT_SEQ)
                        {
                                uprintf("Error - boot sequence did not exist.\n");
                                return;
                        }
                        for (;i < (MAX_BOOT_SEQ-1); i++)
                        {
                                boot_seq[i] = boot_seq[i+1];
                        }
                        boot_seq[MAX_BOOT_SEQ-1] = BOOT_FROM_NONE;
                                                if(is_a_fs())
                                                {
                                                        katara_boot_env_updated = 1;
                                                }
                                                if (is_linux_based_system()) {
                                                        linux_boot_env_updated = 1;
                                                }


                }
                else
                {
#ifdef DEBUG
                        uprintf("boot system flash sec\n");
#endif
                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                        {
                                if (boot_seq[i] == BOOT_FROM_FLASH_SEC)
                                        return;
                                if (boot_seq[i] == BOOT_FROM_NONE)
                                        break;
                        }
                        if (i == MAX_BOOT_SEQ)
                        {
                                uprintf("Error - boot sequence has reached max %d entries.\n", MAX_BOOT_SEQ);
                                return;
                        }
                                                if (is_a_fs() && (boot_seq[0] != BOOT_FROM_FLASH_SEC))
                                                {
                                                        katara_boot_env_updated = 1;
                                                }

                                                if (is_linux_based_system() && (boot_seq[0] != BOOT_FROM_FLASH_SEC)) {

                                                        linux_boot_env_updated = 1;
                                                        
                                                }


                        boot_seq[i] = BOOT_FROM_FLASH_SEC;
                }
        }
}

#ifdef  SR_SWITCH_ROUTER
void cli_set_ip_helper_use_response_ip_flag(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.use_bootp_or_dhcp_src_ip)
                        wr_config(sptr_cdb, "ip helper-use-responder-ip\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip.use_bootp_or_dhcp_src_ip = 0;
                else
                        ip.use_bootp_or_dhcp_src_ip = 1;
        }
}

void cli_set_ip_route_purge_timer(struct cdb* sptr_cdb)
{
        RTM_CLASS       *iprt;
        iprt = rtm_get_global_rtm_class(IP_UNICAST_SAFI,IPVRF_DEFAULT_VRF_IDX);

        if (sptr_cdb->config_gen)
        {
                if(iprt->route_purge_timer != ROUTE_PURGE_TIMER_DEFAULT_OFFSET_SECONDS)
                {
                        ksprintf (cu_line_buf,
                              "ip hitless-route-purge-timer %u\n",
                              iprt->route_purge_timer);
                        wr_config (sptr_cdb, cu_line_buf);
                }
                sptr_cdb->dont_go_next = 1;
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if(iprt->route_purge_timer == 0)
                                uprintf("Ipv4 route purge time is not configured\n");
                        else
                                iprt->route_purge_timer = ROUTE_PURGE_TIMER_DEFAULT_OFFSET_SECONDS;
                }
                else
                {
                        if(sptr_cdb->integer1 < ROUTE_PURGE_TIMER_MINIMUM_CONFIG_SECONDS || sptr_cdb->integer1 > 600)
                        {
                                uprintf("Please specify value in the range %d-600 seconds\n", ROUTE_PURGE_TIMER_MINIMUM_CONFIG_SECONDS);
                                return;
                        }
                        iprt->route_purge_timer = sptr_cdb->integer1;
                }
        }
}

void cli_set_ip_vrf_route_purge_timer(struct cdb* sptr_cdb)
{
        RTM_CLASS       *iprt;

        sptr_cdb->num_of_string = 1 ;
        strncpy(sptr_cdb->string1, sptr_cdb->mode_vrf_name, sizeof(sptr_cdb->mode_vrf_name));
        sptr_cdb->string1[sizeof(sptr_cdb->vrf_name) - 1] = '\0';
        sptr_cdb->vrf_idx = sptr_cdb->mode_vrf_idx;

        iprt = rtm_get_global_rtm_class(IP_UNICAST_SAFI,sptr_cdb->vrf_idx);

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
        {
                if(iprt->route_purge_timer == ROUTE_PURGE_TIMER_DEFAULT_OFFSET_SECONDS)
                        uprintf("Ipv4 route purge time is not configured\n");
                else
                        iprt->route_purge_timer = ROUTE_PURGE_TIMER_DEFAULT_OFFSET_SECONDS;
        }
        else
        {
                if(sptr_cdb->integer1 < ROUTE_PURGE_TIMER_MINIMUM_CONFIG_SECONDS || sptr_cdb->integer1 > 600)
                {
                        uprintf("Please specify value in the range %d-600 seconds\n", ROUTE_PURGE_TIMER_MINIMUM_CONFIG_SECONDS);
                        return;
                }
                iprt->route_purge_timer = sptr_cdb->integer1;
        }
}

void cli_set_ip_helper_use_incoming_interface_ip_flag(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.bootp_sip_use_in_intf)
                        wr_config(sptr_cdb, "ip bootp-use-intf-ip\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip.bootp_sip_use_in_intf = 0;
                else
                        ip.bootp_sip_use_in_intf = 1;
        }
}

#endif

void cli_set_ip_show_subnet_length(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.show_subnet_mask_bits)
                        wr_config(sptr_cdb, "ip show-subnet-length\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip.show_subnet_mask_bits = 0;
                else
                        ip.show_subnet_mask_bits = 1;
        }
}

#ifdef SR_SWITCH_ROUTER
void set_if_bootp_gateway(struct cdb* sptr_cdb)
{
        UINT16 port_id;

        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                if (bootp.relay_agent.gateways[port_id] != 0)
                {
                        ksprintf(cu_line_buf, " ip bootp-gateway %I\n", bootp.relay_agent.gateways[port_id]);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        bootp.relay_agent.gateways[port_id] = 0;
                }
                else
                {
                        bootp.relay_agent.gateways[port_id] = sptr_cdb->ip1;
                }
        }
}

void check_valid_ip_intf(struct cdb* sptr_cdb)
{
        /* When config-gen, check whether a given interface (physical
         * or virtual) is a router interface. If not, don't go further.
         * When not config-gen, we don't allow user to enter ip command
         * in interface mode if the interface is not a router interface,
         * thus we don't need to do any checking.
         */
        if (sptr_cdb->config_gen)
        {
#ifdef SR_SWITCH_ROUTER
#if (defined (__GRE_IP_TUNNEL__) || defined (__TUNNEL_INTERFACE__))
                if ((!is_loopback_port(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))) &&
                        (!is_gre_ip_tunnel_port(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))))
#else (defined (__GRE_IP_TUNNEL__) || defined (__TUNNEL_INTERFACE__))
                if (!is_loopback_port(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
#endif (defined (__GRE_IP_TUNNEL__) || defined (__TUNNEL_INTERFACE__))
#endif /*SR_SWITCH_ROUTER*/
                if (cu_check_interface(
                        (UINT16)INTERFACE_TO_PORT_ID(sptr_cdb->if_num),
                        IP_PROTO_INDEX) != CU_OK)
                        sptr_cdb->dont_go_next = 1;
        }

    if (sptr_cdb->config_gen)
                return;
#ifdef __TUNNEL_INTERFACE__
    if(is_Interface_IPv6_over_IPv4_tunnel(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
    {
        uprintf("Error - cannot configure ip features on a 6-4 tunnel.\n");
                sptr_cdb->dont_go_next = 1;
                return;

    }
#endif

#ifdef MPLS             //DRAFT_MARTINI
        if (sptr_cdb->config_gen)
                return;

        if(sptr_cdb->token[strlen(sptr_cdb->token)-1] == '?')
                return; // This is a ? inquiry.

        if (IS_PORT_DB_VALID(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))
                && SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.vll)
        {
                uprintf("Error - cannot configure ip features on a vll interface\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }
#endif MPLS             //DRAFT_MARTINI
}

void check_valid_ip_mif (struct cdb* sptr_cdb)
{
     set_mif(sptr_cdb, TRUE, (void *)check_valid_ip_intf);
}

/* FINIL3 */
/* VRF Commands */

static enum BOOLEAN
check_set_vrf_on_intf(UINT16 port_id)
{
        enum PORT_MODE tag_type;
        UINT16 port_type;

#if 0
//#ifdef __GVRP_SUPPORT__
        // check if gvrp is enabled on the port
        if (gvrplib_get_is_gvrp_enable()&& gvrplib_get_is_gvrp_port_enable(port_id))
        {
                uprintf("Error - Cannot configure VRF on a GVRP port %p\n",
                                port_id);
                return FALSE;
        }
//#endif __GVRP_SUPPORT__
#endif

        // check port mode
        if (is_physical_port(port_id))
        {
                if (is_physical_port(port_id))
                        cu_get_port_tag_type(port_id, 1, &tag_type);
                else
                        tag_type = UNTAGGED;                    /* get around it */

                if (tag_type == TAGGED)
                {
                        uprintf("Error - cannot configure VRF on a tagged port\n");
                        return FALSE;
                }

                if (tag_type == DUAL_MODE)
                {
                        // REJECT A VRF CONFIGURATION
                        uprintf("Error - cannot configure VRF on a dual-mode port\n");
                        return FALSE;
                }

                /* POS does not support VRF Forwarding */
                if (IS_PORT_POS(port_id))
                {
                        uprintf("Error - cannot configure VRF on a POS interface\n");
                        return FALSE;
                }

                if (VELIB_IS_MEMBER_GMASK(port_id))
                {
                        uprintf("Error - cannot configure VRF on VE members\n");
        return FALSE;
                }
        }

#ifdef MPLS
        if(is_physical_port(port_id) && GET_PORT_MPLS_ENABLE(port_id))
        {
                uprintf("Error - cannot configure VRF on an MPLS enabled interface\n");
                return FALSE;
        }
        if(is_virtual_port(port_id) && IS_MPLS_ENABLED_ON_PORT(port_id))
        {
                uprintf("Error - cannot configure VRF on an MPLS VE enabled interface\n");
                return FALSE;
        }
        if(is_physical_port(port_id) && GET_PORT_VPLS_ENABLE(port_id))
        {
                uprintf("Error - cannot configure VRF on an VPLS enabled interface\n");
                return FALSE;
        }
        if(is_physical_port(port_id) && GET_PORT_VLL_ENABLE(port_id))
        {
                uprintf("Error - cannot configure VRF on an VLL enabled interface\n");
                return FALSE;
        }
#endif MPLS

        return TRUE;
}
#ifdef FI_URPF

void set_mif_urpf_strict(struct cdb* sptr_cdb)
{
         set_mif(sptr_cdb, TRUE, (void *)set_ip_urpf_strict);
}

void set_mif_urpf_loose(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_ip_urpf_loose);
}

void set_mif_urpf_strict_exclude_default(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_ip_urpf_strict_exclude_default);
}

void set_mif_urpf_loose_exclude_default(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_ip_urpf_loose_exclude_default);
}

void set_ip_urpf_interface(struct cdb* sptr_cdb, IP_URPF_MODE urpf_mode, UINT8 default_route)
{
        UINT16 port_id;
        IP_PORT_ERROR err_no = IP_PORT_OK;
        IP_URPF_MODE port_urpf_mode = IP_URPF_DISABLE;
        UINT8 exclude_default_route = FALSE;
        char *exclude_default_route_char = "";

        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (IS_MGMT_PORT(port_id) || is_loopback_port(port_id)
#ifdef __TUNNEL_INTERFACE__ 
                                        ||      is_gre_ip_tunnel_port(port_id)
#endif __TUNNEL_INTERFACE__                     
                                                                                                                                )
        {
                return;
        }


        if (sptr_cdb->config_gen)
    {
                if (ip_is_urpf_global_current_enabled())
                {
                        port_urpf_mode = ip_port_urpf_get_mode(port_id);

                        if (port_urpf_mode == IP_URPF_DISABLE)
                        {
                                /* uRPF not configured */
                                return;
                        }
                        else
                        {
                                exclude_default_route = ip_port_urpf_get_exclude_default_route(port_id);

                                if (exclude_default_route == TRUE)
                                        exclude_default_route_char = " urpf-exclude-default";
                                
                                if (port_urpf_mode == IP_URPF_STRICT)
                                {
                                        ksprintf(cu_line_buf, " rpf-mode strict%s\n", exclude_default_route_char);
                                }
                                else if (port_urpf_mode == IP_URPF_LOOSE)
                                {
                                        ksprintf(cu_line_buf, " rpf-mode loose%s\n", exclude_default_route_char);
                                }
                        }
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (!ip_is_urpf_global_current_enabled())
        {
                uprintf("\nError: Please configure reverse-path-check globally first\n");
                return;
        }

        if (!sptr_cdb->no)
        {
                if (is_physical_port(port_id) && (PORT_MODE(port_id) == TAGGED))
                {
                        uprintf ("rpf-mode cannot be applied to a tagged port\n");
                        return;
                }
                if (is_trunk_primary_port (port_id) && (urpf_mode == IP_URPF_STRICT)) 
                {
                        uprintf ("Error: rpf-mode strict cannot be applied to a trunk primary port\n");
                        return;
                }
    
        }
        
        ip_port_urpf_set_mode(port_id, urpf_mode, default_route, !sptr_cdb->no);
}


void set_ip_urpf_strict(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }
        if (sptr_cdb->config_gen)
        {
                return;
        }       

        set_ip_urpf_interface(sptr_cdb, IP_URPF_STRICT, FALSE);
}

void set_ip_urpf_loose(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }
        
        set_ip_urpf_interface(sptr_cdb, IP_URPF_LOOSE, FALSE);
}

void set_ip_urpf_strict_exclude_default(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }
        if (sptr_cdb->config_gen)
        {
                return;
        }       

        set_ip_urpf_interface(sptr_cdb, IP_URPF_STRICT, TRUE);
}

void set_ip_urpf_loose_exclude_default(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }
        if (sptr_cdb->config_gen)
        {
                return;
        }

        set_ip_urpf_interface(sptr_cdb, IP_URPF_LOOSE, TRUE);
}



void show_ip_urpf_config(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                        sptr_cdb->dont_go_next = 1;
                        show_ip_urpf_global_config();
        }

}

void cli_set_global_urpf(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }

        if (sptr_cdb->config_gen)
        {
                        if (ip_is_urpf_global_config_enabled())
                        {
                                        ksprintf(cu_line_buf, "reverse-path-check\n");
                                        wr_config(sptr_cdb, cu_line_buf);
                        }
        }
        else
        {
                        if (ip_is_urpf_supported())
                                        ip_set_global_urpf(!sptr_cdb->no);
                        else
                                        uprintf ("reverse-path-check is not supported on this platform.\n");
        }
}

void show_ip_urpf_config_interfaces(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }

        if (sptr_cdb->config_gen)
        {
                return;
        }
        else
        {
                        if (ip_is_urpf_supported())
                                        ip_show_urpf_port_config_all();
                        else
                                        uprintf ("reverse-path-check is not supported on this platform.\n");
        }       
}

void show_ip_urpf_config_debug_cpu_enabled(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
        }

        if (sptr_cdb->config_gen)
        {
                return;
        }
        else
        {
                        if (ip_is_urpf_supported())
                                        ip_show_urpf_cpu_enabled_all(TRUE);
                        else
                                        uprintf ("reverse-path-check is not supported on this platform.\n");
        }
}


#endif FI_URPF

void set_ip_vrf_forwarding(struct cdb* sptr_cdb)
{
        UINT16 port_id;
        IP_PORT_ERROR err_no = IP_PORT_OK;
        IP_PORT_ERROR err_no_v6 = IP_PORT_OK;
        VRF_INDEX vrf_index;
        UINT16 tunnel_id;
        UINT16 vlan_id = 0;
        UINT8 check_flag = TRUE;

        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        //verify_v6vrf_cam_resource();

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                if (!IS_IP_PORT_DB_VALID(port_id)|| port_id > maximum_ip_ports)
                        return;

                vrf_index = IP_PORT_VRF_INDEX(port_id);
                if (vrf_index != IPVRF_DEFAULT_VRF_IDX)
                {
                        ksprintf(cu_line_buf, " vrf forwarding %s\n",
                                                make_quoted_string(ipvrf_api_get_vrf_name
                                                (vrf_index)));
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;

                if (cli_set_vrf_loose(sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                        return;

                if (IP_PORT_VRF_INDEX(port_id) != sptr_cdb->vrf_idx)
                {
                        uprintf("Error - Port is not a part of VRF %s\n", sptr_cdb->string1);
                        return;
                }

#ifdef __TUNNEL_INTERFACE__
                if (is_gre_ip_tunnel_port (port_id))
                {
                    tunnel_id = ROUTER_INT_TO_TNID(port_id);
                    if (g_tunnel_table[tunnel_id].tunnel_delete_flag == TRUE)
                    {
                       check_flag = FALSE;
                    }
                }
#endif
		if (check_flag && !ip_is_l3_config_ok_to_remove_vlan_ve_vrf (port_id, "before removing the VRF"))
		{
	            return;
		}
                sptr_cdb->dont_go_next = 1;

                vrf_index = IPVRF_DEFAULT_VRF_IDX;
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return; /* cmd not for me */
                sptr_cdb->dont_go_next = 1;

                if (cli_set_vrf_loose(sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                        return;

                if (check_set_vrf_on_intf(port_id) == FALSE)
                        return;

                vrf_index = sptr_cdb->vrf_idx;

                if (IP_PORT_VRF_INDEX(port_id) == vrf_index)
                        return;

#ifdef INCLUDE_MCT
                vlan_id = getVlanFromIpPort(port_id);
                if (clusterlib_is_vlan_deployed_management_vlan (vlan_id))
                {
                        uprintf ("Error - VIF %p is a cluster management VE, Which must be in Default VRF\n", 
                                         port_id);
                        return;
                }
#endif INCLUDE_MCT

#ifdef __TUNNEL_INTERFACE__
	        if ((!is_gre_ip_tunnel_port (port_id)) &&
	            (is_port_tunnel_source (port_id , &tunnel_id) == TRUE))
	        {
#ifdef __FI_IPSEC_IKE__
			if ( is_IPsec_IPv4_over_IPv4_tunnel(tunnel_id) )
			{
				if ( g_tunnel_table[tunnel_id].base_vrf_index != vrf_index )
				{
					uprintf ("Error - Please remove tunnel source from tunnel %d before moving it to another VRF\n", tunnel_id + 1);
					return FALSE;
				}
			}else
#endif /* __FI_IPSEC_IKE__ */
			if( vrf_index != TUNNEL_VRF_ID(tunnel_id) )
			{
				uprintf ("Error - Please remove tunnel source from tunnel %d before moving it to another VRF\n", tunnel_id + 1);
                                return FALSE;
			}
	        }
		else
#endif /* __TUNNEL_INTERFACE__ */

                if (!ip_is_l3_config_ok_to_remove_vlan_ve_vrf (port_id, 
                                                                "before moving it to another VRF"))
                {
                return;
                }

        }

#ifdef __TUNNEL_LOOPBACK__ 
        if(is_physical_port(port_id) && is_gre_loopback_port(port_id))
        {
                uprintf("Error - cannot change the VRF settings on a GRE loopback port %p\n",port_id);
                return;
        }
#endif __TUNNEL_LOOPBACK__

        /*
         * Delete all the existing IPv4 and IPv6 addresses on this interface.
         * Set ip6_port_config->ip6_protocol_enabled to FALSE
         */
        err_no = ip_port_send_gen_msg(IP_PORT_CU_DEL_ALL_ADDR, port_id, 0, TRUE);
        if (err_no != IP_PORT_OK)
        {
           uprintf("%s\n (err_no:%d; IP_PORT_OK:%d\n)", ip_port_err_to_string(err_no, NULL), err_no, IP_PORT_OK);
           return;
        }

        err_no_v6 = ipv6_delete_interface_addresses(port_id, TRUE);
        if(err_no_v6 != IP_PORT_OK)
        {
          uprintf("Failed to delete ipv6 interface addresses. Error no:%d\n", err_no);
          return;
        }

        err_no_v6  = ipv6_set_interface_enable(port_id, FALSE);
        if(err_no_v6 != IP_PORT_OK)
        {
          uprintf("Failed to disable ipv6 on the interface. Error no:%d\n", err_no);
          return;
        }  

        if (err_no_v6 == IP_PORT_OK)
        {
                if (sptr_cdb->no)
                {
                        /*
                         * No "ipv6 router isis" to remove on this interface since VRF
                         * forwarding exists on this interface.
                         */
                }
                else if (sptr_cdb->config_gen == 0)
                {
                // Remove ISIS on this VRF interface.  Currently ISIS does not support VRFization
#ifdef __ISIS__
#ifdef __IPV6_ISIS__
                        isis_reset_ipv6_port_state(PORT_ID_TO_INTERFACE(port_id));
#endif __IPV6_ISIS__
                        isis_reset_port_state(PORT_ID_TO_INTERFACE(port_id));
#endif __ISIS__
                }
        }

        if (err_no == IP_PORT_OK && err_no_v6 == IP_PORT_OK &&
                                                                                        g_sw_sys.init_in_progress == FALSE)
        {
                uprintf("Warning: All IPv4 and IPv6 addresses (including link-local) on "
                                                                        "this interface have been removed\n");
        }

        clear_rpf_config_on_interface(port_id);
        clear_ipv6_rpf_config_on_interface(port_id);

#ifdef IP_POLICY_ROUTING
        pbr_clear_config_on_interface(port_id);
#endif
		
#ifdef __TUNNEL_LOOPBACK__
        /* if it is a tunnel interface, remove the tunnel loopback */
        if (is_gre_ip_tunnel_port(port_id) && is_GRE_IPv4_over_IPv4_tunnel(ROUTER_INT_TO_TNID(port_id)))
        {
                        tunnel_id = ROUTER_INT_TO_TNID(port_id);
                        if (g_tunnel_table[tunnel_id].loopback_port_configured)
                        {
                                        clear_gre_loopback_port(tunnel_id,TRUE);

                                        pp_delete_ipgre_tunnel_termination_entry(tunnel_id,TRUE);
                        }
        }
#endif __TUNNEL_LOOPBACK__

       /*remove keepalive since it is not supported on vrf tunnel*/
#ifdef __TUNNEL_INTERFACE__
       if (is_gre_ip_tunnel_port(port_id) && is_GRE_IPv4_over_IPv4_tunnel(ROUTER_INT_TO_TNID(port_id)))
       {
                tunnel_id = ROUTER_INT_TO_TNID(port_id);
                ip_gre_disable_keep_alive(tunnel_id);
       }

#endif __TUNNEL_INTERFACE__
        // Configure the VRF index on this interface

        err_no = ip_port_send_gen_msg(IP_PORT_CU_IP_VRF_FWD, port_id, vrf_index,
                                                        sptr_cdb->no);
        if (err_no != IP_PORT_OK)
                        uprintf("%s\n", ip_port_err_to_string(err_no, NULL));

#ifdef IP_POLICY_ROUTING
        pbr_apply_global_pbr_after_vrf_change(port_id);
#endif

#ifdef __FI_IPSEC_IKE__
       if ( is_Interface_IPsec_IPv4_over_IPv4_tunnel (port_id))
       {
              tunnel_id = ROUTER_INT_TO_TNID(port_id);

              if (  g_tunnel_table[tunnel_id].ipsec_protection_profile &&
                     is_ike_vrf_tunnel_vrf_same( g_tunnel_table[tunnel_id].ipsec_protection_profile, tunnel_id))
              {
                     uprintf ("Info: Tunnel forwarding vrf does not match the ipsec protected vrf; ipsec profile removed\n");
                     dy_free((void *)g_tunnel_table[tunnel_id].ipsec_protection_profile);
                     g_tunnel_table[tunnel_id].ipsec_protection_profile = NULL;
              }
        }
#endif /*__FI_IPSEC_IKE__ */

}

void
check_no_ip_address_all(struct cdb* sptr_cdb)
{
        int i;
        UINT16 port_id;
        UINT32 ip_address;
        UINT32 subnet_mask;
        UINT16 vlan_id;
        UINT8 secondary;
        unsigned char token, *sptr_token;

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;

                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

                ip_delete_interface_addresses(port_id,sptr_cdb->ui_port);
                sptr_cdb->dont_go_next = 1;
        }
}


void check_no_ip_address (struct cdb* sptr_cdb)
{
        int i;
        UINT16 port_id;
        UINT32 ip_address;
        UINT32 subnet_mask;
        UINT16 vlan_id;
        UINT8 secondary;
        unsigned char token, *sptr_token;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                /*
                 * Notice that the BOOT code also searches for this
                 * "ip address" keyword from the configuration flash.
                 * Therefore, don't change this syntax.
                 */
                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

                for (i = 0; i < IP_MAXIMUM_NUMBER_OF_ADDRESSES_PER_PORT; i++)
                {
                        ip_get_running_interface_ip_address_and_mask(port_id,
                                (UINT8)i,
                                &ip_address,
                                &subnet_mask,
                                &vlan_id,
                                &secondary);

                        if (ip_address == 0 && subnet_mask == 0)
                                break;
                        else
                        {
                                if (ip.show_subnet_mask_bits)
                                        ksprintf(cu_line_buf, " ip address %I/%d", ip_address, cu_get_number_of_subnet_mask_bits(subnet_mask));
                                else
                                        ksprintf(cu_line_buf, " ip address %I %I", ip_address, subnet_mask);
                                wr_config(sptr_cdb, cu_line_buf);

                                if (secondary)
                                        wr_config(sptr_cdb, " secondary");
                                else if (IP_ADDRESS_ENTRY_OSPF_PASSIVE == IP_ADDR_TBL(port_id)[i].ospf_type)
                                        wr_config(sptr_cdb, " ospf-passive");
                                else if (IP_ADDRESS_ENTRY_OSPF_IGNORE == IP_ADDR_TBL(port_id)[i].ospf_type)
                                        wr_config(sptr_cdb, " ospf-ignore");

                                #ifdef SR_SWITCH_ROUTER
                                else if (IP_ADDR_TBL(port_id)[i].ip_address_dynamic == 1)
                                #else
                                else if (ip.ip_address_dynamic == TRUE)
                                #endif
                                        {
                                        wr_config(sptr_cdb, " dynamic");
                                        }

                                wr_config(sptr_cdb, "\n");
#ifdef NI_SLB
                                if (IP_ADDR_TBL(port_id)[i].dont_advertise)
                                {
                                        ksprintf(cu_line_buf, " ip dont-advertise %I %I\n", ip_address, subnet_mask);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }
#endif
                        }
                }
                return;
        }

#ifdef REMOVE_SOON
        // This code does not seem to be necessary. - mlavine 9/11/01
        if (sptr_cdb->subnet1 != 0)
        {
                /* handle '?' in here because parser can't change
                 * keyword option display dynamically at runtime
                 */
                token = tolower(end_of_token(sptr_cdb->token));
                if (token == '?')
                {
                        sptr_cdb->dont_go_next = 1;
                        uprintf("  secondary\n");
                        uprintf("  <cr>\n");
                        options_printed[sptr_cdb->ui_port] = 1;
                        return;
                }
                if (token == 's')
                {
                        /* move token to "secondary" */
                        sptr_token = sptr_cdb->token;
                        next_token(&sptr_token);
                        token = end_of_token(sptr_token);
                        if (token == '?')
                        {
                                sptr_cdb->dont_go_next = 1;
                                uprintf("  <cr>\n");
                                options_printed[sptr_cdb->ui_port] = 1;
                                return;
                        }
                }
        }
#endif REMOVE_SOON

        if (sptr_cdb->no)
        {
                extern int set_group_ve_follow[MAX_IO_CB];
                UINT16 port_id;
                UINT16 tunnel_id;

                if (sptr_cdb->help)
                        return;

                if (set_group_ve_follow[sptr_cdb->ui_port])
                {
                   if(sptr_cdb->vlan_group_id) {
                        port_id = INTERFACE_TO_PORT_ID(VID_TO_ROUTER_INT(g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].vlan_group_member[0]));
                        if (IP_ADDR_COUNT(port_id) > 0)
                        {
                                g_vlan_group_cmd = 0;
                                return;
                        }
                        ip_remove_follower_from_primary_port(IP_IP_PORT(port_id).config.primary_port,
                                                             port_id); 
                   } else {
                     sptr_cdb->dont_go_next = 1;
                     return;
                   }
                } else {
                        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

#ifdef __TUNNEL_INTERFACE__
                        if (is_ip_common_tunnel_source_address_or_source_port
				(sptr_cdb->ip1, port_id, &tunnel_id) == TRUE)
                        {
                                uprintf ("Error - Please remove tunnel source from tnnl %d " \
                         "before removing IP address\n",
                         tunnel_id + 1);
                                sptr_cdb->dont_go_next = 1;
                                return;
                        }
#endif __TUNNEL_INTERFACE__

                        ip_set_interface_ip_address_and_mask(
                                sptr_cdb->ui_port,
                                port_id,
                                sptr_cdb->ip1,
                                0,
                                0,
                                0,
                                (UINT8)sptr_cdb->no);
                        if(sptr_cdb->vlan_group_id)
                        {
                                set_group_ve_follow[sptr_cdb->ui_port] = 1;
                        }
                }
                sptr_cdb->dont_go_next = 1;
        }
        else
        {
                if (sptr_cdb->subnet1 != 0)
                {
                        token = tolower(end_of_token(sptr_cdb->token));
                        if (token == 's')
                        {
                                sptr_cdb->dont_go_next = 1;
                                next_token(&(sptr_cdb->token));
                                sptr_cdb->ip2 = sptr_cdb->subnet1;
                                set_if_ip_sec(sptr_cdb);
                        }
                        else
                        {
                                sptr_cdb->ip2 = sptr_cdb->subnet1;
                                set_if_ip(sptr_cdb);
                        }
                }
        }
}

UINT8 ip_address_entry_ospf_type;
UINT8 ip_address_replace;

void set_if_ip(struct cdb* sptr_cdb)
{
        int slot;
        PORT_ID port_id;
        enum PORT_MODE tag_type = UNTAGGED;
        UINT8 ip_config_success = 0; // 1 - ip address gets successfully configured, 0 - failure. can be used by any functions later
        UINT16  vlan_id = 0;
        extern int set_group_ve_follow[MAX_IO_CB];

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
                if (set_group_ve_follow[sptr_cdb->ui_port]) /* Configure the rest of the ve group to follow first ve in the group */
                {
                        set_if_ip_follow(sptr_cdb);
                        ip_config_success = 1;
                }
                else
                if (end_of_token(sptr_cdb->token) == '\0')
                {
                        sptr_cdb->dont_go_next = 1;

                        if (sptr_cdb->mode == CONFIG_VRRP_ROUTER_ID)
                        {
                                uprintf("Error - cannot configure an interface IP address in VRRP sub-command mode\n");
                                return;
                        }
#ifndef __NO_VRRPE__
                        if (sptr_cdb->mode == CONFIG_VRRPE_ROUTER_ID)
                        {
                                uprintf("Error - cannot configure an interface IP address in VRRP-Extended sub-command mode\n");
                                return;
                        }
#endif __NO_VRRPE__

                        /*
                         * Notice that the BOOT code also searches for this
                         * "ip address" keyword from the configuration flash.
                         * Therefore, don't change this syntax.
                         */
                        //port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
#ifdef __TUNNEL_INTERFACE__
/*do not allow the user to configure ip address before configuring the mode*/
            if(is_gre_ip_tunnel_port(port_id))
            {
                UINT16 tunnel_id = (UINT16)ROUTER_INT_TO_TNID (port_id);
                if(!is_GRE_IPv4_over_IPv4_tunnel(tunnel_id) 
#ifdef __FI_IPSEC_IKE__
				&& !is_IPsec_IPv4_over_IPv4_tunnel(tunnel_id)
#endif __FI_IPSEC_IKE__
				)
                {
                    uprintf("Error - cannot Configure ip address before tunnel mode configuration\n");
                    return;
                }
            }
#endif __TUNNEL_INTERFACE__


                        /* Check if member of Group VE. If not base, do nothing more */
                        if (is_virtual_port(port_id))
                        {
                                int vlan_group_id;
                                if (is_ve_a_member_of_ve_group(ROUTER_INT_TO_VID(port_id), &vlan_group_id)
                                                == NON_BASE_MEMBER_OF_GROUP_VE)
                                        return ;
                        }

                        if (is_virtual_port(port_id) &&
                            IP_IP_PORT(port_id).config.is_puppet &&
                            IP_IP_PORT(port_id).config.primary_port != port_id)
                        {
                                uprintf("Error - cannot configure ip address on a follower interface\n");
                                return;
                        }

                        if (is_physical_port(port_id))
                                cu_get_port_tag_type(port_id, 1, &tag_type);
                        else
                                tag_type = UNTAGGED;            /* get around it */


#ifdef __GVRP_SUPPORT__

                        if (IS_GVRP_ENABLED() && IS_GVRP_PORT_ENABLED(port_id))
                        {
                                uprintf("Error - Port %P has GVRP enabled. Cannot configure IP address on it.\n", port_id);
                                return;
                        }

#endif __GVRP_SUPPORT__

#if (defined(__GRE_IP_TUNNEL__) && defined(__TUNNEL_LOOPBACK__)) 
                        if(is_physical_port(port_id) && is_gre_loopback_port(port_id))
                        {
                                uprintf("Error - cannot configure IP address on a GRE loopback port %p\n",port_id);
                                return;
                        }
#endif /* (defined(__GRE_IP_TUNNEL__) && defined(__TUNNEL_LOOPBACK__)) */

#ifdef PRIVATE_VLAN
                          //TR000405278
                          if ((is_physical_port(port_id)) && (tag_type == UNTAGGED))
                          {
                                          vlan_id = gi_get_port_vlan_id(port_id);
                                          if (is_pvlan_enabled(vlan_id))
                                          {
                                                          uprintf("Error - Cannot configure IP address on a private vlan port\n");
                                                          return;
                                          }
                          }
#endif /*PRIVATE_VLAN*/

#ifdef FI_PROTECTED_PORTS
                          if ((is_physical_port(port_id)) && 
                              (IS_PORT_DB_VALID(port_id)) &&
                              ((SPTR_PORT_DB(port_id))->port_config.protected))
                          {
                              uprintf("Error - Cannot configure IP address on a protected port %p\n",port_id);
                              return;
                          }
#endif 
#if 0 //def FIOFL_INCLUDE
              if ((is_physical_port(port_id)) && (IS_PORT_OPENFLOW_PORT (port_id)))
              {
                   uprintf("Error - Cannot configure IP address on open-flow enabled port %p\n", port_id);
                   return;
              }
#endif FIOFL_INCLUDE

                        if (tag_type == TAGGED)
                                uprintf("Error - cannot configure IP address on a tagged port\n");
                        else
                        {

                                #ifdef __DHCP_CLIENT__
                                if (ip_address_entry_dynamic == 0)
                                        {
                                enum BOOLEAN disable_dhcp_client = FALSE;

                                if (is_dhcpc_enabled_on_port((size_t)port_id) == TRUE)
                                        {
                                        if (dhcpc_have_port_lease_time ((size_t)port_id) == TRUE)
                                                {
                                                disable_dhcp_client = TRUE;
                                                dhcpc_set_port_protocol_state((size_t)port_id, disable_dhcp_client, TRUE);
                                                }
                                        }
                                        if(! is_mgmt_active())
                                        {
                                                dhcpc_delete_ip_address_on_new_active(port_id);
                                        }

                                }
                                #endif __DHCP_CLIENT__

                                if (IS_MINIONS() && (validate_l3_if_int_sys_max() == FALSE) && !is_loopback_port(port_id))
                                {
                                    uprintf("\nError: L3 interface number reaches the system max value\n");
                                    return;
                                }

                                if (

                                ip_set_interface_ip_address_and_mask(
                                        sptr_cdb->ui_port,
                                        port_id,
                                        sptr_cdb->ip1,
                                        sptr_cdb->ip2,
                                        (UINT16) sptr_cdb->integer1,
                                        sptr_cdb->secondary,
                                        (UINT8)sptr_cdb->no) == -1)
                                                g_vlan_group_cmd = 0;
                                        else
                                        {
                                                if ((sptr_cdb->vlan_group_id) &&
                                                        IS_PORT_IN_VIRTUAL_PORT(port_id))
                                                {
                                                        set_group_ve_follow[sptr_cdb->ui_port] = 1;
                                                        IP_IP_PORT(port_id).config.next_puppet = 0;
                                                }
                                                ip_config_success = 1;
                                        }
                        }
                }
#ifdef PRIVATE_VLAN
                          //TR000405278
                          if ((is_physical_port(port_id)) && (tag_type == UNTAGGED))
                          {
                                          vlan_id = gi_get_port_vlan_id(port_id);
                                          if (is_pvlan_enabled(vlan_id))
                                          {
                                                          uprintf("Error - Cannot configure IP address on a private vlan port\n");
                                                          return;
                                          }
                          }
#endif /*PRIVATE_VLAN*/

	if((ip_config_success) && (sptr_cdb->mode != CONFIG_SUBIF))
                        igmp_snoop_retrigger_querier_election(sptr_cdb->if_num, TRUE);


#ifndef FASTIRON
        // FI's RTM4 design does not need this message to be synced to RTM.
        // Checked with Mcast design, and these messages are handled through
        // ip_port_db_notify_address_change
                //Bug 78635
                {
                        IP_PORT_ERROR error;
                        error = ip_port_send_addr_msg(port_id, sptr_cdb->ip1, sptr_cdb->ip2,
                                sptr_cdb->secondary, sptr_cdb->no,  ip_address_entry_ospf_type);

                        uprintf("In set_if_ip , we do ip_port_send_addr_msg - return %u\n",error);
                }
#endif  FASTIRON
        }
}




void set_if_ip_ospf_passive(struct cdb* sptr_cdb)
{
        ip_address_entry_ospf_type = IP_ADDRESS_ENTRY_OSPF_PASSIVE;

        /* if replace option given with ospf-passive then 
         * interface ip will set in set_if_ip_replace
         */
        if(sptr_cdb->token && (end_of_token(sptr_cdb->token) == '\0')) {
            set_if_ip(sptr_cdb);
            ip_address_entry_ospf_type = 0;
        }
}

void set_if_ip_ospf_ignore(struct cdb* sptr_cdb)
{
        ip_address_entry_ospf_type = IP_ADDRESS_ENTRY_OSPF_IGNORE;
 
        /* if replace option given with ospf-ignore then 
         * interface ip will set in set_if_ip_replace
         */
        if(sptr_cdb->token && (end_of_token(sptr_cdb->token) == '\0')) {
            set_if_ip(sptr_cdb);
            ip_address_entry_ospf_type = 0;
        }
}

void set_if_ip_sec(struct cdb* sptr_cdb)
{
        sptr_cdb->secondary = 1;
        set_if_ip(sptr_cdb);
}

void set_if_ip_replace(struct cdb* sptr_cdb)
{
        ip_address_replace = 1;
        set_if_ip(sptr_cdb);
        ip_address_replace = 0;
        ip_address_entry_ospf_type = 0;
        ip_address_entry_dynamic = 0;
}

#ifndef __NO_ICMP_RA_CONFIG__
extern void icmp_ra_add_timer(ICMP_RA_INTERFACE *newRaP);
extern ICMP_RA_INTERFACE * icmp_ra_find_timer(UINT16 port_id);
extern void icmp_ra_delete_timer(ICMP_RA_INTERFACE *oldRaP);

void set_if_ip_irdp(struct cdb* sptr_cdb)
{
        char *cp;
        ICMP_RA_INTERFACE *raP;
        ICMP_RA_INTERFACE my_ra;
        int old_ui_port, i=0, k;
        int delete_needed = FALSE;
        UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        int hold_configured, min_configured, max_configured;

        hold_configured = min_configured = max_configured = FALSE;
        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = sptr_cdb->ui_port;

        if (sptr_cdb->config_gen)
        {
                if ((raP = (ICMP_RA_INTERFACE *)IP_IP_PORT(port_id).config.sptr_irdp) != NULL)
                {
                        if (raP->use_multicast_address)
                                ksprintf(cu_line_buf, " ip irdp multicast holdtime %d min %d max %d preference %d\n",
                                                raP->advertisement_lifetime, raP->minimum_advertisement_interval, raP->maximum_advertisement_interval, raP->router_preference);
                        else
                                ksprintf(cu_line_buf, " ip irdp broadcast holdtime %d min %d max %d preference %d\n",
                                                raP->advertisement_lifetime, raP->minimum_advertisement_interval, raP->maximum_advertisement_interval, raP->router_preference);
                        wr_config(sptr_cdb, cu_line_buf);
                }
                g_uprintf_dest = old_ui_port;
                return;
        }
        else
        {
                        raP = &my_ra;
                        if (IP_IP_PORT(port_id).config.sptr_irdp == NULL)
                        {
                                raP = memset(raP, 0, sizeof(ICMP_RA_INTERFACE));
                                raP->port_number = port_id;
                                raP->minimum_advertisement_interval = DEFAULT_ICMP_ROUTER_MINIMUM_ADVERTISEMENT_INTERVAL/SECOND;
                                raP->maximum_advertisement_interval = DEFAULT_ICMP_ROUTER_MAXIMUM_ADVERTISEMENT_INTERVAL/SECOND;
                                raP->use_multicast_address = FALSE;
                                raP->advertisement_lifetime = DEFAULT_ICMP_ROUTER_ADVERTISEMENT_LIFETIME;
                                raP->router_preference = 0;
                        }
                        else
                                *raP = *(ICMP_RA_INTERFACE *)IP_IP_PORT(port_id).config.sptr_irdp;

                        /* parse the ping command line */
                        cp = sptr_cdb->token;
                        /* skip ip address */
                        NEXT_TOKEN(cp);
                        while (*cp != '\0')
                        {
                                /* convert the 1st two characters to lower case */
                                if (isupper(*cp))
                                        *cp = tolower(*cp);
                                if (isupper(*(cp+1)))
                                        *(cp+1) = tolower(*(cp+1));

                                i = 0;
                                if ((*cp == 'm') && (*(cp+1) == 'u'))           /* multicast */
                                {
                                        raP->use_multicast_address = TRUE;
                                        NEXT_TOKEN(cp);
                                }
                                else if ((*cp == 'b') && (*(cp+1) == 'r'))              /* broadcast */
                                {
                                        raP->use_multicast_address = FALSE;
                                        NEXT_TOKEN(cp);
                                }
                                else if (*cp == 'h') /* holdtime */
                                {
                                        NEXT_TOKEN(cp);
                                        i = cli_get_int(cp,1,&k);
                                        if (i == -1)
                                                break;
                                        raP->advertisement_lifetime = i;
                                        hold_configured = TRUE;
                                        NEXT_TOKEN(cp);
                                }
                                else if (*cp == 'p') /* preference */
                                {
                                        NEXT_TOKEN(cp);
                                        if (*cp == '-')
                                        {
                                                cp++;
                                                i = cli_get_int(cp,1,&k);
                                                if (i == -1) break;
                                                if (i < 0) i= -i;       // i guarranteed to be positive
                                                raP->router_preference = -i;
                                        }
                                        else
                                        {
                                                i = cli_get_int(cp,1,&k);
                                                if (i == -1) break;
                                                if (i < 0) i= -i;
                                                raP->router_preference = i;
                                        }
                                        NEXT_TOKEN(cp);
                                }
                                else if ((*cp == 'm') && (*(cp+1) == 'i')) /* min advertinterval */
                                {
                                        NEXT_TOKEN(cp);
                                        i = cli_get_int(cp,1,&k);
                                        if (i == -1)
                                                break;
                                        raP->minimum_advertisement_interval = i;
                                        min_configured = TRUE;
                                        NEXT_TOKEN(cp);
                                }
                                else if ((*cp == 'm') && (*(cp+1) == 'a')) /* max advertinterval */
                                {
                                        NEXT_TOKEN(cp);
                                        i = cli_get_int(cp,1,&k);
                                        if (i == -1)
                                                break;
                                        raP->maximum_advertisement_interval = i;
                                        max_configured = TRUE;
                                        NEXT_TOKEN(cp);
                                }
                                else
                                {
                                        i = -1;
                                        break;
                                }
                        }

                        if (i == -1)
                        {
                                //uprintf("Error: command syntax below.\n");  //Why is error?? wrong comment!
                                uprintf("[no] ip irdp [multicast|broadcast] [holdtime <seconds>] [minadvertinterval\n"
                                                "     <seconds>] [maxadvertinterval <seconds>] [preference <number>]\n");
                                options_printed[sptr_cdb->ui_port] = 1;
                                goto irdp_exit;
                        }
        }

        if (sptr_cdb->dont_go_next || !sptr_cdb->execute)
        {
                g_uprintf_dest = old_ui_port;
                return;
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if ((raP = (ICMP_RA_INTERFACE *)IP_IP_PORT(port_id).config.sptr_irdp) != NULL)
                        {
                                icmp_ra_delete_timer(raP);
                                dy_free(raP);
                                IP_IP_PORT(port_id).config.sptr_irdp = NULL;
                        }
                }
                else
                {
                        if (max_configured)
                        {
                                if (!min_configured)
                                        raP->minimum_advertisement_interval = (raP->maximum_advertisement_interval >> 2) * 3;
                                if (!hold_configured)
                                        raP->advertisement_lifetime = raP->maximum_advertisement_interval * 3;
                        }
                        if (raP->minimum_advertisement_interval > raP->maximum_advertisement_interval)
                        {
                                uprintf("Error: Bad advertise interval values.\n");
                                goto irdp_exit;
                        }
                        if ((raP->advertisement_lifetime <= raP->maximum_advertisement_interval) ||
                                (raP->advertisement_lifetime > 9000))
                        {
                                uprintf("Error: holdtime value should be between maxadvertinterval and 9000.\n");
                                goto irdp_exit;
                        }

                        if ((raP = (ICMP_RA_INTERFACE *)IP_IP_PORT(port_id).config.sptr_irdp) == NULL)
                                raP = (ICMP_RA_INTERFACE *)dy_malloc_zero(sizeof(ICMP_RA_INTERFACE));
                        else
                                icmp_ra_delete_timer(raP);

                        IP_IP_PORT(port_id).config.sptr_irdp = (void *)raP;
                        *raP = my_ra;
                        icmp_send_router_advertisement_message(raP, 0); // do one advertise first
        #ifdef __FSRP__
                        if (fsrp.protocol_enabled)
                                icmp_send_router_advertisement_message(raP, 1);
        #endif __FSRP__

                        raP->next = raP->prev = NULL; // set the next and previous pointers to null,
                                                                                                         // so that it does not create loop when added
                                                                                                         // to the link list.
                        icmp_ra_add_timer(raP);
                }
        }
irdp_exit:
        /* This is the end of parsing */
        sptr_cdb->dont_go_next = 1;
        g_uprintf_dest = old_ui_port;
}
#endif __NO_ICMP_RA_CONFIG__

/*72423 */
/*
 * Function
 *    set_if_ip_proxy_arp_disable
 * Disable proxy arp on the ip interface,
 * the disable action would overrun the global proxy arp configuration.
 */
void set_if_ip_proxy_arp_disable(struct cdb* sptr_cdb)
{
  PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

  if (sptr_cdb->config_gen == 0)
  { /* not config gen */

    if (sptr_cdb->no == 1)
    {
      /*uprintf("set_if_ip_proxy_arp_disable: pid=%d enable\n", port_id);*/
      //uprintf("'no ip proxy-arp disable' is not a valid command\n");

      if (!is_physical_or_virtual_port(port_id))
      {
        uprintf("Error - proxy-arp can only be enabled for physical or ve interfaces\n");
        return;
      }

      if (!IS_IP_PORT_DB_VALID(port_id))
      {
        uprintf("Error - IP port database is not initialized for port %p\n", port_id);
        return;
      }

      if(IP_IP_PORT(port_id).config.intf_proxy_arp_enabled == INTF_PROXY_ARP_DISABLED)
        IP_IP_PORT(port_id).config.intf_proxy_arp_enabled = INTF_PROXY_ARP_DEFAULT;

    }
    else
    {
      if (!is_physical_or_virtual_port(port_id))
      {
        uprintf("Error - proxy-arp can only be enabled for physical or ve interfaces\n");
        return;
      }

      if (!IS_IP_PORT_DB_VALID(port_id))
      {
        uprintf("Error - IP port database is not initialized for port %p\n", port_id);
        return;
      }
      IP_IP_PORT(port_id).config.intf_proxy_arp_enabled = INTF_PROXY_ARP_DISABLED;
    }
  }
  else
  { /* config gen */
    /* get the user configured port enable state */

    if (IP_IP_PORT(port_id).config.intf_proxy_arp_enabled == INTF_PROXY_ARP_DISABLED)
    {
        wr_config(sptr_cdb, " ip proxy-arp disable\n");
    }
    return;
  }
}

/*
 * Function
 *    set_if_ip_proxy_arp_enable
 * Enable proxy arp on the ip interface,
 * the enable action would overrun the global proxy arp configuration.
 */
void set_if_ip_proxy_arp_enable(struct cdb* sptr_cdb)
{
  PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

  if (sptr_cdb->config_gen == 0)
  { /* not config gen */

    if (sptr_cdb->no == 1)
    {
      /*uprintf("set_if_ip_proxy_arp_disable: pid=%d enable\n", port_id);*/
      //uprintf("'no ip proxy-arp enable' is not a valid command\n");


      if (!is_physical_or_virtual_port(port_id))
      {
        uprintf("Error - proxy-arp can only be enabled on physical or ve interfaces\n");
        return;
      }

      if (!IS_IP_PORT_DB_VALID(port_id))
      {
        uprintf("Error - IP port database is not initialized on port %p\n", port_id);
        return;
      }

      if (IP_IP_PORT(port_id).config.intf_proxy_arp_enabled == INTF_PROXY_ARP_ENABLED)
        IP_IP_PORT(port_id).config.intf_proxy_arp_enabled = INTF_PROXY_ARP_DEFAULT;

    }
    else
    {
      if (!is_physical_or_virtual_port(port_id))
      {
        uprintf("Error - proxy-arp can only be enabled on physical or ve interfaces\n");
        return;
      }

      if (!IS_IP_PORT_DB_VALID(port_id))
      {
        uprintf("Error - IP port database is not initialized on port %p\n", port_id);
        return;
      }


      IP_IP_PORT(port_id).config.intf_proxy_arp_enabled = INTF_PROXY_ARP_ENABLED;
    }
  }
  else
  { /* config gen */
    /* get the user configured port enable state */

    if (IP_IP_PORT(port_id).config.intf_proxy_arp_enabled == INTF_PROXY_ARP_ENABLED)
    {
        wr_config(sptr_cdb, " ip proxy-arp enable\n");
    }
    return;
  }
}

/*
 * Function
 *    set_if_ip_proxy_arp_default
 * Set proxy arp on the ip interface to default value, the proxy arp behavior for the ARP packets received on this interface
 * would follow global proxy arp configuration.
 *
 */
void set_if_ip_proxy_arp_default(struct cdb* sptr_cdb)
{
  PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

  if (sptr_cdb->config_gen == 0)
  { /* not config gen */

    if (sptr_cdb->no == 1)
    {
      /*uprintf("set_if_ip_proxy_arp_disable: pid=%d enable\n", port_id);*/
      uprintf("'no ip proxy-arp default' is not a valid CLI operation\n");
    }
    else
    {
      if (!is_physical_or_virtual_port(port_id))
      {
        uprintf("Error - proxy-arp can only be enabled on physical or ve interfaces\n");
        return;
      }

      if (!IS_IP_PORT_DB_VALID(port_id))
      {
        uprintf("Error - IP port database is not initialized on port %p\n", port_id);
        return;
      }
      IP_IP_PORT(port_id).config.intf_proxy_arp_enabled = INTF_PROXY_ARP_DEFAULT;
    }
  }
}

void set_if_ip_local_proxy_arp(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                if (IP_IP_PORT(port_id).config.local_proxy_arp_enabled)
                {
                        wr_config(sptr_cdb, " ip local-proxy-arp\n");
                }
                return;
        }
        else
        {
                if (!is_physical_or_virtual_port(port_id))
                {
                        uprintf("Error - local-proxy-arp can only be enabled on physical or ve interfaces\n");
                        return;
                }

                if (!IS_IP_PORT_DB_VALID(port_id))
                {
                        uprintf("Error - IP port database is not initialized for port %p\n", port_id);
                        return;
                }

                if (sptr_cdb->no)
                {
                        IP_IP_PORT(port_id).config.local_proxy_arp_enabled = 0;
                }
                else
                {
                        IP_IP_PORT(port_id).config.local_proxy_arp_enabled = 1;
                }
        }
}

void set_if_ip_dbcast(struct cdb* sptr_cdb)
{
        UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                /* if version is newer then 06.0.00, the default directed broadcast
                 * enable value is FALSE; older than 06.0.00, default is TRUE
                 */
                if (IP_IP_PORT(port_id).config.directed_bcast_fwd_enabled)
                {
                                wr_config(sptr_cdb, " ip directed-broadcast\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                        IP_IP_PORT(port_id).config.directed_bcast_fwd_enabled = FALSE;
                else
                        IP_IP_PORT(port_id).config.directed_bcast_fwd_enabled = TRUE;
        }
}

void set_if_ip_redirect(struct cdb* sptr_cdb)
{
        UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                if(hal_is_icmp_redirect_on_vlan_only())
                {
                    if (is_virtual_port(port_id))
                    {
                        if (!IP_IP_PORT(port_id).config.icmp_redirect_enabled)
                        {
                            wr_config(sptr_cdb, " no ip redirect\n");
                        }
                    }
                }
                else 
                {
                    if (!IP_IP_PORT(port_id).config.icmp_redirect_enabled)
                    {
                        wr_config(sptr_cdb, " no ip redirect\n");
                    }
                }
        }
        else
        {
            if(hal_is_icmp_redirect_on_vlan_only())
            {
                    if(!is_virtual_port(port_id))
                    {
                            uprintf("ERROR - icmp redirect can only be enabled on a VE\n");
                            return;
                    }
            }
            ip_set_interface_redirect(port_id, (sptr_cdb->no == FALSE));
        }
}

void check_no_if_ip_arpAge(struct cdb* sptr_cdb)
{
        UINT32 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
        {
                IP_IP_PORT(port_id).config.cache_timeout = DEFAULT_ARP_CACHE_TIMEOUT;
                sptr_cdb->dont_go_next = 1;
        }
}

void set_if_ip_arpAge(struct cdb* sptr_cdb)
{
        UINT32 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {

                if (IP_IP_PORT(port_id).config.cache_timeout == DEFAULT_ARP_CACHE_TIMEOUT)
                        return;
                else
                {
                        ksprintf(cu_line_buf, " ip arp-age %d\n", IP_IP_PORT(port_id).config.cache_timeout);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no) {
                        IP_IP_PORT(port_id).config.cache_timeout = DEFAULT_ARP_CACHE_TIMEOUT;
                } else {

                        if (! valid_integer1_value_range(sptr_cdb, 0, 240))
                                return;

                        IP_IP_PORT(port_id).config.cache_timeout = sptr_cdb->integer1;
                }
        }
}

void set_mif_ip_dbcast (struct cdb* sptr_cdb)
{
    set_mif(sptr_cdb, TRUE, (void *)set_if_ip_dbcast);
}

void check_no_mif_ip_arpAge(struct cdb* sptr_cdb)
{
    set_mif(sptr_cdb, TRUE, (void *)check_no_if_ip_arpAge);
}

void set_mif_ip_arpAge(struct cdb* sptr_cdb)
{
    set_mif(sptr_cdb, TRUE, (void *)set_if_ip_arpAge);
}

void set_if_ip_follow(struct cdb* sptr_cdb)
{
        UINT16 port_id = INTERFACE_TO_PORT_ID (sptr_cdb->if_num);
        UINT16 primary_port;

        if (sptr_cdb->config_gen)
        {
                if (IP_IP_PORT(port_id).config.is_puppet &&
                    IP_IP_PORT(port_id).config.primary_port != port_id)
                {
                        ksprintf(cu_line_buf, " ip follow ve %d\n", internal_ve_lookup(ROUTER_INT_TO_VID(IP_IP_PORT(port_id).config.primary_port)) + 1);
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (!valid_integer1_value_range(sptr_cdb, 1, EXTERNAL_VE_MAX))
                return;

        if (IP_IP_PORT(port_id).vport_type != VPORT_VLAN)
        {
                uprintf("Error - This CLI operation is only supported on a VE configured on a port-based VLAN\n");
                return;
        }

        if (sptr_cdb->no)
        {
                if (IP_IP_PORT(port_id).config.primary_port == port_id)
                {
                        // uprintf("Error - Virtual Interface is not an IP Follow interface\n");
                        return;
                }
                else if (IP_IP_PORT(port_id).config.is_puppet)
                {
                        ip_remove_follower_from_primary_port(IP_IP_PORT(port_id).config.primary_port, port_id);
                }
        }
        else
        {
                /* Only check base port when not in vlan group case */
                if (!set_group_ve_follow[sptr_cdb->ui_port])
                {
                        /* Check if member of Group VE. If not base, do nothing more */
                        if (is_virtual_port (port_id))
                        {
                                int vlan_group_id;
                                if (is_ve_a_member_of_ve_group(ROUTER_INT_TO_VID(port_id), &vlan_group_id))
                                {
                                        uprintf("Error - Cannot configure IP Follow on a group-VE interface\n");
                                        return ;
                                }
                        }
                }

                if (IP_ADDR_COUNT (port_id) != 0)
                {
                        uprintf("Error - Please remove ip addresses on this interface first\n");
                        return;
                }

                primary_port = external_ve_lookup (sptr_cdb->integer1 - 1);
                if (is_internal_ve_valid (primary_port) == FALSE)
        {
                        uprintf ("Error - VE %d is invalid\n", sptr_cdb->integer1);
                        return;
                }
                primary_port = VID_TO_ROUTER_INT (primary_port);

                if (primary_port == port_id)
                {
                        uprintf ("Error - cannot follow yourself\n");
                        return;
                }

                if (IP_IP_PORT (primary_port).vport_type != VPORT_VLAN)
                {
                        uprintf ("Error - VE %d does not exist or is not configured on a port-based VLAN\n",
                                 sptr_cdb->integer1);
                        return;
                }

                if (IP_IP_PORT (primary_port).config.is_puppet &&
                        IP_IP_PORT (primary_port).config.primary_port != primary_port)
                {
                        uprintf("Error - cannot follow a follower interface\n");
                        return;
                }

                if (IP_IP_PORT (port_id).config.primary_port != port_id)
                {
                        if (!g_vlan_group_cmd)
                        {
                        uprintf ("Error - already following VE %d\n",
                                 internal_ve_lookup (ROUTER_INT_TO_VID (IP_IP_PORT (port_id).config.primary_port)) + 1);
                        return;
                        }
                }

                ip_add_follower_to_primary_port (primary_port, port_id);
        }
        return;
}

#endif /* SR_SWITCH_ROUTER */

void set_if_string(struct cdb* sptr_cdb)
{
        int i, j;
        int num_of_slash=0;
        char *if_string; // 75991

        if (sptr_cdb->config_gen) {
                sptr_cdb->dont_go_next = 1; /* don't go further */
                return;
        }

        /* seperate 1st digit from keywords, e2t -> e 2 t, 2e2 -> 2 e2 */
        i = j = 0;
        /* re-process the token after
           digit(s) separation from keyword*/
        sptr_cdb->dont_move_token = 1;
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                int len; // 75991
                len = strlen(sptr_cdb->token);
                len += 8; // It looks like that it requires 2 more spaces. We add 8
                if_string = (char *)dy_malloc(len);
                if(!if_string)
                {
                        uprintf("Cannot allocate %u bytes for parsing interface string\n", len);
                        sptr_cdb->dont_go_next = 1; /* don't go further */
                        return;
                }

                if (!isdigit(sptr_cdb->token[0])) { /* start from non-digit */
                        while (!isdigit(sptr_cdb->token[i])) {
                                if (sptr_cdb->token[i] == '\0')
                                {
                                        dy_free(if_string);
                                        return; /* no digit, just return */
                                }
                                if (isupper((int)sptr_cdb->token[i])) {
                                        if_string[i+j] = (unsigned char)tolower((int)sptr_cdb->token[i]);
                                        i++;
                                }
                                else {
                                        if_string[i+j] = sptr_cdb->token[i++];// Ignore this in coverity defect 22419
                                                                }
                        }

                        /* got 1st digit */
                        if_string[i+j] = ' '; /* insert space, increment pointer */
                        j++;
                }
                /* sptr_cdb->token[i] is digit now */
                /* when e1/2/3 or e1/2/3:3 should get expanded and parsed properly as "e 1/2/3" or "e 1/2/3:3" */
                                #ifdef SIDEWINDER_BREAKOUT
                                while (isdigit(sptr_cdb->token[i]) || (sptr_cdb->token[i] == '/') || (sptr_cdb->token[i] == ':'))
                                #else
                while (isdigit(sptr_cdb->token[i]) || sptr_cdb->token[i] == '/')
                                #endif
                {
                    if(sptr_cdb->token[i] == '/')
                        num_of_slash++;
                    if_string[i+j] = sptr_cdb->token[i++];// Ignore this in coverity defect 22419
                }

                /* TR000367706 : Check if the token has any other string after the digits or "g" (10g-full)
                 *  and copy the full string*/

                /* end of digit */
                if (sptr_cdb->token[i] != '\0') {
                        if(!(((sptr_cdb->token[i] == '-') || (tolower(sptr_cdb->token[i]) == 'g')) && (num_of_slash==0)))
                        {
                                if (sptr_cdb->token[i] != ' ') {
                                        if_string[i+j] = ' '; /* insert space, increment pointer */
                                        j++;
                                }
                        }
                        else
                        {
                                if (end_of_token(sptr_cdb->token) == '\0')
                                        sptr_cdb->dont_go_next=1;
                        }

                        while (sptr_cdb->token[i] != '\0')  /* copy the rest */
                                if_string[i+j] = sptr_cdb->token[i++];// Ignore this in coverity defect 22419

                }

                if_string[i+j] = '\0';

                /* copy back to cdb including space,
                will back to original node and continue parsing */
                for (i = 0; if_string[i] != '\0'; i++)
                                sptr_cdb->token[i] = if_string[i];
                sptr_cdb->token[i] = '\0';
                sptr_cdb->num_of_string--;
                sptr_cdb->expand_if_string = TRUE; // TR000453032
                dy_free(if_string);
        }

}

#ifdef SR_SWITCH_ROUTER
void config_gen_source_interface(struct cdb* sptr_cdb)
{
        PORT_ID source_interface;

        if ((source_interface = cu_telnet_get_source_interface()) != 0xFFFF)
        {
                wr_config(sptr_cdb, "ip telnet source-interface ");
                if (is_virtual_port(source_interface))
                       ksprintf(cu_line_buf, "ve %d\n", internal_ve_lookup(ROUTER_INT_TO_VID(source_interface)) + 1);
                else if (is_loopback_port(source_interface))
                        ksprintf(cu_line_buf, "loopback %d\n", ROUTER_INT_TO_LBID(source_interface)+1);
                else if ((mport_id_get()!= BAD_PORT_ID) && (mport_id_get()== source_interface))
                        ksprintf(cu_line_buf, "management 1\n");
                else
                        ksprintf(cu_line_buf, "%s %L\n",get_port_type_str(source_interface), get_port_num(source_interface));
                wr_config(sptr_cdb, cu_line_buf);
        }

        if ((source_interface = cu_tacacs_get_source_interface()) != 0xFFFF)
        {
                wr_config(sptr_cdb, "ip tacacs source-interface ");
                if (is_virtual_port(source_interface))
                        ksprintf(cu_line_buf, "ve %d\n", internal_ve_lookup(ROUTER_INT_TO_VID(source_interface)) + 1);
                else if (is_loopback_port(source_interface))
                        ksprintf(cu_line_buf, "loopback %d\n", ROUTER_INT_TO_LBID(source_interface)+1);
                else if ((mport_id_get()!= BAD_PORT_ID) && (mport_id_get()== source_interface))
                        ksprintf(cu_line_buf, "management 1\n");
                else
                        ksprintf(cu_line_buf, "%s %L\n",get_port_type_str(source_interface), get_port_num(source_interface));
                wr_config(sptr_cdb, cu_line_buf);
        }

        if ((source_interface = cu_radius_get_source_interface()) != 0xFFFF)
        {
                wr_config(sptr_cdb, "ip radius source-interface ");
                if (is_virtual_port(source_interface))
                        ksprintf(cu_line_buf, "ve %d\n", internal_ve_lookup(ROUTER_INT_TO_VID(source_interface)) + 1);
                else if (is_loopback_port(source_interface))
                        ksprintf(cu_line_buf, "loopback %d\n", ROUTER_INT_TO_LBID(source_interface)+1);
                else if ((mport_id_get()!= BAD_PORT_ID) && (mport_id_get()== source_interface))
                        ksprintf(cu_line_buf, "management 1\n");
                else if(IS_LAG_VIRTUAL_PORT(source_interface))
                        ksprintf(cu_line_buf, "%s %L\n",get_port_type_str(source_interface), get_port_num(source_interface));
				else
                        ksprintf(cu_line_buf, "%s %L\n",get_port_type_str(source_interface), get_port_num(source_interface));					
                wr_config(sptr_cdb, cu_line_buf);
        }

        if ((source_interface = cu_tftp_get_source_interface()) != 0xFFFF)
        {
                wr_config(sptr_cdb, "ip tftp source-interface ");
                if (is_virtual_port(source_interface))
                        ksprintf(cu_line_buf, "ve %d\n", internal_ve_lookup(ROUTER_INT_TO_VID(source_interface)) + 1);
                else if (is_loopback_port(source_interface))
                        ksprintf(cu_line_buf, "loopback %d\n", ROUTER_INT_TO_LBID(source_interface)+1);
                else if ((mport_id_get()!= BAD_PORT_ID) && (mport_id_get()== source_interface))
                        ksprintf(cu_line_buf, "management 1\n");
                else
                        ksprintf(cu_line_buf, "%s %L\n",get_port_type_str(source_interface), get_port_num(source_interface));
                wr_config(sptr_cdb, cu_line_buf);
        }

        /* SNTP is not supported */
        #if 0
        if ((source_interface = cu_sntp_get_source_interface()) != 0xFFFF)
        {
                wr_config(sptr_cdb, "ip sntp source-interface ");
                if (is_virtual_port(source_interface))
                        ksprintf(cu_line_buf, "ve %d\n", ROUTER_INT_TO_VID(source_interface)+1);
                else if (is_loopback_port(source_interface))
                        ksprintf(cu_line_buf, "loopback %d\n", ROUTER_INT_TO_LBID(source_interface)+1);
                else
                        ksprintf(cu_line_buf, "ethernet %p\n", source_interface);
                wr_config(sptr_cdb, cu_line_buf);
        }
        #endif

        if ((source_interface = cu_logging_get_source_interface()) != PORT_INDEX_INVALID)
        {
                wr_config(sptr_cdb, "ip syslog source-interface ");
                if (is_virtual_port(source_interface))
                        ksprintf(cu_line_buf, "ve %d\n", internal_ve_lookup(ROUTER_INT_TO_VID(source_interface)) + 1);
                else if (is_loopback_port(source_interface))
                        ksprintf(cu_line_buf, "loopback %d\n", ROUTER_INT_TO_LBID(source_interface)+1);
                else if ((mport_id_get()!= BAD_PORT_ID) && (mport_id_get()== source_interface))
                        ksprintf(cu_line_buf, "management 1\n");
                else
                        ksprintf(cu_line_buf, "%s %L\n",get_port_type_str(source_interface), get_port_num(source_interface));
					wr_config(sptr_cdb, cu_line_buf);
        }

}

void set_source_inteface(struct cdb* sptr_cdb)
{

                UINT16 port_id = 0;
        VRF_INDEX mvrf_idx = get_mvrf_id();
        BOOLEAN ipV4orV6address_configured = FALSE;

        if (sptr_cdb->flag1 == 0)                       /* physical port */
                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        else if (sptr_cdb->flag1 == 1)          /* loopback port */
                port_id = LBID_TO_ROUTER_INT(sptr_cdb->integer2-1);
         else if (sptr_cdb->flag1 == 2)
                {
                                /* virtual port */
                                VE_MAP_INDEX_TYPE internal_ve;

                                internal_ve = external_ve_lookup(sptr_cdb->integer2 - 1);
                                if ((is_internal_ve_valid (internal_ve) == FALSE) && (!sptr_cdb->no))
                        {
                                        uprintf("Error - non-existent virtual interface %d\n", sptr_cdb->integer2);
                                        return;
                                }
                                port_id = VID_TO_ROUTER_INT(internal_ve);
            }
        else if (sptr_cdb->flag1 == 6)  /* srepalle: for managment interface, bug 278311 */
            {
                if(sptr_cdb->integer2 != 1)
                {
                        uprintf("Error - non-existent management interface %d\n", sptr_cdb->integer2);
                        return;
                }
                port_id = mport_id_get();
                if ( BAD_PORT_ID == port_id )
                        return;
            }

        if((!sptr_cdb->no) && (IPVRF_DEFAULT_VRF_IDX != mvrf_idx) && (sptr_cdb->integer1 != 4))
        {
                if(CU_ERROR == vrf_cu_check_portid_in_vrf(mvrf_idx, &port_id))
                {
                        uprintf("Warning - Given source-interface is not part of the management-vrf.\n");
                }
        }
        if((ip_get_port_ip_address(port_id) != 0) ||
                (ip6_get_first_configured_address_on_interface(port_id) != NULL))
        {
                ipV4orV6address_configured = TRUE;
        }
        if (sptr_cdb->integer1 == 0)
        {
                if (sptr_cdb->no)
                        cu_telnet_set_source_interface(0xFFFF);
                else if (ipV4orV6address_configured)
                        cu_telnet_set_source_interface(port_id);
                else
                        uprintf("Error - no IPv4/IPv6 address configured on interface\n");
        }
        else if (sptr_cdb->integer1 == 1)
        {
                if (sptr_cdb->no)
                {
                        cu_tacacs_set_source_interface(0xFFFF);
                        cu_tacplus_set_source_interface(0xFFFF);
                }
                else if (ipV4orV6address_configured)
                {
                        cu_tacacs_set_source_interface(port_id);
                        cu_tacplus_set_source_interface(port_id);
                }
                else
                        uprintf("Error - no IPv4/IPv6 address configured on interface\n");
        }
        else if (sptr_cdb->integer1 == 2)
        {
                if (sptr_cdb->no)
                        cu_radius_set_source_interface(0xFFFF);
                else if (ipV4orV6address_configured)
                        cu_radius_set_source_interface(port_id);
                else
                        uprintf("Error - no IPv4/IPv6 address configured on interface\n");
        }
        else if (sptr_cdb->integer1 == 3)
        {
                if (sptr_cdb->no)
                        cu_tftp_set_source_interface(0xFFFF);
                else if (ipV4orV6address_configured)
                        cu_tftp_set_source_interface(port_id);
                else
                        uprintf("Error - no IPv4/IPv6 address configured on interface\n");
        }
        else if (sptr_cdb->integer1 == 4)
        {
                /* SNTP is not supported */
                #if 0
                if (sptr_cdb->no)
                        cu_sntp_set_source_interface(0xFFFF);
                else if (ipV4orV6address_configured)
                        cu_sntp_set_source_interface(port_id);
                else
                        uprintf("Error - no IPv4/IPv6 address configured on interface\n");
                #endif
        }
        else if (sptr_cdb->integer1 == 5)
        {
                if (sptr_cdb->no)
                        cu_logging_set_source_interface(PORT_INDEX_INVALID);
                else if (ipV4orV6address_configured)
                        cu_logging_set_source_interface(port_id);
                else
                        uprintf("Error - no IPv4/IPv6 address configured on interface\n");
        }

}

void set_source_interface_telnet(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = 0;
        sptr_cdb->num_of_integer++;
}

void set_source_interface_tacacs(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = 1;
        sptr_cdb->num_of_integer++;
}

void set_source_interface_radius(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = 2;
        sptr_cdb->num_of_integer++;
}

void set_source_interface_tftp(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = 3;
        sptr_cdb->num_of_integer++;
}

void set_source_interface_sntp(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = 4;
        sptr_cdb->num_of_integer++;
}

void set_source_interface_syslog(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = 5;
        sptr_cdb->num_of_integer++;
}
#endif SR_SWITCH_ROUTER

void set_interface_physical(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 0;
}
void set_interface_loopback(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 1;
}
void set_interface_ve(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 2;
}
void set_interface_enet(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 3;
}
void set_interface_pos(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 4;
}
void set_interface_atm(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 5;
}
void set_interface_mgmt(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 6;
}
void set_interface_lag(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 7;
}
#ifdef SR_SWITCH_ONLY
void check_no_global_ip(struct cdb* sptr_cdb)
{
        UINT32 ip_address, subnet_mask;
        unsigned char token;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                /*
                 * Notice that the BOOT code also searches for this
                 * "ip address" keyword from the configuration flash.
                 * Therefore, don't change this syntax.
                 */
                ip_address = cu_get_ip_addr();
                subnet_mask = cu_get_net_mask();
                if (ip_address == 0)
                        return;

                /*bug id - 100701*/
                if (ip.show_subnet_mask_bits)
                        ksprintf(cu_line_buf, "ip address %I/%d", ip_address, cu_get_number_of_subnet_mask_bits(subnet_mask));
                else
                        ksprintf(cu_line_buf, "ip address %I %I", ip_address, subnet_mask);
                wr_config(sptr_cdb, cu_line_buf);

                if (ip.ip_address_dynamic == TRUE)
                {
					wr_config (sptr_cdb, " dynamic");
                }

                wr_config(sptr_cdb, "\n");
                return;
        }

#ifdef REMOVE_SOON
        // This code does not seem to be necessary. - mlavine 9/11/01
        if (sptr_cdb->subnet1 != 0)
        {
                /* handle '?' in here because parser can't change
                 * keyword option display dynamically at runtime
                 */
                token = end_of_token(sptr_cdb->token);
                if (token == '?')
                {
                        sptr_cdb->dont_go_next = 1;
                        uprintf("  <cr>\n");
                        options_printed[sptr_cdb->ui_port] = 1;
                        return;
                }
        }
#endif REMOVE_SOON

        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;

                ip_address = cu_get_ip_addr();

                if(sptr_cdb->ip1 != ip_address)
                {
                    sptr_cdb->dont_go_next = 1;
                    uprintf("Error: IP Address not found!\n");
                    return;
                }

                cu_set_ip_addr(0,sptr_cdb->ui_port);
                cu_set_net_mask(0);

#ifdef __MPORT_SUPPORT__
#ifndef __MPORT_IP_ON_SWITCH__
                cu_set_mport_ip_address(0);
                cu_set_mport_ip_subnet_mask(0);
#endif // __MPORT_IP_ON_SWITCH__
#endif // __MPORT_SUPPORT__

                /*bug id -- 100701*/
        ip.ip_address_dynamic = FALSE;
                sptr_cdb->dont_go_next = 1;
        }
        else
        {
                if (sptr_cdb->subnet1 != 0)
                {
                        sptr_cdb->ip2 = sptr_cdb->subnet1;
                        set_global_ip(sptr_cdb);
                }
        }
}

void set_global_ip(struct cdb* sptr_cdb)
{
        int i;
        UINT32 ip_address, subnet_mask;
        UINT32 old_ip_address;
        enum BOOLEAN found_one = FALSE;
        enum BOOLEAN disable_dhcp_client = FALSE;


        if (sptr_cdb->config_gen == 0)
        {
                if (end_of_token(sptr_cdb->token) == '\0')
                {
                        sptr_cdb->dont_go_next = 1;

                        /* BUG: 29185 */
                        g_vlan_group_cmd = 0;

                        /*
                         * Notice that the BOOT code also searches for this
                         * "ip address" keyword from the configuration flash.
                         * Therefore, don't change this syntax.
                         */
                        ip_address = sptr_cdb->ip1;
                        subnet_mask = sptr_cdb->ip2;
                        if (subnet_mask == 0xFFFFFFFF || subnet_mask == 0x00000000)
                        {
                                uprintf("Error - subnet mask cannot be 255.255.255.255 or 0.0.0.0\n");
                                return;
                        }
                        for (i=0; i<32; i++)
                        {
                                if ((subnet_mask >> i) & 0x00000001)
                                {
                                        if (!found_one)
                                                found_one = TRUE;
                                }
                                else
                                {
                                        if (found_one)
                                        {
                                                uprintf("Error - non-contiguous subnet mask!\n");
                                                return;
                                        }
                                }
                        }
                        if ((ip_address & subnet_mask) == ip_address ||
                            (ip_address & (~subnet_mask)) == (~subnet_mask))
                        {
                                uprintf("Error - cannot assign broadcast address!\n");
                                return;
                        }

						old_ip_address = ip.ip_address;
						if(sptr_cdb->mode == CONFIG_MGMT_IF)
							uprintf("The configured IP address will be set as the global IP address.\n");
						cu_set_ip_addr(ip_address,sptr_cdb->ui_port);
						cu_set_net_mask(subnet_mask);
#ifdef __MPORT_SUPPORT__
#ifndef __MPORT_IP_ON_SWITCH__
                        cu_set_mport_ip_address(ip_address);
                        cu_set_mport_ip_subnet_mask(subnet_mask);
#endif // __MPORT_IP_ON_SWITCH__
#endif // __MPORT_SUPPORT__
                        sw_l4_rebind_all_ACL_with_log_option(old_ip_address,0xFFFFFFFF);

                        //Bug 78635
                        igmp_snoop_retrigger_querier_election(0, TRUE);

                        #ifdef __DHCP_CLIENT__
                        if (ip_address_entry_dynamic == 1)
                                {
                                ip.ip_address_dynamic = TRUE;
                                }
                        else
                                {
                                ip.ip_address_dynamic = FALSE;
                                }
                        #endif
                }
        }
}
#endif SR_SWITCH_ONLY


/* 96594 - Function to validate the MAC ADDRESS entered by user */
int validate_mac_address (MAC_ADDRESS* mac_addr)
{
    int rc = 0;

    SAME_MAC_ADDRESS(&static_station.mac_addr, mac_addr);
    if (IS_BROADCAST_MAC(mac_addr))
    {
        rc = 1;
        uprintf("Error - cannot assign broadcast MAC address!\n");
        return rc;
    }
    if (IS_ZERO_MAC(mac_addr))
    {
        rc = 1;
        uprintf("Error - cannot assign all zero MAC address!\n");
        return rc;
    }
    if (IS_BRIDGE_GROUP_MAC(mac_addr))
    {
        rc = 1;
    }
#ifdef __GARP_SUPPORT__
    else if (IS_GARP_MAC_ADDRESS(mac_addr))
    {
        rc = 1;
    }
#endif __GARP_SUPPORT__

#ifndef NO_VSRRP
    else if (IS_VSRP_VIRTUAL_MAC(mac_addr))
    {
        rc = 1;
    }
#endif NO_VSRRP
    else if (IS_VRRP_VIRTUAL_MAC(mac_addr))
    {
        rc = 1;
    }
#ifdef M_RING
    else if (IS_MRP_CONTROL_MAC(mac_addr))
    {
        rc = 1;
    }
#endif M_RING

#ifndef __NO_PVST__
    else if (SAME_MAC_ADDRESS(mac_addr, &pvst_bridge_group_address))
    {
        rc = 1;
    }
#endif __NO_PVST__

#ifdef SINGLE_SPAN
#ifndef NO_SUPER_STP
    else if (IS_CSTP_MAC_ADDRESS(mac_addr))
    {
        rc = 1;
    }
#endif NO_SUPER_STP
#endif SINGLE_SPAN

#ifdef __FDP__
    else if ( SAME_MAC_ADDRESS(mac_addr, &fdp_group_address) )
    {
        rc = 1;
    }
    else if ( SAME_MAC_ADDRESS(mac_addr, &cdp_group_address) )
    {
        rc = 1;
    }
#endif __FDP__

#ifndef NO_LINK_KEEPALIVE
    else if (SAME_MAC_ADDRESS(mac_addr, &foundry_resv_address))
    {
        rc = 1;
    }
#endif NO_LINK_KEEPALIVE
    if (rc)
    {
        uprintf("Error - cannot assign control MAC address!\n");
    }
    return rc;
}

void cli_static_mac_address_check (struct cdb* sptr_cdb)
{
    MAC_ADDRESS *mac_addr;

    mac_addr = (MAC_ADDRESS *)sptr_cdb->mac1;

    if (validate_mac_address (mac_addr))
    {
        sptr_cdb->dont_go_next = 1;
    }
}

//CHEETAH_STACKING
int cu_stack_mac_address_check (MAC_ADDRESS* mac_addr)
{
    int rc = 0;

    /* CHEETAH_STACKING : 89533 , 88341 - filter out multicast MAC addresses */
    if (MULTICAST_MAC == pp_get_mac_da_type((UINT8  *)mac_addr))
    {
        rc = 1;
        uprintf("Error - cannot assign multicast MAC address!\n");
        return rc;
    }

    if (rc = validate_mac_address (mac_addr))
    {
        return rc;
    }
    return rc;
}


static void print_mac_fbase_error_messages(int err_code, CU_MAC_STATION *sptr_static_station)
{
        switch (err_code)
        {
        case CU_OK:
        break;
        case CU_DUPLICATE_ENTRY:
                        if (sptr_static_station->mmac_idx != 0)
        uprintf("Error - please remove duplicate unicast MAC first\n");
        else
        uprintf("Error - duplicate MAC address found.\n");
        break;

                case CU_TABLE_FULL:
                        if (sptr_static_station->mmac_idx != 0)
        uprintf("Error - Static MMAC address table is full.\n");
        else
        uprintf("Error - Static MAC address table is full.\n");
        break;

        case CU_PORT_HAS_NO_VLAN:
                        if (sptr_static_station->mmac_idx != 0)
        uprintf("Error - not all ports specified belong to port-vlan %d.\n",
                        sptr_static_station->vlan_id);
        else
        uprintf("Error - port %p does not belong to port-vlan %d.\n",
                                sptr_static_station->port, sptr_static_station->vlan_id);
                        break;

        case CU_NO_VLAN_ENTRY:
        uprintf("Error - port-vlan %d does not exist.\n",
                        sptr_static_station->vlan_id);
        break;
#ifdef SR_SWITCH_ROUTER
        case CU_INVALID_INDEX:
        uprintf("Error - conflicting port defined in static arp table.\n");
        break;
#endif SR_SWITCH_ROUTER
        default:
        uprintf("Error - cannot add static MAC station.\n");
        break;
        }
}

/*
 * Function
 *   add_mac_fbase_entry
 * Description
 *   Before we enter here, every field of the global variable, static_station, should already be filled. 
 *   The only new info is sptr_cdb->port_mask1 for MMAC,
 *
 *
 */
void add_mac_fbase_entry(struct cdb* sptr_cdb)
{
    int        rcode;
    int        j;
    PORT_ID    port_id;
    char       *port_mask_str1 = g_port_mask_str;
    UINT8      mmac_idx;
    UINT8      is_mmac_flag=0; // is multi-destination mac entry;
    UINT8      is_mcast_mac=0;
    UINT32     count = 0;
    VLAN_ENTRY *vlan_entry;

    copy_mask(static_station.mmac_cfg_portmask, sptr_cdb->port_mask1); // Maocheng++: g_sw_sys.mmac_portmask[0] is used a temp variable to hold port mask,
    is_mmac_flag = (cu_count_ports_in_mask(static_station.mmac_cfg_portmask, &port_id) > 1);

    if (IS_MULTICAST_MAC(&static_station.mac_addr))
    {
        if (IS_BROADCAST_MAC(&static_station.mac_addr))
        {
            is_mcast_mac = 0; // Broadcast Mac Address
        }
        else
        {
            is_mcast_mac = 1; // Multicast Mac Address
        }
    }

	memset(port_mask_str1,0,sizeof(g_port_mask_str));
    if (end_of_token(sptr_cdb->token) == '\0')
    {
        sptr_cdb->dont_go_next = 1;

        cu_port_mask_to_string(port_mask_str1, sptr_cdb->port_mask1);

        if(debug_static_mac_ctrl>1)
            uprintf("add_mac_fbase_entry: mac=%m,vlan=%d,port_mask1=%s,intf1=%p vlan_group=%d\n", 
					&(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1, (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb->vlan_group_id);


        for (j=0; j < g_hw_info.total_config_ports; j++)
        {
            port_id = sw_config_port_list[j];

            if (!(is_member(static_station.mmac_cfg_portmask, port_id)))
                continue;

            if (!IS_PORT_DB_VALID(port_id))
            {
                uprintf("Error - port %p is not valid\n", port_id);
                continue;
            }

            if (is_mmac_flag && IS_PE_PORT(port_id)) 
            {
                uprintf("Error - port %p is a PE port. Static multi-MAC address cannot be configured on a PE port.\n", port_id);
                return;
            }

            // Maocheng++: make sure the input port only have primary port, for example you have trunk (1-4),
            // static-mac-address 0000.0000.1000 ethe 1 ethe 3 should have input portmask only have port 1, otherwise it turns into a MMAC,
            if (port_id!=trunk_primary_port(port_id))
            {
                //clear_mask_bit(static_station.mmac_cfg_portmask, port_id);
                uprintf("Error - port %p is a trunk secondary port, please use primary in the configuration\n", port_id);
                return;
            }

            if(IS_DOT1X_PORT_ENABLED((UINT16)port_id))
            {
                uprintf("Error - port %P is a dot1x port. Static mac address cannot be configured on a dot1x port.\n", port_id);
                return;
            }
            if(IS_MAC_BASED_VLAN_ENABLED_ON_PORT((UINT16)port_id))
            {
                uprintf("Error - port %P is a Mac Based Vlan port. Static mac address cannot be configured on a Mac Based Vlan port.\n", port_id);
                return;
            }
            if(IS_SPX_PORT((UINT16)port_id))
            {  
                uprintf("Error - port %P is a spx-port. Static mac address can't be configured on a spx-port.\n", port_id);
                return;
            }
        }// end of for loop

        if (IS_MAC_AUTH_ENABLED())
        {
            port_id = trunk_primary_port(static_station.port);

            if(IS_MAC_AUTH_ENABLED_ON_PORT(port_id))
				macAuth_free_mac_session(port_id, &static_station.mac_addr,static_station.vlan_id,TRUE,0, FLEXAUTH_LOGOFF_REASON_ADMIN_RESET);
        }

#ifdef PRIVATE_VLAN

        //Donot allow Static MACs in secondary VLANs: TR000407957
        //Donot allow Static MACs in secondary VLANs in sidewinder : TR000479794
        if ((hw_pvlan_support()==HW_PVLAN_SUPPORT_FCX)||(IS_FI_BCM() && (hw_pvlan_support() == HW_PVLAN_SUPPORT_TI)))
        {
            vlan_entry=g_sptr_vlan_db + VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id);
            if (VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id)!=VLAN_INDEX_INVALID)
            {
                if ((vlan_entry->pvlan_type==PVLAN_TYPE_COMMUNITY)||(vlan_entry->pvlan_type==PVLAN_TYPE_ISOLATED))
                {
                    uprintf("Error: static MAC address is not allowed in secondary Private VLAN\n");
                    return;
                }
                else if((vlan_entry->pvlan_type) && is_mmac_flag )
                {
                    //Do not allow static MMAC config on private vlans: TR000479799
                    uprintf("Error: static MAC address is not allowed in Private VLAN\n");
                    return;
                }
            }
        }
#endif /*PRIVATE_VLAN*/

        /*space check is needed in during system bootup*/
        if (!g_sw_sys.init_in_progress)
        {

            /* if it is a vlan-group, before attempting to add, check if we have enough space/ BUG:80711 */
            // TR000446538: this check is not required on standby as mmac is already synced
            if ((sptr_cdb->vlan_group_id) && 
                    (static_station.vlan_id == g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].vlan_group_member[0])
					&& (static_station.static_entry_exist_flag == 0))

            {
                /* if mmac entry or MCT VLAN, check available mmac indices */
                if (is_mmac_flag || is_mcast_mac || clusterlib_is_mct_vlan(g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].vlan_group_member[0]))
                {
                    for (mmac_idx=MIN_MMAC_INDEX; mmac_idx<MAX_MMAC_ENTRIES; mmac_idx++)
                    {
                        if (is_mask_clear(g_sw_sys.mmac_entry[mmac_idx].mmac_portmask))
                        {
                            count++;
                        }
                    }

					if(debug_static_mac_ctrl>1)
						uprintf("add_mac_fbase_entry: MMAC Number of VLANs for VLAN group=%d available space=%d\n",
								g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].num_vlans, count);


                    if (g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].num_vlans > count)
                    {
                        rcode = CU_TABLE_FULL;
                        static_station.mmac_idx = 1;// Maocheng++: set to 1 so print_mac_fbase_error_messages() would print MMAC full instead of just STATIC MAC FULL.
                        print_mac_fbase_error_messages(rcode, &static_station);
                        return;
                    }
                }
                else
                {
                    count = 0;
                    for (j=g_sw_sys.head_static_station_index; j != INVALID_STATIC_STATION_INDEX; j=g_sw_sys.static_station[j].next_index)
                        count++;

					if(debug_static_mac_ctrl>1)
						uprintf("add_mac_fbase_entry: Static MAC Number of VLANs for VLAN group=%d available space=%d\n",
								g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].num_vlans, MAX_STATIC_STATION - count);

                    if (g_sw_sys.sptr_vlan_group_db[sptr_cdb->vlan_group_id-1].num_vlans > MAX_STATIC_STATION - count)
                    {
                        rcode = CU_TABLE_FULL;
                        static_station.mmac_idx = 0;
                        print_mac_fbase_error_messages(rcode, &static_station);
                        return;
                    }
                }
            } //VLAN-group

            //TR000535649 - Check if the MAX static entries were full for VLAN. If so, return error.
            count = 0;
            for (j=g_sw_sys.head_static_station_index; j != INVALID_STATIC_STATION_INDEX; j=g_sw_sys.static_station[j].next_index)
                count++;

            if (count >= MAX_STATIC_STATION)
            {
                if (is_mmac_flag == 1)
                    static_station.mmac_idx = 1;
                else
                    static_station.mmac_idx = 0;

                rcode = CU_TABLE_FULL;
                print_mac_fbase_error_messages(rcode, &static_station);
                return;
                        }
        }//end of if (!g_sw_sys.init_in_progress)


        static_station.mmac_vidx = APP_VLAN_INDEX_INVALID;

        if(debug_static_mac_ctrl>1)
            uprintf("add_mac_fbase_entry: sptr_cdb(mac=%m,vlan=%d,port_mask1=%s,intf1=%p,intg1=%d), static_station(mac=%m,vlan=%d,port=%p,pri=%d,mmac_vidx=%d,mmac_idx=%d)\n",
                    &(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1, (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb->integer1,
                    &static_station.mac_addr, static_station.vlan_id, static_station.port, static_station.priority, static_station.mmac_vidx, static_station.mmac_idx);


        rcode = cu_add_static_station(&static_station);
        if (rcode == CU_OK)
        {
            /* log the adding of the entry and check for 80493  */
            send_static_mmac_add_trap(&static_station, sptr_cdb);
        }
        print_mac_fbase_error_messages(rcode, &static_station);
        if (rcode == CU_ERROR)
            sptr_cdb->rel_sync_status = 0; //_sxhitless_

        static_station.mmac_idx = 0;

    }//end of token
}

/*
 * Function
 *   del_mac_fbase_entry
 * Description
 *   "no static-mac-address" callback,
 *   Before we enter here, every field of the global variable, static_station, should already be filled. The only new info is sptr_cdb->port_mask1 for MMAC,
 *
 *
 */

void del_mac_fbase_entry(struct cdb* sptr_cdb)
{
        int rcode;
        MAC_STATION     *sptr_mac_entry;
        char            *port_mask_str1 = g_port_mask_str;
        #ifdef __DOT1X_SUPPORT__
        int j;
        PORT_ID port_id;
#endif __DOT1X_SUPPORT__

        copy_mask(static_station.mmac_cfg_portmask, sptr_cdb->port_mask1); // Maocheng++: g_sw_sys.mmac_portmask[0] is used a temp variable to hold port mask,
        //is_mmac_flag = (cu_count_ports_in_mask(static_station.mmac_cfg_portmask, &port_id) > 1);
		memset(port_mask_str1,0,sizeof(g_port_mask_str));
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;

                cu_port_mask_to_string(port_mask_str1, sptr_cdb->port_mask1);

                if(debug_static_mac_ctrl>1)
                uprintf("del_mac_fbase_entry: mac=%m,vlan=%d,port_mask1=%s,intf1=%p\n", &(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1, (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1));

#ifdef __DOT1X_SUPPORT__
         if (IS_DOT1X_ENABLED())
        {
                for (j=0; j < g_hw_info.total_config_ports; j++)
                {
                        port_id = sw_config_port_list[j];
                                if (!(is_member(static_station.mmac_cfg_portmask, port_id)||(static_station.port==port_id)))
                                continue;

                        if(IS_DOT1X_PORT_ENABLED((UINT16)port_id))
                        {
                                uprintf("Error - port %P is a dot1x port. Static mac address cannot be configured on a dot1x port.\n", port_id);
                                return;
                        }
                }
        }
#endif __DOT1X_SUPPORT__

                if ((rcode = cu_del_static_station(&static_station)) != CU_OK)
                        uprintf("Error - cannot delete static MAC station %m.\n", (unsigned char *)&static_station.mac_addr);
                else
                {
                        /* log the deletion of the entry and check for 80493  */
                        send_static_mmac_del_trap(&static_station, sptr_cdb);
                }

                static_station.mmac_idx = 0;
        }
}

int is_multicast_mac_address(MAC_ADDRESS *mac_addr)
{
        if ((mac_addr->_ulong & 0xffffff80) == 0x01005e00) //v4
                return 1;
        else if ((mac_addr->_ulong & 0xffff0000) == 0x33330000) //v6
                return 1;
        else
                return 0;
}

/*
 * Function
 *   set_mac_fbase
 * Description
 *   When use cli to set static MAC entry, this is the 1st callback api, it prepares the global variable static_station (which is hard to eliminate because
 * it might take a few stages to finally set the static MAC depends on how many ports involved, priority setting, we need a global varible to hold all information)
 *   For example, here is the callbacks when you create a static entry involves two ports and priority setting, you can see the port_mask is expanding and intg1 (priority) is being set
 * All those are done by CLI callbacks, finally we should have all info about that static mac read when we call add_mac_fbase_entry(), that info is in statc_stataion.
R3(config-vlan-10)#static-mac-address 0000.0000.1111 ethernet 1/7 ethernet 1/15 priority 3
set_mac_fbase: mac=0000.0000.1111, vlan=10, port_mask1=, intf1=1/7, intg1=0
set_mac_fbase_priority: mac=0000.0000.1111, vlan=10, port_mask1= 1/7, intf1=1/15, intg1=3
add_mac_fbase_entry: mac=0000.0000.1111, vlan=10, port_mask1= 1/7 1/15, intf1=1/15
 *
 * Maocheng++: 2011/04/27
 * Maocheng++: 2011/05/10, this API is only "ADD" ports into static MAC station, to delete, use "no static-mac-station" command -> del_mac_fbase_entry(),

vlan 20 by port
 tagged ethe 1 to 18
 vsrp vrid 20
  backup
  enable
 static-mac-address 0000.aaaa.bbbb ethe 1 to 2 ethe 4
!
R1(config-vlan-20)#static-mac-address 0000.aaaa.bbbb ethernet 6 ethernet 7
SYSLOG: <14>Jan  1 00:00:00 R1 System: Static Mac entry with Mac Address 0000:aaaa:bbbb is added to ethe 6 to 7  on VLAN 20 : No Src Port Suppression
R1(config-vlan-20)#
vlan 20 by port
 tagged ethe 1 to 18
 vsrp vrid 20
  backup
  enable
 static-mac-address 0000.aaaa.bbbb ethe 1 to 2 ethe 4 ethe 6 to 7
!
R1(config-vlan-20)#no static-mac-address 0000.aaaa.bbbb ethernet 10
Error - can't delete static MAC station 0000.aaaa.bbbb.
R1(config-vlan-20)#
R1(config-vlan-20)#no static-mac-address 0000.aaaa.bbbb ethernet 7 ethernet 8 <-- Maocheng++: p8 is not member, but command get take for p7, and p7 get deleted,

SYSLOG: <14>Jan  1 00:00:00 R1 System: Static Mac entry with Mac Address 0000:aaaa:bbbb is deleted from portnumber 7 on VLAN 20
R1(config-vlan-20)#
R1(config-vlan-20)#
vlan 20 by port
 tagged ethe 1 to 18
 vsrp vrid 20
  backup
  enable
 static-mac-address 0000.aaaa.bbbb ethe 1 to 2 ethe 4 ethe 6
!
 */

void set_mac_fbase(struct cdb* sptr_cdb)
{
        PORT_ID port_id;
    VLAN_ENTRY *vlan_entry;
        char            *port_mask_str1 = g_port_mask_str;
        MAC_ADDRESS *mac_addr;


        int             if_type;

		memset(port_mask_str1,0,sizeof(g_port_mask_str));
        if (sptr_cdb->config_gen)
        {
                /* Moved config gen code to sw_cu_vlan.c */
                sptr_cdb->dont_go_next = 1;
        }
        else
        {
                if (sptr_cdb->help)
                        return;

                mac_addr = (MAC_ADDRESS *)sptr_cdb->mac1;

                if (mac_addr->_ulong == 0 && mac_addr->_ushort == 0)
                {
                        uprintf("Error - Invalid Mac Address %m\n", mac_addr);
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                /* for TR: TR000384665 */
                if(is_multicast_mac_address(mac_addr))
                {
                        uprintf("ERROR: Mac Address cannot be IPv4/IPv6 Multicast Mac Address \n");
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                if(SAME_MAC_ADDRESS(mac_addr, &ethernet_broadcast_address)) // TR000405842 fix.
                {
                        uprintf("ERROR: Mac Address cannot be Broadcast Mac Address \n");
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                {
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

        /* Default to priority 0 and non-router MAC address. */
        memset(&static_station, 0, sizeof(CU_MAC_STATION));
        COPY_MAC(&static_station.mac_addr, sptr_cdb->mac1);
        static_station.port = PORT_INDEX_INVALID;

                static_station.vlan_id = sptr_cdb->vlan_id;
#ifdef PRIVATE_VLAN
                if (hw_pvlan_support()==HW_PVLAN_SUPPORT_TI)
                {
        vlan_entry=g_sptr_vlan_db + VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id);
                        if (VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id)!=VLAN_INDEX_INVALID)
                        {       if (((vlan_entry->pvlan_type==PVLAN_TYPE_COMMUNITY)||(vlan_entry->pvlan_type==PVLAN_TYPE_ISOLATED))&&(vlan_entry->pvlan_link!=0))
                                        static_station.vlan_id = vlan_entry->pvlan_link;
                        }
                }

#endif
                port_id = (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                static_station.port = port_id;

                cu_port_mask_to_string(port_mask_str1, sptr_cdb->port_mask1);

                if(debug_static_mac_ctrl>1)
                        uprintf("set_mac_fbase: sptr_cdb(mac=%m,vlan=%d,port_mask1=%s,intf1=%p,intg1=%d), static_station(mac=%m,vlan=%d,port=%p)\n",
                                &(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1, (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb->integer1,
                                &static_station.mac_addr, static_station.vlan_id, static_station.port);


                if (sptr_cdb->no)
                {
                        /* Ignore rest of the tokens. */
                        /* sptr_cdb->dont_go_next = 1; */
                        if_type = sptr_cdb->if_type;

                        /* This function is can be invoked by timer flow in case of multi-vlan.
                         * Hence, sptr_cdb->prev_node can be ZERO, as it would have been cleared.
                         * The interface information would be stored in sptr_cdb->port_mask1 in 
                         * set_port_list_num().
                         */
                        sptr_cdb->if_type = ((NULL != sptr_cdb->prev_node) \
                                              && (strncmp(sptr_cdb->prev_node->keyword,"lag",strlen("lag")) == 0)) \
                                              ?VLAG:ETHERNET;
                        set_port_list_num(sptr_cdb, del_mac_fbase_entry);
                        sptr_cdb->if_type = if_type;
                }
                else
                {
                    if_type = sptr_cdb->if_type;
                    sptr_cdb->if_type = ((NULL != sptr_cdb->prev_node) \
                                          && (strncmp(sptr_cdb->prev_node->keyword,"lag",strlen("lag")) == 0)) \
                                          ?VLAG:ETHERNET;
                    set_port_list_num(sptr_cdb, add_mac_fbase_entry);
                    sptr_cdb->if_type = if_type;
                }
        }
}

#ifdef INCLUDE_MCT
extern int static_station_find_entry(MAC_ADDRESS * mac_addr, UINT16 vlan_id, int *index);
#endif

/*
 * Function
 *   set_mac_fbase_priority
 * Description
 *   This is the callback for c_static_Mac_enet_pri_Num[]
 *
                {
                        KEYWORD | LAST_ENTRY | CR_ALLOWED,
                        "priority",
                        "Assign a Priority to this MAC Address",
                        c_static_Mac_enet_pri_Num,
                        NULL
                }
 * the global variable static_station should already be set by set_mac_fbase(), only the static_station.priority suppose to be changed by this API.
 * Maocheng++: 2011/04/27
 *  The vlan_id field of static_station should already be set by set_mac_fbase(), espically when pvlan is used, the re-set in this API should put a warning.
 */
void set_mac_fbase_priority(struct cdb* sptr_cdb)
{
        int     if_type,i;
        char    *port_mask_str1 = g_port_mask_str;

#ifdef INCLUDE_MCT
                UINT8 static_entry_exist_flag=0;
                UINT8 is_mct_static_mac=0;
                VLAN_INDEX      vlan_idx;
                VLAN_ENTRY      *vlan_ptr;
#endif
		
		memset(port_mask_str1,0,sizeof(g_port_mask_str));
        if (sptr_cdb->config_gen == 0)
        {
                cu_port_mask_to_string(port_mask_str1, sptr_cdb->port_mask1);

                if(debug_static_mac_ctrl> 1)
                        uprintf("set_mac_fbase_priority: sptr_cdb(mac=%m,vlan=%d,port_mask1=%s,intf1=%p,intg1=%d)\n", &(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1,
                                (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb->integer1);


                if (!valid_integer1_value_range(
                        sptr_cdb,
                        VAL_snVLanByPortCfgQos_level0,
                        VAL_snVLanByPortCfgQos_level7))
                {
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
            if (sflowEnabled)
            {
                        if (sptr_cdb->integer1 == SFLOW_TRAFFIC_CLASS)
                        {
                                /* This QOS profile is reserved for SFLOW internally */
                                uprintf("Error -  priority %d is reserved for sFLOW.\n", sptr_cdb->integer1);
                                sptr_cdb->dont_go_next = 1;
                                return;
                        }
            }
                if(static_station.vlan_id==0)
                {
                        if(debug_static_mac_ctrl>1)
                                uprintf("set_mac_fbase_priority: sptr_cdb(mac=%m,vlan=%d,port_mask1=%s,intf1=%p,intg1=%d) WARNING, current static_station's VLAN id is 0!\n",
                                        &(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1, (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb->integer1);


                }

                static_station.vlan_id = sptr_cdb->vlan_id;//Defect TR000484134
                static_station.priority = sptr_cdb->integer1;

                if(debug_static_mac_ctrl>1)
                        uprintf("set_mac_fbase_priority: sptr_cdb(mac=%m,vlan=%d,port_mask1=%s,intf1=%p,intg1=%d), static_station(mac=%m,vlan=%d,port=%p,pri=%d)\n",
                                &(sptr_cdb->mac1),sptr_cdb->vlan_id, port_mask_str1, (PORT_ID) INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb->integer1,
                                &static_station.mac_addr, static_station.vlan_id, static_station.port, static_station.priority);


                if_type = sptr_cdb->if_type;
                sptr_cdb->if_type = ETHERNET;
                if (sptr_cdb->no)
                        set_port_list_num(sptr_cdb, del_mac_fbase_entry);
                else{
#ifdef INCLUDE_MCT
                                                vlan_idx = VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id);
                                                if (vlan_idx != VLAN_INDEX_INVALID)
                                                {                               
                                                        vlan_ptr = (VLAN_ENTRY *) (g_sptr_vlan_db + vlan_idx);
                                                        if(clusterlib_is_vlan_cluster_member_vlan_or_session_vlan(vlan_ptr->vlan_config.vlan_id))
                                                        is_mct_static_mac=1;
                                                }
                                                i = INVALID_STATIC_STATION_INDEX;                       
                                                static_entry_exist_flag = static_station_find_entry((MAC_ADDRESS*)sptr_cdb->mac1, sptr_cdb->vlan_id, &i);
                                                if(static_entry_exist_flag && is_mct_static_mac)
                                                        set_port_list_num(sptr_cdb, del_mac_fbase_entry);
												static_station.static_entry_exist_flag = static_entry_exist_flag;
#endif INCLUDE_MCT
                        set_port_list_num(sptr_cdb, add_mac_fbase_entry);
						static_station.static_entry_exist_flag = 0;
                }

                sptr_cdb->if_type = if_type;
        }
}

// Maocheng++: 2011/04/27, source port group suppression is not shown but still a valid command although we are not intend to support it any furture.
void set_src_port_group_suppression_enable(struct cdb* sptr_cdb)
{
        int if_type;

        if (sptr_cdb->config_gen == 0)
        {
        static_station.mmac_trunk = 1;
        }
        static_station.vlan_id = sptr_cdb->vlan_id; // Maocheng++: This is also very strange. we should not set the static_station.vlan_id because set_mac_fbase() already did.

        if_type = sptr_cdb->if_type;
        sptr_cdb->if_type = ETHERNET;
        if (sptr_cdb->no)
                set_port_list_num(sptr_cdb, del_mac_fbase_entry);
        else
                set_port_list_num(sptr_cdb, add_mac_fbase_entry);

        sptr_cdb->if_type = if_type;
        return;
}


#ifndef NO_STATIC_MMAC
void set_static_Mac_portList_enet_Num(struct cdb* sptr_cdb)
{
        int if_type,i;
#ifdef INCLUDE_MCT
                UINT8 static_entry_exist_flag=0;
                UINT8 is_mct_static_mac=0;
                VLAN_INDEX      vlan_idx;
                VLAN_ENTRY      *vlan_ptr;
#endif
        static_station.mmac_idx = 0;
        static_station.vlan_id = sptr_cdb->vlan_id;
        if_type = sptr_cdb->if_type;
        sptr_cdb->if_type = ETHERNET;
        if (sptr_cdb->no)
                set_port_list_num(sptr_cdb, del_mac_fbase_entry);
        else{
#ifdef INCLUDE_MCT
                                vlan_idx = VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id);
                                if (vlan_idx != VLAN_INDEX_INVALID)
                                {                               
                                        vlan_ptr = (VLAN_ENTRY *) (g_sptr_vlan_db + vlan_idx);
                                        if(clusterlib_is_vlan_cluster_member_vlan_or_session_vlan(vlan_ptr->vlan_config.vlan_id))
                                                is_mct_static_mac=1;
                                }
                                i = INVALID_STATIC_STATION_INDEX;                       
                                static_entry_exist_flag = static_station_find_entry((MAC_ADDRESS*)sptr_cdb->mac1, sptr_cdb->vlan_id, &i);
                                if(static_entry_exist_flag && is_mct_static_mac)
                                        set_port_list_num(sptr_cdb, del_mac_fbase_entry);
#endif INCLUDE_MCT
                            set_port_list_num(sptr_cdb, add_mac_fbase_entry);
        }
        sptr_cdb->if_type = if_type;
}

void set_static_Mac_portList_enet_Num_Num(struct cdb* sptr_cdb)
{
        int if_type,i;
        unsigned char sec_last_token[256]={0};
#ifdef INCLUDE_MCT
                UINT8 static_entry_exist_flag=0;
                UINT8 is_mct_static_mac=0;
                VLAN_INDEX      vlan_idx;
                VLAN_ENTRY      *vlan_ptr;
#endif

        /* Bug 8464
         * User typed ? -- one parse only, during which sptr_cdb->help = TRUE
         * User entered valid command to be executed: two parse
         *              first parse: sptr_cdb->help = FALSE and sptr_cdb->execute = FALSE
         *              second parse: sptr_cdb->help = FALSE and sptr_cdb->execute = TRUE
         */
        if (sptr_cdb->help || (!sptr_cdb->execute))
        {
                sptr_cdb->num_of_if = 0;
        }
        else
        {
                static_station.mmac_idx = 0;
                static_station.vlan_id = sptr_cdb->vlan_id;
                if_type = sptr_cdb->if_type;
                sptr_cdb->if_type = ETHERNET;
                if((sptr_cdb->prev_node) && strncmp(sptr_cdb->prev_node->keyword,"to",strlen("to")) == 0)
                {
                    get_second_last_token(sptr_cdb->cli_expanded_cmd, sec_last_token);
                    if((strncmp(sec_last_token, "lg", 2) == 0) && (strncmp(sptr_cdb->token, "lg", 2) ==0))
                    {
                        sptr_cdb->if_type = VLAG;
                    }
                }

                if (sptr_cdb->no)
                        set_port_list_num_num(sptr_cdb, del_mac_fbase_entry);
                else{
#ifdef INCLUDE_MCT
                                                //debug_print_current_stack_trace();
                                                vlan_idx = VLAN_IDX_FROM_VLAN_ID(sptr_cdb->vlan_id);
                                                if (vlan_idx != VLAN_INDEX_INVALID)
                                                {                               
                                                        vlan_ptr = (VLAN_ENTRY *) (g_sptr_vlan_db + vlan_idx);
                                                        if(clusterlib_is_vlan_cluster_member_vlan_or_session_vlan(vlan_ptr->vlan_config.vlan_id))
                                                        is_mct_static_mac=1;
                                                }
                                                i = INVALID_STATIC_STATION_INDEX;                       
                                                static_entry_exist_flag = static_station_find_entry((MAC_ADDRESS*)sptr_cdb->mac1, sptr_cdb->vlan_id, &i);
                                                if(static_entry_exist_flag && is_mct_static_mac)
                                                        set_port_list_num(sptr_cdb, del_mac_fbase_entry);
#endif INCLUDE_MCT
                        set_port_list_num_num(sptr_cdb, add_mac_fbase_entry);
                }
                sptr_cdb->if_type = if_type;
        }
}
#endif NO_STATIC_MMAC

//Disable MAC Learning on all ports of trunk
void cli_disable_mac_learning_for_trunk(PORT_ID port_id, int disable)
{
        CU_TRUNK_CONFIG_ENTRY   *trunk_entry;
        UINT16                                  trunk_id, j;
        UINT8   flush_mac_when_dis_learning=1; //TR000309555, FCX does not use, SX's default is 1 if disable MAC learning, SX enable learning, this flag does not take effect.

        trunk_id        = cu_get_trunk_id(port_id, 1);
        if (trunk_id >= INVALID_LOAD_SHARE_GROUP_ID)
        {
                return;
        }
        trunk_entry     = &g_sw_sys.trunk_config.trunk_entry[trunk_id];

        //Traverse port list of trunk
        for(j = 0; j < trunk_entry->number_of_ports; j++)
        {
                port_id = trunk_entry->port_list[j];
                                if(!IS_PORT_DB_VALID(port_id))
                                        continue;
                //Disable/Enable MAC Learning for port
                (SPTR_PORT_DB(port_id))->port_config.mac_learning_disabled = disable;
                sw_pp_set_mac_learning(port_id, (disable ? 0 : 1), flush_mac_when_dis_learning);
        }
        // TR000309555, for sx, this is NOT necessary
        if (disable)
        {
                mac_action_request(MA_ALL_VLAN, MAC_FLUSH);
                MA_SET_PORT_MASK(g_sw_load_group[trunk_id].lag_active_mask);
        }
}

extern MAC_NOTIFICATION_BUFFER mac_notification;
extern SNMP_CLASS snmp;

//Disable MAC Learning on port using "mac-learn-disable" feature
void cli_disable_mac_learning(struct cdb* sptr_cdb)
{
        UINT8   flush_mac_when_dis_learning=1; //TR000309555, FCX does not use, SX's default is 1 if disable MAC learning, SX enable learning, this flag does not take effect.
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        //Not valid command for Virtual ports
        if(!IS_PORT_DB_VALID(port_id))
                        return;
        if (is_virtual_port (port_id))
        {
                uprintf("Error - Cannot disable MAC Learning for Virtual Interfaces\n");
                return;
        }

        if (sptr_cdb->config_gen)
        {
//Don't write to config for ICL ports
#ifdef INCLUDE_MCT
                if (!(IS_PORT_ICL_PORT (port_id)))
#endif
                {
                        if ((SPTR_PORT_DB(port_id))->port_config.mac_learning_disabled)
                                wr_config(sptr_cdb, " mac-learn-disable\n");
                }

        }
        else
        {
#ifdef SR_SWITCH_ROUTER
                //If route-only is enabled on the port, do nothing
                if (((SPTR_PORT_DB(port_id))->port_config.route_only) ||
                        (cu_get_global_route_only() == ENABLE))
                {
                        uprintf("Error - Route Only configured on this port\n");
                        return;
                }
#endif SR_SWITCH_ROUTER
                if (IS_PORT_DOT1X_PORT(port_id) || (IS_MAC_AUTH_ENABLED_ON_PORT(port_id)))
                {
                        uprintf("Error - Authentication enabled on this port %p\n", port_id);
                        return;
                }
                if (pms_is_enabled(port_id))
                {
                    uprintf("Error - Cannot disable MAC learning on a port with MAC port security enabled.\n");
                    return;
                }
                if (is_mac_learning_flow_based() && !sptr_cdb->no)
                {
                        uprintf("Error - Cannot Disable Mac Learning with 'mac-learning-flow-based'\n");
                        return;
                }
#ifdef INCLUDE_MCT
                   if((sptr_cdb->no)  && IS_PORT_ICL_PORT(port_id))
                   {
                            uprintf("Error - Cannot Enable Mac Learning on ICL \n");
                            return;
                   }
#endif
                //Trunk port, should be primary only..
                if (IS_GROUP_PORT(port_id) || is_config_trunk_port(port_id))
                {
                        cli_disable_mac_learning_for_trunk(port_id, (sptr_cdb->no ? 0 : 1));
                }
                else
                {
                        (SPTR_PORT_DB(port_id))->port_config.mac_learning_disabled = (sptr_cdb->no ? 0 : 1);
#ifdef FIOFL_INCLUDE
                        if ((sptr_cdb->no) && IS_PORT_OPENFLOW_NONHYBRID(port_id))
                        {
                            uprintf("Warning - On OpenFlow port Mac-Learning remains disabled \n");
                        }
                        else
#endif FIOFL_INCLUDE
                            sw_pp_set_mac_learning(port_id, (sptr_cdb->no ? 1 : 0), flush_mac_when_dis_learning);
                }
                if (sptr_cdb->no == 0)
                {
                        mac_action_request(MA_ALL_VLAN, MAC_FLUSH);
                        if(((SPTR_PORT_DB(port_id))->port_config.mac_notification_enabled )&& snmp.trap_mac_notification_enabled && (mac_notification.flush_type == MAC_EVENT_DEFAULT))
                        {
                                MAC_ADDRESS mac_address = {0, 0};
                                mac_notification_validate_trunk_and_enqueue(&mac_address,0,port_id,MAC_EVENT_REMOVE_ALL_MAC_ON_PORT);
                                mac_notification.flush_type = MAC_EVENT_REMOVE_ALL_MAC_ON_PORT;
                        }
                        MA_SET_PORT(port_id);
                }
                if (sptr_cdb->no && pms_is_enabled_global())
                {
                    uprintf("Warning - Global Port MAC Security is enabled. To also have it enabled for this port, please re-apply it.\n");
                }
        }
}

void mif_cli_disable_mac_learning(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_disable_mac_learning);
}

int g_disable_mac_storm_prevention = 0;

//#if (defined(SR_SWITCH_ROUTER) || defined(MAC_FILTER))
UINT16 cli_max_number_of_filters;
UINT16 cli_number_of_filters;
UINT16 *cli_filters;
//#endif

void allocate_cli_filter_id_list(void)
{
        UINT16 cur_size;

        if (cli_filters)
                return;
        /* cli_filters is shared by ip, rip, and mac, allocate the maximum
         * size among them.
         */
#ifdef SR_SWITCH_ROUTER
        cli_max_number_of_filters = IP_RIP_MAXIMUM_NUMBER_OF_FILTERS;
        cur_size = cu_get_curr_param(IP_FILTER_PORT_ENTRIES_INDEX);
        if (cur_size > cli_max_number_of_filters)
                cli_max_number_of_filters = cur_size;
#else
        cli_max_number_of_filters = 0;
#endif SR_SWITCH_ROUTER
        cur_size = (UINT16) cu_get_curr_param(L2_FILTER_PORT_ENTRIES_INDEX);
        if (cur_size > cli_max_number_of_filters)
                cli_max_number_of_filters = cur_size;
        if ((cli_filters = (UINT16 *)dy_malloc_zero(sizeof(UINT16) * (cli_max_number_of_filters+1))) == NULL)
                kprintf("Error - failed to allocate memory for %d cli_filters\n", cli_max_number_of_filters);
}

void free_cli_filter_id_list(void)
{
        if (cli_filters)
                dy_free(cli_filters);
        cli_filters = NULL;
}

#ifdef SR_SWITCH_ROUTER


void set_port_filters(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen == 0) {
        /* not config gen */

                if (sptr_cdb->no) {
                        if (end_of_token(sptr_cdb->token) == '\0')
                        {
                                sptr_cdb->dont_go_next = 1;
                                ip_add_filters_to_port(
                                        port_id,
                                        (UINT8) sptr_cdb->flag1,
                                        0, /* number of filter */
                                        NULL
                                        );
                        }
                } else {
                        if (cli_number_of_filters >= ip_maximum_number_of_filters_per_list) {
                                uprintf("Error - maximum allowed filters exceeded.\n");
                                sptr_cdb->dont_go_next = 1;
                                return;
                        }
                        cli_filters[cli_number_of_filters] = sptr_cdb->integer1;
                        cli_number_of_filters++;
                        if (end_of_token(sptr_cdb->token) == '\0') {
                                /* it's last filter */
                                sptr_cdb->dont_go_next = 1;
                                ip_add_filters_to_port(
                                        port_id,
                                        (UINT8) sptr_cdb->flag1,
                                        cli_number_of_filters,
                                        cli_filters
                                        );
                        } else {
                                /* it's not last filter yet, continue parsing to
                                integer1 */
                                sptr_cdb->num_of_integer = 0;
                        }
                }
        } else { /* config gen */

        }
}

/* "no" process routine for ip port filter */
void check_port_filters(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        int i;
        int rf=0;
        int range_flag=0;
        char *buffer;
        char temp1[] = " ip access-policy-g ";          /* access-policy-group */
        char temp3[] = "in ";
        char temp4[] = "out ";

        if (sptr_cdb->config_gen != 0)
        {
                /* config gen */
                sptr_cdb->dont_go_next = 1;
                cli_number_of_filters =
                        ip_get_filters_on_port(port_id,
                                IP_FILTER_MODE_RECEIVE,
                                cli_filters);
                if (cli_number_of_filters != 0)
                {
                        wr_config(sptr_cdb, temp1);
                        wr_config(sptr_cdb, temp3);
                        buffer = (char *)&cu_line_buf[0];
                        //fill with zero, so when compare for sequence always difference
                        cli_filters[cli_number_of_filters]=0;

                        for (i=0; i<cli_number_of_filters; i++)
                        {
                                if (cli_filters[i] != (cli_filters[i+1] - 1))
                                {
                                        if (range_flag)
                                        {
                                                buffer += ksprintf(buffer, "%d to %d ", rf, cli_filters[i]);
                                                range_flag = 0;
                                        }
                                        else
                                                buffer += ksprintf(buffer, "%d ", cli_filters[i]);
                                        continue;
                                }
                                else
                                {
                                        if (range_flag == 0)
                                        {
                                                rf = cli_filters[i];
                                                range_flag = 1;
                                        }
                                }
                        }
                        wr_config(sptr_cdb, cu_line_buf);
                        wr_config(sptr_cdb, "\n");
                }

                range_flag = 0;
                cli_number_of_filters =
                        ip_get_filters_on_port(port_id,
                                IP_FILTER_MODE_TRANSMIT,
                                cli_filters);
                if (cli_number_of_filters != 0)
                {
                        wr_config(sptr_cdb, temp1);
                        wr_config(sptr_cdb, temp4);
                        buffer = (char *)&cu_line_buf[0];

                        //fill with zero, so when compare for sequence always difference
                        cli_filters[cli_number_of_filters]=0;

                        for (i=0; i<cli_number_of_filters; i++)
                        {
                                if (cli_filters[i] != (cli_filters[i+1] - 1))
                                {
                                        if (range_flag)
                                        {
                                                buffer += ksprintf(buffer, "%d to %d ", rf, cli_filters[i]);
                                                range_flag = 0;
                                        }
                                        else
                                                buffer += ksprintf(buffer, "%d ", cli_filters[i]);
                                        continue;
                                }
                                else
                                {
                                        if (range_flag == 0)
                                        {
                                                rf = cli_filters[i];
                                                range_flag = 1;
                                        }
                                }
                        }

                        wr_config(sptr_cdb, cu_line_buf);
                        wr_config(sptr_cdb, "\n");
                }
        }
        else
        {
                /*
                 * Initialize sptr_cdb->flag1 to 1. If command is
                 * "ip group-filter in", it will be reset back to 0,
                 * then continue parsing.
                 */

                if (rtr_use_acl)
                {
                        uprintf("Must disable ACL mode first by using ip dont-use-acl command\n"); /* Bug 14392 */
                        print_require_reload();
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                set_cdb_flag1(sptr_cdb);

                /* not config gen */
                if (sptr_cdb->no)
                {
                        if (end_of_token(sptr_cdb->token) == '\0')
                        {
                                sptr_cdb->dont_go_next = 1;
                                ip_add_filters_to_port(port_id,
                           0, /* in filters */
                           0, /* number of filter */
                           NULL
                           );
                                ip_add_filters_to_port(port_id,
                           1, /* out filters */
                           0, /* number of filter */
                           NULL
                           );
                        }
                }
                else
                {
                        cli_number_of_filters = 0; /* init */
                        /* just continue parsing */
                }
        }
}

void check_port_policies(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        check_port_filters(sptr_cdb);
}
#endif  /* SR_SWITCH_ROUTER */


// 85441: after copying config to slave, we must check stacking flash.
void slave_config2flash(UINT32 error,UINT32 ui_port) // CHEETAH STACKING
{
        flash2flashB(error, ui_port);
        if (error == 0 && (IS_STACKING_ENABLED || (STACK_AM_I_CB_AND_PE_NUM)))
        {
                // 85441 Also write the flash if it does not exist
                stacking_write_to_eeprom_due_to_write_mem(0); // KKLIN_8021BR

                /* In case of Katara we need to sync uboot env variable (boot-src) to
                 * all stack members. With the help of this, uboot will decide from
                 * where to load image on next boot. This step is required since
                 * Katara's boot code can't read startup-config to decide on from
                 * where to boot
                 */
                if (is_linux_based_system() || is_a_fs()  )
                                {
                                        
#ifndef PV_CHANGES
                                        if ( katara_boot_env_updated || linux_boot_env_updated)
                                        {
                                                
                        dnld_send_boot_env_update_req_all(boot_seq[0], boot_ip, boot_file);
                        katara_boot_env_updated = 0;
                                                linux_boot_env_updated = 0;
                        }
#ifdef FI_LINUX
                                        if(katara_fips_boot_env_updated)
                                        {
                                                dnld_send_fips_status_update_req_all(sil_get_fips_status());
                                                katara_fips_boot_env_updated =0;
                                        }
#endif/*FI_LINUX*/
#endif/*!PV_CHANGES*/
                                }
        }
}


/* cmd3.h */
/* exec cmds */

void copy_extern_config(UINT32 ui_port)
{
#ifndef NO_FDRY_HW

        switch(g_config_file.config_file)
        {
        case 0:
                break;

        case 1:
                /*************************************************************/
                /*                  write Vlan and Ve config to slot1                */
                /*  config_buffer_ptr[ui_port] should be release in callback */
                /*  function FLASHCARD_WRITE = 1, the second parameters      */
                /*************************************************************/
                slot_cb.use = 1;
                flashcard_oper_with_cb(0, 1, config_buffer_ptr[ui_port],
                strlen(config_buffer_ptr[ui_port]), 0, g_config_file.filename, 0, NULL);
                break;

        case 2:
                /*************************************************************/
                /*                  write Vlan and Ve config to slot2                */
                /*  config_buffer_ptr[ui_port] should be release in callback */
                /*  function FLASHCARD_WRITE = 1, the second parameters      */
                /*************************************************************/
                        slot_cb.use = 1;
                        flashcard_oper_with_cb(0, 1, config_buffer_ptr[ui_port],
                                strlen(config_buffer_ptr[ui_port]), 1, g_config_file.filename, 0, NULL);
                break;

        case 3:
                        tftp_perform_data_upload(runConfig2tftpB, 0, g_config_file.ip_address,
                                g_config_file.filename, (UINT8 *)config_buffer_ptr[ui_port], (UINT32) strlen((char *)config_buffer_ptr[ui_port]));
                break;

                default:
                        uprintf("system error\n");
                        return;
        }
#endif NO_FDRY_HW
}

extern UINT8 write_config_in_progress;
extern UINT8 write_config_remote_in_progress;

/* Reset particular cdb structure fields during config gen to avoid
    carrying its transient state while node parsing
*/
void clean_cdb_for_autosave_running_config(struct cdb* sptr_cdb)
{
        /*      The line or taken may have an incomplete command without carriage return. Clear it  */
        sptr_cdb->line = sptr_cdb->token = NULL;

        /* Clear the integers. Should not confuse the node functions as input parameters to them */
        sptr_cdb->num_of_integer = 0;
        sptr_cdb->integer1 = 0;
        sptr_cdb->integer2 = 0;
        sptr_cdb->integer3 = 0;
        sptr_cdb->integer4 = 0;
        sptr_cdb->integer5 = 0;
        sptr_cdb->integer6 = 0;
        sptr_cdb->integer7 = 0;
        sptr_cdb->integer8 = 0;
        sptr_cdb->integer9 = 0;
        sptr_cdb->integer10 = 0;
        sptr_cdb->integer11 = 0;
        sptr_cdb->integer12 = 0;
        sptr_cdb->integer13 = 0;

        /* Line status should not be CMD_LINE_HELP while parsing nodes for config generation.
             May cause a crash - TR000288114 */
        sptr_cdb->line_status = CMD_LINE_EXECUTE;
        sptr_cdb->expand_request = FALSE;
        sptr_cdb->help = FALSE;
        sptr_cdb->execute = FALSE;

}

extern int    wm_retrieve_running_config(struct cdb*sptr_cdb, void(*callbckfn)(struct cdb*,int) )  ;



struct cdb *my_cdb=NULL;

/* TR000310029 -> This bug is caused because the original copy_runConfig_startConfig was taking
  * too much time to return and this causes the VRRP protocol to flap, as the system runs in a
  * single threaded environment. This function is the replacement for the original copy_runConfig_startConfig.
  */
void copy_runConfig_startConfig_Immediate(struct cdb* sptr_cdb)
{
        struct cdb *my_cdb;
        int rcode;
        UINT8 *buf;
        char runConfig_md5_digest[16];
        char startConfig_md5_digest[16];
        UINT32 runConfig_len;
        UINT32 startConfig_len;

        UINT32 handle = 0;
        int len;


        if (sptr_cdb->config_gen
        ||  sptr_cdb->no)
          return;

        if(!is_mgmt_active())
        {
                if (debugGlobal.stacking.sync_rel_msg_level & STK_SYNC_DBG_LEVEL_3)
                {
                        debug_print_current_stack_trace();
                }
                return;
        }
    if(is_flash_use_in_progress())
    {
        uprintf("Flash access in progress. Please try later\n");
        return;
    }
    else
    {
        if(!set_flash_use_in_progress())
		return;
    }

    my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb));
    if (!my_cdb)
    {
        reset_flash_use_in_progress();
        return;
    }
#ifdef DEBUG
        uprintf("copy_runConfig_startConfig\n");
#endif


        /*****************************************************************/
        /*        for scp, the config data is already in the buffer      */
        /*****************************************************************/

        if(!sptr_cdb->scp_in_progress)   /* for scp only */
        {
        buf = get_config_buffer(sptr_cdb->ui_port);

        if (buf == 0)
        {
                uprintf("Running-config to startup-config abort.\n");
                reset_flash_use_in_progress();
                goto exit_this_function;
        }

        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;

        }

        sptr_cdb->gen_to = GEN_TO_FLASH;

        sptr_cdb->write_mem_flag = 1;

        /* BUG FIX: we should not do the tricks for vlan group interface when doing "write memory" */
        g_vlan_group_cmd = 0;

        *my_cdb = *sptr_cdb;

//      write_config_in_progress=TRUE;

        if(!sptr_cdb->scp_in_progress)   /* for scp only */
        {
                /*
                        TR000288114 - Router crash - Port MAC Security Autosave
                        Port MAC Security Autosave Timer may get triggered when user is in middle of writing some commands.
                        This incomplete user activity can leave the sptr_cdb structure vulnerable to misinterpretations by the node functions
                        during parsing of nodes while config generation.
                        Hence, clean the cdb structure to not contain transient state information.
                */
                clean_cdb_for_autosave_running_config(my_cdb);

                //if (retrieve_running_config(my_cdb)<0)
                if(retrieve_all_module_config_new(my_cdb)<0)
                {
                        uprintf("Running-config to startup-config abort.\n");
                        reset_flash_use_in_progress();
                        goto exit_this_function;
                }
        }

#ifdef __PORT_EXTENSION__
                spx_write_memory_callback(0); // from_cb = 0
#endif __PORT_EXTENSION__

        stacking_write_memory_callback();

#ifndef NO_FIPS_XCAT_LINUX_BRINGUP
        runConfig_len = get_buffer_md5_digest(runConfig_md5_digest, config_buffer, strlen((char *)config_buffer)); //CHEETAH_STACKING
        startConfig_len = get_startup_config_md5_digest(startConfig_md5_digest);

        if ((runConfig_len != startConfig_len) ||
                (memcmp(runConfig_md5_digest, startConfig_md5_digest, 16) != 0))
        {
                nt_write_config_file(config_buffer, strlen((char *)config_buffer));
                copy_startConfig_slaves(sptr_cdb); // CHEETAH_STACKING
        }
        else
        {
                reset_flash_use_in_progress();
        }
#else /* ifdef NO_FIPS_XCAT_LINUX_BRINGUP */
        nt_write_config_file(config_buffer, strlen((char *)config_buffer));
        copy_startConfig_slaves(sptr_cdb); // CHEETAH_STACKING
#endif /* NO_FIPS_XCAT_LINUX_BRINGUP */
        cli_log_config_changed(sptr_cdb->ui_port, TRUE);

        free_config_buffer(sptr_cdb->buffer_base);      /* data was copied to flash_config_buffer */

exit_this_function:
        write_config_in_progress=FALSE;
    copy_extern_config(sptr_cdb->ui_port);
    dy_free(my_cdb);
}

#define LINE_SIZE 100 

char get_current_startup_patch (char *patch)
{
        int flash_file, k, ch, major_version=0, maintenance_version;
        int minor_version;
        int startup_ver = 0;
         unsigned char c, *sptr_start, *sptr_end;
         char line[LINE_SIZE];

        flash_file = sys_flash_fopen(g_startup_config_filename, "r");

        if (flash_file == 0 )
        {
                /* the startup file was not found */
                uprintf("\n There is no startup config file, unable to save legacy config \n");
                return 0 ;
        }

        for (k = 0;;)
                {
                        ch = sys_fgetc(flash_file);
                        if (ch == '\n' || ch == -1)
                        {
                                line[k] = '\0';
        
                                if (!startup_ver && (sptr_start = search_string_in_line_and_move_pointer(line, "ver "))) //Find startup version
                                {
                                        
                                        sptr_end = cli_find_char(sptr_start, '.');
                                        if (sptr_end != NULL)
                                        {
                                        c = *sptr_end;
                                        *sptr_end = 0;
                                        major_version = atoi(sptr_start);
                                        *sptr_end = c;
                                        sptr_start = sptr_end+1;
                                        sptr_end = cli_find_char(sptr_start, '.');
                                        if (NULL != sptr_end)
                                        {
                                                sptr_start = sptr_end + 1;
                                                sptr_end = sptr_start + 1;
                                                c = *sptr_end;
                                                *sptr_end = 0;
                                                minor_version = atoi(sptr_start);
                                                *sptr_end = c;
                                                sptr_start = sptr_end;
                                                sptr_end = sptr_start + 1;
                                                c = *sptr_end;
                                                *sptr_end = 0;
                                                maintenance_version = atoi(sptr_start);
                                                *sptr_end = c;

                                                sptr_start = sptr_end;
                                                sptr_end = cli_find_char(sptr_start, 'T');
                                                if ((sptr_end != NULL) && (sptr_end != sptr_start))
                                                {
                                                        *sptr_end = 0;
                                                        strcpy(patch, sptr_start);
                                                        *sptr_end = c;
                                                }
                                                else
                                                {
                                                        *patch = 0;
                                                }

                                                
                                        }

                                }
                                startup_ver = 1;
                        }//Find startup version
        
                                
        
                                if (ch == -1) break;
                                k = 0;
                                continue;
                        }
                        if (k < LINE_SIZE-1) line[k++] = ch;
                }
        
                sys_fclose(flash_file);
        return major_version;
}

int get_current_startup_version (void)
{
        int flash_file, k, ch, major_version = 0;
        int minor_version;
        int startup_ver = 0;
         unsigned char c, *sptr_start, *sptr_end;
         char line[LINE_SIZE];

        flash_file = sys_flash_fopen(g_startup_config_filename, "r");

        if (flash_file == 0 )
        {
                
                /* the startup file was not found */
                uprintf("\n There is no startup config file, unable to save legacy config \n");
                
                
                        return 0 ;
                
        }

        



        
        for (k = 0;;)
                {
                        ch = sys_fgetc(flash_file);
                        if (ch == '\n' || ch == -1)
                        {
                                line[k] = '\0';
        
                                if (!startup_ver && (sptr_start = search_string_in_line_and_move_pointer(line, "ver "))) //Find startup version
                                {
                                        
        
                                        sptr_end = cli_find_char(sptr_start, '.');
                                        if (sptr_end != NULL)
                                        {
                                                c = *sptr_end;
                                                *sptr_end = 0;
                                                major_version = atoi(sptr_start);
                                                
                                                *sptr_end = c;
                                                sptr_start = sptr_end+1;
                                                sptr_end = cli_find_char(sptr_start, '.');
                                                if (sptr_end != NULL)
                                                {
                                                        c = *sptr_end;
                                                        *sptr_end = 0;
                                                        minor_version = atoi(sptr_start);
                                                        *sptr_end = c;
                                                }
                                        }
                                        startup_ver = 1;
                                }//Find startup version
        
                                
        
                                if (ch == -1) break;
                                k = 0;
                                continue;
                        }
                        if (k < LINE_SIZE-1) line[k++] = ch;
                }
        
                sys_fclose(flash_file);
        return major_version;
}
void copy_runConfig_startConfig(struct cdb* sptr_cdb)
{
        struct cdb *my_cdb;
        int rcode;
                int ver;
        UINT8 *buf;
        char runConfig_md5_digest[16];
        char startConfig_md5_digest[16];
        UINT32 runConfig_len;
        UINT32 startConfig_len;
                int file;

        UINT32 handle = 0;
        int len;


        if (sptr_cdb->config_gen
        ||  sptr_cdb->no)
          return;

		if(is_flash_use_in_progress())
    {
        uprintf("Flash access in progress. Please try later\n");
        return;
    }
    else
    {
        if(!set_flash_use_in_progress())
		return;
    }
#if __PORT_EXTENSION__ // KKLIN_8021BR, 
        if(!g_stacking_allow_all_slave_commands && is_pe_fully_controlled_by_cb())
                {
                        uprintf("\"write memory\" is not allowed because this PE is managed by the CB unit %u. Please execute on the CB\n",
                                g_stacking.master);
                        print_pe_unconfigure_instrunction();
						reset_flash_use_in_progress();
                        return;
                }
                spx_write_memory_callback(0); // from_cb = 0 // must call this to remove the pe-enable from flash even in regular mode
                if(is_in_pe_or_provisional_pe_mode())
                {
						reset_flash_use_in_progress();
                        return;
                }
#endif __PORT_EXTENSION__ // KKLIN_8021BR, 

        if(!is_mgmt_active())
        {
                if (debugGlobal.stacking.sync_rel_msg_level & STK_SYNC_DBG_LEVEL_3)
                {
                        debug_print_current_stack_trace();
                }
				reset_flash_use_in_progress();
        return;
    }
   

    my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb));
    if (!my_cdb)
    {
        reset_flash_use_in_progress();
        return;
    }
#ifdef DEBUG
    uprintf("copy_runConfig_startConfig\n");
#endif

/* Back up any pre 8.0 config  */
/* Open the startup config file and check if the header is <8.0  rename it*/
     ver = get_current_startup_version();
     if (ver < 8 && ver != 0)
     {
        file = flash_fopen(g_startup_config_filename, "r");
                if (file != 0)
                {
                        flash_fclose(file);
                        sys_flash_fremove(g_startup_config_legacy );
            if(!(cu_fips_get_status() || get_fips_flag_on_eeprom()))    
                flash_rename(g_startup_config_filename,g_startup_config_legacy );
                        downgrade_cli_issued = 0;
                }
     }

        /*****************************************************************/
        /*        for scp, the config data is already in the buffer      */
        /*****************************************************************/

        if(!sptr_cdb->scp_in_progress)   /* for scp only */
        {
        buf = get_config_buffer(sptr_cdb->ui_port);

        if (buf == 0)
        {
                uprintf("Running-config to startup-config abort.\n");
                reset_flash_use_in_progress();
                goto exit_this_function;
        }

        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;
        }

        sptr_cdb->gen_to = GEN_TO_FLASH;

        sptr_cdb->write_mem_flag = 1;

        /* BUG FIX: we should not do the tricks for vlan group interface when doing "write memory" */
        g_vlan_group_cmd = 0;

        *my_cdb = *sptr_cdb;

        //write_config_in_progress=TRUE;

        if(!sptr_cdb->scp_in_progress)   /* for scp only */
        {
                /*
                        TR000288114 - Router crash - Port MAC Security Autosave
                        Port MAC Security Autosave Timer may get triggered when user is in middle of writing some commands.
                        This incomplete user activity can leave the sptr_cdb structure vulnerable to misinterpretations by the node functions
                        during parsing of nodes while config generation.
                        Hence, clean the cdb structure to not contain transient state information.
                */
                clean_cdb_for_autosave_running_config(my_cdb);

                if( module_dat[sptr_cdb->ui_port].sh_run_in_progress ? (retrieve_all_module_config_new(my_cdb) < 0) : (retrieve_running_config(my_cdb)<0))
                {
                        uprintf("Running-config to startup-config abort.\n");
                        reset_flash_use_in_progress();
                        goto exit_this_function;
                }
        }
#ifdef __PORT_EXTENSION__
// Note: must be done above, not here because PE may return early
//              spx_write_memory_callback(0); // from_cb = 0
#endif __PORT_EXTENSION__

        stacking_write_memory_callback();

#ifndef NO_FIPS_XCAT_LINUX_BRINGUP
        runConfig_len = get_buffer_md5_digest(runConfig_md5_digest, config_buffer, strlen((char *)config_buffer)); //CHEETAH_STACKING
        startConfig_len = get_startup_config_md5_digest(startConfig_md5_digest);

        if ((runConfig_len != startConfig_len) ||
                (memcmp(runConfig_md5_digest, startConfig_md5_digest, 16) != 0))
        {
                nt_write_config_file(config_buffer, strlen((char *)config_buffer));
                copy_startConfig_slaves(sptr_cdb); // CHEETAH_STACKING
                update_startup_config_flash_signature();
        }
        else
        {
                reset_flash_use_in_progress();
        }
#else /* ifdef NO_FIPS_XCAT_LINUX_BRINGUP */
        nt_write_config_file(config_buffer, strlen((char *)config_buffer));
        copy_startConfig_slaves(sptr_cdb); // CHEETAH_STACKING
        update_startup_config_flash_signature();
#endif /* NO_FIPS_XCAT_LINUX_BRINGUP */
        cli_log_config_changed(sptr_cdb->ui_port, TRUE);

        free_config_buffer(sptr_cdb->buffer_base);      /* data was copied to flash_config_buffer */

exit_this_function:

    copy_extern_config(sptr_cdb->ui_port);
    dy_free(my_cdb);
}


/* TR000310029 -> This bug is caused because the original copy_runConfig_startConfig was taking
  * too much time to return and this causes the VRRP protocol to flap, as the system runs in a
  * single threaded environment. Now copy_runConfig_startConfig is split into two. One for generating the
  * requests and the other one to finish the command after timer based data read and write are completed.
  * This ensures that the function doesn't block other important tasks that are running in the system.
  * copy_runConfig_startConfig_end will be called when the timer based read was completed.
  */

void copy_runConfig_startConfig_end(struct cdb *sptr_cdb, int result){
        char runConfig_md5_digest[16];
        char startConfig_md5_digest[16];
        UINT32 runConfig_len;
        UINT32 startConfig_len;
        //uprintf("copy_runConfig_startConfigend called at %x \n",read_long_time_base());
        if(result<0){
                uprintf("Running-config to startup-config abort.\n");
                reset_flash_use_in_progress();
                write_config_in_progress=FALSE;
                goto  exit_this_function;
        }
#ifdef __PORT_EXTENSION__
                spx_write_memory_callback(0); // from_cb = 0
#endif __PORT_EXTENSION__

        stacking_write_memory_callback();
        runConfig_len = get_buffer_md5_digest(runConfig_md5_digest, config_buffer, strlen((char *)config_buffer)); //CHEETAH_STACKING
        startConfig_len = get_startup_config_md5_digest(startConfig_md5_digest);



        if ((runConfig_len != startConfig_len) ||
                (memcmp(runConfig_md5_digest, startConfig_md5_digest, 16) != 0))
        {
                nt_write_config_file(config_buffer, strlen((char *)config_buffer));
                copy_startConfig_slaves(sptr_cdb); // CHEETAH_STACKING
                /* For the case where the run config changes have to be written to flash,
                  * write_config_in_progress variable will be reset by the lower layer after
                  * completing the write to flash.
                  */

        }else{
                reset_flash_use_in_progress();
                write_config_in_progress=FALSE;
        }


        cli_log_config_changed(sptr_cdb->ui_port, TRUE);

        free_config_buffer(sptr_cdb->buffer_base);      /* data was copied to flash_config_buffer */

exit_this_function:

    copy_extern_config(sptr_cdb->ui_port);
    dy_free(my_cdb);
    my_cdb=NULL;

       //  uprintf("DONE\n");
        //uprintf("copy_runConfig_startConfigend ENDED at %x \n",read_long_time_base());
}

extern UINT16 *flash_config_buffer;
/* changed "UINT32 error" to "int error" to match up with flash.c - rlau */
void runConfig2startConfigPB(int error,UINT32 ui_port)
{
        int old_ui_port, result;
        int len;
        struct cdb*     sptr_cdb;

        sptr_cdb = &cdbs[ui_port];
        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

#ifdef DEBUG
        uprintf("prepare write flash callback\n");
#endif
        if (error) {
                uprintf("Error - failed in flash write prepare callback.\n"); /* just return */
                g_uprintf_dest = old_ui_port;
                return;
        }

        /* get config data length, in 2-byte unit */
        len = strlen((char *)flash_config_buffer);
        if (len & 1)
                len = (len +1)/2;
        else
                len = len/2;

        /* make sure there are 4 bytes left for flash check sum */
        if ((len+2) > (int)(max_config_size/2))
                len = (max_config_size/2) - 2;

        result = flashpgm(sptr_cdb->flash_handle,
                                        FLASH_WRITE,
                                        (UINT16 *)flash_config_buffer,
                                        /* reserve 4 bytes for flash check sum */
                                        len+2,
                                        runConfig2startConfigWB,
                                        ui_port);

        if (result != 0) {
                uprintf("Error - failed to flash write.\n");
                finish_flashpgm(sptr_cdb->flash_handle, FLASH_WRITE, NULL, ui_port);
        }

        g_uprintf_dest = old_ui_port;
}

/* changed "UINT32 error" to "int error" to match up with flash.c - rlau */
void runConfig2startConfigWB(int error,UINT32 ui_port)
{
        int old_ui_port;
        struct cdb*     sptr_cdb;

        sptr_cdb = &cdbs[ui_port];

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;


#ifdef DEBUG
        uprintf("write flash callback\n");
#endif
        /* flash.c returns 0 (not CU_OK) and -1 (not CU_ERROR) - rlau */
        if (error == 0)
        {
                finish_flashpgm(sptr_cdb->flash_handle, FLASH_WRITE, runConfig2startConfigFB, ui_port);
                uprintf("Write startup-config in progress.\n");
        }
        else
        {
                uprintf("Error - failed to write startup-config.\n");
        }

        g_uprintf_dest = old_ui_port;
}

#ifndef IP_ADDRESS
#define IP_ADDRESS  unsigned long
#endif

void cli_log_config_changed(UINT32 ui_port, UINT8 startup_config)
{
        int                       index;
        char*                   tUserName=0, session[128];
#ifdef __IPV6__
        enum BOOLEAN     tUseIpv6=FALSE;
        IP6_IPV6_ADDRESS* tIp6AddressPtr=0;
#endif __IPV6__
        IP_ADDRESS          tIpAddress=0;

#ifdef __CLOUD_MGR_ENABLE__
	/* Disable Cloud Agent ZTP if the switch is not configured. */
	ca_disable_cloud_agent_ztp();
#endif

        if (!g_sw_sys.log_config_changed || ui_port >= MAX_IO_CB)
                return;

        if (cdbs[ui_port].user_name[0] != '\0')
                tUserName = cdbs[ui_port].user_name;
        else
                tUserName = NULL;

        session[0] = 0;
        if (IS_CONSOLE_CDBS_INDEX(ui_port))
        {
                ksnprintf(session, sizeof(session), "console");
        }
        else if (IS_RCONSOLE_SESSION(ui_port))
        {
                ksnprintf(session, sizeof(session), "rconsole console");
        }
        else if (IS_TELNET_CDBS_INDEX(ui_port))
        {
                index = CDBS_TO_TELNET_INDEX(ui_port);
                if (telnet.client[index].ip_address)
                        ksnprintf(session, sizeof(session),
                                          "telnet client %I", telnet.client[index].ip_address);
#ifdef __IPV6__
                else
                        ksnprintf(session, sizeof(session),
                                          "telnet client %s", ipv6_address_to_string(&telnet.client[index].ip6_address, NULL));
#endif __IPV6__
        }
        else if (IS_SSH_CDBS_INDEX(ui_port))
        {
                index = CDBS_TO_SSH_INDEX(ui_port);
                if (ssh.client[index].ip_address)
                        ksnprintf(session, sizeof(session),
                                          "ssh client %I", ssh.client[index].ip_address);
#ifdef __IPV6__
                else
                        ksnprintf(session, sizeof(session),
                                          "ssh client %s",  ipv6_address_to_string(&ssh.client[index].ip6_address, NULL));
#endif __IPV6__
        }
        else if (IS_WEB_CDBS_INDEX(ui_port))
        {
                ksnprintf(session, sizeof(session), "web management");
        }
        else if (IS_SNMP_CDBS_INDEX(ui_port))
        {
                ksnprintf(session, sizeof(session), "snmp management");
        }


        cu_logging_config_changed(tUserName, session, startup_config);
        return;
}

int generate_running_config_checksum(struct cdb* sptr_cdb)
{
        UINT8 *buf;

        /* Cal checksum for checking config changed or not */
        sptr_cdb->num_of_check_sum = 0;
        sptr_cdb->check_sum1 = 0;
        sptr_cdb->gen_to = GEN_TO_CHKSUM;
        buf = get_config_buffer(sptr_cdb->ui_port);
        if (buf == 0)
        {
                uprintf("Error - config buffer is not available.\n");
                return -1;
        }
        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;

        //retrieve_running_config(sptr_cdb);
        if(retrieve_all_module_config_new(sptr_cdb) < 0)
	{
		/*do nothing*/
	}
        free_config_buffer(sptr_cdb->buffer_base);
        return 0;
}

#if 0
void check_running_config_change(struct cdb* sptr_cdb)
{
        UINT8 *buf;

        /* Compare checksums to check for config changed or not */
        if (sptr_cdb->check_sum1 == 0)
                return;
        sptr_cdb->num_of_check_sum = 1;
        sptr_cdb->check_sum2 = 0;
        sptr_cdb->gen_to = GEN_TO_CHKSUM;
        buf = get_config_buffer(sptr_cdb->ui_port);
        if (buf == 0)
        {
                uprintf("Error - config buffer is not available.\n");
                return;
        }
        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;

	if(!STACK_AM_I_CB_ENABLE)	//Skipping checksum calculation based on "sxp cb-enable"
	{
        	//retrieve_running_config(sptr_cdb);
		if(retrieve_all_module_config_new(sptr_cdb) < 0)
		{
			/*do nothing*/
		}
	        if (sptr_cdb->check_sum1 != sptr_cdb->check_sum2)
        	        cli_log_config_changed(sptr_cdb->ui_port, FALSE);
	}
	else
		cli_log_config_changed(sptr_cdb->ui_port, FALSE);

        free_config_buffer(sptr_cdb->buffer_base);
}
#endif
void runConfig2startConfigFB(int error,UINT32 ui_port)
{
        int old_ui_port;
        struct cdb*     sptr_cdb;

        DEBUG_CODE_DECLARE_REG(old);

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        /* flash.c returns 0 (not CU_OK) and -1 (not CU_ERROR) - rlau */
        if (error == 0)
        {
                if (ui_port != 0xFFFFFFFF)
                {
                        sptr_cdb = &cdbs[ui_port];
                        uprintf("Write startup-config done.\n");
                }
                DEBUG_CODE_GET_r26(&old);
                cli_log_config_changed(ui_port, TRUE);
                DEBUG_CODE_COMPARE_r26(old);
        }
        else
        {
                uprintf("Error - failed to write startup-config.\n");
        }
        if (ui_port != 0xFFFFFFFF)
        {
                sptr_cdb = &cdbs[ui_port];
                DEBUG_CODE_GET_r26(&old);
                        print_prompt(sptr_cdb);
                DEBUG_CODE_COMPARE_r26(old);
        }
        g_uprintf_dest = old_ui_port;
}

void copy_startConfig_runConfig(struct cdb* sptr_cdb)
{
        copy_startConfig_runConfig_service(sptr_cdb->ui_port);
}

int copy_startConfig_runConfig_service(unsigned int ui_port)
{
        int result = 0;
        UINT32 handle = FLASH_MAX_ERR;
    int load_config_from_card = 0;
        struct cdb *sptr_cdb = &cdbs[ui_port];
        unsigned char *config_buf = sptr_cdb->buffer_base;
	int cfg_read_ret = 0;

        if(is_mgmt_active())
                cfg_read_ret = nt_read_config_file(config_buf, max_config_size);
        else
                sxr_stby_get_runningConfig(config_buf, max_config_size);

#ifdef __CLOUD_MGR_ENABLE__
	if (cfg_read_ret  == -2) {
		/* Start up config is not present */
		ca_start_cloud_agent_ztp();
	}
#endif

        parse_configBuf(config_buf, ui_port);
        uprintf("\n");
        cu_lag_deploy_lacp_cmds(); // Maocheng++: 8.0 dyn lag
        return 0; /* no error */
}

#ifdef SR_SWITCH_ROUTER
void renew_system_default_configuration(void)
{
        UINT16 port_id;

        {
                /* if version is newer then 06.0.00, the default directed broadcast
                 * enable value is FALSE; older than 06.0.00, default is TRUE
                 */
                ip.directed_bcast_fwd_enabled = FALSE;
                for (port_id=0; port_id < NUMBER_OF_IP_PORTS; port_id++)
                {
                        if (!IS_IP_PORT_DB_VALID(port_id))
                                continue;
                        IP_IP_PORT(port_id).config.directed_bcast_fwd_enabled = FALSE;
                }
                ip.arp.proxy_arp_enabled = FALSE;
                /* route-only default to enable */
#ifdef BUILD_ISP
                /* AOL request: turn on route-only if no config for IP ONLY builds */
                g_sw_sys.route_only_enabled = ENABLE;
#endif BUILD_ISP
        }
}
#endif /* SR_SWITCH_ROUTER */

/* build skipConfig condition, which varies based on product flags */
int cli_is_skip_config(void)
{
        int skipConfig = 0;

  /* build skipConfig condition, which varies based on product flags */
#ifdef WINNT
  skipConfig = 0;
#else 
  skipConfig = (g_bootinfo_sptr->bootconfig.option.s.noconfig) ? 1 : 0;
#endif

  return skipConfig;
}
extern void lagctrl_check_port_config_speed_discrepancy_and_undeploy(void);
extern UINT32 cli_boot;
void init_runConfig_from_startConfig(void)
{
        int i;

        struct cdb *sptr_cdb = &cdbs[0];

        sptr_cdb->ui_port = 0;
        sptr_cdb->buffer_base = get_config_buffer(sptr_cdb->ui_port);
        if (sptr_cdb->buffer_base == 0)
        {
                //uprintf("Failed to get config buffer\n");
                return;
        }
        sptr_cdb->buffer_base[0] = '\0';
        sptr_cdb->buffer = sptr_cdb->buffer_base;

        /******* Fan Trunk enhancement ********/
        for(i = 0 ; i < MAX_MIRRORS; i++)
        {
                g_mirror_list[i] = WILD_ADDRESS;
        }

#ifndef FIXED_RESERVE_VLAN_ID // initialize to a stable base.
        g_cfg_cpu_vlan_id = g_cpu_vlan_id = global_cpu_vlan_id;
        g_cfg_all_ports_vlan_id = g_all_ports_vlan_id = global_all_ports_vlan_id;
#endif  /* FIXED_RESERVE_VLAN_ID */

        if((g_bootinfo_sptr->bootconfig.option.s.di)||
                         (g_bootinfo_sptr->bootconfig.option.s.di_alt))
   {
           uprintf("Initializing with default configuration.\n");
           parse_configBuf(sptr_cdb->buffer_base, sptr_cdb->ui_port);
   }
   else
        {
                if(cli_is_skip_config() || // running "dm diag"
                        (is_diag_on() || is_diag_extra_on()))
                {
                        uprintf("Initializing with default configuration.\n");
                        //BUG: 9585 for ssh when default config should not have ssh host keys included

                        parse_configBuf(sptr_cdb->buffer_base, sptr_cdb->ui_port);
                }
                else
                {
                        if (cli_boot != TRY_BOOT_FAST)
                                uprintf("Parsing Config Data ...\n");

                        //sptr_cdb->startupCfg = 1;
                        copy_startConfig_runConfig(sptr_cdb);
                }
        }

#ifdef SR_SWITCH_ROUTER
        if (sptr_cdb->buffer_base[0] == '\0')
        {
                /* blank startup config buffer */
                /* route-only default to enable */
#if !defined(__BASE_L3__)
                /* AOL request: turn on route-only if no config for IP ONLY builds */
#endif
                renew_system_default_configuration();
#ifdef BUILD_ISP
                /* for ISP build, disable all ports by default. user will enable port manually */
                for (i=0; i<g_hw_info.max_mod; i++)
                {
                        if (!CONFIG_MODULE_EXIST(i))
                                continue;
                        cu_set_module_port_state(i, PORT_DISABLE);
                }
#endif BUILD_ISP
        }
#endif /* SR_SWITCH_ROUTER */

        free_config_buffer(sptr_cdb->buffer_base);
#ifndef WINNT
        /*
         * If user informs the bootcode to by-pass the password
         * during power up, the bootcode will set SYSIF_SSR4_R
         * to inform us to reset password back to NULL string.
         */
if (g_bootinfo_sptr->bootconfig.option.s.nopasswd)
        {
                g_access_control.level_password[CU_SECURITY_LEVEL0][0] = 0;
                // g_priv_aaa_enabled = FALSE;
                aaa_set_console_authentication_override_flag(TRUE);
        }
#endif
        /* If console authentication is enabled, set mode to console login.*/
        if (cu_aaa_is_login_authen_enabled_for_console())
                set_cli_mode(sptr_cdb, CONSOLE_LOGIN);
        else
                set_cli_mode(sptr_cdb, USER_EXEC);

        default_current_login_password_level(sptr_cdb, 0);

#ifdef SR_SWITCH_ROUTER
        ospf_init_done();
#endif SR_SWITCH_ROUTER

//#if (defined(SR_SWITCH_ROUTER) || defined(MAC_FILTER))
        allocate_cli_filter_id_list();
//#endif

#ifndef EVAL_BOARD
        /* Last chance to initialize vlan config data structures. If it was
         * initialized during config file parsing, calling the following
         * function will not perform initialization again. If it was not
         * initialized because of config flash corruption or user wants
         * to ignore the config flash data, then calling the following
         * function will initialize vlan config data to the default number
         * of entries.
         */
        port_vlan_config_init((UINT16)cu_get_def_param(VLAN_ENTRIES_INDEX));
        ip_read_dhcp_snoop_data_file();

		/* Call Lag function to validate config speed
		 * discrepancy and if needed un-deploy
		 * the Lag.
		 * This function is added to handle any
		 * config speed mismatch for Spatha_32P
		 * Port pairing
		 */
		lagctrl_check_port_config_speed_discrepancy_and_undeploy();
#else
	uprintf("pvlan_config_init , ip_read_dhcp_snoop_data_file, lagctrl_check_port_config_speed_discrepancy_and_undeploy are blocked for eval board!!\n");
#endif
        return;
}

void
copy_startConfig_slaves(struct cdb* sptr_cdb) // CHEETAH_STACKING
{
        int old_ui_port;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = sptr_cdb->ui_port;

        dnld_init_info_all();
        nt_cfg_flash_copy(slave_config2flash, sptr_cdb->ui_port); // 85441
        g_uprintf_dest = old_ui_port;
}

void erase_flash_slaves_pri(struct cdb* sptr_cdb)
{
    if (!set_flash_use_in_progress())
    {
        return;
    }
    nt_delete_code_slaves_primary(sptr_cdb->string1);
    reset_flash_use_in_progress();
}

void erase_flash_slaves_sec(struct cdb* sptr_cdb)
{
    if(!set_flash_use_in_progress())
    {
        return;
    }
    nt_delete_code_slaves_secondary(sptr_cdb->string1);
    reset_flash_use_in_progress();
}


void erase_flash_pri(struct cdb* sptr_cdb)
{
        UINT8 ii;
        UINT32 slave_ary[MAX_SYS_UNIT_NUM] = {0}; // yes, the size is not +1 because it shift by 1

        if(!set_flash_use_in_progress())
        {
            return;
        }
        if(!STACK_AM_I_STANDALONE)
        {
                for (ii = 0; ii < MAX_SYS_UNIT_NUM; ii++)
                        slave_ary[ii] = ii + 1;

                dnld_send_erase_primary_req(slave_ary);
        }

        nt_delete_code_primary();
        reset_flash_use_in_progress();
        return;
}

/* changed "UINT32 error" to "int error" to match up with flash.c - rlau */
void eraseFlashB(int error,UINT32 ui_port)
{
        int old_ui_port;
        enum BOOLEAN is_config_data;
        struct cdb*     sptr_cdb;
        struct flash_control_block *sptr_flash_cb;

        sptr_cdb = &cdbs[ui_port];

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        /* flash.c returns 0 (not CU_OK) and -1 (not CU_ERROR) - rlau */
        if (error == 0)
        {
                sptr_flash_cb = (struct flash_control_block *)sptr_cdb->flash_handle;
                is_config_data = (sptr_flash_cb->data_type == CONFIG_DATA);
                finish_flashpgm(sptr_cdb->flash_handle, FLASH_READ, NULL, ui_port);
                if (is_config_data)
                {
                        uprintf("Erase startup-config Done.\n");
                        cli_log_config_changed(ui_port, TRUE);
                }
                else
                uprintf("Erase flash Done.\n");
        }
        else
        {
                uprintf("Error - failed to erase flash.\n");
        }
        g_uprintf_dest = old_ui_port;
}

void erase_flash_sec(struct cdb* sptr_cdb)
{
        UINT8 ii;
        UINT32 slave_ary[MAX_SYS_UNIT_NUM] = {0}; // yes, the size is not +1 because it shift by 1

        if(!set_flash_use_in_progress())
        {
            return;
        }
        if(!STACK_AM_I_STANDALONE)
        {
                for (ii = 0; ii < MAX_SYS_UNIT_NUM; ii++)
                        slave_ary[ii] = ii + 1;

                dnld_send_erase_secondary_req(slave_ary);
        }
        nt_delete_code_secondary();
        reset_flash_use_in_progress();
        return;
}

void clear_ip_cache(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        else {
                uprintf("%s\n",sptr_cdb->line);
                sptr_cdb->dont_go_next = 1;
        }
}

#ifdef LATER
void ping_Ip_Multiple(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        else {
                icmp_perform_ping(ping_callback,
                                sptr_cdb->ui_port,
                                sptr_cdb->ip1,
                                sptr_cdb->integer1);
                sptr_cdb->dont_go_next = 1;
        }
        uprintf("ping ip multiple time.\n");
        uprintf("ip = %x count = %d\n", sptr_cdb->ip1, sptr_cdb->integer1);
}
#endif

void show_ip(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
#ifdef SR_SWITCH_ROUTER
                ip_show_global_info();
#else
                cu_show_ip();
#endif SR_SWITCH_ROUTER
        }
        else
        {
                set_afi_ipv4(sptr_cdb);
        }
}

/* Telnet configuration show routine */
void cli_show_telnet_config(struct cdb* sptr_cdb)
{
        UINT32 idle_timeout, login_timeout, login_retries, timeout;
        UINT32 i, ipv4_addr, len;
        IPV6_ADDRESS ipv6_addr;
        enum BOOLEAN atleast_one_found = FALSE, print_comma = FALSE;
        UINT16 acl_id;
        MAC_ADDRESS t_mac_addr= { 0, 0 };
        /* Each IPv4 address requires 15 characters. 2 characters for space and comma
         * For example: 200.200.200.201
         */
        char ipv4_addr_buffer[17*10] = "";
        /* Each IPv6 address requires 39 characters. 2 characters for space and comma
         * For example : 3ffe:1934:4545:3112:2040:f8ff:fe21:6001
         */
        char ipv6_addr_buffer[41*10] = "";
        char *temp = NULL;

        if (sptr_cdb->config_gen || sptr_cdb->no)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        uprintf("Telnet server                  : ");
        if (cu_telnet_get_status())
                uprintf("Enabled\n");
        else
                uprintf("Disabled\n");

        idle_timeout = cu_telnet_get_idle_timeout();
        uprintf("Idle timeout (minutes)         : %d\n", idle_timeout);

        login_timeout = cu_telnet_get_login_timeout();
        uprintf("Login timeout (minutes)        : %d\n", login_timeout);

        login_retries = cu_telnet_get_login_retries();
        uprintf("Login retries                  : %d\n", login_retries);

    if(!(IS_SICA())) {
        uprintf("Strict management VRF          : ");
        if(cu_telnet_get_strict_mvrf())
                uprintf("Enabled\n");
        else
                uprintf("Disabled\n");
    }

        uprintf("Authentication                 : ");
        if (cu_telnet_get_aaa_status())
                uprintf("Enabled\n");
        else
                uprintf("Disabled\n");  

        uprintf("suppress-reject-message        : ");
        if (cu_telnet_get_suppress_reject_message())
                uprintf("Enabled\n");
        else
                uprintf("Disabled\n");

        memset(ipv4_addr_buffer, 0, sizeof(ipv4_addr_buffer));
        uprintf("Telnet IPv4 clients            :");
        len = 0;
        for (i = 1;; i++)
        {
                if (cu_find_client_entry(TELNET_CLIENT, i, &ipv4_addr, &t_mac_addr) == CU_INVALID_INDEX)
                        break;
                /* Print comma before all the entries excpept first one */
                if (len)
                {
                        ksprintf(&(ipv4_addr_buffer[len]), ", ");
                        len++;
                }
                ksprintf(&(ipv4_addr_buffer[len]), " %I", ipv4_addr);
                len = strlen(ipv4_addr_buffer);
        }
        if (0 == strlen(ipv4_addr_buffer))
                uprintf(" All\n");
        else
        {
                if (NULL != (temp = (char *)cu_cli_format_long_string(ipv4_addr_buffer, 29, FALSE)))
                        uprintf("%s\n", temp);
                else uprintf("Something went wrong\n");
        }

        memset(ipv6_addr_buffer, 0, sizeof(ipv6_addr_buffer));
        uprintf("Telnet IPv6 clients            : ");
        len = 0;
        for (i = 1;; i++)
        {
                if (cu_find_v6_client_entry(TELNET_CLIENT, i, &ipv6_addr) == CU_INVALID_INDEX)
                        break;
                /* Print comma before all the entries excpept first one */
                if (len)
                {
                        ksprintf(&(ipv6_addr_buffer[len]), ", ");
                        len += 2;
                }

                ipv6_address_to_string(&ipv6_addr, &(ipv6_addr_buffer[len]));
                len = strlen(ipv6_addr_buffer);
        }
        if (0 == strlen(ipv6_addr_buffer))
                uprintf("All\n");
        else
        {
                if (NULL != (temp = (char *)cu_cli_format_long_string(ipv6_addr_buffer, 29, FALSE)))
                {
                        uprintf("%s\n", temp);
                        dy_free(temp);
                } else uprintf("Something went wrong\n");
        }

        uprintf("Telnet IPv4 access-group       : ");
        acl_id = g_sw_sys.telnet_acl_id;
        if (acl_id)
        {
                if (IS_STD_NAMED_ACL_ID(acl_id))
                        uprintf("%s", ACL_id_to_std_name(acl_id));
                else
                        uprintf("%d", acl_id);
        }
        uprintf("\n");

        uprintf("Telnet IPv6 access-group       : ");
        if (g_sw_sys.ip6_telnet_acl_name[0] != '\0')
        {
                uprintf("%s", g_sw_sys.ip6_telnet_acl_name);
        }
        uprintf("\n");
        return;                                  
}

void show_telnet(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

                if (end_of_token(sptr_cdb->token) != '\0')
                        return;
        
                sptr_cdb->dont_go_next = 1;
        cu_show_telnet();
                cu_show_ssh();
}

#ifdef SR_SWITCH_ONLY
void enable_layer3Switch0(struct cdb* sptr_cdb)
{
        int mode;

        if (sptr_cdb->config_gen)
        {
                return;
        }
        else
        {
                if (sptr_cdb->no)
                        cu_set_l3_switch_mode(SW_DFLT_IP_L3_SWITCH_MODE);
                else
                        cu_set_l3_switch_mode(1); /* 1: enable */
        }
}

void enable_layer3Switch(struct cdb* sptr_cdb)
{
        int mode;

        if (sptr_cdb->config_gen)
        {
                mode = cu_get_l3_switch_mode(1);
                if (mode == SW_DFLT_IP_L3_SWITCH_MODE) /* default is disabled */
                        return;
                else
                        wr_config(sptr_cdb, "ip-route-accelerating\n");
        }
        else
        {
                if (sptr_cdb->no)
                        cu_set_l3_switch_mode(SW_DFLT_IP_L3_SWITCH_MODE);
                else
                        cu_set_l3_switch_mode(1); /* 1: enable */
        }
}

void show_ip_traffic(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        cu_show_ip_traffic();
}

void clear_ip_traffic(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        cu_clear_ip_traffic();
}
#endif /* SR_SWITCH_ONLY */



void show_vlan_port(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                return;

#ifndef NO_MULTI_CONFIG_VLAN
        sptr_cdb->vlan_id_action_next = 0;      /* BUG:72943 */
        cu_show_new_all_vlan(TRUE, INTERFACE_TO_PORT_ID(sptr_cdb->if1), sptr_cdb); /* BUG:72943 */
#else
        cu_show_all_vlan(TRUE, INTERFACE_TO_PORT_ID(sptr_cdb->if1), 0);
#endif NO_MULTI_CONFIG_VLAN

}

/*  FUNCTION:
 *              show_vlan_port_brief()
 *
 *  SYNOPSIS:
 *              "show vlan brief ethernet <slot/port>" target function.
 *              displays all vlans that have the port as a member.
 */
void show_vlan_port_brief(struct cdb* sptr_cdb)
{
        VLAN_MASK vlanmask;
        UINT16 vlan_id, count;
        PORT_ID port_number;
		VLAN_INDEX vlan_index;
		
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }

        port_number = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        vlanmask_clear_all(&vlanmask);
        count = 0;

        for (vlan_id = MIN_VLAN_ID; vlan_id <= MAX_VLAN_ID; vlan_id++)
        {
                if (vlanlib_is_port_member(vlan_id, port_number))
                {
                        VLAN_MASK_SET(vlanmask, vlan_id);
                        count++;
                }
        }

        vlanmask_to_string(&vlanmask, cu_line_buf, CU_LINE_BUF_SIZE);
        uprintf("\n%s %p is a member of %d VLANs\n",(IS_LAG_AP(port_number)? "Lag" : "Port"), port_number, count);
        uprintf("VLANs %s\n", cu_line_buf);

		vlan_id = SW_DFLT_VLAN_ID;
		VLAN_MASK_CLR(vlanmask,SW_DFLT_VLAN_ID);
		vlan_index = (SPTR_PORT_DB(port_number))->port_config.port_vlan_idx;
		if(vlan_index != VLAN_INDEX_INVALID)
		{
			if (port_is_dual_mode(port_number))
			{
				vlan_id = VLAN_ID_FROM_IDX(vlan_index);
			}
			else if((SPTR_PORT_DB(port_number))->port_config.mode == UNTAGGED)
			{
				vlan_id	= VLAN_ID_FROM_IDX(vlan_index);
				VLAN_MASK_CLR(vlanmask,vlan_id);
			}
		}
		vlanmask_to_string(&vlanmask, cu_line_buf, CU_LINE_BUF_SIZE);

		uprintf("Untagged VLAN  : %d\n",  vlan_id);
		uprintf("Tagged   VLANs : %s\n\n", cu_line_buf);

		return;
}

void dm_stg_show_one(struct cdb* sptr_cdb)
{
extern void cu_show_stpctrl_by_id(int id);
        if (sptr_cdb->config_gen)
                return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        cu_show_stpctrl_by_id((UINT16)sptr_cdb->integer1);
}



void show_vlan_Id(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        if (!valid_integer1_value_range(sptr_cdb, CU_MIN_VLAN_ID_VAL, CU_MAX_VLAN_ID_VAL))
                return;
        cu_show_vlan_by_id((UINT16)sptr_cdb->integer1, 0);
}

void show_vlan_brief(struct cdb* sptr_cdb)
{
        VLAN_MASK vlanmask;
        UINT16 vlan_id;
        PORT_ID port_number;
        UINT32  vlan_index, count, index;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        vlanmask_clear_all(&vlanmask);
        count = 0;

        for (vlan_id = MIN_VLAN_ID; vlan_id <= MAX_VLAN_ID; vlan_id++)
        {
                if(vlan_id==g_cpu_vlan_id) // 78838
                        continue;

                vlan_index = VLAN_IDX_FROM_VLAN_ID(vlan_id);

                if ( (vlan_index!= VLAN_INDEX_INVALID) && (g_sptr_vlan_db+vlan_index)->vlan_inuse )
                {
                        VLAN_MASK_SET(vlanmask, vlan_id);
                        count++;
                }
        }
        vlanmask_to_string(&vlanmask, cu_line_buf, CU_LINE_BUF_SIZE);

        index = cu_get_sys_param_index("vlan");
        if ((index != 0) && (index < cu_get_sys_param_table_size()))
        {
                uprintf("\nSystem-max vlan Params: Max(%d) Default(%d) Current(%d)\n",
                                fndry_system_parameters[index].max, fndry_system_parameters[index].def,
                                fndry_system_parameters[index].current);
        }
        uprintf("Default vlan Id :%d\n", SW_DFLT_VLAN_ID);
        uprintf("Total Number of Vlan Configured :%d\n", count);
        uprintf("VLANs Configured :%s\n\n", cu_line_buf);
}

void show_vlan_Id_skip(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (!valid_integer1_value_range(sptr_cdb, CU_MIN_VLAN_ID_VAL, CU_MAX_VLAN_ID_VAL))
                return;
        cu_show_vlan_by_id((UINT16)sptr_cdb->integer1, (UINT16)sptr_cdb->integer2);
}

enum BOOLEAN is_gi_jumbo_mode_supported_on_this_platform(void)
{
        return TRUE;
}

enum BOOLEAN is_gi_jumbo_mode_enabled(void)
{
        if(bm_is_jumbo_mode_current())
                return TRUE;
        return FALSE;
}

void cli_set_tanto_rear_module(struct cdb* sptr_cdb, int rear_module_id)
{
    if(!(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE))
        return;

    if(sptr_cdb != NULL)
    {
        sptr_cdb->dont_go_next = 1;

        if (end_of_token(sptr_cdb->token) != '\0')
            return;

        if (sptr_cdb->config_gen)
            return;

        if(sptr_cdb->no)
        {
            rear_module_id = TANTO_REAR_MODULE_DEFAULT;
        }
    }

    if(stack_set_tanto_rear_module_info(rear_module_id, TANTO_REAR_INFO_CONFIG) == 0)
    {
        //g_stacking.eeprom_data_current.tanto_rear_module_id = rear_module_id;
        if(sptr_cdb != NULL)
        {
            uprintf("ICX-7650 rear module setting changes requires a reload to take effect!!! \n");
        }
    }
}



static BOOLEAN s_rear_module_xstack_skip_check_trunk = FALSE;
static struct cdb s_rear_module_xstack_cdb;
static void (*callback_rear_module_xstack_remove_trunk_caller)(struct cdb* sptr_cdb);
static void callback_rear_module_xstack_remove_trunk(int yes, UINT32 param2, UINT32 param3)
{
	if (yes)
	{
		s_rear_module_xstack_skip_check_trunk = TRUE;
		stack_remove_trunk_cfg();
		callback_rear_module_xstack_remove_trunk_caller(&s_rear_module_xstack_cdb); // call the cli function again
		s_rear_module_xstack_skip_check_trunk = FALSE;
	}
	release_confirm_mode();
}
static BOOLEAN dispatch_confirm_mode_rear_module_xstack_check_trunk(struct cdb* sptr_cdb, void(*caller)(struct cdb* sptr_cdb))
{
	if (!s_rear_module_xstack_skip_check_trunk && stack_exists_trunk_cfg())
	{
		memcpy(&s_rear_module_xstack_cdb, sptr_cdb, sizeof(struct cdb));
		callback_rear_module_xstack_remove_trunk_caller = caller;
		uprintf("Warning: trunk configuration will be removed! Continue?");
		set_confirm_mode(callback_rear_module_xstack_remove_trunk, 0, 0);
		return TRUE;
	}
	return FALSE;
}

static void cli_set_tanto_rear_module_stack_100G(struct cdb* sptr_cdb)
{
    if(stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_CONFIG) == TANTO_REAR_MODULE_STACK_100G)
        return;
    
	//@TODO: need more discuss on the behavior of removing trunk.
	//if (dispatch_confirm_mode_rear_module_xstack_check_trunk(sptr_cdb, cli_set_tanto_rear_module_stack_100G))
	//	return;

    cli_set_tanto_rear_module(sptr_cdb, TANTO_REAR_MODULE_STACK_100G);

    uprintf("The rear module operates in stacking mode with 100Gbps speed after reload.\n");
}

void cli_set_tanto_rear_module_stack_40G(struct cdb* sptr_cdb)
{
    if(stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_CONFIG) == TANTO_REAR_MODULE_STACK_40G)
    {
		if(!sptr_cdb->no)
		    return;
    }
    else
    {
        if(sptr_cdb->no)
        {
            uprintf("The rear module is not stack-40g yet!\n");
            return;
        }
    }
       


    if(!sptr_cdb->no)
	{
		cli_set_tanto_rear_module(sptr_cdb, TANTO_REAR_MODULE_STACK_40G);
        uprintf("The rear module operates in stacking mode with 40Gbps speed after reload.\n");
	}
    else
        cli_set_tanto_rear_module_stack_100G(sptr_cdb);
}

extern void unconfigure_confirm_callback(UINT32 yes, UINT32 param2, UINT32 param3);

void cli_set_tanto_rear_module_uplink_100G(struct cdb* sptr_cdb)
{
    if(stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_CONFIG) == TANTO_REAR_MODULE_UPLINK_100G)
    {
		if(!sptr_cdb->no)
		    return;
    }
    else
    {
        if(sptr_cdb->no)
        {
            uprintf("The rear module is not uplink-100g yet!\n");
            return;
        }
    }

    if(!sptr_cdb->no)
	{
		if(!stack_allow_rear_module_uplink())
		{
			uprintf("Cannot set rear module to uplink mode when the stack is active.\n");
			uprintf("Please use 'stack unconfigure all' to unconfigure the stack.\n");
			return;
		}
		if (IS_TANTO_48GP())
		{
            uprintf ("Rear module uplink-100g is not a supported option in ICX7650-48P.");
            return;
		}
		cli_set_tanto_rear_module(sptr_cdb, TANTO_REAR_MODULE_UPLINK_100G);
        uprintf("The rear module would operate in uplink mode with 100Gbps speed after reload.\n");
        uprintf("After reload, rear module ports will be configured as uplink ports, and module 2 will be unused.\n");
	}
    else
        cli_set_tanto_rear_module_stack_100G(sptr_cdb);
}

void cli_set_tanto_rear_module_uplink_40G(struct cdb* sptr_cdb)
{
    if(stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_CONFIG) == TANTO_REAR_MODULE_UPLINK_40G)
    {
		if(!sptr_cdb->no)
            return;
    }
    else
    {
        if(sptr_cdb->no)
        {
            uprintf("The rear module is not uplink-40g yet!\n");
            return;
        }
    }
    
    if(!sptr_cdb->no)
	{
		if(!stack_allow_rear_module_uplink())
		{
			uprintf("Cannot set rear module to uplink mode when the stack is active.\n");
			uprintf("Please use 'stack unconfigure all' to unconfigure the stack.\n");
			return;
		}

		cli_set_tanto_rear_module(sptr_cdb, TANTO_REAR_MODULE_UPLINK_40G);
        uprintf("The rear module would operate in uplink mode with 40Gbps speed after reload.\n");
        uprintf("After reload, rear module ports will be configured as uplink ports, and module 2 will be unused.\n");
	}
    else
        cli_set_tanto_rear_module_stack_100G(sptr_cdb);
}

void cli_generate_tanto_rear_module_config(struct cdb* sptr_cdb)
{
    if (sptr_cdb->config_gen)
    {
        sptr_cdb->dont_go_next = 1;

        switch(stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_CONFIG))
        {
            case TANTO_REAR_MODULE_STACK_100G:
            {
                //ksprintf(cu_line_buf, "rear-module stack-100g\n");
                //wr_config(sptr_cdb, cu_line_buf);
                wr_config(sptr_cdb, "!\n");
                break;
            }
            case TANTO_REAR_MODULE_STACK_40G:
            {
                ksprintf(cu_line_buf, "rear-module stack-40g\n");
                wr_config(sptr_cdb, cu_line_buf);
                wr_config(sptr_cdb, "!\n");
                break;
            }
            case TANTO_REAR_MODULE_UPLINK_100G:
            {
                ksprintf(cu_line_buf, "rear-module uplink-100g\n");
                wr_config(sptr_cdb, cu_line_buf);
                wr_config(sptr_cdb, "!\n");          
                break;
            }
            case TANTO_REAR_MODULE_UPLINK_40G:
            {
                ksprintf(cu_line_buf, "rear-module uplink-40g\n");
                wr_config(sptr_cdb, cu_line_buf);
                wr_config(sptr_cdb, "!\n");          
                break;
            }
            default:
            {
                break;
            }
        }
    }
	else
	{
		if(sptr_cdb->no)
		{
			if (end_of_token(sptr_cdb->token) != '\0')
				return;

			sptr_cdb->dont_go_next = 1;
			cli_set_tanto_rear_module_stack_100G(sptr_cdb);
		}
	}
}

void set_gi_jumbo_mode(struct cdb *sptr_cdb)
{
        UINT32 system_type = querySysType ();
#ifdef __PORT_EXTENSION__
        if(is_in_pe_or_provisional_pe_mode())
        {
                pe_set_gi_jumbo_mode(sptr_cdb);
                return;
        }
#endif __PORT_EXTENSION__

        if (sptr_cdb->config_gen)
        {
                if (is_gi_jumbo_mode_supported_on_this_platform() && bm_is_jumbo_mode_config())
                {
                        ksprintf(cu_line_buf, "jumbo\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (is_gi_jumbo_mode_supported_on_this_platform())
                        sw_gi_set_jumbo_mode(!sptr_cdb->no);
                else
                        uprintf ("Jumbo not supported on this platform.\n");
        }
}

void set_cut_through_enable(int enable)
{
    gi_cut_through_enable = enable;
    return;
}


void set_gi_cut_through_enable(struct cdb *sptr_cdb)
{

    if (sptr_cdb->config_gen)
    {
#if 0
        if (is_gi_cut_through_mode_supported_on_this_platform() && (!gi_cut_through_enable))
        {
            ksprintf(cu_line_buf, "store-and-forward\n");
            wr_config(sptr_cdb, cu_line_buf);
        }
#endif
    } 
    else
    {
        if (is_gi_cut_through_mode_supported_on_this_platform())
        {
            sw_gi_set_cut_through_enable(sptr_cdb->no);
        }
        else
        {
            uprintf ("Cut-through not supported on this platform.\n");
        }
    }
}


UINT8 ip_cu_error_string[IP_ERR_MAX][PARSER_STRING_LEN] =
{
        "No error",     // IP_OK
        "Error",        //IP_ERR

        "ITC not successful",                   //IP_ERR_ITC
        "Invalid TTL value should be between 1 and 255", //IP_INVLD_TTL
        "Cannot enable dr-aggregate & net-aggregate at the same time", //IP_DR_AND_NET_AGGR
        "Invalid update interval should be between 1 and 60", //IP_NET_UPDATE_INTVL
        "We only support up to 4 default networks", //IP_MAX_DEF_NET
        "Invalid network address", //IP_INVLD_NET_ADDR

        "Trace Route Failed, no response from target node.",
        "No response from target or intermediate node.",
        "Trace Route operation is already in progress!",
        "Target Node IP(v6) address is a local address!",
        "Target Node IP(v6) address is a broadcast address!",
        "Target Node IP(v6) address is a loopback address!",
        "Target Node IP(v6) address is invalid!",
        "Cannot transmit packet to target node.",
        "Bad minttl value, valid value is in range 1 - 255.",
        "Bad maxttl value, valid value is in range 1 - 255.",
        "Bad maxttl value, maxttl is less than minttl!",
        "Bad timeout value, valid value is in range 1 - 120.",
        "Inactive source IP(v6) address.",
        "Trace route aborted",
        "Invalid IP cam age value",
        "Invalid ui_port"
};
static char ip_err_string_buffer[PARSER_STRING_LEN];

char *ip_err_to_string(UINT32 err_no, char *port_buf)
{
        if (port_buf == NULL)
                port_buf = ip_err_string_buffer;

        if (err_no < IP_ERR_MAX)
        {
                ksprintf(port_buf, "IP: Errno(%d) %s", err_no, ip_cu_error_string[err_no]);
        }
        return port_buf;
}

#ifdef SR_SWITCH_ROUTER
#ifndef NO_ROUTE_AGGREGATION
extern UINT32 do_route_aggr;
extern UINT32 aggr_update_interval;
extern void ip_disable_route_aggregation(void);
extern void ip_enable_route_aggregation(void);
extern void fpip_show_route_aggregate_one(UINT32 ip_address);
extern void fpip_show_route_aggregate(UINT32 lines_to_skip);

void enable_ip_route_aggregate(struct cdb* sptr_cdb)
{
        UINT32 old_value;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                sptr_cdb->dont_go_next = 1;     // tell parser this cmd ends here
                old_value = do_route_aggr;
                if (sptr_cdb->no)
                {
                        do_route_aggr = 0;
                }
                else
                {
                        if (ip.dr_netcache_enabled == TRUE)
                        {
                                uprintf("Error - cannot enable net-aggregate when dr-aggregate is ON\n");
                                return;
                        }

                        if (sptr_cdb->integer1 == 0)
                                sptr_cdb->integer1 = 1;

                        if (!valid_integer1_value_range(sptr_cdb, 1, 60))
                                return;

                        aggr_update_interval = sptr_cdb->integer1;

                        do_route_aggr = 1;
                }
                if ((init_in_progress == FALSE) && (old_value != do_route_aggr))
                {
                        if (do_route_aggr == 0)
                                ip_disable_route_aggregation();
                        else
                                ip_enable_route_aggregation();
                }
        } else {
                if (do_route_aggr == 0)
                        return; /* default OFF */
                if (aggr_update_interval != 1)
                        ksprintf(cu_line_buf, "ip net-aggregate %d\n", aggr_update_interval);
                else
                        ksprintf(cu_line_buf, "ip net-aggregate\n");
                wr_config(sptr_cdb, cu_line_buf);
                sptr_cdb->dont_go_next = 1;     // tell parser this cmd ends here
        }
}

void show_ip_route_aggregate_one(struct cdb* sptr_cdb)  /* show_ip_cache_one */
{
        if (sptr_cdb->config_gen)
          return;

        fpip_show_route_aggregate_one(sptr_cdb->ip1);
}

void show_ip_route_aggregate_with_index(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        fpip_show_route_aggregate(sptr_cdb->integer1);          /* indexed print */
}

void show_ip_route_aggregate(struct cdb* sptr_cdb)              /* show_ip_route */
{
        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        fpip_show_route_aggregate(0xFFFFFFFF);                  /* page mode print */
}

extern void fpip_set_route_aggr_show_not_eligible(void);
void show_ip_route_aggregate_not_eligible(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        fpip_set_route_aggr_show_not_eligible();
        fpip_show_route_aggregate(0xFFFFFFFF);                  /* page mode print */
}
#endif NO_ROUTE_AGGREGATION

#ifndef NO_DR_NETCACHE
void enable_ip_dr_netcache(struct cdb* sptr_cdb)
{
        BYTE old_value;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                sptr_cdb->dont_go_next = 1;     // tell parser this cmd ends here
                old_value = ip.dr_netcache_enabled;
                if (sptr_cdb->no)
                {
                        ip.dr_netcache_enabled = FALSE;
                }
                else
                {
                        if (do_route_aggr == 1)
                        {
                                uprintf("Error - cannot enable dr-aggregate when net-aggregate is ON\n");
                                return;
                        }
                        ip.dr_netcache_enabled = TRUE;
                }
                if (old_value != ip.dr_netcache_enabled)
                        ip_flush_associated_cache_entries((IP_FORWARDING_ROUTE_ENTRY *)(ip.default_route.route_info), 0xFF, IP_UNICAST_SAFI);
        } else {
                if (ip.dr_netcache_enabled == FALSE)
                        return; /* default OFF */
                wr_config(sptr_cdb, "ip dr-aggregate\n");
        }
}

void clear_ip_dr_netcache(struct cdb* sptr_cdb)
{
        extern void fpip_flush_dr_netcache(UINT32);
        int rc;

        if (sptr_cdb->config_gen)
          return;

        fpip_flush_dr_netcache(0xFFFFFFFF);
}

void create_ip_dr_netcache_one(struct cdb* sptr_cdb)
{
        extern int fpip_create_dr_netcache_entry(UINT32);
        int rc;

        if (sptr_cdb->config_gen)
          return;

        if (0 == (rc = fpip_create_dr_netcache_entry(sptr_cdb->ip1)))
                uprintf("A DR net cache was created\n");
        else if (1 == rc)
                uprintf("Error - a host cache was created\n");
        else if (2 == rc)
                uprintf("Error - a net cache for this target already exists\n");
        else if (3 == rc)
                uprintf("Error - the specified target is not on default route\n");
}

void show_ip_dr_netcache_one(struct cdb* sptr_cdb)      /* show_ip_cache_one */
{
        extern void fpip_show_dr_netcache_one(UINT32);

        if (sptr_cdb->config_gen)
          return;

        fpip_show_dr_netcache_one(sptr_cdb->ip1);
}

void show_ip_dr_netcache_with_index(struct cdb* sptr_cdb)
{
        extern void fpip_show_dr_netcache(UINT32);

        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        fpip_show_dr_netcache(sptr_cdb->integer1);              /* indexed print */
}

void show_ip_dr_netcache(struct cdb* sptr_cdb)          /* show_ip_route */
{
        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        fpip_show_dr_netcache(0xFFFFFFFF);                      /* page mode print */
}
#endif NO_DR_NETCACHE

void show_ip_cache_one(struct cdb* sptr_cdb)
{
        extern void fpip_show_route_cache_one(UINT32);

        if (sptr_cdb->config_gen)
          return;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        DISPLAY_SET_SAFI(IP_UNICAST_SAFI);
        DISPLAY_SET_VRF_INDEX(sptr_cdb->vrf_idx);

        //Cheetah_stacking, superX safe.
        if(STACK_AM_I_SLAVE) //87617
                return;
        fpip_show_route_cache_one(sptr_cdb->ip1);
}

void show_ip_cache(struct cdb* sptr_cdb)
{
        extern void fpip_show_route_cache(UINT32);

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        DISPLAY_SET_SAFI(IP_UNICAST_SAFI);
        DISPLAY_SET_VRF_INDEX(sptr_cdb->vrf_idx);

        //Cheetah_stacking, superX safe.
        if(STACK_AM_I_SLAVE) //87617
                return;
        fpip_show_route_cache(0xFFFFFFFF);
}

void show_ip_cache_resource (struct cdb* sptr_cdb)
{
    if (sptr_cdb->config_gen)
          return;

    fpip_show_route_cache_resource (); 
}

void show_ip_cache_with_index(struct cdb* sptr_cdb)
{
        extern void fpip_show_route_cache(UINT32);

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        DISPLAY_SET_SAFI(IP_UNICAST_SAFI);
        DISPLAY_SET_VRF_INDEX(sptr_cdb->vrf_idx);

        //Cheetah_stacking, superX safe.
        if(STACK_AM_I_SLAVE) //87617
                return;
        fpip_show_route_cache(sptr_cdb->integer1);
}

#ifdef IP_POLICY_ROUTING
void show_ip_policy_cache(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        ip_show_policy_flow_cache( (UINT32 *)NULL, (UINT32 *)NULL );
}
#endif IP_POLICY_ROUTING

void show_ip_filter_cache(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        ip_show_flow_cache( (UINT32 *)NULL, (UINT32 *)NULL );
}

void show_ip_filter_cache_address(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        ip_show_flow_cache( (UINT32 *)&sptr_cdb->ip1, (UINT32 *)NULL );
}

void show_ip_filter_cache_address_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        ip_show_flow_cache( (UINT32 *)&sptr_cdb->ip1, (UINT32 *)&sptr_cdb->ip2 );
}


void show_ip_interfaces(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        ip_show_all_interfaces();
}

void show_ip_int_enet_num(struct cdb* sptr_cdb)
{
        UINT16 port_id;

        if (sptr_cdb->config_gen)
                return;

        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                return;

        port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if1);

#ifdef NOT_USED
        if (sptr_cdb->integer1 < 1 ||
            sptr_cdb->integer1 > g_hw_info.number_of_ports)
        {
                uprintf("Error - port number out of range\n");
                return;
        }
#endif NOT_USED

        ip_show_one_interface(port_id);
}

void show_ip_int_ve_num(struct cdb* sptr_cdb)
{
        UINT16 port_id;

        if (sptr_cdb->config_gen)
                return;

        if (! valid_integer1_value_range(sptr_cdb, 1, EXTERNAL_VE_MAX) )
                return;
#ifdef NOT_USED
        if (sptr_cdb->integer1 < 1 ||
            sptr_cdb->integer1 > EXTERNAL_VE_MAX)
        {
                uprintf("Error - port number out of range\n");
                return;
        }
#endif NOT_USED

        port_id = external_ve_lookup(sptr_cdb->integer1 - 1);
        if (is_internal_ve_valid(port_id) == FALSE) {
                uprintf("Error - non-existent ip virtual interface\n");
                return;
        }
        port_id = VID_TO_ROUTER_INT(port_id);

        if (IP_IP_PORT(port_id).member_mask == 0)
        {
                uprintf("Error - non-existent IP virtual interface\n");
                return;
        }

        ip_show_one_interface(port_id);
}

void show_ip_int_loopback_num(struct cdb* sptr_cdb)
{
        UINT16 port_id=LBID_TO_ROUTER_INT(sptr_cdb->integer1-1);

        if (sptr_cdb->config_gen)
                return;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_LOOPBACK_INT))
                return;

        ip_show_one_interface(port_id);
}


#ifdef MPLS
void show_ip_route_tunnel(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        ip_show_mpls_tnnl_route(1, TRUE, 0);
}
#endif

void show_ip_traffic(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        ip_show_statistics();
}

void show_ip_mtu(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        ip_show_mtu_profile(FALSE);
}
void show_ip_mtu_detail(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        ip_show_mtu_profile(TRUE);
}

/* config cmds */
void check_no_ip_arpAge(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
        {
                ip.arp.cache_timeout = DEFAULT_ARP_CACHE_TIMEOUT;
                sptr_cdb->dont_go_next = 1;
        }
}

//88938
void check_no_ip_cacheAge(struct cdb* sptr_cdb)
{
}


//88938
void set_ip_cacheAge(struct cdb* sptr_cdb)
{

}


void set_ip_arpAge(struct cdb* sptr_cdb)
{
#ifdef NOT_USED
        char temp[] = "ip arp-age ";
#endif  /* NOT_USED */

        if (sptr_cdb->config_gen)
        {

                if (ip.arp.cache_timeout == DEFAULT_ARP_CACHE_TIMEOUT)
                        return;
                else
                {
#ifdef NOT_USED
                        wr_config(sptr_cdb, temp);
                        ksprintf(cu_line_buf, "%d\n", ip.arp.cache_timeout);
                        wr_config(sptr_cdb, cu_line_buf);
#endif  /* NOT_USED */
                        ksprintf(cu_line_buf, "ip arp-age %d\n", ip.arp.cache_timeout);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no) {
                        ip.arp.cache_timeout = DEFAULT_ARP_CACHE_TIMEOUT;
                } else {
#ifdef DEBUG
                        uprintf("ip arp-age %d\n",sptr_cdb->integer1);
#endif

                        if (! valid_integer1_value_range(sptr_cdb, 0, 240))
                                return;
#ifdef NOT_USED
                        if (sptr_cdb->integer1 < 0 || sptr_cdb->integer1 > 240)
                        {
                                uprintf("Error - arp age needs to be between 0 and 240\n");
                                return;
                        }
#endif NOT_USED

                        ip.arp.cache_timeout = sptr_cdb->integer1;
                }
        }
}

#ifdef SR_SWITCH_ROUTER
void set_ip_learn_gratuitous_arp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.arp.learn_gratuitous_arp)
                        wr_config (sptr_cdb, "ip arp learn-gratuitous-arp\n");
        }
        else
        {
                if (sptr_cdb->no)
                {
                        ip.arp.learn_gratuitous_arp = 0;
                }
                else
                {
                        ip.arp.learn_gratuitous_arp = 1;
                }
        }
}
#endif SR_SWITCH_ROUTER

void check_no_ip_router_id(struct cdb* sptr_cdb)
{
        IP_ERR_NO err = IP_OK;
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->mode_vrf_idx != IPVRF_DEFAULT_VRF_IDX)
        {
                sptr_cdb->num_of_string = 1 ;
                strncpy(sptr_cdb->string1, sptr_cdb->mode_vrf_name, sizeof(sptr_cdb->mode_vrf_name));
                sptr_cdb->string1[sizeof(sptr_cdb->vrf_name) - 1] = '\0';
                sptr_cdb->vrf_idx = sptr_cdb->mode_vrf_idx;
        }

        if (sptr_cdb->no)
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return; /* cmd not for me */
                sptr_cdb->dont_go_next = 1;

                err = ip_port_send_router_id_msg(0, sptr_cdb->vrf_idx);
                if (err != IP_OK)
                        uprintf("%s\n", ip_err_to_string(err, NULL));
        }
}

extern enum BOOLEAN ip_add_host_route_first;
void set_ip_add_host_route_first(struct cdb* sptr_cdb)
{
     if (sptr_cdb->config_gen)
     {
           if (ip_add_host_route_first)
           {
                 ksprintf(cu_line_buf, "ip add-host-route-first\n");
                 wr_config(sptr_cdb, cu_line_buf);
           }
     }
     else
     {
           if (end_of_token(sptr_cdb->token) != '\0')
               return; /* cmd not for me */
           sptr_cdb->dont_go_next = 1;
    
           if (sptr_cdb->no)
           {
                ip_add_host_route_first = FALSE;
                uprintf("\n Order of host route processing:\n1. Flush buffered packets\n2. Program hardware\n");
           }
           else
           {
                ip_add_host_route_first = TRUE;
                uprintf("\n Order of host route processing:\n1. Program Hardware\n2. Flush buffered packets\n");
           }
      }
}


void set_ip_router_id(struct cdb* sptr_cdb)
{
        IP_ERR_NO err = IP_OK;
        UINT32 router_id;

        if (sptr_cdb->config_gen)
        {
//              if (ip.router_id == 0)
                if (gPortInfo.config_router_id[IPVRF_DEFAULT_VRF_IDX] == 0)
                        return;
                else
                {
//                      ksprintf(cu_line_buf, "ip router-id %I\n", ip.router_id);
                        ksprintf(cu_line_buf, "ip router-id %I\n", gPortInfo.config_router_id[IPVRF_DEFAULT_VRF_IDX]);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return; /* cmd not for me */
                sptr_cdb->dont_go_next = 1;

                if (sptr_cdb->ip1 == 0xFFFFFFFF)
                {
                        uprintf("Error - IP Router-id of 255.255.255.255 not valid\n");
                        return;
                }

                if (sptr_cdb->no)
                {
                        router_id = 0;
                }
                else
                {
                        router_id = sptr_cdb->ip1;
                }

                err = ip_port_send_router_id_msg(router_id, sptr_cdb->vrf_idx);
//              err = ip_port_send_router_id_msg(router_id, IPVRF_DEFAULT_VRF_IDX);
                if (err != IP_OK)
                        uprintf("%s\n", ip_err_to_string(err, NULL));
        }
}

void clear_ip_router_id(struct cdb *sptr_cdb)
{
        IP_ERR_NO err = IP_OK;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        err = ip_port_send_clear_router_id_msg(0, sptr_cdb->vrf_idx);
        if (err != IP_OK)
                uprintf("%s\n", ip_err_to_string(err, NULL));
}
#endif /* SR_SWITCH_ROUTER */

/* TTL setting are applied to both switch and router from now on  --- rkwong 8/7/99 */
void check_no_ip_ttl(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no) {
                ip.mib.ipDefaultTTL = DEFAULT_TTL; /* 64 */
                sptr_cdb->dont_go_next = 1;
        }
}

void set_ip_ttl(struct cdb* sptr_cdb)
{
#ifdef NOT_USED
        char temp[] = "ip ttl ";
#endif  /* NOT_USED */

        if (sptr_cdb->config_gen)
        {

                if (ip.mib.ipDefaultTTL == DEFAULT_TTL)
                        return;
                else
                {
#ifdef NOT_USED
                        wr_config(sptr_cdb, temp);
                        ksprintf(cu_line_buf, "%d\n", ip.mib.ipDefaultTTL);
                        wr_config(sptr_cdb, cu_line_buf);
#endif  /* NOT_USED */
                        ksprintf(cu_line_buf, "ip ttl %d\n", ip.mib.ipDefaultTTL);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no) {
                        ip.mib.ipDefaultTTL = DEFAULT_TTL; /* 64 */
                } else {

                        if (! valid_integer1_value_range(sptr_cdb, 1, 255))
                                return;
#ifdef NOT_USED
                        if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > 255)
                        {
                                uprintf("Error - ttl needs to be between 1 and 255\n");
                                return;
                        }
#endif NOT_USED
                        ip.mib.ipDefaultTTL = sptr_cdb->integer1;
                }
        }
}

#ifdef SR_SWITCH_ONLY
#ifdef __DHCP_CLIENT__
void cli_set_default_gateway_dynamic(struct cdb* sptr_cdb)
{
	// Nothing to do in swo run or wr mem.
	if(sptr_cdb->config_gen)
		return;
	// This hould be the last token. Erturn if not the last token.
	if(end_of_token(sptr_cdb->token) !=0)
		return;
	// Do not process the next token.
	sptr_cdb->dont_go_next = 1;

	// This hould be executed only during reload. Other times, this configuration is not allowed.
	if(!g_sw_sys.init_in_progress) {
		uprintf("Manual configuration is not allowed for this option.\n");
		return;
	}

        
	if (sptr_cdb->no)
           cu_set_dft_gateway_addr(0);
        else
           cu_set_dft_gateway_addr(sptr_cdb->ip1);
	// Now set the variable to STATIC_GATEWAY_DYNAMIC for the configured gatewey.
	ip.default_route.static_gateway = DYNAMIC_GATEWAY;
	return;       
}	
#endif

void set_ip_dGateway(struct cdb* sptr_cdb)
{
        UINT32 ip_address;

        /*
         * Notice that the BOOT code also searches for this "ip default-gateway" keyword
         * from the configuration flash. Therefore, don't change this syntax.
         */
        if (sptr_cdb->config_gen)
        {
                ip_address = cu_get_dft_gateway_addr();

                /* Do not add to config if illegal address */
                if ((ip_address == 0) || (ip.mngt_vlan_id))
                        return;
                else
                {
                        if(ip.default_route.static_gateway == DYNAMIC_GATEWAY) 
				ksprintf(cu_line_buf, "ip default-gateway %I dynamic\n", ip_address);
			else
	                        ksprintf(cu_line_buf, "ip default-gateway %I\n", ip_address);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
        	if (end_of_token(sptr_cdb->token) != '\0'){
                	return;
		}

		sptr_cdb->dont_go_next = 1;  // This line is neededto avoid Incomplete command error.

                /* Do not allow if Management VLAN present */

                if (ip.mngt_vlan_id)
                {
                        uprintf("Management vlan is configured. Please set default gateway under the vlan\n");
                        return;
                }

                if (sptr_cdb->no)
                        cu_set_dft_gateway_addr(0);
                else
                        cu_set_dft_gateway_addr(sptr_cdb->ip1);
        }
}
#endif SR_SWITCH_ONLY

void set_ip_domainName(struct cdb* sptr_cdb)
{
        UINT32 max_domain_list;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
                if (sptr_cdb->config_gen)
                                        return;

        /*
                 * handle add request
                 */
                if (strlen(sptr_cdb->string1) > DNS_MAX_NAME_LENGTH) {
                        uprintf("set_ip_domainList(): Error - DNS domain name length cannot exceed %d\n",
                                        DNS_MAX_NAME_LENGTH);
                        return;
                }

                if(dns_domain_names.orig_def_name != NULL)
                {
                        dns_domain_names.orig_def_name_length = strlen(sptr_cdb->string1);
                        if (dns_domain_names.orig_def_name_length > DNS_MAX_NAME_LENGTH)
                        {
                                uprintf("Error - DNS domain name length cannot exceed %d\n",
                                DNS_MAX_NAME_LENGTH);
                                return;
                        }
                        strncpy(dns_domain_names.orig_def_name, sptr_cdb->string1,DNS_MAX_NAME_LENGTH+4 );
                        dns_cook_string_name(dns_domain_names.orig_def_name, dns_domain_names.def_name);
                        dns_domain_names.def_name_length = strlen(dns_domain_names.def_name);
                }

                if (dns_find_domain(sptr_cdb->string1)) return;

                if (dns_domain_names.orig_def_name_length == 0) {
                        max_domain_list = DNS_MAX_DOMAIN_LIST - 1;
                } else {
                        max_domain_list = DNS_MAX_DOMAIN_LIST;
                }

                if (dns_domain_list.num_of_domains >= max_domain_list) {
                        uprintf("Error - Reached DNS domain list maximum %d, including default domain name (reserves 1 count if not entered yet)\n",
                                        DNS_MAX_DOMAIN_LIST);
                        return;
                }

                if (dns_add_domain(sptr_cdb->string1,FALSE) < 0) { 
                        uprintf("set_ip_domainList(): Failed to add domain name %s\n", sptr_cdb->string1);
                }
}

void set_ip_domainList(struct cdb* sptr_cdb)
{
    char                 *line_ptr = cu_line_buf;
	int wr_flag = 0;

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

    /*
     * handle config gen request
     */
    if (sptr_cdb->config_gen) {
        DNS_DOMAIN *dp;
        dp = dns_domain_list.first_domain;

		while (dp ) {
	        if(!sptr_cdb->show && (dp->name && dp->dynamic))
                dp = dp->next;
            else
            {
                if(dp->dynamic) 
			line_ptr += ksprintf(line_ptr, "ip dns domain-list %s dynamic\n", dp->orig_name);
		else
			line_ptr += ksprintf(line_ptr, "ip dns domain-list %s\n", dp->orig_name);
                 dp = dp->next;
				 wr_flag = 1;
            }
        }

	    if (dns_domain_list.first_domain && wr_flag == 1) 
        {
    		wr_config(sptr_cdb, cu_line_buf);
        }
		return;
    }

    if(dns_domain_names.orig_def_name != NULL)
    {
        dns_domain_names.orig_def_name_length = strlen(sptr_cdb->string1);
        if (dns_domain_names.orig_def_name_length > DNS_MAX_NAME_LENGTH)
        {
                uprintf("Error - DNS domain name length cannot exceed %d\n",
                DNS_MAX_NAME_LENGTH);
                return;
        }
        strncpy(dns_domain_names.orig_def_name, sptr_cdb->string1, DNS_MAX_NAME_LENGTH+4);
        dns_cook_string_name(dns_domain_names.orig_def_name, dns_domain_names.def_name);
        dns_domain_names.def_name_length = strlen(dns_domain_names.def_name);
    }


    /*
     * handle delete request
     */
    if (sptr_cdb->no) {
        if (dns_del_domain(sptr_cdb->string1)) {
            uprintf("No domain name %s found in domain list\n", sptr_cdb->string1);
        }
        return;
    }

    /*
     * handle add request
     */
    if (strlen(sptr_cdb->string1) > DNS_MAX_NAME_LENGTH) {
        uprintf("set_ip_domainList(): Error - DNS domain name length cannot exceed %d\n",
                DNS_MAX_NAME_LENGTH);
        return;
    }

    if (dns_find_domain(sptr_cdb->string1)) return;





    if (dns_domain_list.num_of_domains >= DNS_MAX_DOMAIN_LIST ) {
        uprintf("Error - Reached DNS domain list maximum %d, including default domain name (reserves 1 count if not entered yet)\n",
                DNS_MAX_DOMAIN_LIST);
        return;
    }

    if (dns_add_domain(sptr_cdb->string1,FALSE) < 0) { 
        uprintf("set_ip_domainList(): Failed to add domain name %s\n", sptr_cdb->string1);
    }

    return;
}
void set_ip_nameServer(struct cdb* sptr_cdb)
{
        int i;
        char *cp;
        int first_time = 1;
		int wr_flag = 0;

		if (sptr_cdb->config_gen) /* config gen request */
        {
            if (!dns_servers.num_name_server)
                    return;

            // IPV6 change : This check is needed for the parser to force using IPV6 if it is configured
            if(dns_servers.name_server[0] == 0)
                    return;
            
            for (i=0; i<dns_servers.num_name_server; i++)
            {
                if(!sptr_cdb->show && (dns_servers.name_server[i] && dns_servers.dynamic[i]))
                    continue; 
                if(first_time)
                {
                    wr_config(sptr_cdb, "ip dns server-address");
                    first_time = 0;
					wr_flag = 1;
                }

				if(dns_servers.dynamic[i])
					ksprintf(cu_line_buf, " %I(dynamic)", dns_servers.name_server[i]);
				else
					ksprintf(cu_line_buf, " %I", dns_servers.name_server[i]);
                wr_config(sptr_cdb, cu_line_buf);
            }

			if(wr_flag == 1)
				wr_config(sptr_cdb, "\n");
        }
        else /* normal command execution */
#ifdef NOT_USED
        if ((sptr_cdb->token)[strlen((char*)sptr_cdb->token)-1])
#endif NOT_USED
        {
                cp = sptr_cdb->token;
#ifdef NOT_USED
                /* skip ip address */
                NEXT_TOKEN(cp);
                if (*cp == '?')
                {
                        uprintf("  <cr>\n");
                }
#endif NOT_USED
                if (sptr_cdb->help)
                {
                        return;
                }
                else
                {
                        if (sptr_cdb->no) /* delete request */
                        {
                                for (i=0; i<dns_servers.num_name_server; i++)
                                {
                                        if (dns_servers.name_server[i] == sptr_cdb->ip1)
                                        {
                                                dns_servers.name_server[i] = 0;
						sptr_cdb->num_of_ip=0;
                                                        break;
                                        }
                                }
                                dns_sort_name_servers();
                        }
                        else
                        {
                                for (i=0; i<dns_servers.num_name_server; i++)
                                {
                                        if (dns_servers.name_server[i] == sptr_cdb->ip1)
                                        {
                                                if (end_of_token(sptr_cdb->token) != '\0')
                                                        /* Not end of IP list */
                                                        sptr_cdb->num_of_ip = 0;
                                                else
                                                        sptr_cdb->dont_go_next = 1;
                                                return;
                                        }
                                }

                                if (dns_servers.num_name_server == MAX_NAME_SERVER)
                                {
                                        uprintf("exceeds maximum %d DNS servers\n", MAX_NAME_SERVER);
                                        sptr_cdb->dont_go_next = 1;
                                        return;
                                }
                                else
                                {
                                   dns_servers.name_server[dns_servers.num_name_server] = sptr_cdb->ip1;
                                        dns_servers.num_name_server++;
                                }
                        }

                        if (end_of_token(sptr_cdb->token) != '\0')
                                /* Not end of IP list */
                                sptr_cdb->num_of_ip = 0;
                        else
                                sptr_cdb->dont_go_next = 1;
                }
        }
}
void show_ip_nameServer(struct cdb* sptr_cdb)
{
        int i;
        if (sptr_cdb->config_gen)
                  return;
        if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;
        uprintf("IPV4 DNS server address:\n");
            if (!dns_servers.num_name_server)
                {
                  uprintf("NO ipv4 DNS server address is configured\n");
                        return;
                }

                for (i=0; i<dns_servers.num_name_server; i++)
                {
                        uprintf("%d. %I\n", i+1,dns_servers.name_server[i]);

                }
}
void show_ip_domainList(struct cdb* sptr_cdb)
{
         DNS_DOMAIN *dp;
         char *line_ptr = cu_line_buf;

         if (sptr_cdb->config_gen)
                   return;
         if (end_of_token(sptr_cdb->token) != '\0')
                          return;
     sptr_cdb->dont_go_next = 1;
         dp = dns_domain_list.first_domain;
                  uprintf("DNS Domain-list\n");
                  if(!dp)
                        {
                        uprintf("No DNS Domain-list is configured\n");
                        return;
                        }
                  else
                        {
                        print_dns_domain_list();

                        }

}
extern void show_ipv6_nameServer(struct cdb* sptr_cdb);
void show_ip_dns_server(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                  return;


    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

        uprintf("DNS Server information\n");
        show_ip_domainList( sptr_cdb);
        show_ip_nameServer(sptr_cdb);
        show_ipv6_nameServer(sptr_cdb);


}


#ifdef SR_SWITCH_ROUTER
void set_ip_encap_enet(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no ||        /* no ip encap eth is no-op */
                    IP_IP_PORT(port_id).config.l2_encapsulation == L2_ENCAP_TYPE_ETHERNET) /* no change */
                        return;
                ip_set_interface_encap(port_id, L2_ENCAP_TYPE_ETHERNET);
        }
}


void set_ip_encap_snap(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT16 mtu_index;
        if (sptr_cdb->config_gen)
        {
                if (IP_IP_PORT(port_id).config.l2_encapsulation == L2_ENCAP_TYPE_ETHERNET)
                        return;
                else
                {
                        wr_config(sptr_cdb, " ip encapsulation snap\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if (IP_IP_PORT(port_id).config.l2_encapsulation == L2_ENCAP_TYPE_ETHERNET)
                                return;
                        ip_set_interface_encap(port_id, L2_ENCAP_TYPE_ETHERNET);
                }
                else
                {
                        if (IP_IP_PORT(port_id).config.l2_encapsulation == L2_ENCAP_TYPE_SNAP)
                                return;
                        ip_set_interface_encap(port_id, L2_ENCAP_TYPE_SNAP);
                }
        }
}

void cli_set_port_ip_mtu(struct cdb* sptr_cdb)
{
        UINT16 mtuSize;
        PORT_ID port_id = INTERFACE_TO_PORT_ID (sptr_cdb->if_num);

        if (!IS_IP_PORT_DB_VALID (port_id))
                return;

        if (sptr_cdb->config_gen)
        {
                if (getIpMtuSize (port_id) == IP_IP_PORT (port_id).config.def_mtu)
                        return;
                else
                {
                        ksprintf (cu_line_buf, " ip-port-mtu %d\n", getIpMtuSize (port_id));
                        wr_config (sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (sptr_cdb->no)
        {
                sptr_cdb->dont_go_next = 1;
                mtuSize = IP_IP_PORT (port_id).config.def_mtu;
        }
        else
        {
                mtuSize = (UINT16) sptr_cdb->integer1;

                if (!valid_integer1_value_range (sptr_cdb, IP_MIN_MTU, IP_IP_PORT (port_id).config.max_mtu))
                         return;

                if (getIpMtuSize (port_id) == sptr_cdb->integer1)               /* no change */
                        return;
        }

#if 0
        if (mtuSize < IP_IP_PORT(port_id).config.max_mtu)
                IP_IP_PORT(port_id).route_reply_info.flags.frag_check_req = TRUE;
        else
                IP_IP_PORT(port_id).route_reply_info.flags.frag_check_req = FALSE;
#endif

        if (trunk_port_state (port_id) != TRUNK_NONE)
        {
                UINT32 group_id, k;
                group_id = trunk_group_id (port_id);

                for (k = 0; k < g_sw_load_group[group_id].config_ports; k++)
                {
                        pp_update_hw_mtu (mtuSize, g_sw_load_group[group_id].port_list[k]);
                        IP_IP_PORT (g_sw_load_group[group_id].port_list[k]).config.mtu = mtuSize;
                }
        }
        else
        {
                pp_update_hw_mtu (mtuSize, port_id);
                IP_IP_PORT (port_id).config.mtu = mtuSize;
        }

        #if 0
        if (!init_in_progress && trunk_port_state(port_id) != TRUNK_SECONDARY)
        {
                fpip_flush_cache_selective(port_id, NO_SUCH_PORT, INTERNET_ADDRESS_ANY, FLUSH_BY_INTERFACE);
#ifndef NO_DVMRP
                dvmrp_config_change_notify(port_id);
#endif /* NO_DVMRP */
        }
        #endif
}

void check_no_if_port_mtu(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if(sptr_cdb->no)
                cli_set_port_ip_mtu(sptr_cdb);
}

void check_no_mif_port_mtu(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if(sptr_cdb->no)
                set_mif(sptr_cdb, TRUE, (void*)cli_set_port_ip_mtu);
}

void check_no_if_mtu (struct cdb* sptr_cdb)
{
        UINT16 port_id = INTERFACE_TO_PORT_ID (sptr_cdb->if_num);
                UINT32 min_mtu = IP_MIN_MTU;

        if (sptr_cdb->config_gen)
                return;

                if (sptr_cdb->help)
                {
                        /* dynamically change the help string to reflect the valid range
                         * for the expected decimal input.
                         */
                        UINT32 max_mtu = g_ip_max_ethernet_mtu;
                        UINT32 def_mtu = g_ip_default_ethernet_mtu;
                        
                        if (IS_IP_PORT_DB_VALID(port_id))
                        {
                                if (IS_FI_BCM())
                                {
                                        if (is_virtual_port(port_id) || is_physical_port(port_id))
                                                min_mtu = IP6_MIN_MTU;
                                }
                                
                                max_mtu = IP_IP_PORT (port_id).config.max_mtu;
                                def_mtu = IP_IP_PORT (port_id).config.def_mtu;
                        }

                        ksnprintf(ip_mtu_help_string,
                                        sizeof(ip_mtu_help_string),
                                        "IP MTU valid range <%d - %d>, default:%d",
                                        min_mtu, max_mtu, def_mtu);
                        return;
                }

                if (end_of_token(sptr_cdb->token) != '\0')
                                return;

                if (sptr_cdb->no)
                {
                        sptr_cdb->dont_go_next = 1;
                        if (IP_IP_PORT (port_id).config.mtu == IP_IP_PORT (port_id).config.def_mtu)
                                return;
                        if (ip_set_interface_mtu (port_id, (UINT16)IP_IP_PORT (port_id).config.def_mtu))
                        {
                                uprintf ("Error while resetting port %p MTU %d\n",
                                port_id, IP_IP_PORT (port_id).config.def_mtu);
                        }
                }
}

#ifdef __TUNNEL_INTERFACE__
extern enum BOOL isInvalid_Tunnel ( UINT32 port_id );
#endif /* __TUNNEL_INTERFACE__ */

void set_if_mtu (struct cdb* sptr_cdb)
{
        int status;
        UINT32 min_mtu = IP_MIN_MTU;
        UINT16 port_id = INTERFACE_TO_PORT_ID (sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                if (IP_IP_PORT (port_id).config.mtu == IP_IP_PORT (port_id).config.def_mtu
#ifdef __TUNNEL_INTERFACE__
                    || ( isInvalid_Tunnel ( ROUTER_INT_TO_TNID (port_id) ) )
#endif /* __TUNNEL_INTERFACE__ */
                    )
                        return;
                else
                {
                        ksprintf (cu_line_buf, " ip mtu %d\n", IP_IP_PORT (port_id).config.mtu);
                        wr_config (sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (TRUE == is_loopback_port (port_id))
                {
                        uprintf ("ip mtu is not supported on loopback interface\n");
                        return;
                }

                #ifndef __IPV6_HOST_ONLY__
                if (IS_FI_BCM() && (is_physical_port(port_id) || is_virtual_port(port_id)))
                {
                        min_mtu = IP6_MIN_MTU;
                }
                #endif __IPV6_HOST_ONLY__
                
                if (!valid_integer1_value_range (sptr_cdb, min_mtu, IP_IP_PORT (port_id).config.max_mtu))
                        return;

                if (sptr_cdb->no)
                {
                        if (sptr_cdb->integer1 != IP_IP_PORT (port_id).config.mtu)
                        {
                                if (IS_FI_BCM() 
                                        &&  (IP_IP_PORT (port_id).config.mtu == IP_IP_PORT (port_id).config.def_mtu))
                                {
                                        /* No need to display error on Sidewinder, when mtu is already default mtu.
                                            IPv6 and IP MTU shares same config */                                       
                                        return;
                                }
                                
                                uprintf("Invalid mtu value\n");
                                return;
                        }
                        if (IP_IP_PORT (port_id).config.mtu == IP_IP_PORT (port_id).config.def_mtu)
                        {
                                return;
                        }
                        if (status = ip_set_interface_mtu (port_id, (UINT16)IP_IP_PORT (port_id).config.def_mtu))
                        {
                                uprintf ("Error while removing port %p MTU %d\n",
                                                 port_id, IP_IP_PORT (port_id).config.def_mtu);
                        }
                }
                else
                {
#ifdef __TUNNEL_INTERFACE__
                        UINT16 tunnel_id = ROUTER_INT_TO_TNID (port_id);
                        if (is_gre_ip_tunnel_port (port_id))
                        {
				if (!is_GRE_IPv4_over_IPv4_tunnel(tunnel_id) 
#ifdef __FI_IPSEC_IKE__
						&& !is_IPsec_IPv4_over_IPv4_tunnel(tunnel_id)
#endif __FI_IPSEC_IKE__
						)
				{
#ifdef __FI_IPSEC_IKE__
					uprintf ("Error - IP mtu can be configured ONLY on IPv4 GRE Or IPSEC/IPv4 tunnels\n");
#else
					uprintf ("Error - IP mtu can be configured ONLY on IPv4 GRE tunnels\n");
#endif __FI_IPSEC_IKE__
					return;
				}
                        }
#endif __TUNNEL_INTERFACE__

                        if (IP_IP_PORT (port_id).config.mtu == sptr_cdb->integer1)               /* no change */
                                return;

#ifdef __TUNNEL_INTERFACE__
                        if (is_Interface_GRE_IPv4_over_IPv4_tunnel (port_id))
                        {
                                if (IS_TUNNEL_NEXTHOP_VALID (&g_tunnel_table[tunnel_id]) &&
                                        (0 != g_tunnel_table[tunnel_id].pathMtuSize) &&
                                        (sptr_cdb->integer1 > g_tunnel_table[tunnel_id].pathMtuSize - IPV4_GRE_MTU_ADJUSTMENT))
                                {
                                        uprintf ("Warning: Configuring mtu larger than %u discovered " \
                                                         "by pmtu mechanism\n",
                                                         g_tunnel_table[tunnel_id].pathMtuSize - IPV4_GRE_MTU_ADJUSTMENT);
                                }
                        }
#ifdef __FI_IPSEC_IKE__
			else if (is_Interface_IPsec_IPv4_over_IPv4_tunnel (port_id))
			{
				if (ip_ipsec_ipv4_tunnel_is_nexthop_valid(tunnel_id, TRUE, FALSE) &&
					(0 != g_tunnel_table[tunnel_id].pathMtuSize) &&
					(sptr_cdb->integer1 > g_tunnel_table[tunnel_id].pathMtuSize - IPSEC_DATAPORT_PKT_ESP_TUNNEL_OVERHEAD))
				{
					uprintf ("Warning: Configuring mtu larger than %u discovered " \
							 "by pmtu mechanism\n",
							 g_tunnel_table[tunnel_id].pathMtuSize - IPSEC_DATAPORT_PKT_ESP_TUNNEL_OVERHEAD);
				}
			}
#endif __FI_IPSEC_IKE__
#endif __TUNNEL_INTERFACE__

                        if (status = ip_set_interface_mtu (port_id, (UINT16)sptr_cdb->integer1))
                        {
                                if (status == -1)
                                {
                                        uprintf ("Maximum number of different size MTU reached port %p\n", port_id);
                                }
                                else
                                {
                                        uprintf ("Error while setting port %p MTU %d\n", port_id, sptr_cdb->integer1);
                                }
                        }
                }
        }
        return;
}

#ifdef SR_SWITCH_ROUTER
void cli_mtu_exceed_none_df_harddrop(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                return;
        }
        else
        {
                if (sptr_cdb->no)
                {
                        g_sw_sys.mtu_exceed_action = MTU_FRAG_FORWARD;
                }
                else
                {
                        g_sw_sys.mtu_exceed_action = MTU_HARD_DROP;
                }
                set_pp_mtu_exceed_none_df_exception(g_sw_sys.mtu_exceed_action);
        }
}
void cli_mtu_exceed_none_df_softdrop(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.mtu_exceed_action == MTU_SOFT_DROP)
                        wr_config(sptr_cdb, "mtu-exceed soft-drop\n");
        }
        else
        {
                if (sptr_cdb->no)
                {
                        g_sw_sys.mtu_exceed_action = MTU_FRAG_FORWARD;
                }
                else
                {
                        g_sw_sys.mtu_exceed_action = MTU_SOFT_DROP;
                }
                set_pp_mtu_exceed_none_df_exception(g_sw_sys.mtu_exceed_action);
        }
}
void cli_mtu_exceed_none_df_cpu(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.mtu_exceed_action == MTU_FRAG_FORWARD)
                        wr_config(sptr_cdb, "mtu-exceed forward\n");
        }
        else
        {
                if (sptr_cdb->no)
                {
                        g_sw_sys.mtu_exceed_action = MTU_HARD_DROP;
                }
                else
                {
                        g_sw_sys.mtu_exceed_action = MTU_FRAG_FORWARD;
                }
                set_pp_mtu_exceed_none_df_exception(g_sw_sys.mtu_exceed_action);
        }
}
void cli_set_udp_follow_ingress_vrf (struct cdb* sptr_cdb)
{
	if (sptr_cdb->config_gen)
	{
		if (get_udp_follow_ingress_vrf())
		{
			wr_config(sptr_cdb, "ip follow-ingress-vrf\n");
		}
		return;
	}

	set_udp_follow_ingress_vrf(!sptr_cdb->no);
	
}
#endif SR_SWITCH_ROUTER

void cli_set_route_only(struct cdb* sptr_cdb)
{
        UINT8 global_route_only = cu_get_global_route_only();
        PORT_ID port_id;

        if (sptr_cdb->mode == CONFIG_IF_PE || sptr_cdb->mode == CONFIG_MIF_PE) {
            uprintf("Error - Route-Only Cannot be Enabled on PE ports\n"); 
            return;
        } 

        if (sptr_cdb->config_gen)
        {
                if (global_route_only == ENABLE)
                        wr_config(sptr_cdb, "route-only\n");
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if (global_route_only == DISABLE)
                                return;
                        cu_set_global_route_only(DISABLE);
                }
                else
                {
                        if (global_route_only == ENABLE)
                                return;

                        if (gi_sw_fwd_enable)
                        {
                                uprintf("Error - Global Route-Only Cannot be Enabled with Protocol VLANs ");
                                uprintf("or Private VLAN Mappings also Enabled in the System\n");
                                return;
                        }
#ifdef PRIVATE_VLAN
                        if (hw_pvlan_support()==HW_PVLAN_SUPPORT_FCX)
                                {
                                                /* TR000307361 */
                                                /* disallow global route-only when some pvlans are configured in the system */
                                                VLAN_ENTRY *temp_vlan_entry;
                                                VLAN_INDEX   temp_vlan_index;
                                                UINT32          temp_vlan_id;
                                                UINT32          vlan_cnt = cu_get_vlan_entry_cnt();
                                                for (temp_vlan_index=0; temp_vlan_index < g_sw_sys.max_vlans; temp_vlan_index++)
                                                {
                                                        temp_vlan_id = VLAN_ID_FROM_IDX(temp_vlan_index);
                                                        if (temp_vlan_id == VLAN_ID_INVALID)
                                                        {
                                                                continue;
                                                        }
                                                        if (temp_vlan_id == g_cpu_vlan_id)
                                                                continue;

                                                        temp_vlan_entry = g_sptr_vlan_db + temp_vlan_index;

                                                        if (temp_vlan_entry->pvlan_link)
                                                        {
                                                                uprintf("error - global route-only cannot be enabled with private vlan associations enabled in the system \n");
                                                                return;
                                                        }
                                                        if (--vlan_cnt == 0)
                                                                break;
                                                }
                                }
#endif

                        if (is_mac_learning_flow_based())
                        {
                                uprintf("Error - Global Route-Only Cannot be Enabled with 'mac-learning-flow-based'\n");
                                return;
                        }
                        if ((hw_pvlan_support()==HW_PVLAN_SUPPORT_TI) && (!IS_FI_BCM()))
                                if (g_pvlans_configured)
                                {
                                        uprintf("Error - Global Route-Only Cannot be Enabled with Private VLAN also Enabled in the System\n");
                                        return;
                                }

#ifdef INCLUDE_MCT
            /* a system with mct configuration can't have global route-only */
            if (NULL != g_cluster_info.sptr_cluster_entry)
            {
                uprintf ("Error - Global Route-Only cannot be enabled when an mct cluster is configured\n");
                return;
            }
#endif INCLUDE_MCT
                        //if (is_mac_auth_enabled_on_any_port (PORT_INDEX_INVALID))
                        // BUG: 101445 Need to check whether any authentication feature is enabled on any port since MAC learing
                        // will be disabled and any UnkSrcAddr packet will be dropped.
                        for(port_id=0; port_id < MAX_PORTS; port_id++)
                        {
                                if (IS_PORT_DB_VALID(port_id) &&
                                        (IS_PORT_DOT1X_PORT(port_id) || IS_MAC_AUTH_ENABLED_ON_PORT(port_id)))
                                {
                                        uprintf ("Route-only cannot be applied due to port(s) with authentication feature enabled \n");
                                        return;
                                }
#ifdef FI_PROTECTED_PORTS
                                if(IS_PORT_DB_VALID(port_id) && (SPTR_PORT_DB(port_id))->port_config.protected)
                                {
                                        uprintf("Error- Global Route-only cannot be enabled as port %p is a Protected Port.\n",port_id);
                                        return;
                                }
#endif
                        }
                        cu_set_global_route_only(ENABLE);
                }
        }
}

/*
 * cli_set_if_route_only : Handles iinterface level route-only 
 *
 *
 * NOTES :   Main entry point for interface level route-only 
 *           applies validation on the route-only ports 
 **/
void cli_set_if_route_only(struct cdb* sptr_cdb)
{

    UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

    if(!IS_PORT_DB_VALID(port_id))
       return;

    if (sptr_cdb->config_gen)
    {
        if (is_virtual_port (port_id))
            return;
        if ((SPTR_PORT_DB(port_id))->port_config.route_only)
            wr_config(sptr_cdb, " route-only\n");
    }
    else
    {
        if (sptr_cdb->no)
        {
            if ((is_virtual_port (port_id)) ||(PORT_MODE(port_id) == TAGGED))
                return;

            if (is_member(g_vport_member_mask, port_id))
            {
                uprintf("Error - Cannot change Route-Only setting on physical port that is part of a VE\n");
                uprintf("Note - Route-Only is not active (config is ignored) when the physical port is part of a VE\n");
                return;
            }

            sw_reset_port_route_only(port_id);
        }
        else
        {
            if (gi_sw_fwd_enable)
            {
                uprintf("Error - Route-Only Cannot be Enabled with Protocol VLANs ");
                uprintf("or Private VLAN Mappings also Enabled in the System\n");
                return;
            }
            if (is_mac_learning_flow_based())
            {
                uprintf("Error - Route-Only Cannot be Enabled with 'mac-learning-flow-based'\n");
                return;
            }
            if (g_pvlans_configured)
            {
                uprintf("Error - Global Route-Only Cannot be Enabled with Private VLAN also Enabled in the System\n");
                return;
            }

            if (is_virtual_port (port_id))
            {
                uprintf ("Route-only cannot be applied to a VE interface\n");
                return;
            }

            if (pms_is_enabled(port_id)) 
            {
                uprintf ("Route-only cannot be applied to a PMS enabled port\n");
                return;
            }

#ifdef FI_PROTECTED_PORTS
            if((SPTR_PORT_DB(port_id))->port_config.protected)
	    {
	        uprintf("Error- Route-only cannot be enabled to a Protected Port.\n");
	        return;
	    }
#endif
            /* If tagged port, block the config */
            if (PORT_MODE(port_id) == TAGGED)
            {
                uprintf ("Route-only cannot be applied to a tagged port\n");
                return;
            }

            /* If port is part of a VE, block the config */
            if (is_member(g_vport_member_mask, port_id))
            {
                uprintf ("Route-only cannot be applied on a physical port that is part of a VE\n");
                return;
            }

            /* If port has mac-learn-disable on it, block the config */
            if ((SPTR_PORT_DB(port_id))->port_config.mac_learning_disabled)
            {
                uprintf ("Route-only cannot be applied on a port with mac-learn-disable feature\n");
                return;
            }
            /* if (is_mac_auth_enabled_on_any_port (port_id)) */
            if (IS_PORT_DOT1X_PORT(port_id) || (IS_MAC_AUTH_ENABLED_ON_PORT(port_id)))
            {
                uprintf ("Route-only cannot be applied on a port with Authentication feature enabled \n");
                return;
            }
#ifdef FIOFL_INCLUDE
            if (IS_PORT_OPENFLOW_PORT(port_id))
            {
                uprintf("Route-only cannot be applied on a port %p with Openflow feature enabled\n", port_id);
                return;
            }
#endif FIOFL_INCLUDE

#ifdef INCLUDE_MCT
            if (IS_PORT_DB_VALID (port_id))
            {
                if (IS_PORT_ICL_PORT (port_id))
                {
                    uprintf ("Route-only cannot be applied on an icl port\n");
                    return;
                }
                if (IS_PORT_CCEP_PORT (port_id))
                {
                    uprintf ("Route-only cannot be applied on a ccep port\n");
                    return;
                }
            }
#endif INCLUDE_MCT
            sw_set_port_route_only(port_id);

        }
    }
}

#ifdef SR_SWITCH_ROUTER
void set_if_virtual(struct cdb* sptr_cdb)
{
        UINT16 router_int, current_port;

        g_vlan_group_cmd = 0;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */

                /*
                 * The following situation only happens when we parse the
                 * configuration file during initialization:
                 * Configuration file does not have an "exit" command
                 * to jump from CONFIG_IF mode to CONFIG mode. If an
                 * interface number is invalid, we could be left in the
                 * CONFIG_IF mode from the last valid interface command.
                 * Therefore, we need to reset the mode to CONFIG before
                 * we parse interface command.
                 */
                if (sptr_cdb->mode != CONFIG)
                {
                        set_cli_mode(sptr_cdb, CONFIG);
                        sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
                }

                if (!valid_integer1_value_range(sptr_cdb, 1, EXTERNAL_VE_MAX))
                        return;

                //reset mode_vrf_index here for all interface command.
                cli_reset_vrf_mode(sptr_cdb);

                router_int = external_ve_lookup(sptr_cdb->integer1 - 1);

                if (is_internal_ve_valid(router_int) == FALSE)
                {
                        uprintf("Error - invalid virtual ethernet interface number.\n");
                        return;
                }

/*
 * need to worry about setting up things properly at start-up time
 * some of the vlan crap would not be set up yet
 * check init_in_progress flag to determine whether to do certain things
 * should check for whether virtual interface is configured in CU, if not,
 * reject the command.
 * let ip_post_config take care of setting up the port mask and so on, only
 * at that time would the stuff by ready
 */
                router_int = VID_TO_ROUTER_INT(router_int);

                if (IP_IP_PORT(router_int).vport_type == VPORT_NONE)
                {
                        uprintf("Error - invalid virtual ethernet interface number.\n");
                        return;
                }

                current_port = sptr_cdb->if_num;
                sptr_cdb->if_type = VIRTUAL;
                sptr_cdb->if_num = router_int+1;
                sptr_cdb->router_intf = sptr_cdb->integer1;
                sptr_cdb->parent_mode = CONFIG_VIF;
                if (sptr_cdb->no)
                {
                        if (!ip_is_l3_config_ok_to_remove_vlan_ve_vrf (router_int, 
                                                                "before removing interface"))
                                        {
                                                sptr_cdb->dont_go_next = 1;
                                        return;
                                        }

                            /*just check whether this VE is used as track port in any configured VRID - VRRP*/
                            vrrp_find_vrid_track_port_and_delete (router_int);

#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
                        ospf6_remove_distribute_list_on_interface(router_int);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__
                        default_interface(sptr_cdb);
                        sptr_cdb->if_num = current_port;
                }
                else
        {
                        sptr_cdb->vlan_group_id = 0;
                        set_cli_mode(sptr_cdb, CONFIG_VIF);
                }
        }
}
#endif /* SR_SWITCH_ROUTER */
#endif  /* SR_SWITCH_ROUTER */

#ifdef SR_SWITCH_ROUTER
//#ifdef __LOOPBACK__
void set_lbif_up(struct cdb* sptr_cdb)
{
                PORT_ID  port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
                
        
                if (sptr_cdb->config_gen)
                {
                        if (IP_IP_PORT(port_id).config.port_configured)
                        {
                                if (IP_IP_PORT(port_id).config.port_enabled == FALSE)
                                {
                                        wr_config(sptr_cdb, " disable\n");
                                }
                        }
                        return;
                }
        
                if(sptr_cdb->no)
                {
                        sptr_cdb->no = 0;
                        set_lbif_down(sptr_cdb);
                        return;
                }
        
                 if (IP_IP_PORT(port_id).config.port_enabled == FALSE)
                 {
                         IP_IP_PORT(port_id).config.port_enabled = TRUE;
                         IP_IP_PORT(port_id).port_last_change_time_stamp = sv_get_time();
        
                                if      (!g_sw_sys.init_in_progress)
                         {
                                         do_ip_port_state_notify(port_id, PPORT_UP);
                         }
                 }
        
        }


void set_lbif_down(struct cdb* sptr_cdb)
{
                PORT_ID  port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        
                
        if (sptr_cdb->config_gen)
                return;

        if(sptr_cdb->no)
        {
                sptr_cdb->no = 0;
                set_lbif_up(sptr_cdb);
                return;
        }

                 if (IP_IP_PORT(port_id).config.port_enabled == TRUE)
        {
                if (!g_sw_sys.init_in_progress)
                {
                                         do_ip_port_state_notify(port_id, PPORT_DOWN);
                }
        
                         IP_IP_PORT(port_id).config.port_enabled = FALSE;
                         IP_IP_PORT(port_id).port_last_change_time_stamp = sv_get_time();
#ifdef __ISIS__
                isis_delete_loopback_interface((UINT16)(sptr_cdb->if_num-1));
#endif /*__ISIS__*/
                
        }
}


void set_if_loopback (struct cdb* sptr_cdb)
{
#ifdef MPLS
    extern void mpls_set_is_local_route (enum BOOLEAN flag);
#endif MPLS
    UINT16 router_int;
    PORT_ID current_port;

    if (sptr_cdb->config_gen)
        return;

    if (!valid_integer1_value_range(sptr_cdb, 1, MAX_LOOPBACK_INT ))
        return;

    //reset mode_vrf_index here for all interface command.
    cli_reset_vrf_mode(sptr_cdb);

    router_int = LBID_TO_ROUTER_INT(sptr_cdb->integer1-1);

    if (sptr_cdb->no)     /* removing a loopback interface */
    {
        /*check whether loopback is configured as tunnel source or not*/
        if (!ip_is_l3_config_ok_to_remove_vlan_ve_vrf (router_int, 
                                        "before removing interface"))
                {
                        sptr_cdb->dont_go_next = 1;
                return;
                }

#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
        ospf6_remove_distribute_list_on_interface(router_int);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__

        if (IP_IP_PORT(router_int).config.port_enabled)
        {
#ifdef MPLS
            // indicate to MPLS LDP that route going down is loopback
            mpls_set_is_local_route(TRUE);
#endif MPLS
            do_ip_port_state_notify(router_int, PPORT_DOWN);
#ifdef MPLS
            mpls_set_is_local_route (FALSE);
#endif MPLS
        }
        ip_clear_addresses_on_port(router_int,sptr_cdb->ui_port);
        current_port = sptr_cdb->if_num;
        sptr_cdb->if_num = router_int+1;
        default_interface(sptr_cdb);
        sptr_cdb->if_num = current_port;
        IP_IP_PORT(router_int).config.port_configured = FALSE;
        cu_set_port_name(router_int, NULL);
#ifdef __ISIS__
        isis_delete_loopback_interface (router_int);
#endif /*__ISIS__*/
        /* reset the mode to config */
        sptr_cdb->parent_mode = CONFIG;
        set_cli_mode(sptr_cdb, CONFIG);

    }
    else
    {
        sptr_cdb->if_type = LOOPBACK;
        sptr_cdb->if_num = router_int+1;
        sptr_cdb->parent_mode = CONFIG_LBIF;
        set_cli_mode(sptr_cdb, CONFIG_LBIF);
        if (IP_IP_PORT(router_int).config.port_configured == FALSE)
        {
            IP_IP_PORT(router_int).config.port_configured = TRUE;
            IP_IP_PORT(router_int).config.port_enabled = TRUE;
#ifdef __ISIS__
            isis_create_loopback_interface(router_int);
#endif /*__ISIS__*/
            if (!g_sw_sys.init_in_progress)
            {
                do_ip_port_state_notify(router_int, PPORT_UP); /* bring it up 1st time */
            }
        }
    }
}
//#endif __LOOPBACK__
#endif /*SR_SWITCH_ROUTER*/


void clear_if_port_range(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1; /* don't loop back */
                return;
        }

        clear_mask(sptr_cdb->mif_port_mask);

        if((sptr_cdb->mode == CONFIG_MIF)
#ifdef __PORT_EXTENSION__
            || (sptr_cdb->mode == CONFIG_MIF_SPX)
            || (sptr_cdb->mode == CONFIG_MIF_PE)
#endif __PORT_EXTENSION__
	    || (sptr_cdb->mode == CONFIG_MIF_LAG)
        )
                set_cli_mode(sptr_cdb, CONFIG);
}

static UINT8 have_trunk_port_in_interface_config(struct cdb* sptr_cdb)
{
    int i;
    PORT_ID port_id=0; 

    for (i=0; i < g_hw_info.total_config_ports; i++)
    {
        port_id = sw_config_port_list[i];
        if (!is_member(sptr_cdb->mif_port_mask, port_id))
            continue;
        if (IS_LAG_AP(port_id))
        {
            if (!(IS_LAG_OPERATIONAL_AP(port_id)))
            {
                uprintf("Error - Cannot use %p , which is not configured. \n",port_id);
                return 1;
            }
        }
    }
    return 0;
}

// CHEETAH_STACKING
BOOLEAN32 cli_port_is_stacking_port(
        struct cdb *sptr_cdb, PORT_ID port_id, BOOLEAN32 is_mode_change, UINT8 from_enet)
{
        if (sptr_cdb->execute && !sptr_cdb->stacking_ports_allowed
                && is_port_stack_enabled (port_id))
        {
                if (from_enet && g_sw_sys.init_in_progress) // 10g-full speed config is required on stack-trunk secondary ports
                        return FALSE;

                uprintf("Error - command not allowed for stacking port: %P\n", port_id);
                sptr_cdb->dont_go_next = 1;
                sptr_cdb->error = is_mode_change
                        ? MODE_CHANGE_PARSE_ERROR : UNSPECIFIED_PARSE_ERROR;
                return TRUE;
        }

        return FALSE;
}

#ifdef __PORT_EXTENSION__

/***************************************************************************
 * Name: cli_port_is_spx_port
 *
 * Description: To validate if the interface is spx-port/spx-lag or not
 *
 * Parameter : port_id , is_mode_change , from_enet
 *
 * Return: TRUE - if spx-port/spx-lag found ; FALSE if not found
 *
 * Method:
 *
***************************************************************************/

BOOLEAN32 cli_port_is_spx_port(
        struct cdb *sptr_cdb, PORT_ID port_id, BOOLEAN32 is_mode_change, UINT8 from_enet)
{
    /* 000571784: flag sptr_cdb->stacking_ports_allowed will be set to true in set_show_flag, which will allow
     * execution of show commands in stacking ports, using the same flag for spx-ports since both should
     * behave same. is_mode_change and from_enet will be true only from functions set_if_enet and set_if_enet_enet  
     * */
    /* 000570052 - should block any command configuration on spx-ports similar to stack ports */
    /* TR000575765 - Since stack is disabled, the variable sptr_cdb->stacking_ports_allowed is getting set to 1 in parser function. 
     * When this variable is set , it will allow the commands to include the stacking ports, the same variable is used to include 
     * the spx ports also in the command. Apart from parser this variables are set only for show/debug commands.  
     * Now spx_port_allowed variable is used to handle it seperately */
    if(sptr_cdb->execute && !sptr_cdb->spx_ports_allowed &&
            IS_SPX_PORT(port_id))
    {

        if (from_enet && g_sw_sys.init_in_progress) // 10g-full speed config is required on stack-trunk secondary ports
            return FALSE;

        uprintf("Error - command not allowed for spx port: %P\n", INTERFACE_TO_PORT_ID(sptr_cdb->if1));
        sptr_cdb->dont_go_next = 1;
        sptr_cdb->error = is_mode_change
            ? MODE_CHANGE_PARSE_ERROR : UNSPECIFIED_PARSE_ERROR;
        return TRUE;

    }

    return FALSE;
}
#endif __PORT_EXTENSION__


PORT_ID mask_includes_a_system_stacking_port(const PORT_MASK *port_mask);

// CHEETAH_STACKING
BOOLEAN32 cli_mask_includes_stacking_ports(
        struct cdb *sptr_cdb, PORT_MASK *port_mask, BOOLEAN32 is_mode_change)
{
        BOOLEAN32 has_stacking_ports = FALSE;

        if (sptr_cdb->execute && !sptr_cdb->stacking_ports_allowed)
        {
                PORT_ID stacking_port_id
                        = mask_includes_a_system_stacking_port(port_mask);

                if (stacking_port_id != PORT_INDEX_INVALID)
                {
                        if (g_sw_sys.init_in_progress)
                        {
                                PORT_MASK port_mask_copy[MAX_SLOT];

                                // During initialization, instead of disallowing a command
                                // completely and losing part of the configuration, we
                                // just exclude the stacking ports (unless those are the
                                // only ports that were specified).
                                memcpy(port_mask_copy, port_mask, sizeof(port_mask_copy));

                                do
                                {
                                        uprintf("Warning - This CLI operation is not allowed on stacking port:"
                                                        " %P -- port removed\n", stacking_port_id);
                                        clear_mask_bit(port_mask_copy, stacking_port_id);
                                        stacking_port_id
                                                = mask_includes_a_system_stacking_port(port_mask_copy);

                                } while (stacking_port_id != PORT_INDEX_INVALID);

                                if (is_mask_clear(port_mask_copy))
                                        has_stacking_ports = TRUE;
                                else
                                        memcpy(port_mask, port_mask_copy, sizeof(port_mask_copy));
                        }
                        else
                        {
                                uprintf("Error - This CLI opertaion is not allowed on stacking port: %P\n",
                                                stacking_port_id);
                                has_stacking_ports = TRUE;
                        }

                        if (has_stacking_ports)
                        {
                                sptr_cdb->dont_go_next = 1;
                                sptr_cdb->error = is_mode_change
                                        ? MODE_CHANGE_PARSE_ERROR : UNSPECIFIED_PARSE_ERROR;
                        }
                }
        }

        return has_stacking_ports;
}

void set_if_vlag_vlag(struct cdb* sptr_cdb)
{
    PORT_ID fslot, tslot, fport, tport;
    PORT_MASK port_mask[MAX_SLOT];
    int i,j;
    int port_type_value;
    PORT_ID port,current_port;

    if (sptr_cdb->config_gen)
    {
        sptr_cdb->dont_go_next = 1;
        return;
    }
    /* not config gen */
    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    if((sptr_cdb->if1 < LAG_START_PORT) || (sptr_cdb->if1 > LAG_END_PORT))
    {
        uprintf("Error: Valid range is lg<1-%d> \n",MAX_LAG_PORTS);
        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
        return;
    }

    if((sptr_cdb->if2 < LAG_START_PORT) || (sptr_cdb->if2 > LAG_END_PORT))
    {
        uprintf("Error: Valid range is lg<1-%d> \n",MAX_LAG_PORTS);
        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
        return;
    }
    if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
    {
        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
        return;
    }
    if (!validate_interface_value(sptr_cdb, 2, ENET_INTERFACE))
    {
        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
        return;
    }
    fslot = INTERFACE_SLOT(sptr_cdb->if1);
    fport = INTERFACE_PORT(sptr_cdb->if1);
    tslot = INTERFACE_SLOT(sptr_cdb->if2);
    tport = INTERFACE_PORT(sptr_cdb->if2);

    if(CU_ERROR == cu_verfiy_config_range_is_allowed(fslot, fport, tslot, tport))
    {
        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
        return;
    }

#if 0
    if (fslot != tslot)
    {
        uprintf("Error - cannot configure multi-ports on different slot\n");
        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
        return;
    }
#endif
    /*
     * #ifdef SIDEWINDER_BREAKOUT
     * */
    port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);

    if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
    {
        if(cu_range2maskLong_vlag(fslot, fport, tslot, tport, port_mask) == CU_ERROR)
        {
            cu_range2maskLongError(sptr_cdb);
            sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
            return;
        }
    }
    else
    {
        if(cu_range2maskLong(fslot, fport, tslot, tport, port_mask) == CU_ERROR)
        {
            cu_range2maskLongError(sptr_cdb);
            sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
            return;
        }
    }
    /*
     * #else
     *               cu_range2maskLong(fslot, fport, tslot, tport, port_mask);
     *               #endif
     *               */
    or_masks(sptr_cdb->mif_port_mask, sptr_cdb->mif_port_mask, port_mask);

    if (cli_mask_includes_stacking_ports(sptr_cdb, sptr_cdb->mif_port_mask, TRUE))
        return;

    if (have_trunk_port_in_interface_config( sptr_cdb ))
        return;

    sptr_cdb->if_type = VLAG;
    sptr_cdb->if_num = sptr_cdb->if1;
    sptr_cdb->num_of_if = 0;
    port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);
    /*
     *  A port configured as ZTP should behave same as SPX port , The prompt and mode would be similar to SPX port. 
     *          With this it will allow only the commands supported for SPX port to be executed for ZTP interface also.
     *          */
    if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
    {
        sptr_cdb->parent_mode = CONFIG_MIF_SPX;
        set_cli_mode(sptr_cdb,CONFIG_MIF_SPX);
    }
#if 0
    else if(port_type_value == EXT_PORT_TYPE_HOST)
    {
        sptr_cdb->parent_mode = CONFIG_MIF_PE;
        set_cli_mode(sptr_cdb,CONFIG_MIF_PE);
    }
#endif
    else
    {
        sptr_cdb->parent_mode = CONFIG_MIF_LAG;
        set_cli_mode(sptr_cdb, CONFIG_MIF_LAG);
    }
    if(sptr_cdb->no)
    {
        copy_mask(port_mask, sptr_cdb->mif_port_mask);
        for (i = 0; i < g_hw_info.max_mod; i++) {
            if (!PORT_MASK_ISSET_ANY(port_mask[i]))
                continue;
            for (j = 0, port = MAKE_PORTID(i, 0); j < g_module[i].number_of_ports; j++, port++) {
                if (!PORT_MASK_ISSET(port_mask[i], j))
                    continue;
                if(!IS_PORT_DB_VALID(port)) /* SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid */
                    continue;
                current_port = sptr_cdb->if_num;
                sptr_cdb->if_num = PORT_ID_TO_INTERFACE(port);
#ifdef MPLS
                if(GET_PORT_MPLS_ENABLE(port) && !GET_PORT_FORCED_DELETION(port))
                {
                    uprintf("Error: Port %p is an MPLS port.\n", port);
                }
#endif MPLS
                if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
                        (port == ntp_source_interface()))
                {
                    uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                            port);
                }
		/*This is specific to Spatha 32p , Minions does not have port pairing issue*/	
                else if (is_platform_got_port_pair_limitation() && (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
                        (SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) &&
						IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                {
					

						uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                        	    INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                }
                else
                {
                    default_interface(sptr_cdb);
                }
                sptr_cdb->if_num = current_port;
            }
        }
        sptr_cdb->dont_go_next = 1; /* stop parser in here */
        set_cli_mode(sptr_cdb, CONFIG);
    }
}

void set_if_enet_enet(struct cdb* sptr_cdb)
{
        PORT_ID fslot, tslot, fport, tport;
        PORT_MASK port_mask[MAX_SLOT];
                int i,j;
        int port_type_value;
                PORT_ID port,current_port;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        /* not config gen */
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
        {
                sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                return;
        }
        if (!validate_interface_value(sptr_cdb, 2, ENET_INTERFACE))
        {
                sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                return;
        }
        fslot = INTERFACE_SLOT(sptr_cdb->if1);
        fport = INTERFACE_PORT(sptr_cdb->if1);
        tslot = INTERFACE_SLOT(sptr_cdb->if2);
        tport = INTERFACE_PORT(sptr_cdb->if2);
        if (fslot != tslot)
        {
                uprintf("Error - cannot configure multi-ports on different slot\n");
                sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                return;
        }
		
		if(CU_ERROR == cu_verfiy_config_range_is_allowed(fslot, fport, tslot, tport))
		{
		    sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
	            return;
		}
//#ifdef SIDEWINDER_BREAKOUT
        if(cu_range2maskLong(fslot, fport, tslot, tport, port_mask) == CU_ERROR)
        {
            cu_range2maskLongError(sptr_cdb);
            sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                        return;
        }
//#else
//              cu_range2maskLong(fslot, fport, tslot, tport, port_mask);
//#endif
        or_masks(sptr_cdb->mif_port_mask, sptr_cdb->mif_port_mask, port_mask);

        if (cli_mask_includes_stacking_ports(sptr_cdb, sptr_cdb->mif_port_mask, TRUE))
                return;

        if (have_trunk_port_in_interface_config( sptr_cdb ))
                // error, bug#11668
                return;

        sptr_cdb->if_type = ETHERNET;
        sptr_cdb->if_num = sptr_cdb->if1;
        sptr_cdb->num_of_if = 0;
        port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);

		//A port configured as ZTP should behave same as SPX port , The prompt and mode would be similar to SPX port. 
		//With this it will allow only the commands supported for SPX port to be executed for ZTP interface also.
        if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
        {
            sptr_cdb->parent_mode = CONFIG_MIF_SPX;
            set_cli_mode(sptr_cdb,CONFIG_MIF_SPX);
        }
        else if(port_type_value == EXT_PORT_TYPE_HOST)
        {
            sptr_cdb->parent_mode = CONFIG_MIF_PE;
            set_cli_mode(sptr_cdb,CONFIG_MIF_PE);
        }
        else
        {
            sptr_cdb->parent_mode = CONFIG_MIF;
            set_cli_mode(sptr_cdb, CONFIG_MIF);
        }
                if(sptr_cdb->no)
                {
                                copy_mask(port_mask, sptr_cdb->mif_port_mask);
                                for (i = 0; i < g_hw_info.max_mod; i++) {
                                        if (!PORT_MASK_ISSET_ANY(port_mask[i]))
                                                continue;
                                        for (j = 0, port = MAKE_PORTID(i, 0); j < g_module[i].number_of_ports; j++, port++) {
                                                if (!PORT_MASK_ISSET(port_mask[i], j))
                                                        continue;
                                                if(!IS_PORT_DB_VALID(port)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                                        continue;
                                                current_port = sptr_cdb->if_num;
                                                sptr_cdb->if_num = PORT_ID_TO_INTERFACE(port);
                                         #ifdef MPLS
                                                if(GET_PORT_MPLS_ENABLE(port) && !GET_PORT_FORCED_DELETION(port))
                                                {
                                                        uprintf("Error: Port %p is an MPLS port.\n", port);
                                                }
                                 #endif MPLS
                                                if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
                                                                (port == ntp_source_interface()))
                                                {
                                                        uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                                                                         port);
                                                }
						/*This is specific to Spatha32p , Minions does not have port pairing issue*/
						else if (is_platform_got_port_pair_limitation() &&  (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
                                                	(SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) &&
													IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                                {
                                                     

													 		uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                                                             INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                }     
                                                else
                                                {
                                                        default_interface(sptr_cdb);
                                                }
                                                sptr_cdb->if_num = current_port;
                                        }
                                }
                                sptr_cdb->dont_go_next = 1; /* stop parser in here */
                                set_cli_mode(sptr_cdb, CONFIG);
                        }
}


/* code taken fron NI 5.2 code base for bug 000348697 starts*/

/* Returns TRUE if conflict found, FALSE otherwise */
static int cli_check_mode_conflict_for_protocol(struct cdb* sptr_other_cdb, enum parser_mode this_mode, struct cdb*sptr_this_cdb )
{
        int conflict_found=FALSE; /*assume no conflicts */


        if (this_mode == CONFIG_IF && sptr_other_cdb->mode == CONFIG_IF)
        {
                if (sptr_this_cdb->if1 == sptr_other_cdb->if_num)
                        conflict_found = TRUE;
        }
#if (defined(__FOUNDRY_BGP__) || defined(PBR_M5)) || defined(POS_PBR)
        else if (this_mode == CONFIG_BGP_ROUTEMAP && sptr_other_cdb->mode == CONFIG_BGP_ROUTEMAP)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->routemap_name)) //routemap name in string1.
                        conflict_found = TRUE;
        }
#endif
        else if (this_mode == CONFIG_L4_ACL_STD_NAME && sptr_other_cdb->mode == CONFIG_L4_ACL_STD_NAME)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->acl_name))
                        conflict_found = TRUE;
        }
        else if (this_mode == CONFIG_L4_ACL_EXT_NAME && sptr_other_cdb->mode == CONFIG_L4_ACL_EXT_NAME)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->acl_name))
                        conflict_found = TRUE;
        }
        else if (this_mode == CONFIG_IPV6_ACCESS_LIST && sptr_other_cdb->mode == CONFIG_IPV6_ACCESS_LIST)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->acl_name))
                        conflict_found = TRUE;
        }
        else if (this_mode==CONFIG_IP_VRF && sptr_other_cdb->mode == CONFIG_IP_VRF)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->mode_vrf_name))
                        conflict_found = TRUE;
        }
                else if (this_mode==CONFIG_IPV4_VRF && sptr_other_cdb->mode == CONFIG_IPV4_VRF)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->mode_vrf_name))
                        conflict_found = TRUE;
        }
                else if (this_mode==CONFIG_IPV6_VRF && sptr_other_cdb->mode == CONFIG_IPV6_VRF)
        {
                if (!strcmp(sptr_this_cdb->string1, sptr_other_cdb->mode_vrf_name))
                        conflict_found = TRUE;
        }
        else if (this_mode == sptr_other_cdb->mode)
                        conflict_found = TRUE;

        return conflict_found;
}


int cli_is_mode_conflict_found(struct cdb* sptr_cdb, enum parser_mode mode)
{
        int i;
        if (sptr_cdb->no && !sptr_cdb->config_gen && sptr_cdb->mode >= CONFIG)
        { /*Allow undo of group config only if there's no other shell user in that mode*/
                for (i=0; i<=MAX_SSH_SESSION_NUM; i++)
                {
                        if (IS_OUTBOUND_TELNET_CDBS_INDEX(i))
                                continue; /*Ignore outbound telnet session */
                        if (&cdbs[i] != sptr_cdb  /*its not me*/&&
                                cli_check_mode_conflict_for_protocol(&cdbs[i], mode, sptr_cdb))
                        {
                                {
                                        if (IS_CONSOLE_CDBS_INDEX(i))
                                                uprintf("Error: Cannot undo the configuration as console session is using this mode.\n");
                                        else if (IS_TELNET_CDBS_INDEX(i))
                                                uprintf("Error: Cannot undo the configuration as telnet %d session is using this mode.\n", CDBS_TO_TELNET_INDEX(i)+1);
                                        else if (IS_SSH_CDBS_INDEX(i))
                                                uprintf("Error: Cannot undo the configuration as SSH %d session is using this mode.\n", CDBS_TO_SSH_INDEX(i)+1);
                                        else
                                                uprintf("Error: Cannot undo the configuration as session %d is using this mode.\n", i);
                                        return TRUE;
                                }
                        }
                        
                }
        }
        return FALSE;
}
#ifdef SIDEWINDER_BREAKOUT

int cu_config_verify_for_interface(
        struct cdb *sptr_cdb, PORT_ID sw_port)
{
        PORT_DB *port_ptr;
        UINT8 port_string[32];
        UINT16 lock_address_count = 0;
        char ret_reason[HAS_CONFIG_REASON_BUF_SIZE];
        lag_cb_t *cb;

        // as the check is relevant on active, just return 0
#ifndef NO_ROUTER_RAPID_FAILOVER
        if (STACK_AM_I_MEMBER) // Even standby must verify it. Otherwise, it could reject in master, and pass in standby
                return 0; 
        // If it is a standby, and not get the configuration yet, don't check otherwise it could complain.
        if(STACK_AM_I_STANDBY && g_stacking.standby_state < STANDBY_HOTSWAP_STATE_GOT_CONFIG)
                return 0;
#else NO_ROUTER_RAPID_FAILOVER
        if(STACK_AM_I_SLAVE)
                return 0; // 290024
#endif NO_ROUTER_RAPID_FAILOVER
        
        if(!IS_PORT_DB_VALID(sw_port))
                return 0;
        
    if(is_port_stack_enabled (sw_port))
    {
            uprintf("Error: Breakout command is not allowed on a stacking port: %P\n", sw_port);
            return TRUE;
    }
                        
        ksprintf(port_string, "Error: Port %p", sw_port);
        port_ptr = SPTR_PORT_DB(sw_port);
		
		if( IS_ZTP_PORT(sw_port) ) //if port has configured as ztp, should not allow to configure interface breakout
		{
			kprintf("%s is configured as zero-touch-port\n", port_string);
			return 1;
		}
        
		
#ifdef __PORT_EXTENSION__
        if(cu_is_cb_spx_port(sw_port))
        {
                uprintf("%s is configured as SPX port\n", port_string);
                return 1;
        }
        if(cu_is_cb_spx_lag_port(sw_port))
        {
                uprintf("%s is configured as SPX LAG port\n", port_string);
                return 1;
        }
#endif __PORT_EXTENSION__

        if(port_ptr->loop_detect_entry)
        {
                uprintf("%s has loop detection\n", port_string);
                return 1;
        }
        /* 101887 */
        if(port_ptr->port_config.link_keepalive_enable)
        {
                uprintf("%s has link-keepalive\n", port_string);
                return 1;
        }

        if(port_ptr->port_config.disable_by_user)
        {
                uprintf("%s is disabled\n", port_string);
                return 1;
        }
/* Enabled the code for spanning tree ,since "no span" command will be enabled on port level*/ 
        if(!port_ptr->port_config.stp_enable)
        {
                uprintf("%s has per port stp\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.oper_bpduguard)
        {
                uprintf("%s has stp-bpdu-guard\n", port_string);
                return 1;
        }
#ifdef PRIVATE_VLAN
        if (hw_pvlan_support()==HW_PVLAN_SUPPORT_FCX)           
                {
                        if(port_ptr->port_config.oper_bpduguard_pvlan)
                        {
                                uprintf("%s has stp-bpdu-guard on this secondary vlan port \n", port_string);
                                return 1;
                        }
                }

#endif
    if (port_ptr->port_config.stp_admin_rootguard)
    {
        uprintf("%s has spanning-tree root-protect\n",port_string);
        return 1;
    }
    if (port_ptr->port_config.stp_admin_designatedguard)
    {
        uprintf("%s has spanning-tree designated-protect\n",port_string);
        return 1;
    }
    if (port_ptr->port_config.rstp_adminOperEdge)
    {
        uprintf("%s has spanning-tree 802-1w admin-edge-port\n",port_string);
        return 1;
    }
    if (port_ptr->port_config.rstp_adminPt2PtMac)
    {
        uprintf("%s has spanning-tree 802-1w admin-pt2pt-mac\n",port_string);
        return 1;
    }
        if(port_ptr->port_config.route_only)
        {
                uprintf("%s has route-only\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.trunk_state != TRUNK_NONE)
        {
                uprintf("%s is in a trunk group\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.mcast_limit)
        {
                uprintf("%s has multicast limit\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.brd_limit)
        {
                uprintf("%s has broadcast limit\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.unknown_unicast_limit)
        {
                uprintf("%s has unknown-unicast limit\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.mode == TAGGED)
        {
                uprintf("%s is tagged\n", port_string);
                return 1;
        }
    if (!is_init_in_progress() && (sw_pp_is_port_mirror(sw_port) != CU_MONITOR_PORT_OFF))
    {
        uprintf("%s is configured as mirror-port\n",port_string);
        return 1;
    }
        if(mrp_conf_is_port_ring_member_any (sw_port) == TRUE)
        {
                uprintf("%s is MRP Ring Member\n", port_string);
                return 1;
        }
        if(port_ptr->port_oper_info.num_vlans_active == 1)
        {
                // If it belongs to the default vlan, it is OK.
                int vlan_id;
                vlan_id = VLAN_ID_FROM_IDX(port_ptr->port_config.port_vlan_idx);
                if(vlan_id != g_sw_sys.default_vlan_id)
                {
                        uprintf("%s belongs to vlan %u\n", port_string, vlan_id);
                        return 1;
                }
        }
        if(port_ptr->port_oper_info.num_vlans_active > 1)
        {
                // If it belongs to the default vlan, it is OK.
                uprintf("%s belongs to %u L2 vlans\n", port_string, port_ptr->port_oper_info.num_vlans_active);
                return 1;
        }
        if(port_ptr->port_config.sFlowEnable)
        {
                uprintf("%s has sflow forwarding\n", port_string);
                return 1;
        }
        if(port_ptr->port_config.uplink_group)
        {       // stacking ports cannot be Fast uplink ports
                uprintf("%s has fast uplink-span\n", port_string);
                return 1;
        }
#ifdef SR_SWITCH_ROUTER 
        if(IS_IP_PORT_DB_VALID(sw_port))
        {
                if(IP_ADDR_COUNT(sw_port))
                {
                        uprintf("%p has IP address configured\n", sw_port);
                        return 1;
                }
        }
#endif  
        // uprintf(" flow control rx %d tx %d \n", 
        //         port_ptr->port_config.flow_control, port_ptr->port_config.flow_control_tx);

        if (port_ptr->port_config.flow_control_tx == 1 && (!is_gi_cut_through_enable_on_hw()))
        {
             uprintf("%p has symmetrical flow control configured. Please disable symmetrical flow control. \n", sw_port);
             return 1;
        }

        if (port_ptr->port_config.flow_control == 0 && (!is_gi_cut_through_enable_on_hw()))
        {
             uprintf("%p has flow control configured. Please remove flow control.\n", sw_port);
             return 1;
        }

        if(gi_check_if_input_acl_is_configured_on_intf(sw_port))
        {
                /*10g K-H Connections - Avoding it
                        451429: In this defect when fail-over is performed corresponding units goes down and PBR_ACL is applied on all peri-ports when PBR is configured
                        Hence new actives peri-port has PBR_ACL, which is needed and its not an issue, so avoiding this check for 10G links only
                */
#ifdef IP_POLICY_ROUTING
                if( !is_pp_link_x10g_port(sw_port) )
#endif                  
                {
                        debug_uprintf("%s has ACL configuration on the port\n", port_string);
                        return 1;
                }
        }       

         // Check for MAC Based VLAN
         if(IS_MAC_BASED_VLAN_ENABLED_ON_PORT(sw_port))
         {
                 uprintf("%s has Mac Based Vlan configuration on the port\n", port_string);
                 return 1;
         }

        if(gi_check_if_mac_filtering_is_associated_with_ip_port(sw_port))
        {
                uprintf("%s has Mac Filter configuration on the port\n", port_string);
                return 1;
        }       

        if(gi_check_if_rate_limiting_is_associated_with_ip_port (sw_port))
        {
                uprintf("%s has Rate Limiting configuration on the port\n", port_string);
                return 1;
        }       
        if(gi_check_if_any_icmp_attack_is_associated_with_phy_port(sw_port))
        {
                uprintf("%s has ICMP attack configuration on the port\n", port_string);
                return 1;
        }       
        if(gi_check_if_any_tcp_syn_attack_is_associated_with_phy_port(sw_port))
        {
                uprintf("%s has TCP SYN attack configuration on the port\n", port_string);
                return 1;
        }       
#ifdef IP_POLICY_ROUTING
        if (gi_check_if_any_pbr_is_associated_with_phy_port(sw_port))
        {
                uprintf("%s has PBR configuration on the port\n", port_string);
                return 1;
        }       
#endif IP_POLICY_ROUTING
        if (!g_sw_sys.init_in_progress
                && parser_check_if_interface_has_config(sw_port, ret_reason, 0))
        {
                uprintf("%s has config: \"%s\"\n", port_string, ret_reason);
                return 1;
        }       

        if(cu_get_lock_address(sw_port, &lock_address_count) == CU_OK)
        {
                if (lock_address_count != 0)
                {
                        uprintf("%s has lock-address configuration on the port\n", port_string);
                        return 1;
                }
                                
        }
        if(IS_DOT1X_PORT_ENABLED(sw_port))
        {
                uprintf("%s has dot1x configuration on the port\n", port_string);
                return 1;
        }
        /* Check for port-name configuration */
        if(cu_get_port_name(sw_port, NULL)!=NULL)
        {
                uprintf("Port name is configured on port %p \n", sw_port);
                return 1;
        }
        /* Check for lag configuration on sw_port */
        if((cb = GET_LAG_BY_PORT(sw_port) != NULL))
        {
                uprintf("%p has LAG configuration on the port\n", sw_port);
                return 1;
        }
        
#ifndef NO_OPTICAL_MONITOR
        /* Check for optical monitor configuration */
        if((SPTR_PORT_DB(sw_port))->port_config.optical_monitor_interval != 0)
        {
                uprintf("Optical-monitor is configured on port %p \n", sw_port);
                return 1;
        }
#endif NO_OPTICAL_MONITOR
 
    /* Check for static mac configuration */
    if(port_ptr->static_stn_cnt != 0)
    {
       uprintf("%p has static mac configuration on the port\n", sw_port);
       return 1;
    }

        return 0;
}

int cli_config_verify_for_interface(
        struct cdb *sptr_cdb, PORT_ID sw_port)
{
    int ret = -1;
    int tmp_show_brk_run;

    tmp_show_brk_run  = g_show_breakout_running;
    g_show_breakout_running = 0;
    ret = cu_config_verify_for_interface(sptr_cdb,sw_port);
    g_show_breakout_running = tmp_show_brk_run;

    return ret;
}


/* Should return true if it has configuration , else false */
int cu_validate_interface_for_config(struct cdb *sptr_cdb,PORT_ID port_id)
{
    PORT_ID port_id_chk;
    int flag = 0;

    port_id_chk = port_id;

    if(cli_allow_fourth_tuple(port_id_chk))     
    {
        if(g_parser_debug)
            debug_uprintf("  p=%x: allow 4th tupple\n", port_id_chk);
        for(port_id_chk; port_id_chk <=(port_id+3);port_id_chk++)
        {
            if(cli_config_verify_for_interface(sptr_cdb,port_id_chk) == 1)
            {
                /* Even if one sub port has config, it should still run all sub-ports in loop for the interface*/
                flag = 1;
                continue;
            }
        }
        if(flag)
        {
            if(g_parser_debug)
                debug_uprintf("  p=%x has config, ***abort\n", port_id_chk);
            return TRUE;
        }
    }
    else
    {
        if(g_parser_debug)
            debug_uprintf("  p=%x: NOT allow 4th tupple\n", port_id_chk);
        if(cli_config_verify_for_interface(sptr_cdb,port_id_chk) == 1)
        {
            if(g_parser_debug)
                debug_uprintf("  p=%x has config, ***abort\n", port_id_chk);
            return TRUE;
        }
    }   
    return FALSE;
}

/* Return TRUE if can be broken , else false*/
int cu_validate_interface_for_breakout_support(struct cdb *sptr_cdb,PORT_ID port_id)
{
    int tmp_show_brk_run;
    int stack_module = -1;
    tmp_show_brk_run  = g_show_breakout_running;
    g_show_breakout_running = 0;

    stack_module = PORT_TO_MODULE_ID_LOCAL(port_id);
    if((!MODULE_EXIST(stack_module)) && MODULE_IS_CONFIGURED(stack_module))   
    {
        uprintf("\nPort %p : cannot breakout port in a configured module\n", port_id);
        if(g_parser_debug)
            debug_uprintf("  get_subport_4th_t(p=%x)=0 cannot be broken out, ***abort\n", port_id);
        g_show_breakout_running = tmp_show_brk_run;
        return FALSE;
    }

    if(get_subport_fourth_tuple(port_id)==0)
    {
        uprintf("\nPort %p : cannot breakout port\n", port_id);
        if(g_parser_debug)
            debug_uprintf("  get_subport_4th_t(p=%x)=0 : cannot be breakout port, ***abort\n", port_id);
        g_show_breakout_running = tmp_show_brk_run;
        return FALSE;
    }
    if(is_phy_84328_chip_A0(port_id)) //Breakout is only supported on rear module chip version 0x00b0 and above
    {
        uprintf("Error: breakout is not supported on %p port. Please use chip-revision 0x00b0 and above.\n", port_id);
        g_show_breakout_running = tmp_show_brk_run;
        return FALSE;
    }
    if(sptr_cdb->no && (get_breakout_interface(port_id) != 1))
    {
         if (!is_init_in_progress())
         {
             /* g_show_breakout_running = 1 this will make sure displaying 3 tuples*/
             g_show_breakout_running = 1;
             if(get_breakout_interface_operational(port_id)==1)
                 uprintf("Port %p is not configured for breakout but is operational; please wr mem and reload.\n",get_breakoutPort_from_swport(port_id));
             else
                 uprintf("Port %p is not configured for breakout\n",get_breakoutPort_from_swport(port_id));
             g_show_breakout_running = tmp_show_brk_run;
             return FALSE;
         }
    }
    else if(!sptr_cdb->no && (get_breakout_interface(port_id) == 1))
    {
        if (!is_init_in_progress())
        {
            /* g_show_breakout_running = 1 this will make sure displaying 3 tuples*/
            g_show_breakout_running = 1;
            if(!(get_breakout_interface_operational(port_id)==1))
                uprintf("Port %p is already configured for breakout but is not operational; please wr mem and reload.\n",get_breakoutPort_from_swport(port_id));
            else
                uprintf("Port %p is already configured for breakout\n",get_breakoutPort_from_swport(port_id));
            g_show_breakout_running = tmp_show_brk_run;
            return FALSE;
        }
    }
    g_show_breakout_running = tmp_show_brk_run;
    return TRUE;
}

/* return CU_OK if no issues , else CU_ERROR */
int cu_validate_breakout_port(struct cdb *sptr_cdb,PORT_ID port_id)
{
    if(cu_validate_interface_for_breakout_support(sptr_cdb,port_id) == FALSE)
        return CU_ERROR;

    if(cu_validate_interface_for_config(sptr_cdb,port_id) == TRUE)
        return CU_ERROR;

    return CU_OK;
}

void cli_config_gen_interface_breakout(struct cdb* sptr_cdb)
{
    PORT_ID port_id;
    PORT_ID f = NULL;
    PORT_ID t = NULL;
    PORT_ID prev_port = NULL;
    UINT8 curr_slot = NULL;
    UINT8 prev_slot = NULL;
    int i;
    int breakout_show = 1;
    int counter = 1;
    g_show_breakout_running = 1;

    if (sptr_cdb->config_gen)
    {
        for (i=0; i < g_hw_info.total_config_ports;i++)
        {       
            port_id = sw_config_port_list[i];
                        if(!IS_PORT_DB_VALID(port_id))
                                continue;
            curr_slot = PORT_TO_MODULE_ID_LOCAL(port_id)+1;
            if ((get_breakout_interface(port_id)==1) && (is_physical_port(port_id)))
            {
                if (breakout_show)
                {
                    ksprintf(cu_line_buf, "breakout");
                    wr_config(sptr_cdb, cu_line_buf);
                    breakout_show = 0;
                }
                if(counter == 1)
                {
                    f = port_id;
                    prev_slot = curr_slot;
                    counter = 0;
                }
                                if(prev_slot == curr_slot)
                    {
                        prev_slot = curr_slot;
                        prev_port = port_id;
                        if(get_breakout_interface_operational(port_id)==1 ||
                            (MODULE_IS_CONFIGURED(PORT_TO_MODULE_ID(port_id)) && get_breakout_interface(port_id)))
                                                        i=i+3;
                        continue;
                    }
                else
                    {
                        t = prev_port;
                                                /* For second and third module decrement the port_id value and iterate again since counter will set to  1 */
                                                i = i-1;
                        counter = 1;
                    }
                        }
            else if((get_breakout_interface(port_id)==0))
            {
                if(counter == 0)
                {
                    t = prev_port;
                    counter = 1;
                }
            }

            if((f != NULL) && (t != NULL))
            {
                if(f == t)
                {
				    ksprintf(cu_line_buf, " ethernet %L",
							 get_port_num(get_breakoutPort_from_swport(f)));
                    wr_config(sptr_cdb, cu_line_buf);
                }
                else
                {
					ksprintf(cu_line_buf, " ethernet %L to %L",
							get_port_num(get_breakoutPort_from_swport(f)),
							get_port_num(get_breakoutPort_from_swport(t)));
                    wr_config(sptr_cdb, cu_line_buf);
                }
               f = NULL;
               t = NULL;
            }
        }
		if((f != NULL) && (t == NULL))
		{
			t = port_id;
			if(f == t)
			{       
				 ksprintf(cu_line_buf, " ethernet %L",
						 get_port_num(get_breakoutPort_from_swport(f)));
				wr_config(sptr_cdb, cu_line_buf);
			}
			else
			{
				ksprintf(cu_line_buf, " ethernet %L to %L",
						get_port_num(get_breakoutPort_from_swport(f)),
						get_port_num(get_breakoutPort_from_swport(t)));
				wr_config(sptr_cdb, cu_line_buf);
			}
		}

        ksprintf(cu_line_buf, "\n!\n!\n");
        wr_config(sptr_cdb, cu_line_buf);
    }
    g_show_breakout_running = 0;
}


void clear_breakout_add_delete_mask()
{
        PORT_MASK_ZERO_ARRAY(g_breakout_delete_mask,MAX_LOCAL_SLOT*MAX_STACKING_NUM);
        PORT_MASK_ZERO_ARRAY(g_breakout_add_mask,MAX_LOCAL_SLOT*MAX_STACKING_NUM);
}
void set_breakout_delete_mask(PORT_ID port_id)
{
        UINT8 ii;
        for(ii=0;ii<4;ii++)
        {
                PORT_MASK_SET(g_breakout_delete_mask[PORT_TO_MODULE_ID(port_id)], PORT_TO_MODULE_PORT(port_id+ii));
        }
        return;
}

void set_breakout_add_mask(PORT_ID port_id)
{
        UINT8 ii;
        for(ii=0;ii<4;ii++)
        {
                PORT_MASK_SET(g_breakout_add_mask[PORT_TO_MODULE_ID(port_id)], PORT_TO_MODULE_PORT(port_id+ii));
        }
        return;
}


int cu_set_reset_breakout_interface(struct cdb *sptr_cdb,PORT_ID port_id,int *print_required, int *intf_not_brkout_conf, int *intf_already_brkout_conf)
{
    if(sptr_cdb->no){
        if(get_breakout_interface(port_id) == 1)        
        {
            set_breakout_interface(port_id,0);
            if(!g_sw_sys.init_in_progress)
            {
                                clear_breakout_add_delete_mask();
                set_breakout_delete_mask(port_id);
            }
            /* skip no operational breakout port */
            if (get_breakout_interface_operational(port_id) == 1)
                *print_required = 1;
        }
        else
            *intf_not_brkout_conf = 1;
    }
    else 
    {
        if(g_parser_debug)
            debug_uprintf("  set_BrkOut_intf p=%x\n", port_id);
        if(get_breakout_interface(port_id) != 1)        
        {
            set_breakout_interface(port_id,1);
            if(!g_sw_sys.init_in_progress)
            {
                                clear_breakout_add_delete_mask();
                set_breakout_add_mask(port_id);
            }
            if (get_breakout_interface_operational(port_id) != 1)
            *print_required = 1;
        }
        else
            *intf_already_brkout_conf = 1;
    }
    return CU_OK;
}

int stack_check_if_stack_ports_configured(int stack_id, PORT_ID port_id)
{
    if((port_id == g_stacking.stacking_trunk_config_ary[stack_id][0].primary_port)  ||
            (port_id == g_stacking.stacking_trunk_config_ary[stack_id][1].primary_port))
    {
        /* stk_port will become PORT_INDEX_INVALID on configuring other port as stack_port   */
        if((g_stacking.stacking_trunk_config_ary[stack_id][0].stk_port != PORT_INDEX_INVALID) &&
                (g_stacking.stacking_trunk_config_ary[stack_id][1].stk_port != PORT_INDEX_INVALID))
        {
            return CU_ERROR;
        }
        else if(((port_id == g_stacking.stacking_trunk_config_ary[stack_id][0].primary_port) &&
                    (g_stacking.stacking_trunk_config_ary[stack_id][0].stk_port != PORT_INDEX_INVALID))||
                ((port_id == g_stacking.stacking_trunk_config_ary[stack_id][1].primary_port) && 
                 (g_stacking.stacking_trunk_config_ary[stack_id][1].stk_port != PORT_INDEX_INVALID)))
        {
            return CU_OK;
        }
    } 

    return CU_ERROR;
}

void cli_set_breakout_interface_to_interface(struct cdb* sptr_cdb)
{
        PORT_ID port_id,port_id1,port_id2;
    PORT_ID temp_portid;
        int i , print_required = 0;
    int stackId , stackId1;
    int intf_already_brkout_conf = 0 , intf_not_brkout_conf = 0;
        UINT8 next_token;
        enum BOOLEAN multi_ports = FALSE;

        if(!sptr_cdb->config_gen)
        {
                if(g_parser_debug)
                        debug_uprintf("set BrkOut, intf_to_intf, token=%s, if1=%x if2=%x, init=%u\n", 
                                sptr_cdb->token, sptr_cdb->if1, sptr_cdb->if2, g_sw_sys.init_in_progress);
                next_token = tolower(end_of_token(sptr_cdb->token));

                /* if next token is "to" or "?", command is not for us */
                if (next_token != 'e' && next_token != 0)
                {
                        if(g_parser_debug)
                                debug_uprintf("  next_t = %c !=e, ***abort\n", next_token);
                        return;
                }

                if (end_of_token(sptr_cdb->token) == '\0')
                {
                        if(g_parser_debug)
                                debug_uprintf("  no more, dont_go_next\n");
                        sptr_cdb->dont_go_next = 1;
                        //g_show_breakout_running = 0;
                }

        if(is_stacking_enabled())
        {
            g_show_breakout_running = 0;
            sptr_cdb->dont_go_next = 1;
            uprintf("Error: cannot configure breakout ports because stack is enabled\n");
            return;
        }

        if (is_gi_cut_through_config_enable())
        {
            g_show_breakout_running = 0;
            sptr_cdb->dont_go_next = 1;
            uprintf("Please switch to store-and-forward mode before configuring breakout ports \n");
            return;
        }
                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                {
                        sptr_cdb->dont_go_next = 1;
                        g_show_breakout_running = 0;
                        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                        if(g_parser_debug)
                                debug_uprintf("  fail validate, if1 = %x, ***abort\n", sptr_cdb->if1);
                        return;
                }
                if (!validate_interface_value(sptr_cdb, 2, ENET_INTERFACE))
                {
                        sptr_cdb->dont_go_next = 1;
                        g_show_breakout_running = 0;
                        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                        if(g_parser_debug)
                                debug_uprintf("  fail validate if2 = %x, ***abort\n", sptr_cdb->if2);
                        return;
                }
                
                /* port_id1 and portid2 contains the range entered by user*/
                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                port_id1 = INTERFACE_TO_PORT_ID(sptr_cdb->if2);

                /* To make the port range incremental */
                if(port_id > port_id1)
        {
            temp_portid = port_id1;
            port_id1 = port_id;
            port_id = temp_portid;
        }
                 
                port_id2 = port_id;
   
        stackId = INTERFACE_STACK_ID(sptr_cdb->if1);
        if ((stackId != MY_BOOTUP_STACK_ID) && (!STACK_AM_I_SLAVE))
        {
            uprintf("Error: breakout is not supported in stacking, cannot configure breakout on port %p \n", get_breakoutPort_from_swport(port_id));
            sptr_cdb->dont_go_next = 1;
            g_show_breakout_running = 0;
            return;
        }

        stackId1 = INTERFACE_STACK_ID(sptr_cdb->if2);
        if ((stackId1 != MY_BOOTUP_STACK_ID) && (!STACK_AM_I_SLAVE))
        {
            uprintf("Error: breakout is not supported in stacking, cannot configure breakout on port %p \n", get_breakoutPort_from_swport(port_id1));
            sptr_cdb->dont_go_next = 1;
            g_show_breakout_running = 0;
            return;
        }

        if ((stackId == MY_BOOTUP_STACK_ID) && g_stacking.stack_has_config_ary[stackId])
        {
            if (!stack_check_if_default_port_is_default(stackId))
            {
                uprintf("Error: breakout is not supported in stacking, remove all stacking configuration.\n");
                g_show_breakout_running = 0;    
                sptr_cdb->dont_go_next = 1;
                return;
            }
            if ((g_stacking.stacking_trunk_config_ary[stackId][0].num_trunk_port > 1) || 
                    (g_stacking.stacking_trunk_config_ary[stackId][1].num_trunk_port > 1))
            {
                uprintf("Error: breakout is not supported in stacking, remove stacking trunk configuration.\n");
                g_show_breakout_running = 0;    
                sptr_cdb->dont_go_next = 1;
                return;
            }

            if((!sptr_cdb->no) && stack_check_if_stack_ports_configured(stackId,port_id) == CU_OK) 
            {
                uprintf("Error: breakout is not supported in stacking, remove stacking ports configuration.\n");
                g_show_breakout_running = 0;
                sptr_cdb->dont_go_next = 1;
                return;
            }

            if((!sptr_cdb->no) && stack_check_if_stack_ports_configured(stackId1,port_id1) == CU_OK) 
            {
                uprintf("Error: breakout is not supported in stacking, remove stacking ports configuration.\n");
                g_show_breakout_running = 0;
                sptr_cdb->dont_go_next = 1;
                return;
            }
        }
        /* Port_id2 range check should be for all 4 subports if operational*/
          if(cli_allow_fourth_tuple(port_id1))
          {
                          if(g_parser_debug)
                                  debug_uprintf("  p=%x: allow 4th tup\n", port_id1);
            port_id1 = port_id1+3;
          }

                // kklin, a standby must accept whatever in the base config sync from the master
                // If a breakout port is disabled, somehow it shows up here.
                if(STACK_AM_I_STANDBY && g_sw_sys.init_in_progress)
                        goto standby_skip_check1;

standby_skip_check1:

                if (!is_mask_clear(sptr_cdb->mif_port_mask))
                        multi_ports = TRUE;
                sptr_cdb->if_type = ETHERNET;
                sptr_cdb->if_num = sptr_cdb->if1;

                if (next_token == 'e' || multi_ports)
                {
                        sptr_cdb->parent_mode = CONFIG_MIF;
                        set_mask_bit(sptr_cdb->mif_port_mask, INTERFACE_TO_PORT_ID(sptr_cdb->if1));
                        sptr_cdb->num_of_if = 0;
                }
                
                if(!g_sw_sys.init_in_progress)
                {
                        clear_breakout_add_delete_mask();
                }
                for(port_id;port_id<=port_id1;)
                {
                        /* Each port needs to be validate before set the breakout interface */
                        if(!IS_PORT_DB_VALID(port_id))
                        {
                port_id = port_id + 1;
                                if(g_parser_debug)
                                        debug_uprintf("  p=%x invalid port db, continue\n", port_id);
                                continue;
                        }
                        // kklin, a standby must accept whatever in the base config sync from the master
                        if(STACK_AM_I_STANDBY && g_sw_sys.init_in_progress)
                                goto standby_skip_check2;

            if(IS_MGMT_PORT(port_id)){
            port_id = port_id + 1;
                continue;
            }

            if(cu_validate_interface_for_breakout_support(sptr_cdb,port_id) == FALSE)
                        {
                                /*If port breakout is already operational then add port + 4 for looping
                                 cu_validate_interface_for_breakout_support() checks and return FALSE if port is already breakout configured */
                if(get_breakout_interface_operational(port_id)==1) 
                                        port_id = port_id + 4;
                                else
                                        port_id = port_id + 1;
                                continue;
                        }
            if(cu_validate_interface_for_config(sptr_cdb,port_id) == TRUE)
            {
                port_id = port_id + 4;
                continue;
            }

standby_skip_check2:

            cu_set_reset_breakout_interface(sptr_cdb,port_id,&print_required,&intf_not_brkout_conf,&intf_already_brkout_conf);
            
            port_id = port_id + 4;
                }
        
        if((end_of_token(sptr_cdb->token) == '\0') && g_show_breakout_running) 
        {
                        if(g_parser_debug)
               debug_uprintf("Resetting the variable g_show_breakout_running\n");
            /* g_show_breakout_running should be set to 1 when parsing for 3 tuple during breakout command
             * so when executing "breakout eth 1/1/5 to 1/1/7 eth 1/2/1" it should not be resetted*/
            g_show_breakout_running = 0;        
            sptr_cdb->dont_go_next = 1;
        }

                if(!g_sw_sys.init_in_progress)
                {
                        trigger_dynamic_breakout_initialization();
                }

        if(!g_sw_sys.init_in_progress)
        {
            if(intf_already_brkout_conf)
                uprintf("Some interfaces are already configured for breakout\n");
            else if(intf_not_brkout_conf)
                uprintf("Some interfaces are not configured for breakout\n");
        }
                /* need to reload the device for adding/deleting breakout ports */
                if(!g_sw_sys.init_in_progress && print_required && (end_of_token(sptr_cdb->token) == '\0'))
                    print_require_reload();
                
        }
        return;
}


void cli_set_breakout_interface(struct cdb* sptr_cdb)
{
        UINT8 next_token;
        enum BOOLEAN multi_ports = FALSE;
        PORT_ID port_id;
        int i , stackId;
        static int print_required;
    int intf_already_brkout_conf = 0 , intf_not_brkout_conf = 0;
        int breakout_show = 1 , sptr_intf_value = 0;
        if(!sptr_cdb->config_gen)
        {
                if(g_parser_debug)
                        debug_uprintf("set BrkOut, intf, token=%s, if1=%x, init=%u\n", 
                                sptr_cdb->token, sptr_cdb->if1, g_sw_sys.init_in_progress);
        next_token = tolower(end_of_token(sptr_cdb->token));
        
                /* if next token is "to" or "?", command is not for us */
                if (next_token != 'e' && next_token != 0)
                {
                        if(g_parser_debug)
                                debug_uprintf("  next_t = %c != e, ***abort\n", 
                                        sptr_cdb->token, next_token);
                        return;
                }
        
                if (end_of_token(sptr_cdb->token) == '\0')
                {
                        if(g_parser_debug)
                                debug_uprintf("  no more, dont_go_next\n", 
                                        sptr_cdb->token);
                        sptr_cdb->dont_go_next = 1;
                }

        if(is_stacking_enabled())
        {
            g_show_breakout_running = 0;
            sptr_cdb->dont_go_next = 1;
            uprintf("Error: cannot configure breakout ports because stack is enabled\n");
            return;
        }
      
        if (is_gi_cut_through_config_enable())
        {
            g_show_breakout_running = 0;
            sptr_cdb->dont_go_next = 1;
            uprintf("Please switch to store-and-forward mode before configuring breakout ports \n");
            return;
        }
                
                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
        {
                         sptr_cdb->dont_go_next = 1;
                         g_show_breakout_running = 0;
                         sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                         if(g_parser_debug)
                                 debug_uprintf("  fail validate, if1 = %x, ***abort\n", sptr_cdb->if1);
             return;
                 }
            
        /* num_of_if would have be incremented already before reaching this */
        if (sptr_cdb->num_of_if == 1)
            sptr_intf_value = sptr_cdb->if1;
        else if (sptr_cdb->num_of_if == 2)
            sptr_intf_value = sptr_cdb->if2;
        else if (sptr_cdb->num_of_if == 3)
            sptr_intf_value = sptr_cdb->if3;
        else if (sptr_cdb->num_of_if == 4)
            sptr_intf_value = sptr_cdb->if4;
        else
            sptr_intf_value = sptr_cdb->if1;

                port_id = INTERFACE_TO_PORT_ID(sptr_intf_value);
        
        stackId = INTERFACE_STACK_ID(sptr_intf_value);
        if ((stackId != MY_BOOTUP_STACK_ID) && (!STACK_AM_I_SLAVE))
        {
            uprintf("Error: breakout is not supported in stacking, cannot configure breakout on port %p \n",get_breakoutPort_from_swport(port_id));
            sptr_cdb->dont_go_next = 1;
            g_show_breakout_running = 0;
            return;
        }
/*
        if ((stackId == MY_BOOTUP_STACK_ID) && (!STACK_AM_I_SLAVE)) {
                if(!check_set_unset_media_can_be_breakout(port_id)) { // TR 545911
                        uprintf("Error: breakout is not supported in media type.  port %p cannot be broken out\n",get_breakoutPort_from_swport(port_id));
                        return;
                }
        }
*/
        /* TR538141 */
        if ((stackId == MY_BOOTUP_STACK_ID) && g_stacking.stack_has_config_ary[stackId])
        {
                if (!stack_check_if_default_port_is_default(stackId))
                {
                        uprintf("Error: breakout is not supported in stacking, remove all stacking configuration.\n");
                        g_show_breakout_running = 0;    
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
                if ((g_stacking.stacking_trunk_config_ary[stackId][0].num_trunk_port > 1) || 
                        (g_stacking.stacking_trunk_config_ary[stackId][1].num_trunk_port > 1))
                {
                        uprintf("Error: breakout is not supported in stacking, remove stacking trunk configuration.\n");
                        g_show_breakout_running = 0;    
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                if((!sptr_cdb->no) && stack_check_if_stack_ports_configured(stackId,port_id) == CU_OK) 
                {
                        uprintf("Error: breakout is not supported in stacking, remove stacking ports configuration.\n");
                        g_show_breakout_running = 0;
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
        }

        /* get_subport_fourth_tuple function will return 0 for ports that cannot be broken out */
        // If standby has breakout port disabled, its port db has config.
        if(STACK_AM_I_STANDBY && g_sw_sys.init_in_progress)
                        goto standby_skip_check1;

        if (cu_validate_breakout_port(sptr_cdb,port_id) == CU_ERROR)
        {
            if((end_of_token(sptr_cdb->token) == '\0') && g_show_breakout_running) 
            {
                if(g_parser_debug)
                    debug_uprintf("Resetting the variable g_show_breakout_running\n");
                /* g_show_breakout_running should be set to 1 when parsing for 3 tuple during breakout command
                 * so when executing "breakout eth 1/1/5 to 1/1/7 eth 1/2/1" it should not be resetted*/
                g_show_breakout_running = 0;    
                sptr_cdb->dont_go_next = 1;
                                /* check for print_required flag before returning from end_of_taken                 
                                 * since the print statement are missed for reverse configuring breakout ports like "bre e 1/1/6 e 1/1/5 e 1/1/4" */
                                if(print_required)
                                {
                                        print_require_reload();
                                        print_required=0;
                                }
            }
            return;
        }

standby_skip_check1:
                if (!is_mask_clear(sptr_cdb->mif_port_mask))
            multi_ports = TRUE;
                
                sptr_cdb->if_type = ETHERNET;
        sptr_cdb->if_num = sptr_cdb->if1;
                if (next_token == 'e' || multi_ports)
        {
                sptr_cdb->parent_mode = CONFIG_MIF;
            set_mask_bit(sptr_cdb->mif_port_mask, INTERFACE_TO_PORT_ID(sptr_cdb->if1));
            sptr_cdb->num_of_if = 0;
        }

        cu_set_reset_breakout_interface(sptr_cdb,port_id,&print_required,&intf_not_brkout_conf,&intf_already_brkout_conf);

        if((end_of_token(sptr_cdb->token) == '\0') && g_show_breakout_running) 
        {
                        if(g_parser_debug)
               debug_uprintf("Resetting the variable g_show_breakout_running\n");
            /* g_show_breakout_running should be set to 1 when parsing for 3 tuple during breakout command
             * so when executing "breakout eth 1/1/5 to 1/1/7 eth 1/2/1" it should not be resetted*/
            g_show_breakout_running = 0;        
            sptr_cdb->dont_go_next = 1;
        }

                if(!g_sw_sys.init_in_progress)
                        {
                                trigger_dynamic_breakout_initialization();
                        }
                
                        if (next_token == 0)
                        {
                                if (sptr_cdb->port_mask_callback)
                                        (*sptr_cdb->port_mask_callback)(sptr_cdb);
                        } 

        if(!g_sw_sys.init_in_progress)
        {
            if(intf_already_brkout_conf)
                uprintf("Interface is already configured for breakout\n");
            else if(intf_not_brkout_conf)
                uprintf("Interface is not configured for breakout\n");
        }
                /* need to reload the device for adding/deleting breakout ports */
                if(!g_sw_sys.init_in_progress && print_required && (end_of_token(sptr_cdb->token) == '\0'))
                {
                    print_require_reload();
                        print_required = 0;
                }
}
//      else check_set_unset_media_can_be_breakout(port_id); // removing existing non-capable breakout media or no touch during show run

        return;
}
#endif

int cu_get_intf_port_type(PORT_ID  port_id)
{
    int ret_value,stack_id;

    if(!IS_PORT_DB_VALID(port_id))
        return CU_ERROR;

    if(IS_LAG_AP(port_id)  && (LAG_AP_TO_LAG_ID(port_id) > 256))
        ret_value = EXT_PORT_TYPE_CASCADE;
    else if(IS_LAG_AP(port_id))
		ret_value = EXT_PORT_TYPE_VLAG;
    else if(is_port_cb_enable(port_id) == 1)
        ret_value = EXT_PORT_TYPE_CASCADE;
    else if (is_port_pe_stk_port(port_id) == 1)
        ret_value = EXT_PORT_TYPE_UPLINK;
    else
    {
        stack_id = PORT_TO_STACK_ID(port_id);
        if((stack_id >= PE_START_NUM)  && (stack_id <= MAX_SYS_UNIT_NUM))
            ret_value = EXT_PORT_TYPE_HOST;
        else
            ret_value= EXT_PORT_TYPE_NONE;
    }

    return ret_value;
}

int cu_clean_interface_config(PORT_ID port_id)
{
    struct cdb* my_cdb;
    struct cdb* sptr_cdb;
    PORT_ID current_port;
   unsigned char *line = NULL;	
    my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb));

    if (!my_cdb)
    {
        return;
    }
	
    memcpy(my_cdb,&cdbs[g_cu_session],sizeof(struct cdb));
    sptr_cdb = &cdbs[g_cu_session];
    sptr_cdb->ui_port = g_cu_session ;
    #if 0
    if (sptr_cdb->line != NULL)
    {
            sptr_cdb->token = sptr_cdb->line;
    }
    else if((line = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE+1)) != NULL)
    {
            line[0] = '\0';
            sptr_cdb->line = line;
            sptr_cdb->token = sptr_cdb->line;
    }
   #endif
	if (sptr_cdb->mode != CONFIG)
    {
        set_cli_mode(sptr_cdb, CONFIG);
        sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
    }
    if(IS_LAG_AP(port_id))
    {
        sptr_cdb->if_type = VLAG;
        sptr_cdb->if_num = PORT_ID_TO_INTERFACE(port_id);
        sptr_cdb->if1 = PORT_ID_TO_INTERFACE(port_id);
        sptr_cdb->parent_mode = CONFIG_IF_LAG;
        set_cli_mode(sptr_cdb, CONFIG_IF_LAG);
    }
    else
    {
        sptr_cdb->if_type = ETHERNET;
        sptr_cdb->if_num = PORT_ID_TO_INTERFACE(port_id);
        sptr_cdb->if1 = PORT_ID_TO_INTERFACE(port_id);
        sptr_cdb->parent_mode = CONFIG_IF;
        set_cli_mode(sptr_cdb, CONFIG_IF);
    }

    current_port = sptr_cdb->if_num;

#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
    ospf6_remove_distribute_list_on_interface(current_port-1);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__
    sptr_cdb->if_num = sptr_cdb->if1;
#ifdef MPLS
    if(GET_PORT_MPLS_ENABLE(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)) && !GET_PORT_FORCED_DELETION(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
    {
        uprintf("Error: Port %p is an MPLS port.\n", INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
    }
#endif MPLS
    if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
            (INTERFACE_TO_PORT_ID(sptr_cdb->if_num) == ntp_source_interface()))
    {
        uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
    
   }
    /*This is spefic to Spatha32p , Minions does not have port pairing issue*/
    else if (is_platform_got_port_pair_limitation() && (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
            (SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) && 
			IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
    {
        
			uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
    }                    
    else
    {
        default_interface(sptr_cdb);
    }
    sptr_cdb->if_num = current_port;
    if(my_cdb->mode == sptr_cdb->mode)
    {
        my_cdb->mode = CONFIG;
    }
	memcpy(sptr_cdb,my_cdb,sizeof(struct cdb));
	set_cli_mode(sptr_cdb, sptr_cdb->mode);
	if(line!=NULL)
	dy_free(line);	
    dy_free(my_cdb);
    return CU_OK;
}

void cli_test_remove_interface_config_from_sw_port(struct cdb* sptr_cdb)
{
	PORT_ID port_id;
	port_id = sptr_cdb->integer1;
	cu_clean_interface_config(port_id);
}

void set_if_vlag(struct cdb* sptr_cdb)
{
        UINT8 next_token;
        enum BOOLEAN multi_ports=FALSE;
        PORT_ID slot, port, current_port,port_id_val;
        int i, j;
        int lag_id = 0, phy_intf = -1;
        int port_type_value, first_port_type;
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        /* if next token is neither "ethernet" nor NULL,
         * this command is not for us
         */
        next_token = tolower(end_of_token(sptr_cdb->token));
		//if (next_token != '\0' && next_token != 'e')
        if (next_token != '\0' && next_token != 'l')
                return;

        //reset mode_vrf_index here for all interface command.
        cli_reset_vrf_mode(sptr_cdb);

        /*
         * The following situation only happens when we parse the
         * configuration file during initialization:
         * Configuration file does not have an "exit" command
         * to jump from CONFIG_IF mode to CONFIG mode. If an
         * interface number is invalid, we could be left in the
         * CONFIG_IF mode from the last valid interface command.
         * Therefore, we need to reset the mode to CONFIG before
         * we parse interface command.
         */
        if (sptr_cdb->mode != CONFIG)
        {
                set_cli_mode(sptr_cdb, CONFIG);
                sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
        }

        if((sptr_cdb->if1 < LAG_START_PORT) || (sptr_cdb->if1 > LAG_END_PORT))
        {
            uprintf("Error: Valid range is lg<1-%d> \n",MAX_LAG_PORTS);
            sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
            return;
        }
        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
        {
                sptr_cdb->dont_go_next = 1;
                sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                return;
        }

        if (cli_port_is_stacking_port(sptr_cdb, INTERFACE_TO_PORT_ID(sptr_cdb->if1), TRUE, 1))
                return;

        slot=INTERFACE_SLOT(sptr_cdb->if1);
        port=INTERFACE_PORT(sptr_cdb->if1);

        // The tftp runconfig and init should not allow this CLI function. TR267219
        if(INIT_AND_TFTP_NOT_IN_PROG())
        {
                if (cu_is_port_trunk_secondary(0, INTERFACE_TO_PORT_ID(sptr_cdb->if1)))
                {
                        uprintf("Error - cannot configure secondary ports of a trunk\n");
                        sptr_cdb->dont_go_next = 1;
                        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                        return;
                }
        }

        if (!is_mask_clear(sptr_cdb->mif_port_mask))
        {
            multi_ports = TRUE;
            /* validate the interface port type parsing to the rest of the interfaces which is already parsed.*/
            first_port_type = CU_ERROR;
            first_port_type = cu_get_intf_port_type(sptr_cdb->if1-1);
            for (i=0; i < g_hw_info.total_config_ports; i++)
            {
                port_id_val = sw_config_port_list[i];

                if(!IS_PORT_DB_VALID(port_id_val))
                    continue;

                if (!is_member(sptr_cdb->mif_port_mask, port_id_val))
                    continue;

                if(IS_SPX_PORT(port_id_val))
                    port_id_val = get_oper_trunk_primary_port(port_id_val);

                if(cu_validate_interface_port_type(port_id_val,first_port_type) != CU_OK)
                {
                    uprintf("\nError: Atleast one port type for multi interface is not correct\n");
                    clear_mask(sptr_cdb->mif_port_mask);
                    sptr_cdb->dont_go_next = 1;
                    sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                    return;
                }
            }
        }

        if (next_token == '\0' && sptr_cdb->no &&
            cli_is_mode_conflict_found(sptr_cdb, CONFIG_IF_LAG))    /* code from NI 5.2 that effects no command */
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        //sptr_cdb->if_type = ETHERNET;		
        sptr_cdb->if_type = VLAG;
        sptr_cdb->if_num = sptr_cdb->if1;
        if (next_token == 'l' || multi_ports)
        {
            if (LAG_AP_TO_LAG_ID(sptr_cdb->if1-1) > 256)
            {
                phy_intf = LAG_AP_TO_FIRST_PHY_PORT(sptr_cdb->if1-1);
                sptr_cdb->if1 = phy_intf + 1;
                sptr_cdb->parent_mode = CONFIG_MIF_SPX;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb,CONFIG_MIF_SPX);
            }
            else
            {
                sptr_cdb->parent_mode = CONFIG_MIF_LAG;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb,CONFIG_MIF_LAG);
            }
            set_mask_bit(sptr_cdb->mif_port_mask, INTERFACE_TO_PORT_ID(sptr_cdb->if1));
            sptr_cdb->num_of_if = 0;

        }
		#if 0
		 if (next_token == 'e' || multi_ports)
        {
            port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);
		
			//A port configured as ZTP should behave same as SPX port, The prompt and mode would be similar to SPX port. 
            if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
            {
                sptr_cdb->parent_mode = CONFIG_MIF_SPX;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb,CONFIG_MIF_SPX);
            }
            else if(port_type_value == EXT_PORT_TYPE_HOST)
            {
                sptr_cdb->parent_mode = CONFIG_MIF_PE;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb,CONFIG_MIF_PE);
            }
            else
            {
                sptr_cdb->parent_mode = CONFIG_MIF;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb, CONFIG_MIF);
            }
            set_mask_bit(sptr_cdb->mif_port_mask, INTERFACE_TO_PORT_ID(sptr_cdb->if1));
            sptr_cdb->num_of_if = 0;
        }
        else
        {
            port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);

            //A port configured as ZTP should behave same as SPX port , The prompt and mode would be similar to SPX port. 
            if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
            {
                sptr_cdb->parent_mode = CONFIG_IF_SPX;
                set_cli_mode(sptr_cdb,CONFIG_IF_SPX);
            }
            else if(port_type_value == EXT_PORT_TYPE_HOST)
            {
                sptr_cdb->parent_mode = CONFIG_IF_PE;
                set_cli_mode(sptr_cdb,CONFIG_IF_PE);
            }
        }
		#endif
        else
        {
            lag_id = LAG_AP_TO_LAG_ID(sptr_cdb->if1-1);
            if(lag_id > 256)
            {
                phy_intf = LAG_AP_TO_FIRST_PHY_PORT(sptr_cdb->if1 - 1);
                sptr_cdb->if1 = phy_intf + 1;
                sptr_cdb->if_type = ETHERNET;
                sptr_cdb->if_num = sptr_cdb->if1;
                sptr_cdb->parent_mode = CONFIG_IF_SPX;
                set_cli_mode(sptr_cdb,CONFIG_IF_SPX);
            }
            else
            {
                sptr_cdb->parent_mode = CONFIG_IF_LAG;
                set_cli_mode(sptr_cdb, CONFIG_IF_LAG);
            }
        }

        sptr_cdb->vlan_group_id = 0;

        if (next_token == '\0') {
                sptr_cdb->dont_go_next = 1; /* stop parser in here */

                if (sptr_cdb->no)       /* bug 000348697 fix: srepalle: resolution: remove interfaces for ports for which port masks set */
                {
                                                        no_int_eth_flag = TRUE;

                                                        if (sptr_cdb->num_of_if)
                                                                {
                                                                                                current_port = sptr_cdb->if_num;

#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
                                                                                                ospf6_remove_distribute_list_on_interface(current_port-1);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__
                                                                                                sptr_cdb->if_num = sptr_cdb->if1;
                                                                #ifdef MPLS
                                                                                                if(GET_PORT_MPLS_ENABLE(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)) && !GET_PORT_FORCED_DELETION(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                                                                                {
                                                                                                        uprintf("Error: Port %p is an MPLS port.\n", INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                                                                }
                                                            #endif MPLS
                                                                                                if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
                                                                                                                (INTERFACE_TO_PORT_ID(sptr_cdb->if_num) == ntp_source_interface()))
                                                                                                {
                                                                                                        uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                                                                                                                         INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                                                                
												}
												/*This is specific to Spatha32p , Minions does not have port pairing issue*/
												else if (is_platform_got_port_pair_limitation() && (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
                                                               (SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) &&
															   IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                                                                                {

                                                                                                        uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                                                                                                                      INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                                                                }                    
                                                                                                else
                                                                                                {
                                                                                                        default_interface(sptr_cdb);
                                                                                                }
                                                                                                sptr_cdb->if_num = current_port;
                                                                                        }

                                        else {
                                        for (i = 0; i < g_hw_info.max_mod; i++) {
                                        if (!PORT_MASK_ISSET_ANY(sptr_cdb->mif_port_mask[i]))
                                                continue;
                                        for (j = 0, port = MAKE_PORTID(i, 0); j < g_module[i].number_of_ports; j++, port++) {
                                                if (!PORT_MASK_ISSET(sptr_cdb->mif_port_mask[i], j))
                                                        continue;
                                                if(!IS_PORT_DB_VALID(port)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                                        continue;
                                                current_port = sptr_cdb->if_num;
#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
                                                ospf6_remove_distribute_list_on_interface(current_port-1);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__
                                                sptr_cdb->if_num = PORT_ID_TO_INTERFACE(port);
                                        #ifdef MPLS
                                                if(GET_PORT_MPLS_ENABLE(port) && !GET_PORT_FORCED_DELETION(port))
                                                {
                                                        uprintf("Error: Port %p is an MPLS port.\n", port);
                                                }
                                     #endif MPLS
                                            if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
                                                                (port == ntp_source_interface()))
                                                {
                                                        uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                                                                         port);
                                                }
						/*This is specific to Spatha32p , Minions does not have port pairing issue*/
											    else if (is_platform_got_port_pair_limitation() && (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
                                                	(SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) &&
													IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                                {

                                                     	uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                                                             INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                }     
                                                else
                                                {
                                                        default_interface(sptr_cdb);
                                                }
                                                sptr_cdb->if_num = current_port;
                                        }
                                }
                        }

                                                        // reset sptr_cdb variables to config.
                                                        sptr_cdb->parent_mode = CONFIG;
                                                        set_cli_mode(sptr_cdb, CONFIG);
                                                        clear_mask(sptr_cdb->mif_port_mask);
                                        }
        }
}

void set_if_enet(struct cdb* sptr_cdb)
{
        UINT8 next_token;
        enum BOOLEAN multi_ports=FALSE;
        PORT_ID slot, port, current_port,port_id_val,primary_port_id_val;
        int i, j;
        int port_type_value, first_port_type;
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        /* if next token is neither "ethernet" nor NULL,
         * this command is not for us
         */
        next_token = tolower(end_of_token(sptr_cdb->token));
        if (next_token != '\0' && next_token != 'e')
                return;

        //reset mode_vrf_index here for all interface command.
        cli_reset_vrf_mode(sptr_cdb);

        /*
         * The following situation only happens when we parse the
         * configuration file during initialization:
         * Configuration file does not have an "exit" command
         * to jump from CONFIG_IF mode to CONFIG mode. If an
         * interface number is invalid, we could be left in the
         * CONFIG_IF mode from the last valid interface command.
         * Therefore, we need to reset the mode to CONFIG before
         * we parse interface command.
         */
        if (sptr_cdb->mode != CONFIG)
        {
                set_cli_mode(sptr_cdb, CONFIG);
                sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
        }

        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
        {
                sptr_cdb->dont_go_next = 1;
                sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                return;
        }

        if (cli_port_is_stacking_port(sptr_cdb, INTERFACE_TO_PORT_ID(sptr_cdb->if1), TRUE, 1))
                return;

        slot=INTERFACE_SLOT(sptr_cdb->if1);
        port=INTERFACE_PORT(sptr_cdb->if1);
#if 0
        // The tftp runconfig and init should not allow this CLI function. TR267219
        if(INIT_AND_TFTP_NOT_IN_PROG())
        {
                if (cu_is_port_trunk_secondary(0, INTERFACE_TO_PORT_ID(sptr_cdb->if1)))
                {
                        uprintf("Error - cannot configure secondary ports of a trunk\n");
                        sptr_cdb->dont_go_next = 1;
                        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                        return;
                }
        }
#endif
        if (!is_mask_clear(sptr_cdb->mif_port_mask))
        {
                multi_ports = TRUE;
                /* validate the interface port type parsing to the rest of the interfaces which is already parsed.*/
                first_port_type = CU_ERROR;
                first_port_type = cu_get_intf_port_type(sptr_cdb->if1-1);
                for (i=0; i < g_hw_info.total_config_ports; i++)
                {
                    port_id_val = sw_config_port_list[i];

                    if(!IS_PORT_DB_VALID(port_id_val))
                        continue;

                    if (!is_member(sptr_cdb->mif_port_mask, port_id_val))
                        continue;

                    if(IS_SPX_PORT(port_id_val))
                        port_id_val = get_oper_trunk_primary_port(port_id_val);

                    if(cu_validate_interface_port_type(port_id_val,first_port_type) != CU_OK)
                    {
                        uprintf("\nError: Atleast one port type for multi interface is not correct\n");
                        clear_mask(sptr_cdb->mif_port_mask);
                        sptr_cdb->dont_go_next = 1;
                        sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                        return;
                    }
                }
        }

        if (next_token == '\0' && sptr_cdb->no &&
            cli_is_mode_conflict_found(sptr_cdb, CONFIG_IF))    /* code from NI 5.2 that effects no command */
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        sptr_cdb->if_type = ETHERNET;
        sptr_cdb->if_num = sptr_cdb->if1;
        if (next_token == 'e' || multi_ports)
        {
            port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);

            if(!IS_SPX_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if1)) && is_trunk_secondary_port(INTERFACE_TO_PORT_ID(sptr_cdb->if1)))
            {
                uprintf("\nError: Mutiple interface for trunk group secondary ports is not allowed \n");
                clear_mask(sptr_cdb->mif_port_mask);
                sptr_cdb->dont_go_next = 1;
                sptr_cdb->error = MODE_CHANGE_PARSE_ERROR;
                return;
            }
			//A port configured as ZTP should behave same as SPX port, The prompt and mode would be similar to SPX port. 
            if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
            {
                sptr_cdb->parent_mode = CONFIG_MIF_SPX;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb,CONFIG_MIF_SPX);
            }
            else if(port_type_value == EXT_PORT_TYPE_HOST)
            {
                sptr_cdb->parent_mode = CONFIG_MIF_PE;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb,CONFIG_MIF_PE);
            }
            else
            {
                sptr_cdb->parent_mode = CONFIG_MIF;
                if( next_token == '\0' )
                    set_cli_mode(sptr_cdb, CONFIG_MIF);
            }
            set_mask_bit(sptr_cdb->mif_port_mask, INTERFACE_TO_PORT_ID(sptr_cdb->if1));
            sptr_cdb->num_of_if = 0;
        }
        else
        {
            primary_port_id_val = get_oper_trunk_primary_port(INTERFACE_TO_PORT_ID(sptr_cdb->if1));
            port_type_value = cu_get_intf_port_type(sptr_cdb->if1-1);
            if((primary_port_id_val != INTERFACE_TO_PORT_ID(sptr_cdb->if1)) && IS_LAG_AP(primary_port_id_val))
            {
                if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
                {
                    sptr_cdb->parent_mode = CONFIG_IF_SPX;
                    set_cli_mode(sptr_cdb,CONFIG_IF_SPX);
                }
                else
                {
                    sptr_cdb->if1 = PORT_ID_TO_INTERFACE(primary_port_id_val);
                    sptr_cdb->if_type = VLAG;
                    sptr_cdb->if_num = sptr_cdb->if1;
                    sptr_cdb->parent_mode = CONFIG_IF_LAG;
                    set_cli_mode(sptr_cdb, CONFIG_IF_LAG);
                }
            }
            else
            {
                /* A port configured as ZTP should behave same as SPX port , The prompt and mode would be similar to SPX port. */
                if((port_type_value == EXT_PORT_TYPE_CASCADE) || (port_type_value == EXT_PORT_TYPE_UPLINK) || IS_ZTP_PORT(sptr_cdb->if1-1) )
                {
                    sptr_cdb->parent_mode = CONFIG_IF_SPX;
                    set_cli_mode(sptr_cdb,CONFIG_IF_SPX);
                }
                else if(port_type_value == EXT_PORT_TYPE_HOST)
                {
                    sptr_cdb->parent_mode = CONFIG_IF_PE;
                    set_cli_mode(sptr_cdb,CONFIG_IF_PE);
                }
                else
                {
                    sptr_cdb->parent_mode = CONFIG_IF;
                    set_cli_mode(sptr_cdb, CONFIG_IF);
                }
            }
        }

        sptr_cdb->vlan_group_id = 0;

        if (next_token == '\0') {
                sptr_cdb->dont_go_next = 1; /* stop parser in here */

                if (sptr_cdb->no)       /* bug 000348697 fix: srepalle: resolution: remove interfaces for ports for which port masks set */
                {
                                                        no_int_eth_flag = TRUE;

                                                        if (sptr_cdb->num_of_if)
                                                                {
                                                                                                current_port = sptr_cdb->if_num;

#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
                                                                                                ospf6_remove_distribute_list_on_interface(current_port-1);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__
                                                                                                sptr_cdb->if_num = sptr_cdb->if1;
                                                                #ifdef MPLS
                                                                                                if(GET_PORT_MPLS_ENABLE(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)) && !GET_PORT_FORCED_DELETION(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                                                                                {
                                                                                                        uprintf("Error: Port %p is an MPLS port.\n", INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                                                                }
                                                            #endif MPLS
                                                                                                if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
                                                                                                                (INTERFACE_TO_PORT_ID(sptr_cdb->if_num) == ntp_source_interface()))
                                                                                                {
                                                                                                        uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                                                                                                                         INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                                                                
												}
												/*This is specific to Spatha32p , Minions does not have port pairing issue*/ 
							else if (is_platform_got_port_pair_limitation() && (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
                                       (SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) &&
										IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                            {

                                  uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                                                INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                                                                }                    
                                                                                                else
                                                                                                {
                                                                                                        default_interface(sptr_cdb);
                                                                                                }
                                                                                                sptr_cdb->if_num = current_port;
                                                                                        }

                                        else {
                                        for (i = 0; i < g_hw_info.max_mod; i++) {
                                        if (!PORT_MASK_ISSET_ANY(sptr_cdb->mif_port_mask[i]))
                                                continue;
                                        for (j = 0, port = MAKE_PORTID(i, 0); j < g_module[i].number_of_ports; j++, port++) {
                                                if (!PORT_MASK_ISSET(sptr_cdb->mif_port_mask[i], j))
                                                        continue;
                                                if(!IS_PORT_DB_VALID(port)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                                        continue;
                                                current_port = sptr_cdb->if_num;
#ifdef __OSPFV3__
#ifdef __OSPF6_ROUTES_FILTERING__
                                                ospf6_remove_distribute_list_on_interface(current_port-1);
#endif __OSPF6_ROUTES_FILTERING__
#endif __OSPFV3__
                                                sptr_cdb->if_num = PORT_ID_TO_INTERFACE(port);
                                        #ifdef MPLS
                                                if(GET_PORT_MPLS_ENABLE(port) && !GET_PORT_FORCED_DELETION(port))
                                                {
                                                        uprintf("Error: Port %p is an MPLS port.\n", port);
                                                }
                                     #endif MPLS
                                            if ((PORT_INDEX_INVALID != ntp_source_interface()) &&
                                                                (port == ntp_source_interface()))
                                                {
                                                        uprintf("Error: Cannot delete port %p, this interface is configured as NTP source interface\n",
                                                                         port);
                                                }
						/*tHIS IS Spefic to SP32P , Minions does not have port pairing issue*/
											    else if (is_platform_got_port_pair_limitation() && (IS_PP_2_5GIG_PORT(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))&&
                                                	(SPTR_PORT_DB(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))->port_config.speed != SPEED_2500) &&
													 IS_PHYSICAL_OR_LAG_OPER_AP(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                                {

                                                     	uprintf("Error: Cannot delete paired port %p, this interface needs to configure as default speed (2500-Full) for removal.\n",
                                                             INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
                                                }     
                                                else
                                                {
                                                        default_interface(sptr_cdb);
                                                }
                                                sptr_cdb->if_num = current_port;
                                        }
                                }
                        }

                                                        // reset sptr_cdb variables to config.
                                                        sptr_cdb->parent_mode = CONFIG;
                                                        set_cli_mode(sptr_cdb, CONFIG);
                                                        clear_mask(sptr_cdb->mif_port_mask);
                                        }
        }
}

void set_no_mon_if(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no)
                {
#ifdef NO_MULTI_MIRROR
                        sptr_cdb->dont_go_next = 1;
                        /* set remove flag to 1 */
                        cu_set_monitor_port(0, 1);
#endif NO_MULTI_MIRROR
                }
        }
}

#ifdef SR_SWITCH_ROUTER
#ifdef SIDEWINDER_LINUX
/* ERSPAN */
const char *mirror_erspan_str = "ERSPAN";
const char *config_mirror_erspan_str = "erspan";



extern int sw_pp_erspan_monitor_ipc_remove(int profile_id);
BOOL is_set_lag_port_monitor_individual(PORT_ID port);

monitor_erspan_profile_t erspan_monitor_port_info[MAX_ERSPAN_MONITOR_PROFILE_NUM];

void cu_erspan_monitor_profile_init(int profile_id)
{
    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
            debug_uprintf("Debug - cu_erspan_monitor_profile_init(profile %u)\n", profile_id);
    }

    memset(&erspan_monitor_port_info[profile_id-1], 0, sizeof(monitor_erspan_profile_t));
    erspan_monitor_port_info[profile_id - 1].outgoing_port = BAD_PORT_ID;
    erspan_monitor_port_info[profile_id - 1].non_reachability_reason = ROUTE_NOT_EXIST;
    return(CU_OK);
}

int cu_init_erspan_monitor_setup()
{
    int i;
    //debugGlobal.infra_struct.debug_mirror.mirroring_type = DEBUG_ERSPAN_MIRROR; //for private build testing
    for (i=0; i < MAX_ERSPAN_MONITOR_PROFILE_NUM; i++)
    {
        cu_erspan_monitor_profile_init(i+1);
    }

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("cu_init_erspan_monitor_setup() done.\n");
    }
    return(CU_OK);

}

void config_gen_monitor_profile(struct cdb* sptr_cdb)
{
    UINT32 i, j;
    monitor_erspan_profile_t *monitor_port_info;
    int port_in_use = FALSE;
    for (i = 0; i < MAX_ERSPAN_MONITOR_PROFILE_NUM; i++)
    {
        monitor_port_info = &erspan_monitor_port_info[i];
        for(j = 0; j < MAX_SLOT; j++)
        {
            if( PORT_MASK_ISSET_ANY(monitor_port_info->monitor_portmask[j])) 
            {
                port_in_use = TRUE;
                break;
            }
        }
        if (port_in_use)
        {
            wr_config(sptr_cdb, "!\n");
            break;
        }
    }
    for (i = 0; i < MAX_ERSPAN_MONITOR_PROFILE_NUM; i++)
    {
                    
        monitor_port_info = &erspan_monitor_port_info[i];
        if (monitor_port_info->monitor_profile_id)
        {
                
            ksprintf(cu_line_buf,"monitor-profile %d type %s\n", monitor_port_info->monitor_profile_id, config_mirror_erspan_str);
            wr_config(sptr_cdb, cu_line_buf);
            if (monitor_port_info->destination_ip)
            {
                ksprintf(cu_line_buf,"destination-ip %I\n", monitor_port_info->destination_ip);
                wr_config(sptr_cdb, cu_line_buf);
            }
            if (monitor_port_info->source_ip)
            {
                ksprintf(cu_line_buf,"source-ip %I\n", monitor_port_info->source_ip);
                wr_config(sptr_cdb, cu_line_buf);
            }
            wr_config(sptr_cdb, "!\n");
        }
    }
}
        


int cu_erspan_monitor_profile_remove(int profile_id)
{
    int i = 0;
    int rc;
    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("Debug - cu_erspan_monitor_profile_remove(profile %u)\n", profile_id);
    }
    /*TR000565866 start*/
    if(STACK_AM_I_MASTER||STACK_AM_I_STANDALONE)
    {
        monitor_erspan_profile_t *monitor_port_info = &(erspan_monitor_port_info[profile_id - 1]);
        rc = sw_pp_erspan_delete_mirror_dest_id(monitor_port_info);
        if(rc != 0)
        {
            uprintf("Warning: HW mirror destination id remove failed \n");
        }
    }
    /*TR000565866 end*/
    cu_erspan_monitor_profile_init(profile_id);
    return(CU_OK);
}


UINT cu_set_erspan_ip_route_notify(UINT add, monitor_erspan_profile_t *monitor_port_info)
{
    UINT rc;
    rc = RTM_ipv4_cu_add_remove_notify_for_client_nexthop_update(add,
    monitor_port_info->monitor_profile_id,
    monitor_port_info->source_ip,
    monitor_port_info->destination_ip,
    monitor_port_info->vrf_idx);

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("Debug - RTM_ipv4_cu_add_remove_notify_for_client_nexthop_update %s rc = %d %s\n", (add)? "add":"del", rc, (rc)? "Pass":"Fail");

        debug_uprintf("Debug - monitor_profile_id %d source_ip %I destination_ip %I vrf_idx %u\n", monitor_port_info->monitor_profile_id, 
                                                                                                    monitor_port_info->source_ip,
                                                                                                    monitor_port_info->destination_ip, 
                                                                                                    monitor_port_info->vrf_idx);
    }
    return((rc) ? CU_OK:CU_ERROR);
}

int cu_erspan_monitor_profile(int profile_id, int add)
{
    monitor_erspan_profile_t *monitor_port_info;
    int i,port_in_use=FALSE,rc = CU_OK;

    monitor_port_info = &erspan_monitor_port_info[profile_id-1];

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("Debug - cu_erspan_monitor_profile(profile %u, add %u)\n",profile_id, add);
    }
    if (add)
    {
        if (monitor_port_info->monitor_profile_id == 0)
        {
            monitor_port_info->mirroring_type = ERSPAN_MIRROR_MODE;
            monitor_port_info->monitor_profile_id = profile_id;
            monitor_port_info->vrf_idx=IPVRF_DEFAULT_VRF_IDX;      //set to default vif for now,
        }
        else
        {
            if (monitor_port_info->monitor_profile_id != profile_id)  
            {
                uprintf("Error: cu_erspan_monitor_profile wrong profile id on %d, existing %d\n", profile_id, monitor_port_info->monitor_profile_id);
                return(CU_ERROR);
            }
        }
    }
    else
    {
        /* check to see anybody else is using this profile */
        for(i=0;i<MAX_SLOT;i++)
        {
            if (PORT_MASK_ISSET_ANY(monitor_port_info->monitor_portmask[i])) 
                port_in_use=TRUE;
        }
        if (port_in_use)
        {
            uprintf("Error: monitor profile %d cannot be removed because ports are being used.\n", profile_id);
            if (cu_show_port_list(monitor_port_info->monitor_portmask, "Monitored Ports", cu_line_buf, sizeof(cu_line_buf)))
            {
                cu_uprintf(cu_line_buf);
            }
            return(CU_ERROR);
        }
        else
        {
            if(monitor_port_info->source_ip&&monitor_port_info->destination_ip)
            {
                if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE || STACK_AM_I_STANDBY)
                {
                    rc = cu_set_erspan_ip_route_notify(FALSE, monitor_port_info);
                    if (rc  == CU_ERROR)
                    {
                        uprintf("Error: fail to notify L3 for erspan profile %d removal,abort\n",monitor_port_info->monitor_profile_id );
                        /*return(CU_ERROR);*/
                    }
                }
            }
            rc = cu_erspan_monitor_profile_remove(profile_id);
            if (rc == CU_ERROR)
            {
                uprintf("Error: fail to remove erspan profile %d\n",monitor_port_info->monitor_profile_id );
                return(CU_ERROR);
            }
        }
    }
    return(rc);
}



int cu_erspan_individual_monitor_port_remove(int profile_id, PORT_ID port_id, UINT32 direction)
{
    monitor_erspan_profile_t *monitor_port_info;
    int rc = CU_OK;
    int remove_port = 0;
    monitor_port_info = &erspan_monitor_port_info[profile_id-1];

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf ("Debug - cu_erspan_individual_monitor_port_remove:profile %d port %p direction %u dest_id 0x%x.\n", 
                                                                        profile_id,
                                                                        port_id, 
                                                                        SPTR_PORT_DB(port_id)->port_config.erspan_direction,
                                                                        SPTR_PORT_DB(port_id)->port_config.erspan_mirror_dest_id);
    }

    if(monitor_port_info->mirror_reachability==ERSPAN_DESTINATION_REACHABLE)
    {
        if(direction == SPTR_PORT_DB(port_id)->port_config.erspan_direction)
        {
            remove_port = 1;
        }
        rc = sw_pp_erspan_monitor_port_remove(profile_id, port_id, direction, remove_port, TRUE);
        if(STACK_AM_I_STANDBY)
        {
            if(direction == SPTR_PORT_DB(port_id)->port_config.erspan_direction) 
            {
                SPTR_PORT_DB(port_id)->port_config.erspan_direction = 0;
                SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id = 0;
                SPTR_PORT_DB(port_id)->port_config.erspan_mirror_dest_id = 0;
                SPTR_PORT_DB(port_id)->port_config.erspan_mirror_reachability = 0;
                PORT_MASK_CLR(monitor_port_info->monitor_portmask[PORT_TO_MODULE_ID(port_id)], PORT_TO_MODULE_PORT(port_id));
            }
            else //still have another direction monitoring exist on this port
            {
                SPTR_PORT_DB(port_id)->port_config.erspan_direction = SPTR_PORT_DB(port_id)->port_config.erspan_direction ^ direction;
            }
        }
    }
    else
    {
        if(direction == SPTR_PORT_DB(port_id)->port_config.erspan_direction) 
        {
            SPTR_PORT_DB(port_id)->port_config.erspan_direction = 0;
            SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id = 0;
            SPTR_PORT_DB(port_id)->port_config.erspan_mirror_dest_id = 0;
            SPTR_PORT_DB(port_id)->port_config.erspan_mirror_reachability = 0;
            PORT_MASK_CLR(monitor_port_info->monitor_portmask[PORT_TO_MODULE_ID(port_id)], PORT_TO_MODULE_PORT(port_id));
        }
        else //still have another direction monitoring exist on this port
        {
            SPTR_PORT_DB(port_id)->port_config.erspan_direction = SPTR_PORT_DB(port_id)->port_config.erspan_direction ^ direction;
        }
    }

    return(rc);
}


void cu_erspan_lag_monitor_port_remove(int profile_id, PORT_ID port_id, UINT32 direction)
{
	
    CU_TRUNK_CONFIG_ENTRY *trunk_entry;
    PORT_ID 	monitor_port;
    UINT16 trunk_id, j;


    trunk_id	= cu_get_trunk_id(port_id, 1);
    trunk_entry = &g_sw_sys.trunk_config.trunk_entry[trunk_id]; 	

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("Debug - cu_erspan_lag_monitor_port_remove: - trunk_id %d profile %d \n",trunk_id , profile_id);
    }
    for(j = 0; j < trunk_entry->number_of_ports; j++)
    {
        //Traverse port list in trunk
        monitor_port = trunk_entry->port_list[j];
        cu_erspan_individual_monitor_port_remove(profile_id, monitor_port, direction);
    }
}

int erspan_source_ip_validation(UINT32 source_ip)
{
	    PORT_ID src_port;
	    // Check if the input src is a valid (permissible) IP address
		if (source_ip >= 0xe0000000)
		{
			uprintf("Error: ERSPAN source has to be a CLASS A, B, or C address\n");
			return (CU_ERROR);
		}
	
		if (source_ip == 0)
		{
			uprintf("Error: ERSPAN source IP has to be a valid interface IP address\n");
			return(CU_ERROR);
		}
	
		
		if (!g_sw_sys.init_in_progress)
		{
			// Check whether the source IP address is configured on default VRF or not
			src_port = ip_get_port_owner_for_ip_address (IPVRF_DEFAULT_VRF_IDX, source_ip);
			if (src_port == INVALID_PORT_INDEX)
			{
				uprintf ("Error - ERSPAN Source IP %I is not configured on any interface in Default-VRF\n",
							source_ip);
				return(CU_ERROR);
			}
		
#ifdef INCLUDE_MCT
			if (clusterlib_is_cluster_management_port (src_port))
			{
				uprintf ("Error - ERSPAN Source IP %I is configured on MCT session interface\n",
							source_ip);
				return(CU_ERROR);
			}
#endif INCLUDE_MCT
		}
		return (CU_OK);
}        

int cu_erspan_individual_monitor_port_add(int profile_id, PORT_ID port_id, UINT32 direction)
{
        monitor_erspan_profile_t *monitor_port_info;
        int rc = CU_OK;
        PORT_ID src_port;
        int add_port = 0;
        monitor_port_info = &erspan_monitor_port_info[profile_id-1];

        if (get_num_ports_from_mask(monitor_port_info->monitor_portmask) >= MAX_ERSPAN_CONFIGURATION_COUNT)
        {
                uprintf("Error: ERSPAN profile %d reached MAX monitor port(%d), can't add monitor port %p\n", profile_id,MAX_ERSPAN_CONFIGURATION_COUNT,port_id);
                return(CU_ERROR);
        }

        if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
        {
                debug_uprintf("Debug - cu_erspan_monitor_port_add %p profile_id %d direction %d\n", port_id, profile_id, direction);
        }

             
        if ((SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id) && (SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id != profile_id)) 
         { 
                 uprintf("Error: monitor profile %d already exists on port %p\n", 
                 SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id, 
                 port_id); 
                 return(CU_ERROR);      
          }   
//verify source ip in case this ip has been changed outside erspan profile
		rc=erspan_source_ip_validation(monitor_port_info->source_ip);
		
		if(rc==CU_ERROR)
		{
			return (CU_ERROR);
		}

    
         
		if(monitor_port_info->mirror_reachability==ERSPAN_DESTINATION_REACHABLE)
		{
            if(SPTR_PORT_DB(port_id)->port_config.erspan_direction == 0)
                add_port = 1;
           	rc = sw_pp_erspan_monitor_port_add(profile_id, port_id, direction, add_port, TRUE);
			if(rc!=CU_OK) return(rc);
		}
		/*update configuration database, add monitor port to profile */
		PORT_MASK_SET(monitor_port_info->monitor_portmask[PORT_TO_MODULE_ID(port_id)], PORT_TO_MODULE_PORT(port_id));
//		++monitor_port_info->port_in_use;
		SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id = profile_id;
		SPTR_PORT_DB(port_id)->port_config.erspan_direction = direction;
		if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
        {
             debug_uprintf("Debug - cu_erspan_monitor_port_add:update config: port %p,profile_id %d,direction %d\n",port_id,profile_id,direction);
        }
        	
        return(rc);
}

void cu_erspan_lag_monitor_port_add(int profile_id, PORT_ID port_id, UINT32 direction)
{
	CU_TRUNK_CONFIG_ENTRY *trunk_entry;
	PORT_ID 	monitor_port;
	UINT16 trunk_id, j;
	
	
	trunk_id	= cu_get_trunk_id(port_id, 1);
	trunk_entry = &g_sw_sys.trunk_config.trunk_entry[trunk_id]; 	

	if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
	{
		debug_uprintf("Debug - cu_erspan_lag_monitor_port_add - trunk_id %d profile %d \n",trunk_id , profile_id);
	}
	for(j = 0; j < trunk_entry->number_of_ports; j++)
	{
		monitor_port = trunk_entry->port_list[j];
		
		cu_erspan_individual_monitor_port_add(profile_id, monitor_port, direction);
				
	}
	return;
}

int cu_show_erspan_monitor_profile_one(int profile_id)
{
	monitor_erspan_profile_t *monitor_port_info;
	int port_in_use=FALSE,rc = CU_OK,i,j=0;
	PORT_MASK in_port_mask[MAX_SLOT];
	PORT_MASK out_port_mask[MAX_SLOT];
	PORT_ID port_id;
	UINT16 ve_port, ve,local_device;

		
        if (profile_id > MAX_ERSPAN_MONITOR_PROFILE_NUM)
        {
                uprintf("Error: Invalid ERSPAN profile id %d\n", profile_id);
                return (CU_ERROR);
        }
        monitor_port_info = &erspan_monitor_port_info[profile_id-1];

        if (monitor_port_info->monitor_profile_id)
        {
                uprintf("\n");
                uprintf(" Profile %d\n", monitor_port_info->monitor_profile_id);
                uprintf(" Type             %s\n",  mirror_erspan_str);
               if(monitor_port_info->mirror_reachability==ERSPAN_DESTINATION_UNREACHABLE)
                {
                	uprintf(" Mirror destination Not reachable.\n");
                    uprintf(" Reason: %s\n",
                        get_rtm_ipv4_nonreachability_reason_str(monitor_port_info->non_reachability_reason));
               	}
               else
			   	{
			   		uprintf(" Mirror destination Reachable.\n");
                              
                }
                if (monitor_port_info->destination_ip)
                {
                        uprintf(" Destination IP   %I\n", monitor_port_info->destination_ip);
                }
                if (monitor_port_info->dest_mac)
                {
                        uprintf(" Destination MAC  %m\n", monitor_port_info->dest_mac);
                }
                if (monitor_port_info->source_ip)
                {
                        uprintf(" Source IP        %I\n", monitor_port_info->source_ip);
                }
                if (monitor_port_info->src_mac)
                {
                        uprintf(" Source MAC       %m\n", monitor_port_info->src_mac);
                }
                
                if (monitor_port_info->outgoing_port != BAD_PORT_ID)
                {
                        uprintf(" Outgoing port    %p\n", monitor_port_info->outgoing_port);
                }
                if (monitor_port_info->outgoing_vlan)
                {
                        uprintf(" Outgoing VLAN    %i\n", monitor_port_info->outgoing_vlan);

                        ve_port  = sw_find_vlan_router_int(monitor_port_info->outgoing_vlan, L2_VLAN_INDEX);
                        if(ve_port) 
                        {
                                ve = internal_ve_lookup(ve_port-1) + 1;
                                if (ve != VE_MAP_INDEX_MAX)
                                {
                                        uprintf(" Outgoing VE      %u\n", ve);
                                }
                        }
                }
                uprintf(" Ports monitored:\n");


//show monitor port list in profile				
		for(i=0;i<MAX_SLOT;i++)
                {
                        if (PORT_MASK_ISSET_ANY(monitor_port_info->monitor_portmask[i])) port_in_use=TRUE;
                }
                if (port_in_use)
					{
						clear_mask(in_port_mask);
						clear_mask(out_port_mask);
						port_id = port_mask_get_first_port (monitor_port_info->monitor_portmask);
				
						while (port_id != BAD_PORT_ID)
						{
							if(SPTR_PORT_DB(port_id)->port_config.erspan_direction & BCM_MIRROR_PORT_INGRESS)
								{
									set_mask_bit(in_port_mask,port_id);
								}
							if(SPTR_PORT_DB(port_id)->port_config.erspan_direction & BCM_MIRROR_PORT_EGRESS)
								{
									set_mask_bit(out_port_mask,port_id);
								} 	
							
							port_id = port_mask_get_next_port(monitor_port_info->monitor_portmask, port_id);
						}
                
                	if (cu_show_port_list(in_port_mask, "  Input monitoring\t", cu_line_buf, sizeof(cu_line_buf)))
                		{
                        	cu_uprintf(cu_line_buf);
                		}
					if (cu_show_port_list(out_port_mask, "  Output monitoring\t", cu_line_buf, sizeof(cu_line_buf)))
                		{
                        	cu_uprintf(cu_line_buf);
                		}
					}
        
//display dest id for each unit
				uprintf(" HW destination id for each device:\n");
				uprintf(" stack_id/device:dest_id   ");
				for(i=0;i<MAX_SLOT;i++)
				{
					if(monitor_port_info->mirror_dest_id[i])
					{
						j++;
			
						local_device=(i%2)+1; // device 1 or device 2
						uprintf("%d/%d:%x ",DEVICE_TO_STACK(i),local_device,monitor_port_info->mirror_dest_id[i]);
						if(j>=3)
							{
									uprintf("\n stack_id/device:dest_id   ");
									j=0;
							}
					}
				}
				uprintf("\n");
        	}
    return(rc);     
}

void cli_set_monitor_profile_id(struct cdb* sptr_cdb)
{

        sptr_cdb->error = NO_PARSE_ERROR;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (sptr_cdb->config_gen)
                return;

        sptr_cdb->dont_go_next = 1;

        if (!valid_integer1_value_range(sptr_cdb, START_ERSPAN_MONITOR_PROFILE_NUM, MAX_ERSPAN_MONITOR_PROFILE_NUM))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }

        if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
        {
                debug_uprintf("Debug - cli_set_monitor_profile_id %d\n", sptr_cdb->integer1);
        }
        
        if (sptr_cdb->no)
        {

               cu_erspan_monitor_profile(sptr_cdb->integer1, FALSE);
                
        }
        else
        {
                if (cu_erspan_monitor_profile(sptr_cdb->integer1, TRUE))
                {
                     
                        return;
                }
                else
                {
                        sptr_cdb->mode = CONFIG_MONITOR_PROFILE;
                        sptr_cdb->monitor_profile = sptr_cdb->integer1;
                        
                }
        }

}

void cli_set_mirroring_mode(struct cdb* sptr_cdb)
{
unsigned char str[PARSER_STRING_LEN];
monitor_erspan_profile_t *monitor_port_info;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (sptr_cdb->config_gen)
                return;

        sptr_cdb->dont_go_next = 1;

        if (!valid_integer1_value_range(sptr_cdb, START_ERSPAN_MONITOR_PROFILE_NUM, MAX_ERSPAN_MONITOR_PROFILE_NUM))
        {
                uprintf("Error: cli_set_mirroring_mode invalid profile id %d\n",sptr_cdb->integer1);
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }

        if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
        {
                debug_uprintf("Debug - cli_set_mirroring_mode %s\n",sptr_cdb->string1);
        }
        if (strcmp(sptr_cdb->string1, "erspan"))        /* mirroring mode/type */
        {
                uprintf("Error: Illegal mirroring mode %s\n", sptr_cdb->string1);
                return;
        }
        
        if (sptr_cdb->no)
        {

                if (cu_erspan_monitor_profile(sptr_cdb->integer1, FALSE))
                {
                        return;
                }
        }
        else
        {
                if (cu_erspan_monitor_profile(sptr_cdb->integer1, TRUE))
                {
                        return;
                }
                
                sptr_cdb->mode = CONFIG_MONITOR_PROFILE;
                sptr_cdb->monitor_profile = sptr_cdb->integer1;
        }
}

void cli_set_mirror_source_ip(struct cdb* sptr_cdb)
{
    monitor_erspan_profile_t *monitor_port_info;
    PORT_ID port_id = PORT_INDEX_INVALID;
    UINT rc,i;
    UINT8 port_in_use=FALSE;
    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    if (sptr_cdb->config_gen)
        return;

    sptr_cdb->dont_go_next = 1;

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("Debug - cli_set_mirror_source_ip %I \n", sptr_cdb->ip1);
    }

    monitor_port_info = &erspan_monitor_port_info[sptr_cdb->monitor_profile-1];

    for(i=0;i<MAX_SLOT;i++)
    {
        if(PORT_MASK_ISSET_ANY(monitor_port_info->monitor_portmask[i])) 
            port_in_use=TRUE;
    }
    if (port_in_use)
    {
        uprintf("Error: cannot modify profile while it being used by monitor ports\n");
        return;
    }
    if (sptr_cdb->no)
    {
        if (monitor_port_info->destination_ip)
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE || STACK_AM_I_STANDBY)
            {
                /*TR000573467 start*/
                rc = sw_pp_erspan_delete_mirror_dest_id(monitor_port_info);
                if(rc != 0)
                {
                    uprintf("Warning: HW mirror destination id remove failed \n");
                }
                /*TR000573467 end*/
                rc = cu_set_erspan_ip_route_notify(FALSE, monitor_port_info);
                if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
                {
                    debug_uprintf("Debug - cu_set_erspan_ip_route_notify,remove source ip %I rc=%d\n",  monitor_port_info->source_ip, rc);
                }
                if (rc == CU_ERROR)
                {
                    uprintf("Error: failed to notify L3 for erspan source ip removal %d\n", rc);
                    /*return;*/
                }
            }
        }
        monitor_port_info->mirror_reachability = ERSPAN_DESTINATION_UNREACHABLE;
        monitor_port_info->source_ip = 0;
        for(i=0;i<6;i++)
        {
            monitor_port_info->src_mac[i] = 0; 
        }
    }
    else
    {
        if(monitor_port_info->source_ip)
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE)
            {
                uprintf("Error: erspan profile %d source ip already exist, please remove it first\n",monitor_port_info->monitor_profile_id);
            }
            return;
        }
        if (!g_sw_sys.init_in_progress)
        {
            rc=erspan_source_ip_validation(sptr_cdb->ip1);
            if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
            {
                debug_uprintf("Debug - erspan_source_ip_validation %I,rc=%d \n",sptr_cdb->ip1,rc);
            }
            if(rc!=CU_OK)
            {
                return;
            }
        }
        monitor_port_info->source_ip = sptr_cdb->ip1;

        if (monitor_port_info->destination_ip) //only when both src/dest ip ready, it then send L3 notify
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE || STACK_AM_I_STANDBY)
            {
                rc = cu_set_erspan_ip_route_notify(TRUE,  monitor_port_info);
                if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
                {
                    debug_uprintf("Debug - cu_set_erspan_ip_route_notify,add %I rc=%d\n",  monitor_port_info->source_ip, rc);
                }
                if (rc  == CU_ERROR)
                {
                    uprintf("Error: failed to notify L3 for erspan add source ip in profile %d\n",monitor_port_info->monitor_profile_id);
                    //the dest ip need to be clear also when fail L3 notify, because the problem can possibly on dest ip,
                    //if we don't clear, user keep changing source ip and continue fail. now we clear both ip, when user enter source id, 
                    //it won't send L3 notify right way, because only when have both src/dest ip, then send L3 notify.	
                    monitor_port_info->source_ip = 0;
                    monitor_port_info->destination_ip = 0;
                    for(i=0;i<6;i++)
                    {
                        monitor_port_info->src_mac[i] = 0; 
                        monitor_port_info->dest_mac[i] = 0;
                    }
                    monitor_port_info->mirror_reachability = ERSPAN_DESTINATION_UNREACHABLE;
                }
            }
        }
    }
    return;
}

void cli_set_mirror_destination_ip(struct cdb* sptr_cdb)
{
    monitor_erspan_profile_t *monitor_port_info;
    UINT rc,i;
    UINT8 port_in_use=FALSE;
    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    if (sptr_cdb->config_gen)
        return;

    sptr_cdb->dont_go_next = 1;

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
        debug_uprintf("Debug - cli_set_mirror_destination_ip %I\n", sptr_cdb->ip1);
    }

    monitor_port_info = &erspan_monitor_port_info[sptr_cdb->monitor_profile-1];
    for(i=0;i<MAX_SLOT;i++)
    {
        if( PORT_MASK_ISSET_ANY(monitor_port_info->monitor_portmask[i])) 
            port_in_use=TRUE;
    }
    if (port_in_use)
    {
        uprintf("Error: cannot modify profile while it being used by monitor ports\n");
            return;
    }
    if (sptr_cdb->no)
    {

        if (monitor_port_info->source_ip)
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE || STACK_AM_I_STANDBY)
            {
                /*TR000565866 start*/
                rc = sw_pp_erspan_delete_mirror_dest_id(monitor_port_info);
                if(rc != 0)
                {
                    uprintf("Warning: HW mirror destination id remove failed \n");
                }
                /*TR000565866 end*/
                rc = cu_set_erspan_ip_route_notify(FALSE, monitor_port_info);
                if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
                {
                    debug_uprintf("Debug - cu_set_erspan_ip_route_notify,remove destination ip %I rc=%d\n",  monitor_port_info->destination_ip, rc);
                }
                if (rc == CU_ERROR)
                {
                    uprintf("Error: failed to notify L3 for erspan destination ip removal %d\n", rc);
                    /*return;*/
                }
            }
        }
        monitor_port_info->mirror_reachability = ERSPAN_DESTINATION_UNREACHABLE;
        monitor_port_info->destination_ip = 0;

        for(i=0;i<6;i++)
        {
            monitor_port_info->dest_mac[i] = 0;
        } 
    }
    else
    {
        if(monitor_port_info->destination_ip)
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE)
            {
                uprintf("Error: erspan profile %d destination ip already exist, please remove it first\n",monitor_port_info->monitor_profile_id);
            }
            return;
        }    
        monitor_port_info->destination_ip = sptr_cdb->ip1;

        if (monitor_port_info->source_ip)  //only when both src/dest ip ready, it then send L3 notify
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE || STACK_AM_I_STANDBY)
            {
                rc = cu_set_erspan_ip_route_notify(TRUE, monitor_port_info);
                if (rc  == CU_ERROR)
                {
                    uprintf("Error: failed to notify L3 for add destination ip\n");
                    uprintf("Please reconfigure source/destination ip address for profile %d \n", monitor_port_info->monitor_profile_id);
                    //the src ip need to be clear also when fail L3 notify, because the problem can possibly on src ip,
                    //if we don't clear, user keep changing dest ip and continue fail. now we clear both ip, when user enter dest id, 
                    //it won't send L3 notify right way, because only when have both src/dest ip, then send L3 notify.
                    monitor_port_info->source_ip = 0;
                    monitor_port_info->destination_ip = 0;
                    for(i=0;i<6;i++)
                    {
                        monitor_port_info->src_mac[i] = 0; 
                        monitor_port_info->dest_mac[i] = 0;
                    }
                    monitor_port_info->mirror_reachability = ERSPAN_DESTINATION_UNREACHABLE;
                }
            }
        }
    }
}

void cli_monitor_profile_default(struct cdb* sptr_cdb)
{
}

void cu_cli_erspan_monitor_port_apply(struct cdb* sptr_cdb, UINT32 direction)
{
	PORT_ID port_id;
	int profile_id;
	int lag_flag=0;
	UINT32 remove_direction=0;
	UINT32 add_direction=0;
	int i;
    UINT8 mode = -1;
    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    if (sptr_cdb->config_gen)
        return;
    
    sptr_cdb->dont_go_next = 1;
	profile_id = sptr_cdb->integer1;

    if(sptr_cdb->mode == CONFIG_LAG)
        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
    else
        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);       

    /*TR000569284 xwan*/
    if(cu_get_being_monitored_port_mode(port_id, &mode) != CU_OK)
        return;
    if(mode != BCM_MIRROR_PORT_OFF)
    {
        uprintf("Warning: There is port mirroring configuration on this port, please remove it. \n");
        return;
    }

    if (!valid_integer1_value_range(sptr_cdb, START_ERSPAN_MONITOR_PROFILE_NUM, MAX_ERSPAN_MONITOR_PROFILE_NUM))
    {
            uprintf("Error: Illegal monitor profile id %u\n", sptr_cdb->integer1);
            return;
    }
	
    if (erspan_monitor_port_info[profile_id-1].monitor_profile_id == 0)
    {
            uprintf("Error: monitor profile %u not created yet\n", profile_id);
            return;
    }

    if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
    {
            debug_uprintf("Debug - cu_cli_erspan_monitor_port_apply interface number=%d flag1=%d flag2=%d if1=%d if2=%d \n",sptr_cdb->if_num,
                                                    sptr_cdb->flag1,
                                                    sptr_cdb->flag2,
                                                    sptr_cdb->if1,
                                                    sptr_cdb->if2);
    }

    if (IS_PE_PORT(port_id))
    {
            uprintf("Error: Port %p is a PE port, invalid ERSPAN monitor port\n", port_id);
            return;
    }


   
    if (!IS_PORT_VALID(port_id))
    {
            uprintf("Error: Port %p is invalid\n", port_id);
			return;
    }

#ifdef FI_PROTECTED_PORTS
    if(SPTR_PORT_DB(port_id)->port_config.protected)
    {           
        uprintf("Error: Port is a Protected Port!\n");
        return;
    }           
#endif


    
	if((SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id )&&(SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id!=profile_id))
	{
			uprintf("Port %p is using ERSPAN profile %d, please change to correct profile.\n ",
						port_id,SPTR_PORT_DB(port_id)->port_config.erspan_monitor_profile_id);
			return;
	}


	if (is_config_trunk_port(port_id))
    {
            if (IS_DEPLOYED_LAG_PORT(port_id))
            {
                    if (is_trunk_primary_port(port_id) && !is_set_lag_port_monitor_individual(port_id))
                    {
                            if (debugGlobal.infra_struct.debug_mirror.mirroring_type & DEBUG_ERSPAN_MIRROR)
                            {
                                    debug_uprintf("Debug - cu_cli_erspan_monitor_port_apply: port %p is primary LAG port\n", port_id);
                            }

							lag_flag=1;
								
                    }
                    else if (!is_set_lag_port_monitor_individual(port_id)&&!is_trunk_primary_port(port_id))
                            {
                                    uprintf("Error: - LAG port %p is not primary port of LAG and it cannot be configured individually, abort ERSPAN configuration\n", port_id);
									return(CU_ERROR);
                            }
                    
            }
            else
            {
                    
                    uprintf("Error: LAG %p has not deployed, abort ERSPAN configuration\n", port_id);
					return(CU_ERROR);
            }
    }

    if (sptr_cdb->no)
    {
    		
            remove_direction=SPTR_PORT_DB(port_id)->port_config.erspan_direction & direction;
			if(!remove_direction)
            {
                if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE)
                {
				    uprintf(" port %p is not monitoring traffic in this direction in ERSPAN\n",port_id);
                }
				return;
			}
			
          	if(lag_flag)
            {
				cu_erspan_lag_monitor_port_remove(profile_id,port_id,remove_direction);
       		}
            else 
            {
				cu_erspan_individual_monitor_port_remove(profile_id, port_id, remove_direction);
           	}
    }
    else
    {
    		
		add_direction=SPTR_PORT_DB(port_id)->port_config.erspan_direction | direction;
		if(add_direction==SPTR_PORT_DB(port_id)->port_config.erspan_direction)
        {
            if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE)
            {
			    uprintf(" port %p is already monitoring  traffic in this direction in ERSPAN profile %d\n",port_id,profile_id);
            }
			return;
		}
		if(lag_flag)
        {
			cu_erspan_lag_monitor_port_add(profile_id,port_id,add_direction);
		}
		else 
        {
       		cu_erspan_individual_monitor_port_add(profile_id, port_id, add_direction);
		}
    }

	if((STACK_AM_I_MASTER)&&(g_stacking.standby))
	{

		sw_pp_sync_erspan_profile(profile_id);
		sw_pp_sync_erspan_port_db(port_id);
		
	}
        
        
}

void cli_set_erspan_monitored_port_in_only(struct cdb* sptr_cdb)
{
 
        cu_cli_erspan_monitor_port_apply(sptr_cdb, BCM_MIRROR_PORT_INGRESS);
}

void cli_set_erspan_monitored_port_out_only(struct cdb* sptr_cdb)
{

        cu_cli_erspan_monitor_port_apply(sptr_cdb, BCM_MIRROR_PORT_EGRESS);
}

void cli_set_erspan_monitored_port_in_out(struct cdb* sptr_cdb)
{

        cu_cli_erspan_monitor_port_apply(sptr_cdb, BCM_MIRROR_PORT_INGRESS_EGRESS);
}
void cli_show_erspan_monitor_profile_one(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (sptr_cdb->config_gen)
                return;
        
        sptr_cdb->dont_go_next = 1;
        cu_show_erspan_monitor_profile_one(sptr_cdb->integer1);
}
void cli_show_erspan_monitor_profile_all(struct cdb* sptr_cdb)
{
int i;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (sptr_cdb->config_gen)
                return;
        
        sptr_cdb->dont_go_next = 1;
        
        for (i=1; i <= MAX_ERSPAN_MONITOR_PROFILE_NUM; i++)
        {
                cu_show_erspan_monitor_profile_one(i);
        }
}
/* ERSPAN */
#endif SIDEWINDER_LINUX
#endif SR_SWITCH_ROUTER

void set_mirr_if_rx(struct cdb* sptr_cdb)
{
        UINT32  i;
        UINT8   separater = 0;
        PORT_ID port;

        if (sptr_cdb->config_gen)
        {
                if (!sw_pp_is_mirroring_enabled())
                        return;

                for (i = 0; i < g_hw_info.total_config_ports; i++)
                {
                        port = sw_config_port_list[i];

                        if (sw_pp_is_port_mirror(port) == CU_MONITOR_PORT_INPUT)
                        {
                                ksprintf(cu_line_buf, "mirror-port %s %p input\n", get_port_type_str(port), get_port_num(port));
                                wr_config(sptr_cdb, cu_line_buf);
                                separater = 1;
                        }
                }
                if (separater)
                        wr_config(sptr_cdb, "!\n");
        }
        else
        {
                PORT_ID mirror_port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                if (!IS_PORT_DB_VALID(mirror_port))
                {
                        uprintf("Error - Invalid Port!\n");
                        return;
                }

                if(IS_MGMT_PORT(mirror_port))
                {
                        uprintf("Error - Invalid Port!\n");
                        return;
                }
#ifdef FI_PROTECTED_PORTS
                if(SPTR_PORT_DB(mirror_port)->port_config.protected)
		{           
		    uprintf("Error - Port is a Protected Port!\n");
		    return;
		}           
#endif
                if (sptr_cdb->no)
                        sw_pp_del_mirror_port_from_table(mirror_port, CU_MONITOR_PORT_INPUT);
                else{
#ifdef __PORT_EXTENSION__
                        if(IS_PE_PORT(mirror_port))
                            uprintf( "Warning: PE Port %p cannot be used as mirror port for VLAN Mirroring!\n", mirror_port);
#endif __PORT_EXTENSION__
                        sw_pp_add_mirror_port_to_table(mirror_port, CU_MONITOR_PORT_INPUT);

                }
        }
}

void set_mirr_if_tx(struct cdb* sptr_cdb)
{
        UINT32  i;
        UINT8   separater = 0;
        PORT_ID port;

        if (sptr_cdb->config_gen)
        {
                for (i = 0; i < g_hw_info.total_config_ports; i++)
                {
                        port = sw_config_port_list[i];
                        if (sw_pp_is_port_mirror(port) == CU_MONITOR_PORT_OUTPUT)
                        {
                                ksprintf(cu_line_buf, "mirror-port %s %L output\n", get_port_type_str(port), get_port_num(port));
                                wr_config(sptr_cdb, cu_line_buf);
                                separater = 1;
                        }
                }
                if (separater)
                        wr_config(sptr_cdb, "!\n");
        }
        else
        {
                PORT_ID mirror_port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                if (!IS_PORT_DB_VALID(mirror_port))
                {
                        uprintf("Error - Invalid Port!\n");
                        return;
                }

                if(IS_MGMT_PORT(mirror_port))
                {
                        uprintf("Error - Invalid Port!\n");
                        return;
                }
#ifdef FI_PROTECTED_PORTS
                if(SPTR_PORT_DB(mirror_port)->port_config.protected)
                {
                    uprintf("Error - Port is a Protected Port!\n");
                    return;
                }
#endif
                if (sptr_cdb->no)
                        sw_pp_del_mirror_port_from_table(mirror_port, CU_MONITOR_PORT_OUTPUT);
                else{
#ifdef __PORT_EXTENSION__
                    if(IS_PE_PORT(mirror_port))
                        uprintf( "Warning: PE Port %p cannot be used as mirror port for VLAN Mirroring!\n", mirror_port);
#endif __PORT_EXTENSION__
                        sw_pp_add_mirror_port_to_table(mirror_port, CU_MONITOR_PORT_OUTPUT);
                }
        }
}

void set_mirr_if_both(struct cdb* sptr_cdb)
{
        UINT32  i;
        UINT8   separater = 0;
        PORT_ID port, mirror_port;

        if (sptr_cdb->config_gen)
        {
                for (i = 0; i < g_hw_info.total_config_ports; i++)
                {
                        port = sw_config_port_list[i];

                        if (sw_pp_is_port_mirror(port) == CU_MONITOR_PORT_INPUT_OUTPUT)
                        {
                                ksprintf(cu_line_buf, "mirror-port %s %L\n",get_port_type_str(port), get_port_num(port));
                                wr_config(sptr_cdb, cu_line_buf);
                                separater = 1;
                        }
                }
                if (separater)
                        wr_config(sptr_cdb, "!\n");
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                sptr_cdb->dont_go_next = 1;

                mirror_port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                if (!IS_PORT_DB_VALID(mirror_port))
                {
                        uprintf("Error - Invalid Port!\n");
                        return;
                }

                if(IS_MGMT_PORT(mirror_port))
                {
                        uprintf("Error - Invalid Port!\n");
                        return;
                }
#ifdef FI_PROTECTED_PORTS
                if(SPTR_PORT_DB(mirror_port)->port_config.protected)
                {
                    uprintf("Error - Port is a Protected Port!\n");
                    return;
                }
#endif
                if (cli_port_is_stacking_port(sptr_cdb, mirror_port, FALSE, 0))
                        return;

                if (sptr_cdb->no)
                {
                        sw_pp_del_mirror_port_from_table(mirror_port, CU_MONITOR_PORT_INPUT_OUTPUT);
                }
                else
		{
#ifdef __PORT_EXTENSION__
			if(IS_PE_PORT(mirror_port))
				uprintf( "Warning: PE Port %p cannot be used as mirror port for VLAN Mirroring!\n", mirror_port);
#endif __PORT_EXTENSION__
                        sw_pp_add_mirror_port_to_table(mirror_port, CU_MONITOR_PORT_INPUT_OUTPUT);
		}
        }
}


void set_mon_if(struct cdb* sptr_cdb)
{
        PORT_ID port_id, i;

        /******* Fan Trunk enhancement ********/
        extern UINT8  g_exiting_trunk;

        if (g_exiting_trunk)
        {
                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                for(i = 0; i < MAX_MIRRORS; i++)
                {
                        if(g_mirror_list[i]==WILD_ADDRESS)
                        {
                                g_mirror_list[i] = port_id;
                                break;
                        }
                }
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->config_gen)
        {
                UINT8 separater = 0;
                sptr_cdb->dont_go_next = 1; /* don't loop back */

#ifdef NO_MULTI_MIRROR
                port_id = cu_get_monitor_port();

                if (port_id != INVALID_MONITOR_PORT_NUMBER)
                {
                        ksprintf(cu_line_buf, "mirror-port %s %L\n", get_port_type_str(port_id), get_port_num(port_id));
                        wr_config(sptr_cdb, cu_line_buf);
                }
#else NO_MULTI_MIRROR
                for (port_id = 0; port_id < MAX_MIRRORS; port_id++)
                {
                        if (g_sw_sys.mirror_ports[port_id] != PORT_INDEX_INVALID)
                        {
                                ksprintf(cu_line_buf, "mirror-port %s %L\n", get_port_type_str(g_sw_sys.mirror_ports[port_id]),
										 get_port_num(g_sw_sys.mirror_ports[port_id]));
                                wr_config(sptr_cdb, cu_line_buf);
                                separater = 1;
                        }
                }
                if (separater) /* BUG: 6257 */
                        wr_config(sptr_cdb, "!\n");
#endif NO_MULTI_MIRROR
        }
        else
        {
                int return_code;
                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                {
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                if (sptr_cdb->no)
                        /* set remove flag to 1 */
#ifdef NO_MULTI_MIRROR
                        cu_set_monitor_port(0, 1);
#else NO_MULTI_MIRROR
                        return_code = cu_set_monitor_port(port_id, 1);
#endif NO_MULTI_MIRROR
                else
                        return_code = cu_set_monitor_port(port_id, 0);

                if (return_code == CU_OUT_OF_RANGE)
                        uprintf("Error - exceeded maximum mirror ports allowed\n");
                if (return_code == CU_DUPLICATE_ENTRY)
                        uprintf("Error - mirror port %p already defined\n", port_id);
                if (return_code == CU_INVALID_INDEX)
                        uprintf("Error - port %p is not defined as a mirror\n", port_id);
        }
}

#ifndef NO_MULTI_MIRROR

//This function checks if config-trunk-independent is on for the trunk port
UINT8 cu_is_port_config_trunk_ind(PORT_ID port)
{
        UINT16 trunk_id;

        trunk_id = cu_get_trunk_id(port, 1);
        return (g_sw_sys.sw_load_group[trunk_id].mon_pri_ind);
}

BOOL is_set_lag_port_monitor_individual(PORT_ID port)
{
        UINT16 trunk_id;

        trunk_id = cu_get_trunk_id(port, 1);
        if (g_sw_sys.sw_load_group[trunk_id].lag_port_monitor_individual)
        {
                return TRUE;
        }
        return FALSE;
}

BOOL is_it_ok_to_do_acl_monitoring_on_this_port(PORT_ID monitor_port, int dir)
{
    ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
    CU_TRUNK_CONFIG_ENTRY   *trunk_entry;
    UINT16  trunk_id, j;
    PORT_ID primary_port;



#ifdef FI_PROTECTED_PORTS
    if(SPTR_PORT_DB(monitor_port)->port_config.protected)
    {           
        uprintf("Error - Port is a Protected Port!\n");
        return FALSE;
    }           
#endif

    if (IS_GROUP_PORT(monitor_port))
    {

            trunk_id        = cu_get_trunk_id(monitor_port, 1);
            sptr_trunk      = &g_sw_sys.sw_load_group[trunk_id];
            trunk_entry     = &g_sw_sys.trunk_config.trunk_entry[trunk_id];
            if (sptr_trunk->lag_port_monitor_individual)
            {
                    return(FALSE);
            }
            /* check for port monitoring */
            if (SPTR_PORT_DB(monitor_port)->port_config.being_monitored & dir)
            {
                    primary_port = trunk_get_primary(trunk_id);
                    if (SPTR_PORT_DB(primary_port)->port_config.being_monitored & dir)
                    {
                            return(FALSE);
                    }
            }
    }
    else
    {
            if (SPTR_PORT_DB(monitor_port)->port_config.being_monitored & dir)
            {
                    return(FALSE);
            }
    }
    return(TRUE);
}

BOOL is_it_ok_to_do_lag_monitoring_on_this_port(PORT_ID monitor_port, int dir)
{
ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
CU_TRUNK_CONFIG_ENTRY   *trunk_entry;
UINT16  trunk_id, j;
PORT_ID primary_port;

#ifdef FI_PROTECTED_PORTS
    if(SPTR_PORT_DB(monitor_port)->port_config.protected)
    {
        uprintf("Error - Port is a Protected Port!\n");
        return FALSE;
    }
#endif

        if (IS_GROUP_PORT(monitor_port))
        {

                trunk_id        = cu_get_trunk_id(monitor_port, 1);
                sptr_trunk      = &g_sw_sys.sw_load_group[trunk_id];
                trunk_entry     = &g_sw_sys.trunk_config.trunk_entry[trunk_id];

                /* lag monitoing is already enabled on this trunk */
                if (sptr_trunk->lag_port_monitor_individual)
                {
                        return(TRUE);
                }
                /* acl monitoring is already enabled on this trunk */
                if (SPTR_PORT_DB(monitor_port)->port_config.acl_mirror)
                {
                        uprintf("Error - Acl mirroring is already enabled on this port %p\n", monitor_port);
                        return(FALSE);
                }
                /* check for port monitoring */
                if (SPTR_PORT_DB(monitor_port)->port_config.being_monitored & dir)
                {
                        primary_port = trunk_get_primary(trunk_id);
                        if (SPTR_PORT_DB(primary_port)->port_config.being_monitored & dir)
                        {
                                uprintf("Error - Port mirroring is already enabled on this port %p\n", monitor_port);
                                return(FALSE);
                        }
                }
        }
        else
        {
                if(LAG_TYPE_KEEP_ALIVE == get_lag_type_by_port(monitor_port))
                {
                        uprintf("Error - Please configure at the interface level for Keep-Alive LAG!\n");
                        return(FALSE);
                }
                uprintf("Error - Port mirroring is already enabled on this port %p\n", monitor_port);
                return(FALSE);
        }
        return(TRUE);
}

BOOL is_it_ok_to_do_port_monitoring_on_this_port(PORT_ID monitor_port, PORT_ID mirror_port, int dir)
{
ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
CU_TRUNK_CONFIG_ENTRY   *trunk_entry;
UINT16  trunk_id, j;
PORT_ID primary_port;

        /* acl monitoring is already enabled on this trunk */
        if (SPTR_PORT_DB(monitor_port)->port_config.acl_mirror &&
                (SPTR_PORT_DB(monitor_port)->port_config.being_monitored & CU_MONITOR_PORT_INPUT))
        {
                uprintf("Error - ACL mirroring is already enabled on this port %p\n", monitor_port);
                return(FALSE);
        }
        
        if (IS_GROUP_PORT(monitor_port))
        {

                trunk_id        = cu_get_trunk_id(monitor_port, 1);
                sptr_trunk      = &g_sw_sys.sw_load_group[trunk_id];
                trunk_entry     = &g_sw_sys.trunk_config.trunk_entry[trunk_id];

                /* lag monitoing is already enabled on this trunk */
                if (sptr_trunk->lag_port_monitor_individual)
                {
                        uprintf("Error - Lag port mirroring is already enabled on this port %p\n", monitor_port);
                        return(FALSE);
                }
        }
        return(TRUE);
}

BOOL cu_set_lag_port_monitor_individual(PORT_ID port)
{
        UINT16 trunk_id;

        trunk_id = cu_get_trunk_id(port, 1);
        g_sw_sys.sw_load_group[trunk_id].lag_port_monitor_individual = 1;
        return TRUE;
}

BOOL cu_clear_lag_port_monitor_individual(PORT_ID port)
{
        UINT16 trunk_id;
        int j;

#ifdef DEBUG_ENABLE
        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
        {
                debug_uprintf("DEBUG: cu_clear_lag_port_monitor_individual(port %p)\n", port);
        }
#endif  DEBUG_ENABLE

        trunk_id = cu_get_trunk_id(port, 1);
        for (j=0; j < HW_MAX_PORTS_PER_GROUP; j++)
        {
                if ((g_sw_sys.sw_load_group[trunk_id].mirror_port[j] != PORT_INDEX_INVALID) ||
                        (g_sw_sys.sw_load_group[trunk_id].tx_mirror_port[j] != PORT_INDEX_INVALID))
                {
                        return FALSE;
                }
        }
#ifdef DEBUG_ENABLE
        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
        {
                debug_uprintf("DEBUG: cu_clear_lag_port_monitor_individual(lag %d port %p) cleared mon individual\n", trunk_id, port);
        }
#endif DEBUG_ENABLE
        g_sw_sys.sw_load_group[trunk_id].lag_port_monitor_individual = 0;
        return TRUE;
}
BOOL cu_set_monitor_named_port(PORT_ID monitor_port, int disable)
{
        UINT16 trunk_id;
        ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
        int j;

        if (IS_GROUP_PORT(monitor_port))
        {
                trunk_id = cu_get_trunk_id(monitor_port, 1);
                sptr_trunk = &g_sw_sys.sw_load_group[trunk_id];
                for (j=0; j < HW_MAX_PORTS_PER_GROUP; j++)
                {
                        if (sptr_trunk->port_list[j] == monitor_port)
                        {
                                if (disable)
                                {
                                        sptr_trunk->monitor_named_port[j] = FALSE;
                                        return(TRUE);
                                }
                                else
                                {
                                        if (sptr_trunk->mirror_port[j] != PORT_INDEX_INVALID)
                                        {
                                                sptr_trunk->monitor_named_port[j] = TRUE;
                                                return(TRUE);
                                        }
                                }
                        }
                }
        }
        return(FALSE);
}

void cli_mirror_config_gen(struct cdb* sptr_cdb, PORT_ID port)
{
        PORT_ID rx_mirr_port, tx_mirr_port;
        UINT8   mode;
                if(!IS_PORT_DB_VALID(port))
                        return;
        if (trunk_port_state(port) == TRUNK_SECONDARY &&  !is_lacp_port(port))
        {
                return;
        }

        if (is_set_lag_port_monitor_individual(port))
        {
                return;
        }

        //For primary, config-trunk-ind should already generate config

        //Validate
        if (cu_get_being_monitored_port_mode(port, &mode) != CU_OK)
                return;

#ifdef SR_SWITCH_ROUTER
#ifdef SIDEWINDER_LINUX
/* ERSPAN */

        /* Check if port is being monitored */
        if (mode == BCM_MIRROR_PORT_OFF)
        {
              if (cu_get_erspan_being_monitored_port_mode(port, &mode) != CU_OK)
              {
                   return;
              }
              else
              {
                        if (mode == BCM_MIRROR_PORT_OFF)
                        {
                                return;
                        }
                        if (mode == BCM_MIRROR_PORT_INGRESS_EGRESS ) //CU_MONITOR_PORT_INPUT_OUTPUT
                   {
                       ksprintf(cu_line_buf, " mon profile %d both\n", SPTR_PORT_DB(port)->port_config.erspan_monitor_profile_id);
                       wr_config(sptr_cdb, cu_line_buf);
                       return;
                   }
                        if (mode == BCM_MIRROR_PORT_INGRESS)
                   {
                       ksprintf(cu_line_buf, " mon profile %d in\n", SPTR_PORT_DB(port)->port_config.erspan_monitor_profile_id);
                       wr_config(sptr_cdb, cu_line_buf);
                       return;
                   }
                        if (mode == BCM_MIRROR_PORT_EGRESS)
                   {
                       ksprintf(cu_line_buf, " mon profile %d out\n", SPTR_PORT_DB(port)->port_config.erspan_monitor_profile_id);
                       wr_config(sptr_cdb, cu_line_buf);
                       return;
                   }
              }

              return;
        }

/* ERSPAN */
#endif SIDEWINDER_LINUX
#endif SR_SWITCH_ROUTER

        rx_mirr_port = SPTR_PORT_DB(port)->port_config.rx_mirror_port_id;
        tx_mirr_port = SPTR_PORT_DB(port)->port_config.tx_mirror_port_id;

        //If inbound and outbound monitored by the same Mirror Port
        if ((mode == CU_MONITOR_PORT_INPUT_OUTPUT) &&
                        (rx_mirr_port == tx_mirr_port) &&
                        (rx_mirr_port != PORT_INDEX_INVALID))
        {
                ksprintf(cu_line_buf, " mon %s %L both\n", get_port_type_str(rx_mirr_port),
						get_port_num(rx_mirr_port));
                wr_config(sptr_cdb, cu_line_buf);
                return;
        }

        if ((mode & CU_MONITOR_PORT_INPUT))
        {
                if (rx_mirr_port != PORT_INDEX_INVALID)
                {
                        ksprintf(cu_line_buf, " mon %s %L in\n", get_port_type_str(rx_mirr_port),
								get_port_num(rx_mirr_port));
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }

        if ((mode & CU_MONITOR_PORT_OUTPUT))
        {
                if (tx_mirr_port != PORT_INDEX_INVALID)
                {
                        ksprintf(cu_line_buf, " mon %s %L out\n", get_port_type_str(tx_mirr_port),
								get_port_num(tx_mirr_port));
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
}

void cli_acl_based_mirror_config_gen(struct cdb* sptr_cdb, PORT_ID port)
{
         PORT_ID        rx_mirr_port, tx_mirr_port;
                 if(!IS_PORT_DB_VALID(port))
                        return;
         if (trunk_port_state(port) == TRUNK_SECONDARY)
         {
                  return;
         }

         //For primary, config-trunk-ind should already generate config
     /*    if (IS_GROUP_PORT(port) && cu_is_port_config_trunk_ind(port))
                  return;
       */
         //Validate
         if (!cu_get_acl_based_mirror_port(port))
                  return;

         rx_mirr_port = SPTR_PORT_DB(port)->port_config.rx_mirror_port_id;
         tx_mirr_port = SPTR_PORT_DB(port)->port_config.tx_mirror_port_id;

         if (rx_mirr_port != PORT_INDEX_INVALID)
         {
                  ksprintf(cu_line_buf, " acl-mirror-port %s %L \n", get_port_type_str(rx_mirr_port), get_port_num(rx_mirr_port));
                  wr_config(sptr_cdb, cu_line_buf);
         }

         return;
}// cli acl based mirror config gen.

void cli_mirror_input_config_gen(struct cdb* sptr_cdb, PORT_ID port)
{
        UINT8 local_slot,mirror_slot;
        PORT_ID mirror_port,i;
        PORT_MASK rxmon_mask;
        UINT16 trunk_id;

        /*** Trunk enhancement Fan ***/
        if(trunk_port_state(port)!=TRUNK_NONE)
        {
                return;
        }

        local_slot = PORT_TO_MODULE_ID(port);
        mirror_slot = g_sw_sys.input_mon_slot[local_slot];
        rxmon_mask = g_sw_sys.rxmon_mask[mirror_slot];


        for (i = 0; i < g_module[mirror_slot].number_of_ports; i++)
        {
                PORT_ID swport, hwport;

                swport = MAKE_PORTID(mirror_slot,i);
                if(!IS_PORT_DB_VALID(swport)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                        continue;
                hwport = SWPORT_TO_HWPORT(swport);
                if (PORT_MASK_ISSET(rxmon_mask, PORT_TO_MODULE_PORT(hwport))) {
                        ksprintf(cu_line_buf, " mon %s %L input\n",
								get_port_type_str(swport),
								get_port_num(swport));
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
}

void cli_mirror_output_config_gen(struct cdb* sptr_cdb, PORT_ID port)
{
        UINT8 mirror_slot;
        PORT_ID mirror_port,i;
        PORT_MASK mirror_portmask[MAX_SLOT];
        UINT16 trunk_id;

        /*** Trunk enhancement Fan ***/
        if(trunk_port_state(port)!=TRUNK_NONE)
        {
                return;
        }

        sw_hwmask_to_swmask(FID_MASK(PORT_HW_PORT(port)), mirror_portmask);
        for (i=0; i < g_hw_info.total_config_ports; ++i)
        {
                mirror_port = sw_config_port_list[i];

                if (!is_member(mirror_portmask, mirror_port))
                        continue;

                if (mirror_port == port)
                        continue;

                ksprintf(cu_line_buf, " mon %s %L output\n", 
						get_port_type_str(mirror_port),
						get_port_num(mirror_port));
                wr_config(sptr_cdb, cu_line_buf);
        }
}
#endif NO_MULTI_MIRROR

void cli_set_being_monitored_port(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 mode;
#ifndef NO_MULTI_MIRROR
        UINT8 mirror_slot,i;

        PORT_MASK *mirror_portmask;
#endif NO_MULTI_MIRROR

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                cli_mirror_config_gen(sptr_cdb, port_id);

        }
//#ifdef NO_MULTI_MIRROR
        else
        {
             if (end_of_token(sptr_cdb->token) != '\0')
                   return;
#ifdef DEBUG_ENABLE
                if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                {
                        debug_uprintf("DEBUG: cli_set_being_monitored_port\n");
                }
#endif
                cli_set_being_monitored_port_in_out(sptr_cdb);
        }
//#endif NO_MULTI_MIRROR
}

void cli_set_acl_based_mirroring(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                cli_acl_based_mirror_config_gen(sptr_cdb, port_id);
        }//if
}// cli set acl based mirroring


#ifdef AOL
void cli_set_port_keep_alive_addr(struct cdb* sptr_cdb)
{
        PORT_ID port = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        extern ICMP_KEEP_ALIVE_INFO icmp_keep_alive_info[];

        if (sptr_cdb->config_gen)
        {
                if (icmp_keep_alive_info[port].ip_addr != 0)
                {
                        ksprintf(cu_line_buf, " keep-alive %I\n", icmp_keep_alive_info[port].ip_addr);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                        sptr_cdb->ip1 = 0;
                icmp_set_port_keep_alive_addr(port, sptr_cdb->ip1);
        }
}
#endif AOL

#ifndef NO_MULTI_MIRROR
void cli_set_default_mirror(struct cdb* sptr_cdb)
{
        int i;
        extern UINT8 g_exiting_trunk;
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        /******* Fan Trunk enhancement ********/
        if(sptr_cdb->flag1==0xFF)
        {
                if(sptr_cdb->flag2==0xFF)
                {
                        port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                }
                else
                {
                        port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if2);
                }

                for(i=0; i < MAX_MIRRORS; i++)
                {
                        if(port_id == g_mirror_list[i])
                        {
                                return;
                        }
                }
        }
        /******* Fan Trunk enhancement ********/

        if (sptr_cdb->config_gen == 0)
        {
                for (i = 0; i < MAX_MIRRORS; i++)
                {
                        if (g_sw_sys.mirror_ports[i] == port_id)
                        {
                                g_sw_sys.monitor_port = port_id;
                                return;
                        }
                }
                uprintf("Error - port %p is not an enabled mirror port\n", port_id);
                sptr_cdb->dont_go_next = 1;
        }
}

#ifdef DEBUG_ENABLE
/* BUG: 6698 Debug command to display modified fid list for out-mon */
#if 0 // klin 99038 remove fid
void display_out_mon_debug_info(struct cdb* sptr_cdb)
{
        PORT_ID sw_mon=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        PORT_ID sw_mir=INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        print_output_monitor_fid_list(sw_mon, sw_mir);
}
#endif
#endif
#endif NO_MULTI_MIRROR

// This function will return FALSE if the port is configured on the trunk but not deployed
UINT8 check_acl_mirror_on_config_trunk(PORT_ID monitor_port)
{
         if( (is_config_trunk_port(monitor_port)) && (!(is_oper_trunk_port(monitor_port))) )
                  return FALSE;
         else
                  return TRUE;

}//check acl mirror on config trunk

PORT_ID cu_get_first_inbound_mirror_port(int no)
{
PORT_ID rx_mirror;
UINT32 count = 0;

        if ((count = sw_pp_rx_mirroring_count()))
        {
                rx_mirror = sw_pp_get_first_rx_mirror();
                if (rx_mirror == PORT_INDEX_INVALID)
                {
                        if (!no)
                                uprintf("Error - No ingress mirror port configured.\n");
                        return(rx_mirror);
                }
                else if(count > 1)
                {
                        if (!no)
                                uprintf("WARNING - ingress mirror port not specified, using first available mirror port %p\n", rx_mirror);
                }
                return(rx_mirror);
        }
        else
        {
                if (!no)
                        uprintf("Error - Cannot mirror to non-existent ingress mirror port!\n");
                return PORT_INDEX_INVALID;
        }
}
PORT_ID cu_get_first_outbound_mirror_port(int no)
{
PORT_ID tx_mirror;
UINT32 count = 0;

        if ((count = sw_pp_tx_mirroring_count()))
        {
                tx_mirror = sw_pp_get_first_tx_mirror();
                if (tx_mirror == PORT_INDEX_INVALID)
                {
                        if (!no)
                                uprintf("Error - No egress mirror port configured.\n");
                        return(tx_mirror);
                }
                else if(count > 1)
                {
                        if (!no)
                                uprintf("WARNING - egress mirror port not specified, using first available mirror port %p\n", tx_mirror);
                }
                return(tx_mirror);
        }
        else
        {
                if (!no)
                        uprintf("Error - Cannot mirror to non-existent egress mirror port!\n");
                return(PORT_INDEX_INVALID);
        }
}
enum BOOLEAN cu_multi_port_valid_trunk_port (struct cdb * sptr_cdb)
{
        UINT16   i = 0;
        enum BOOLEAN    port_found = FALSE;
        PORT_ID  port_id, pListP[HW_MAX_PORTS_PER_GROUP];
        PORT_MASK port_mask[MAX_SLOT];
        int      NumberOfPortsP = 0;

        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        copy_mask(port_mask, sptr_cdb->mif_port_mask);
        cu_PortMask2PortList(port_mask, &NumberOfPortsP, (PORT_ID *)&pListP);

        for(i = 0; i < NumberOfPortsP; i++)
        {
                if(pListP[i] == port_id)
                {
                        port_found = TRUE;
                        break;
                }
        }
        return port_found;
}
//This function extracts the mirror and monitor ports from
//CLI input. It takes care of physical, trunk & named ports.
UINT8 cu_pp_extract_mir_mon_ports(enum CU_MONITOR_PORT direction, struct cdb * sptr_cdb,
    PORT_ID *mirror_port, PORT_ID *monitor_port)
{
  ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
  CU_TRUNK_CONFIG_ENTRY   *sptr_trunk_entry;
  PORT_ID   port_id, port_id_idx;
  PORT_ID   tx_mirror, rx_mirror;
  UINT16    j, trunk_id;
  int flag1 = sptr_cdb->flag1;
  int flag2 = sptr_cdb->flag2;
  unsigned int if_num = sptr_cdb->if_num;
  unsigned int if1 = sptr_cdb->if1;
  unsigned int if2 = sptr_cdb->if2;
  enum BOOLEAN port_found = FALSE;

  //"flag1" indicates if we are in config-trunk-individual mode
  if (flag1 == 0xFF)
  {
    //"flag2" indicates if the port/trunk is named
    if (flag2 == 0xFF)
    {

      if (if1 == 0)
      {
        if (direction & CU_MONITOR_PORT_INPUT)
        {
          *mirror_port = cu_get_first_inbound_mirror_port(sptr_cdb->no);
        }
        else
        {
          *mirror_port = cu_get_first_outbound_mirror_port(sptr_cdb->no);
        }
      }
      else
      {
        *mirror_port    = if1 - 1;
      }

        trunk_id = find_named_port(sptr_cdb->string1, &port_id);                                                                                                                                                                                                                                                                                                                                                                                                          
        if (trunk_id == INVALID_LOAD_SHARE_GROUP_ID)                                                                                                                                                                                                                                                                                                                                                                                                                                              
         {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                uprintf("No port is named as %s!\n", sptr_cdb->string1);                                                                                                                                                                                                                                                                                                                                                                                                   
                return 0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
         }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
         if(port_id == PORT_INDEX_INVALID)                                                                                                                                                                                                                                                                                                                                                                                                                                                                
         {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                uprintf("No port is named as %s!\n", sptr_cdb->string1);                                                                                                                                                                                                                                                                                                                                                                                                   
                 return 0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
        }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
        if((sptr_cdb->mode == CONFIG_LAG) && get_lag_type_by_port(port_id) == LAG_TYPE_KEEP_ALIVE)                                                                                                                                                                                                                                                                                                                         
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                uprintf("trunk-ind command for port-monitoring is not allowed in keepalive lag \n");                                                                                                                                                                                                                                                                                                                                              
                return 0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
        }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

      /* Maintaining mirroring on named port same as disable port-name feature in lag */
      for (trunk_id=0; trunk_id < MAX_LOAD_SHARE_GROUPS; trunk_id++)
      {
        sptr_trunk_entry = &g_sw_sys.trunk_config.trunk_entry[trunk_id];

        if (sptr_trunk_entry->number_of_ports == 0)
        {
          continue;
        }

        port_id = g_sw_sys.sw_load_group[trunk_id].port_list[0];
        if (!is_member(sptr_cdb->mif_port_mask, port_id))
        {
          continue;
        }

        for(j = 0; j < sptr_trunk_entry->number_of_ports; j++)
        {
          port_id = g_sw_sys.sw_load_group[trunk_id].port_list[j];
                  if(!IS_PORT_DB_VALID(port_id))
                        continue;
          if(SPTR_PORT_DB(port_id)->port_config.sptr_port_name)
          {
            //if has been monitored in this direction before, don't do that again during start up      
            if(g_sw_sys.init_in_progress && (sptr_cdb->integer15 & SPTR_PORT_DB(port_id)->port_config.being_monitored))
                continue;

            if(!strcmp(sptr_cdb->string1, SPTR_PORT_DB(port_id)->port_config.sptr_port_name))
            {
#ifdef DEBUG_ENABLE
                        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                        {
                                debug_uprintf("DEBUG: skip cu_pp_extract_mir_mon_ports mon %p %s string = %s\n", port_id, SPTR_PORT_DB(port_id)->port_config.sptr_port_name, sptr_cdb->string1);
                        }
#endif
                        if (sptr_cdb->no && !SPTR_PORT_DB(port_id)->port_config.being_monitored)
                        {
#ifdef DEBUG_ENABLE
                                if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                                {
                                        debug_uprintf("DEBUG: skip cu_pp_extract_mir_mon_ports mon %p \n", port_id);
                                }
#endif
                                continue;
                        }
                        *monitor_port = port_id;
#ifdef DEBUG_ENABLE
                        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                        {
                                debug_uprintf("DEBUG: cu_pp_extract_mir_mon_ports mon %p \n", port_id);
                        }
#endif

                        if(sptr_cdb->integer15 == CU_MONITOR_PORT_INPUT_OUTPUT)
                        {
                                // if disable & mirror port not specified, disable mirroring on both directions (default direction) for the monitored port
                                if(sptr_cdb->no /* && !sptr_cdb->if2 */)                /* TR536056 */
                                {
                                        /*cu_disable_mirroring_on_monitored_port(*monitor_port, sptr_cdb->flag1, sptr_cdb->flag2); TR000575581*/
#ifdef DEBUG_ENABLE
                                        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                                        {
                                                debug_uprintf("DEBUG: cu_pp_extract_mir_mon_ports mon %p if1 = %d if2 = %d\n", port_id, sptr_cdb->if1, sptr_cdb->if2);
                                        }
#endif
//                                      return 1;                                                               /* TR536056 */
                }
              }

              if((sptr_cdb->integer15 == CU_MONITOR_PORT_INPUT_OUTPUT)
                  || (sptr_cdb->integer15 == CU_MONITOR_PORT_INPUT))
              {
                if ((SPTR_PORT_DB(*monitor_port))->port_config.acl_mirror && !sptr_cdb->no)
                {
                  uprintf("Error - ACL mirroring is already enabled on this port %p\n", *monitor_port);
                  return 0;
                }
              }

              if (!sptr_cdb->no && (is_it_ok_to_do_lag_monitoring_on_this_port(*monitor_port, CU_MONITOR_PORT_INPUT_OUTPUT) == FALSE))
              {
                return 0;
              }

              if(sptr_cdb->integer15 == CU_MONITOR_PORT_INPUT_OUTPUT)
              {
                cu_set_being_monitored_port_in_out(*mirror_port, *monitor_port, sptr_cdb->flag1, sptr_cdb->flag2, sptr_cdb->no);
              }
              else if (sptr_cdb->integer15 == CU_MONITOR_PORT_OUTPUT)
              {
                cu_set_being_monitored_port_out_only(*mirror_port, *monitor_port, sptr_cdb->flag1, sptr_cdb->flag2, sptr_cdb->no);
              }
              else
              {
                cu_set_being_monitored_port_in_only(*mirror_port, *monitor_port, sptr_cdb->flag1, sptr_cdb->flag2, sptr_cdb->no, FALSE);
              }
              port_found = TRUE;
            }
#ifdef DEBUG_ENABLE
                else
                        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                        {
                                debug_uprintf("DEBUG: skip cu_pp_extract_mir_mon_ports mon %p %s string = %s\n", port_id, SPTR_PORT_DB(port_id)->port_config.sptr_port_name, sptr_cdb->string1);
                        }
#endif
          }
        }
        /* Breaking after our trunk is reached */
        break;

        if(!port_found)
        {
          uprintf("Error - No port is named as %s!\n", sptr_cdb->string1);
          return 0;
        }
      }
    }
    else
    {
      if (!(g_sw_sys.init_in_progress && (get_current_startup_version() <= 7)))  /* 474125 this will not work with tftp run-config */
      {
        if (!cu_multi_port_valid_trunk_port (sptr_cdb)) 
        {
          uprintf("Invalid port number!\n");
          return 0;
        }
      }
          port_id = INTERFACE_TO_PORT_ID(if1);
      *monitor_port   = INTERFACE_TO_PORT_ID(if1);
        if ((port_id != PORT_INDEX_INVALID) && (sptr_cdb->mode == CONFIG_LAG) && get_lag_type_by_port(port_id) == LAG_TYPE_KEEP_ALIVE)                                                                                                                   
        {                                                                                                                                                                                                                                                                  
                uprintf("trunk-ind command for port-monitoring is not allowed in keepalive lag \n");                                                                                                                                                                           
                return 0;                                                                                                                                                                                                                                                      
        }                                                                                                                                                                                                                                                                  
         
      if (if2 == 0)
      {
        if (direction & CU_MONITOR_PORT_INPUT)
        {
          *mirror_port = cu_get_first_inbound_mirror_port(sptr_cdb->no);
        }
        else
        {
          *mirror_port = cu_get_first_outbound_mirror_port(sptr_cdb->no);
        }
      }
      else
      {
        *mirror_port    = if2 - 1;
      }
    }
  }
  else
  {
    *monitor_port   = INTERFACE_TO_PORT_ID(if_num);
    if (if1 == 0)
    {
      if (direction & CU_MONITOR_PORT_INPUT)
      {
        *mirror_port = cu_get_first_inbound_mirror_port(sptr_cdb->no);
      }
      else
      {
        *mirror_port = cu_get_first_outbound_mirror_port(sptr_cdb->no);
      }
    }
    else
    {
      *mirror_port    = if1 - 1;
    }
  }

  if (*mirror_port == PORT_INDEX_INVALID)
  {
    return 0;
  }
  //Validate monitor port. Mirror port will be checked based on direction.
  if (!IS_PORT_DB_VALID(*monitor_port))
  {
    uprintf("Error - Cannot monitor non-existent port %p!\n", *monitor_port);
    return 0;
  }

  //Validate mirror port.
  if (!IS_PORT_VALID(*mirror_port))
  {
    uprintf("Error - Cannot mirror to non-existent port %p!\n", *mirror_port);
    return 0;
  }
  return 1;
}

void lacp_trunk_disable_monitoring_on_all_ports(PORT_ID port_id)
{
        UINT16 i;
        PORT_ID module_port;
        ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
        UINT16 trunk_id = cu_get_trunk_id(port_id, 1);

        if (!is_lacp_port(port_id))
                return;

        /* no change for mon_pri_ind */
        sptr_trunk = &g_sw_sys.sw_load_group[trunk_id];

        for (i = 0; i < sptr_trunk->config_ports; i++)
        {
                module_port = sptr_trunk->port_list[i];

                if ((SPTR_PORT_DB(module_port))->port_config.being_monitored & CU_MONITOR_PORT_INPUT)
                        sw_pp_set_rx_monitored_port(module_port, 0, DISABLE, FALSE);

                if ((SPTR_PORT_DB(module_port))->port_config.being_monitored & CU_MONITOR_PORT_OUTPUT)
                        sw_pp_set_tx_monitored_port(module_port, 0, DISABLE);
        }
}

 extern enum BOOLEAN is_port_mirroring_valid_in_presence_of_vlan_mirroring(PORT_ID mirror_port, PORT_ID monitor_port, enum BOOLEAN in, enum BOOLEAN out);

//Set monitoring on/off in both directions
void cu_set_being_monitored_port_in_out(PORT_ID mirror_port,
                                                                                PORT_ID monitor_port,
                                                                                int flag1,
                                                                                int flag2,
                                                                                int disable)
{
        UINT32 dev;
        PORT_ID vlan_mirror_port;

        if (IS_PORT_DB_VALID(monitor_port))
        {
                dev = PORT_TO_DEVICE_ID(monitor_port);

        if(!can_sflow_and_mirror_coexist(dev))
        {
                if(sflow_is_enabled_in_dev(dev))
                {
                        uprintf("Error - Please remove SFlow on the port region before enabling Monitoring!\n");
                        return;
                }
        }

        }

#ifdef DEBUG_ENABLE
        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
        {
                debug_uprintf("DEBUG: cu_set_being_monitored_port_in_out f1=%d f2=%d mirror_port=%p monitor_port=%p\n",
                                        flag1,
                                        flag2,
                                        mirror_port,
                                        monitor_port);
        }
#endif

        //Validate Mirror port here.
        if (sw_pp_is_port_mirror(mirror_port) != CU_MONITOR_PORT_INPUT_OUTPUT)
        {
                uprintf("Error - Invalid mirror port %p\n", mirror_port);
                return;
        }
        vlan_mirror_port = sw_pp_get_vlan_ingress_mirrored_port();
        if (!is_port_mirroring_valid_in_presence_of_vlan_mirroring(mirror_port, monitor_port, TRUE, TRUE))
        {
               uprintf("Error - With VLAN mirroring configured, can configure only limited port based mirroring!\n");
               return;
        }
        if(!check_acl_mirror_on_config_trunk(monitor_port))
        {
                uprintf("Error - Trunk configured but not deployed on Monitor port, cannot add Mirroring!\n");
                return;
        }//if

        if (IS_GROUP_PORT(monitor_port))
        {
//              if (!cu_is_port_config_trunk_ind(monitor_port))
#ifdef DEBUG_ENABLE
                if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                {
                        debug_uprintf("DEBUG: cu_set_being_monitored_port_in_out(primary_port %p)\n", monitor_port);
                        debug_print_current_stack_trace();
                }
#endif
                if (flag1 != 0xff)
                {
                        if ((trunk_port_state(monitor_port) == TRUNK_PRIMARY) || (LAG_TYPE_SPX == get_lag_type_by_port(monitor_port)))
                        {
#ifdef DEBUG_ENABLE
                                        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                                        {
                                                debug_uprintf("DEBUG: cu_set_being_monitored_port_in_out1(primary_port %p)\n", monitor_port);
                                        }
#endif  DEBUG_ENABLE
                                //If Primary, do trunk processing, i.e. all ports of the trunk
#if 0
                                if (!is_set_lag_port_monitor_individual(monitor_port))
                                {
                                        sw_pp_set_trunk_mon_port(monitor_port,
                                                                                        mirror_port,
                                                                                        CU_MONITOR_PORT_INPUT_OUTPUT,
                                                                                        disable ? DISABLE : ENABLE,
                                                                                        FALSE);
                                }
                                else
                                {
                                        uprintf("Error - Remove primary lag port %p mirroring from the lag configuration!\n", monitor_port);
                                }
#else
                                        sw_pp_set_trunk_mon_port(monitor_port,
                                                                                        mirror_port,
                                                                                        CU_MONITOR_PORT_INPUT_OUTPUT,
                                                                                        disable ? DISABLE : ENABLE,
                                                                                        FALSE);
                                        if (disable && is_set_lag_port_monitor_individual(monitor_port))
                                        {
                                                cu_clear_lag_port_monitor_individual(monitor_port);
                                        }
#endif
                        }
                        return;
                }
        }
#ifdef DEBUG_ENABLE
        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
        {
                debug_uprintf("DEBUG: cu_set_being_monitored_port_in_out2(primary_port %p)\n", monitor_port);
        }
#endif  DEBUG_ENABLE

        if (disable)
        {
                //Sanity check - see if the port is really being monitored in both directions
                if (!((SPTR_PORT_DB(monitor_port))->port_config.being_monitored & CU_MONITOR_PORT_OUTPUT))
                {
                        uprintf("Error - PortL%p is not being monitored for outbound traffic!\n", monitor_port);
                        return;
                }

                if (!((SPTR_PORT_DB(monitor_port))->port_config.being_monitored & CU_MONITOR_PORT_INPUT))
                {
                        uprintf("Error - Port %p is not being monitored for inbound traffic!\n", monitor_port);
                        return;
                }

                sw_pp_set_rx_monitored_port(monitor_port, mirror_port, DISABLE, FALSE);
                sw_pp_set_tx_monitored_port(monitor_port, mirror_port, DISABLE);
        }
        else
        {
                if (sw_pp_is_port_mirror(monitor_port))
                         uprintf("Error - A Mirror Port cannot be configured as a Monitor Port!\n");
                else
                {
                        sw_pp_set_rx_monitored_port(monitor_port, mirror_port, ENABLE, FALSE);
                        sw_pp_set_tx_monitored_port(monitor_port, mirror_port, ENABLE);
                }
        }

        if (IS_GROUP_PORT(monitor_port))
        {
                if (flag1 == 0xff)
                {
                        if (disable)
                        {
                                cu_clear_lag_port_monitor_individual(monitor_port);
                        }
                        else
                        {
                                cu_set_lag_port_monitor_individual(monitor_port);
                        }
                        if (flag2 == 0xff)
                        {
                                cu_set_monitor_named_port(monitor_port, disable);
                        }
                }
        }
}

// Extract mirror ports and disable mirroring on the monitored port
void cu_disable_mirroring_on_monitored_port(PORT_ID monitor_port, int flag1, int flag2)
{
        PORT_ID inbound_mirror_port =  PORT_INDEX_INVALID;
        PORT_ID outbound_mirror_port = PORT_INDEX_INVALID;

        if (IS_PORT_DB_VALID(monitor_port))
        {
          if ((SPTR_PORT_DB(monitor_port)->port_config.rx_mirror_port_id != PORT_INDEX_INVALID)
                        && (SPTR_PORT_DB(monitor_port)->port_config.being_monitored & CU_MONITOR_PORT_INPUT))
            inbound_mirror_port = SPTR_PORT_DB(monitor_port)->port_config.rx_mirror_port_id;

          if ((SPTR_PORT_DB(monitor_port)->port_config.tx_mirror_port_id != PORT_INDEX_INVALID)
                        && (SPTR_PORT_DB(monitor_port)->port_config.being_monitored & CU_MONITOR_PORT_OUTPUT))
            outbound_mirror_port = SPTR_PORT_DB(monitor_port)->port_config.tx_mirror_port_id;

          if(inbound_mirror_port != PORT_INDEX_INVALID || outbound_mirror_port != PORT_INDEX_INVALID)
          {
            if(inbound_mirror_port == outbound_mirror_port)
                  cu_set_being_monitored_port_in_out(inbound_mirror_port, monitor_port, flag1, flag2, TRUE);
            else
                {
                  if (inbound_mirror_port != PORT_INDEX_INVALID)
                    cu_set_being_monitored_port_in_only(inbound_mirror_port, monitor_port, flag1, flag2, TRUE, FALSE);
              if (outbound_mirror_port != PORT_INDEX_INVALID)
                    cu_set_being_monitored_port_out_only(outbound_mirror_port, monitor_port, flag1, flag2, TRUE);
                }
          }
        }
}
void cli_set_being_monitored_port_in_out(struct cdb* sptr_cdb)
{
    PORT_ID monitor_port = INVALID_PORT_INDEX, mirror_port = INVALID_PORT_INDEX;

    if (sptr_cdb->config_gen)
        return;

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

    sptr_cdb->integer15 = CU_MONITOR_PORT_INPUT_OUTPUT;

    #ifdef DEBUG_ENABLE
    if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
    {
        debug_uprintf("DEBUG: cli_set_being_monitored_port_in_out ifn=%d f1=%d f2=%d if1=%d if2=%d\n",sptr_cdb->if_num,
                                                                                                      sptr_cdb->flag1,
                                                                                                      sptr_cdb->flag2,
                                                                                                      sptr_cdb->if1,
                                                                                                      sptr_cdb->if2);
    }
    #endif

    //Extract mirror and monitor ports
    if (!cu_pp_extract_mir_mon_ports(CU_MONITOR_PORT_INPUT_OUTPUT, sptr_cdb,
                                     &mirror_port, &monitor_port))
    {
    //Kishore -- dont_go_next must be set to 0 for "Incomplete command." to be printed
        sptr_cdb->dont_go_next = 0;
        return;
    }

    /*TR000569284 xwan*/
    if((SPTR_PORT_DB(monitor_port))->port_config.erspan_monitor_profile_id != 0)
    {
        uprintf("Warning: There is ERSPAN configuration on this port, please remove it. \n");
            return;
    }

#ifdef FI_PROTECTED_PORTS
    if(SPTR_PORT_DB(monitor_port)->port_config.protected)
    {           
        uprintf("Error - Port is a Protected Port!\n");
        return;
    }           
#endif



    /* Handle all the case except flag1 and flag2 both equal to 0xFF which is mirroring for named port */
    if((sptr_cdb->flag2 != 0xff) || (sptr_cdb->flag1 == 0))
    {
    // if disable & mirror port not specified, disable mirroring on both directions (default direction) for the monitored port
        if(sptr_cdb->no && !sptr_cdb->if2)
        {
            cu_disable_mirroring_on_monitored_port(monitor_port, sptr_cdb->flag1, sptr_cdb->flag2);
            return;
        }
        if ((SPTR_PORT_DB(monitor_port))->port_config.acl_mirror && !sptr_cdb->no)
        {
            uprintf("Error - ACL mirroring is already enabled on this port %p\n", monitor_port);
            return;
        }
    /*Check for Keep Alive Lag as */
        if (sptr_cdb->flag1 == 0xff)
        {

            if (!sptr_cdb->no)
            {
                if (is_it_ok_to_do_lag_monitoring_on_this_port(monitor_port, CU_MONITOR_PORT_INPUT_OUTPUT) == FALSE)
                {
                    return;
                }
            }
        }
        else
        {
            if (!sptr_cdb->no)
            {
                if (is_it_ok_to_do_port_monitoring_on_this_port(monitor_port, mirror_port, CU_MONITOR_PORT_INPUT_OUTPUT) == FALSE)
                {
                    return;
                }
            }
        }
#ifdef DEBUG_ENABLE
        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
        {
            debug_uprintf("DEBUG: cli_set_being_monitored_port_in_out mirror %p (primary_port %p)\n", mirror_port, monitor_port);
        }
#endif

        cu_set_being_monitored_port_in_out(mirror_port, monitor_port, sptr_cdb->flag1, sptr_cdb->flag2, sptr_cdb->no);
    }
    return;
}

//Set inbound monitoring
void cu_set_being_monitored_port_in_only(PORT_ID mirror_port,
                                                                                 PORT_ID monitor_port,
                                                                                 int flag1,
                                                                                 int flag2,
                                                                                 int disable,
                                                                                 int acl_mirror)
{
        UINT32 dev;
        PORT_ID vlan_mirror_port;

        if (IS_PORT_DB_VALID(monitor_port))
        {
                dev = PORT_TO_DEVICE_ID(monitor_port);

        if(!can_sflow_and_mirror_coexist(dev))
        {
                if(sflow_is_enabled_in_dev(dev))
                {
                        uprintf("Error - Please remove sFlow on the port region before enabling Monitoring!\n");
                        return;
                }
        }
        }

        //Check if mirror port is a valid one in Rx Mirror Table
        if (!(sw_pp_is_port_mirror(mirror_port) & CU_MONITOR_PORT_INPUT))
        {
                uprintf("Error - Invalid rx mirror port %p\n", mirror_port);
                return;
        }
        vlan_mirror_port = sw_pp_get_vlan_ingress_mirrored_port();
        if (!is_port_mirroring_valid_in_presence_of_vlan_mirroring(mirror_port, monitor_port, TRUE, FALSE))
        {
                uprintf("Error - With VLAN mirroring configured, can enable only limited port based mirroring!\n");
                return;
        }
        if(!check_acl_mirror_on_config_trunk(monitor_port))
        {
                uprintf("Error - Trunk configured but not deployed on Monitor port, cannot add Mirroring!\n");
                return;
        }//if

        if (IS_GROUP_PORT(monitor_port))
        {
                 if (flag1 != 0xff)
                {
#ifdef DEBUG_ENABLE
                        if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                        {
                                debug_uprintf("DEBUG: cu_set_being_monitored_port_in_only(primary_port %p)\n", monitor_port);
                                debug_print_current_stack_trace();
                        }
#endif

                        if ((trunk_port_state(monitor_port) == TRUNK_PRIMARY) || (LAG_TYPE_SPX == get_lag_type_by_port(monitor_port)))
                        {
                                //If Primary, do trunk processing, i.e. all ports of the trunk
                                sw_pp_set_trunk_mon_port(monitor_port,
                                                                                        mirror_port,
                                                                                        CU_MONITOR_PORT_INPUT,
                                                                                        disable ? DISABLE : ENABLE,
                                                                                        acl_mirror);
                                if (disable && is_set_lag_port_monitor_individual(monitor_port))
                                {
                                        cu_clear_lag_port_monitor_individual(monitor_port);
                                }
                        }
                        return;
                }
                //else go to regular port proc
        }
        sw_pp_set_rx_monitored_port(monitor_port, mirror_port, disable ? DISABLE : ENABLE, acl_mirror);
        if (IS_GROUP_PORT(monitor_port))
        {
                if (flag1 == 0xff)
                {
                        if (disable)
                        {
                                cu_clear_lag_port_monitor_individual(monitor_port);
                        }
                        else
                        {
                                cu_set_lag_port_monitor_individual(monitor_port);
                        }
                        if (flag2 == 0xff)
                        {
                                cu_set_monitor_named_port(monitor_port, disable);
                        }
                }
        }
}

void cli_set_being_monitored_port_in_only(struct cdb* sptr_cdb)
{
    PORT_ID monitor_port = INVALID_PORT_INDEX, mirror_port = INVALID_PORT_INDEX;
    if (sptr_cdb->config_gen)
        return;

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

    sptr_cdb->integer15 = CU_MONITOR_PORT_INPUT;
    //Extract mirror and monitor ports
    if (!cu_pp_extract_mir_mon_ports(CU_MONITOR_PORT_INPUT_OUTPUT, sptr_cdb,
                                            &mirror_port, &monitor_port))
    {
        return;
    }

    /*TR000569284 xwan*/
    if((SPTR_PORT_DB(monitor_port))->port_config.erspan_monitor_profile_id != 0)
    {
        uprintf("Warning: There is ERSPAN configuration on this port, please remove it. \n");
        return;
    }
#ifdef FI_PROTECTED_PORTS
    if(SPTR_PORT_DB(monitor_port)->port_config.protected)
    {           
        uprintf("Error - Port is a Protected Port!\n");
        return;
    }           
#endif


    /* Handle all the case except flag1 and flag2 both equal to 0xFF which is mirroring for named port */
    if((sptr_cdb->flag2 != 0xff) || (sptr_cdb->flag1 == 0))
    {
        if ((SPTR_PORT_DB(monitor_port))->port_config.acl_mirror && !sptr_cdb->no)
        {
            uprintf("Error - ACL mirroring is already enabled on this port %p\n", monitor_port);
            return;
        }

        if (sptr_cdb->flag1 == 0xff)
        {
            if (!sptr_cdb->no)
            {
                if (is_it_ok_to_do_lag_monitoring_on_this_port(monitor_port, CU_MONITOR_PORT_INPUT) == FALSE)
                {
                    return;
                }
            }
        }
        else
        {
            if (!sptr_cdb->no)
            {
                if (is_it_ok_to_do_port_monitoring_on_this_port(monitor_port, mirror_port, CU_MONITOR_PORT_INPUT) == FALSE)
                {
                    return;
                }
            }
        }
        cu_set_being_monitored_port_in_only(mirror_port, monitor_port, sptr_cdb->flag1, sptr_cdb->flag2, sptr_cdb->no, FALSE);
    }
}

void cu_acl_set_being_monitored_port_in_only(PORT_ID mirror_port,
                                                                                 PORT_ID monitor_port,
                                                                                 int flag1,
                                                                                 int disable)
{
        UINT32 dev;

        if (IS_PORT_DB_VALID(monitor_port))
        {
                dev = PORT_TO_DEVICE_ID(monitor_port);

                if(!can_sflow_and_mirror_coexist(dev))
                {
                        if(sflow_is_enabled_in_dev(dev))
                        {
                                uprintf("Error - Please remove sFlow on the port region before enabling Monitoring!\n");
                                return;
                        }
                }
        }

        //Check if mirror port is a valid one in Rx Mirror Table
        if (!(sw_pp_is_port_mirror(mirror_port) & CU_MONITOR_PORT_INPUT))
        {
                uprintf("Error - Invalid rx mirror port %p\n", mirror_port);
                return;
        }
        if (!is_port_mirroring_valid_in_presence_of_vlan_mirroring(mirror_port, monitor_port, TRUE, FALSE))
        {
                uprintf("Error - With VLAN mirroring configured, can enable only limited port based mirroring!\n");
                return;
        }
        if(!check_acl_mirror_on_config_trunk(monitor_port))
        {
                uprintf("Error - Trunk configured but not deployed on Monitor port, cannot add Mirroring!\n");
                return;
        }//if

        if (IS_GROUP_PORT(monitor_port))
        {

                if (trunk_port_state(monitor_port) == TRUNK_PRIMARY)
                {
                        //If Primary, do trunk processing, i.e. all ports of the trunk
                        sw_pp_set_trunk_mon_port(monitor_port,
                                                                                        mirror_port,
                                                                                        CU_MONITOR_PORT_INPUT,
                                                                                        disable ? DISABLE : ENABLE,
                                                                                        TRUE);
                }
        }
        else
        {
                sw_pp_set_rx_monitored_port(monitor_port, mirror_port, disable ? DISABLE : ENABLE, TRUE);
        }
}

void cli_set_acl_based_inbound_mirroring(struct cdb* sptr_cdb)
{
        PORT_ID monitor_port = INVALID_PORT_INDEX, mirror_port = INVALID_PORT_INDEX;
        UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
                return;

#ifdef __CPU_PORT_SUPPORT__ 
        if(is_cpu_port_id(port_id) && (IS_SIDEWINDER_DEV(PORT_TO_DEVICE_ID(port_id))))
        {
            uprintf("acl-mirroring is not supported on this port\n");
            return;
        }
#endif __CPU_PORT_SUPPORT__ 

        //Extract mirror and monitor ports
        if (!cu_pp_extract_mir_mon_ports(CU_MONITOR_PORT_INPUT_OUTPUT, sptr_cdb,
                                         &mirror_port, &monitor_port))
        {
                return;
        }

        if (sptr_cdb->no)
        {
                cu_acl_set_being_monitored_port_in_only(mirror_port, monitor_port, sptr_cdb->flag1, sptr_cdb->no);
        }
        else
        {
                if (is_it_ok_to_do_acl_monitoring_on_this_port(monitor_port, CU_MONITOR_PORT_INPUT))
                {
                        cu_acl_set_being_monitored_port_in_only(mirror_port, monitor_port, sptr_cdb->flag1, sptr_cdb->no);
                }
                else
                {
                        uprintf("Error - Port or lag mirroring is already enabled on this port %p\n", monitor_port);
                }
        }
}
//Set outbound monitoring
void cu_set_being_monitored_port_out_only(PORT_ID mirror_port,
                                                                                  PORT_ID monitor_port,
                                                                                  int flag1,
                                                                                  int flag2,
                                                                                  int disable)
{
        UINT32 dev;

        if (IS_PORT_DB_VALID(monitor_port))
        {
                dev = PORT_TO_DEVICE_ID(monitor_port);
                if(!can_sflow_and_mirror_coexist(dev))
        {
                if(sflow_is_enabled_in_dev(dev))
                {
                        uprintf("Error - Please remove sFlow on the port region before enabling Monitoring!\n");
                        return;
                }
        }
#if 0
                if(!disable)
                {// when adding the mirror command if, module is not present, we can return from here.
                         // real problem happens with turnk, when the primary port module is not present but secondary
                         // port module is present. will enable mirroring on secondary port but will not even configure
                         // mirroring on primary module.

                         if(!IS_DMA_PRESENT(dev))
                         {
                                  uprintf("Error - Cannot enable monitoring, module %d may be disabled!\n", (dev >> 1) + 1);
                                  return ;
                         }

                }//if
#endif
        }

        //Check if mirror port is a valid one in Tx Mirror Table
        if (!(sw_pp_is_port_mirror(mirror_port) & CU_MONITOR_PORT_OUTPUT))
        {
                uprintf("Error - Invalid tx mirror port %p\n", mirror_port);
                return;
        }
        if (!is_port_mirroring_valid_in_presence_of_vlan_mirroring(mirror_port, monitor_port, FALSE, TRUE))
        {
                uprintf("Error - With VLAN mirroring configured, cannot enable only limited port based mirroring!\n");
                return;
        }
        if(!check_acl_mirror_on_config_trunk(monitor_port))
        {
                uprintf("Error - Trunk configured but not deployed on Monitor port, cannot add Mirroring!\n");
                return;
        }//if

        if (IS_GROUP_PORT(monitor_port))
        {
//              if (!cu_is_port_config_trunk_ind(monitor_port))
#ifdef DEBUG_ENABLE
                if (debugGlobal.infra_struct.debug_mirror.mirroring_type)
                {
                        debug_uprintf("DEBUG: cu_set_being_monitored_port_out_only(primary_port %p)\n", monitor_port);
                        debug_print_current_stack_trace();
                }
#endif
                if (flag1 != 0xff)
                {
                        if ((trunk_port_state(monitor_port) == TRUNK_PRIMARY) || (LAG_TYPE_SPX == get_lag_type_by_port(monitor_port)))
                        {
                                //If Primary, do trunk processing, i.e. all ports of the trunk
                                sw_pp_set_trunk_mon_port(monitor_port,
                                                                                        mirror_port,
                                                                                        CU_MONITOR_PORT_OUTPUT,
                                                                                        disable ? DISABLE : ENABLE,
                                                                                        FALSE);
                                if (disable && is_set_lag_port_monitor_individual(monitor_port))
                                {
                                        cu_clear_lag_port_monitor_individual(monitor_port);
                                }
                        }
                        return;
                }
                //else go to regular port proc
        }
        sw_pp_set_tx_monitored_port(monitor_port, mirror_port, disable ? DISABLE : ENABLE);
        if (IS_GROUP_PORT(monitor_port))
        {
                if (flag1 == 0xff)
                {
                        if (disable)
                        {
                                cu_clear_lag_port_monitor_individual(monitor_port);
                        }
                        else
                        {
                                cu_set_lag_port_monitor_individual(monitor_port);
                        }
                        if (flag2 == 0xff)
                        {
                                cu_set_monitor_named_port(monitor_port, disable);
                        }
                }
        }
}

void cli_set_being_monitored_port_out_only(struct cdb* sptr_cdb)
{
    PORT_ID monitor_port = INVALID_PORT_INDEX, mirror_port = INVALID_PORT_INDEX;

    if (sptr_cdb->config_gen)
        return;

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

    sptr_cdb->integer15 = CU_MONITOR_PORT_OUTPUT;
    //Extract mirror and monitor ports
    if (!cu_pp_extract_mir_mon_ports(CU_MONITOR_PORT_INPUT_OUTPUT, sptr_cdb,
                                                &mirror_port, &monitor_port))
    {
        return;
    }

    /*TR000569284 xwan*/
    if((SPTR_PORT_DB(monitor_port))->port_config.erspan_monitor_profile_id != 0)
    {
        uprintf("Warning: There is ERSPAN configuration on this port, please remove it. \n");
        return;
    }
#ifdef FI_PROTECTED_PORTS
    if(SPTR_PORT_DB(monitor_port)->port_config.protected)
    {           
        uprintf("Error - Port is a Protected Port!\n");
        return;
    }           
#endif


    /* Handle all the case except flag1 and flag2 both equal to 0xFF which is mirroring for named port */
    if((sptr_cdb->flag2 != 0xff) || (sptr_cdb->flag1 == 0))
    {
        if (sptr_cdb->flag1 == 0xff)
        {
            if (!sptr_cdb->no)
            {
                if (is_it_ok_to_do_lag_monitoring_on_this_port(monitor_port, CU_MONITOR_PORT_OUTPUT) == FALSE)
                {
                    return;
                }
            }
        }
        else
        {
            if (!sptr_cdb->no)
            {
                if (is_it_ok_to_do_port_monitoring_on_this_port(monitor_port, mirror_port, CU_MONITOR_PORT_OUTPUT) == FALSE)
                {
                    return;
                }
            }
        }
        cu_set_being_monitored_port_out_only(mirror_port, monitor_port, sptr_cdb->flag1, sptr_cdb->flag2, sptr_cdb->no);
    }
}


#ifndef NO_SUPER_STP
extern enum BOOLEAN delete_port_from_cstp(UINT16 cid, PORT_ID port_id);
extern enum BOOLEAN add_port_to_cstp(UINT16 cid, PORT_ID port_id);
void cli_set_cstp_boundry_port(struct cdb* sptr_cdb)
{
        PORT_ID port_id;
        PORT_DB         *port_ptr;
        VLAN_ENTRY      *vlan_entry;
        int i;

        if ((port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num)) == PORT_INDEX_INVALID)
                return;
                if(!IS_PORT_DB_VALID(port_id))
                                return;
        port_ptr = SPTR_PORT_DB(port_id);

        if (sptr_cdb->config_gen) {
                if (is_member(g_sw_sys.super_stp_portmask, PORT_HW_PORT(port_id))) {
                        sptr_cdb->dont_go_next = 1;
                        ksprintf(cu_line_buf, " stp-boundary %d\n", port_ptr->cid);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        } else {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                if (sptr_cdb->no) {
                        sptr_cdb->dont_go_next = 1;
                        if (port_ptr->cid == 0)
                                return;
                        if (!delete_port_from_cstp(port_ptr->cid, port_id))
                                return;
                        if (find_cstp_entry(port_ptr->cid) == NULL) {
                                vlan_entry = g_sptr_vlan_db+port_ptr->port_config.port_vlan_idx;
                                vlan_entry->pre_forward = 0;
                                vlan_entry->vlan_config_backup.super_stp_enabled = 0;
                                vlan_entry->vlan_config_backup.stp_preforward_delay = 0;
                        }
                        port_ptr->cid = 0;
                        exclude_port_trunk_port_from_hwmask(g_sw_sys.super_stp_portmask, port_id);
                        cu_set_stp_port_state(port_id, 1);
                } else {
                        sptr_cdb->dont_go_next = 1;
                        if (valid_integer1_value_range(sptr_cdb, 1, 0xffff)) {
                                if (!add_port_to_cstp(sptr_cdb->integer1, port_id)) {
                                        uprintf("Error - not enough memory%d\n", sptr_cdb->integer1);
                                        return;
                                }
                                for (i = 0; i < g_sw_sys.max_vlans; i++) {
                                        vlan_entry = g_sptr_vlan_db+i;
                                        if (!vlan_entry->vlan_inuse)
                                                continue;
                                        if (!VLAN_IS_PORT_MEMBER(vlan_entry, port_id))
                                                continue;
                                        if (vlan_entry->pre_forward == 0) {
                                                vlan_entry->pre_forward = 1;
                                                vlan_entry->vlan_config_backup.super_stp_enabled = 1;
                                                vlan_entry->vlan_config_backup.stp_preforward_delay = SW_DFLT_VLAN_STP_PREFORWARD_DELAY;
                                        }
                                }
                                port_ptr->cid = sptr_cdb->integer1;
                                include_port_trunk_port_from_hwmask(g_sw_sys.super_stp_portmask, port_id);
                                cu_set_stp_port_state(port_id, 0);
                        }
                }
        }
}

void clear_one_cstp_counter(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        if (!cu_clear_one_cstp_counter(sptr_cdb->integer1))
                uprintf("Error - customer ID %d is not configured\n", sptr_cdb->integer1);
}

void clear_all_cstp_counter(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        cu_clear_all_cstp_counter();
}
#endif NO_SUPER_STP

/*
        added to support 28115 compatibility mode
*/
void cli_set_phy_mode(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen == 0)
        {
#ifdef X10G
                if (hal_is_pp_10g_port(port_id) &&
                    sptr_cdb->cli_cmd) {
                        uprintf("fail: This CLI operation does not apply to 10G port\n");
                        return;
                }
#endif
                if (sptr_cdb->no)
                {
                        /* Set back to default mode, which is low. */
                        cu_set_phy_mode(port_id, 0);
                }
                else
                {
                        cu_set_phy_mode(port_id, (UINT8)sptr_cdb->integer1);
                }
        }
}

void cli_set_phy_mode_text(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 phy_mode;

        if (sptr_cdb->config_gen)
        {
                /* If current mode is not the default value, then generate command. */
                if (cu_get_phy_mode(port_id, &phy_mode) != CU_OK)
                        return;
                if (phy_mode == 2)
                        wr_config(sptr_cdb, " phy-mode 28k\n");
        }
        else
        {
#ifdef X10G
                if (hal_is_pp_10g_port(port_id) &&
                    sptr_cdb->cli_cmd) {
                        uprintf("fail: This CLI operation does not apply to 10G port\n");
                        return;
                }
#endif
                if (sptr_cdb->no)
                {
                        /* Set back to default mode, which is low. */
                        cu_set_phy_mode(port_id, 0);
                }
                else
                {
                        cu_set_phy_mode(port_id, 2);
                }
        }
}

void set_port_auto_gig(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 auto_gig;
        int stackId = PORT_TO_STACK_ID(port_id);
		if(sptr_cdb->config_gen==0){
			if(check_is_virtual(port_id,"GIG-DEFAULT"))
				return;
		}
        
		if (sptr_cdb->config_gen)
        {
#ifndef NO_GIG_ANA_SWITCH
                if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                        return;

                // if 100-fx is configured, we should not show gig-default
                if (!hal_is_pp_link_100_fx_configed(port_id))
                        if ((auto_gig == AUTO_GIG) && (auto_gig != g_gig_auto))
#ifndef OLD_GIG_ANA_OPT
                                wr_config(sptr_cdb, " gig-default auto-gig\n");
#else OLD_GIG_ANA_OPT
                                wr_config(sptr_cdb, " auto-gig\n");
#endif OLD_GIG_ANA_OPT

#else NO_GIG_ANA_SWITCH
                /* If current mode is not the default value, then generate command. */
                if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                        return;
                if (auto_gig)
                {
                        wr_config(sptr_cdb, " auto-gig\n");
                }
#endif NO_GIG_ANA_SWITCH
        }
        else
        {
                if (hal_is_pp_link_100_fx_configed(port_id)) {
                        uprintf("Error: 100-fx still configured, please remove it first\n");
                        return;
                }
                if (!hal_is_pp_link_gig_port(port_id))
                {
                        uprintf(" fail : port %p is not a gigabit port\n", port_id);
                        return;
                }

                if (IS_FI_BCM()) {
                    if((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_INVALID) || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == NULL))
                        pp_link_media_assign(port_id);
 
                    if (!is_pp_link_fiber_port(port_id) || is_pp_link_x40g_port(port_id) || is_pp_link_x100g_port (port_id) ||
                        ((is_pp_link_x10g_port(port_id) && (SPTR_PORT_DB(port_id))->port_config.speed != SPEED_1000)) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1G_TWINAX) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE))
                    {
                        uprintf(" This CLI operation is Not supported on port %p \n ",port_id);
                        return;
                    }
                }
                else if (( !is_pp_link_combo_port(port_id) && !is_pp_link_gig_fiber_port(port_id)) || 
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1G_TWINAX) || 
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE)) {
                        uprintf(" This CLI operation is Not supported on port %p \n ",port_id);
                        return;
                }


                if (sptr_cdb->no)
                {
#ifndef NO_GIG_ANA_SWITCH
                        if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                                return;
                        if (auto_gig == AUTO_GIG){
                                cu_set_auto_gig(port_id, g_gig_auto);
                                ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_fiber_mode = g_gig_auto;
                                ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_mode_flag = 0;
                                if((stackId != MY_BOOTUP_STACK_ID) && IS_CHASSIS_STACK_EXIST(stackId)){
                                        cu_set_stack_auto_gig(stackId);
                                }
                        }
#else NO_GIG_ANA_SWITCH
                        /* Set back to default mode, which is low. */
                        cu_set_auto_gig(port_id, 0);
#endif NO_GIG_ANA_SWITCH
                }
                else
                {
#ifndef NO_GIG_ANA_SWITCH
                        cu_set_auto_gig(port_id, AUTO_GIG);
                        ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_fiber_mode = AUTO_GIG;
                        ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_mode_flag = 1;
                        if((stackId != MY_BOOTUP_STACK_ID) && IS_CHASSIS_STACK_EXIST(stackId))
                                cu_set_stack_auto_gig(stackId);

#else NO_GIG_ANA_SWITCH
                        cu_set_auto_gig(port_id, 1);
#endif NO_GIG_ANA_SWITCH
                }
        }
}

#ifndef OLD_GIG_ANA_OPT
void old_set_port_auto_gig(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 auto_gig;

        if (sptr_cdb->no)
        {
#ifndef NO_GIG_ANA_SWITCH
                if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                        return;
                if (auto_gig == AUTO_GIG)
                        cu_set_auto_gig(port_id, USER_GIG_DEFAULT);
#else NO_GIG_ANA_SWITCH
                /* Set back to default mode, which is low. */
                cu_set_auto_gig(port_id, 0);
#endif NO_GIG_ANA_SWITCH
        }
        else
        {
#ifndef NO_GIG_ANA_SWITCH
                cu_set_auto_gig(port_id, AUTO_GIG);
#else NO_GIG_ANA_SWITCH
                cu_set_auto_gig(port_id, 1);
#endif NO_GIG_ANA_SWITCH
        }
}
#endif OLD_GIG_ANA_OPT


#ifndef __NO_PVST__
void set_if_pvst_mode(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
        {
                if (cu_get_config_pvst_mode(port_id) == 1)
                        wr_config(sptr_cdb, " pvst-mode\n");
        }
        else
        {
                cu_set_config_pvst_mode(port_id, sptr_cdb->no);
        }
}

void set_mif_pvst_mode(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_pvst_mode);
}

#endif __NO_PVST__

#ifndef NO_GIG_ANA_SWITCH
void set_port_neg_off(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 auto_gig;
        int stackId = PORT_TO_STACK_ID(port_id);
		
		if(sptr_cdb->config_gen==0){
			if(check_is_virtual(port_id,"GIG-DEFAULT"))
				return;
		}

        if (sptr_cdb->config_gen)
        {
                if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                        return;

                // if 100-fx is configured, we should not show gig-default
                if (!hal_is_pp_link_100_fx_configed(port_id))
                        if ((auto_gig == NEG_OFF) && (auto_gig != g_gig_auto))
#ifndef OLD_GIG_ANA_OPT
                                wr_config(sptr_cdb, " gig-default neg-off\n");
#else OLD_GIG_ANA_OPT
                                wr_config(sptr_cdb, " neg-off\n");
#endif OLD_GIG_ANA_OPT

        }
        else
        {
                if (hal_is_pp_link_100_fx_configed(port_id)) {
                        uprintf("Error: 100-fx still configured, please remove it first\n");
                        return;
                }
                if (!hal_is_pp_link_gig_port(port_id))
                {
                        uprintf(" fail : port %p is not a gigabit port\n", port_id);
                        return;
                }

                if (IS_FI_BCM()) {
                    if((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_INVALID) || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == NULL))
                        pp_link_media_assign(port_id);
 
                    if (!is_pp_link_fiber_port(port_id) || is_pp_link_x40g_port(port_id) || is_pp_link_x100g_port (port_id) ||
                        ((is_pp_link_x10g_port(port_id) && (SPTR_PORT_DB(port_id))->port_config.speed != SPEED_1000)) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1G_TWINAX) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE))
                    {
                        uprintf(" This CLI operation is Not supported on port %p \n ",port_id);
                        return;
                    }
                }
                else if (( !is_pp_link_combo_port(port_id) && !is_pp_link_gig_fiber_port(port_id))|| 
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1G_TWINAX) || 
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE)) {
                        uprintf(" This CLI operation is Not supported on port %p \n ",port_id);
                        return;
                }

                if (sptr_cdb->no)
                {
                        if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                                return;
                        if (auto_gig == NEG_OFF){
                                cu_set_auto_gig(port_id, g_gig_auto);
                                ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_fiber_mode = g_gig_auto;
                                ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_mode_flag = 0;
                                if((stackId != MY_BOOTUP_STACK_ID) && IS_CHASSIS_STACK_EXIST(stackId))
                                        cu_set_stack_auto_gig(stackId);
                        }
                }
                else
                {
                        cu_set_auto_gig(port_id, NEG_OFF);
                        ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_fiber_mode = NEG_OFF;
                        ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_mode_flag = 1;
                        if((stackId != MY_BOOTUP_STACK_ID) && IS_CHASSIS_STACK_EXIST(stackId))
                                cu_set_stack_auto_gig(stackId);
                }
        }
}

void set_port_neg_full_auto(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 auto_gig;

        int stackId = PORT_TO_STACK_ID(port_id);

		if(sptr_cdb->config_gen==0){
			if(check_is_virtual(port_id,"GIG-DEFAULT"))
				return;
		}
        
		if (sptr_cdb->config_gen)
        {
                if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                        return;

                if ((auto_gig == NEG_FULL_AUTO) && (auto_gig != g_gig_auto))
#ifndef OLD_GIG_ANA_OPT
                        wr_config(sptr_cdb, " gig-default neg-full-auto\n");
#else OLD_GIG_ANA_OPT
                        wr_config(sptr_cdb, " neg-full-auto\n");
#endif OLD_GIG_ANA_OPT

        }
        else
        {
                if (!hal_is_pp_link_gig_port(port_id))
                {
                        uprintf(" fail : port %p is not a gigabit port\n", port_id);
                        return;
                }

                if (hal_is_pp_link_100_fx_configed(port_id)) {
                        uprintf("Error: 100-fx still configured, please remove it first\n");
                        return;
                }
 
                if (IS_FI_BCM()) {
                    if((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_INVALID) || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == NULL))
                        pp_link_media_assign(port_id);
 
                    if (!is_pp_link_fiber_port(port_id) || is_pp_link_x40g_port(port_id) || is_pp_link_x100g_port (port_id) ||
                        ((is_pp_link_x10g_port(port_id) && (SPTR_PORT_DB(port_id))->port_config.speed != SPEED_1000)) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1G_TWINAX) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE))
                    {
                        uprintf(" This CLI operation is Not supported on port %p \n ",port_id);
                        return;
                    }
                }
                else if (( !is_pp_link_combo_port(port_id) && !is_pp_link_gig_fiber_port(port_id)) || 
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) ||
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1G_TWINAX) || 
                        (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE)) {
                        uprintf(" This CLI operation is Not supported on port %p \n ",port_id);
                        return;
                }

                if (sptr_cdb->no)
                {
                        if (cu_get_auto_gig(port_id, &auto_gig) != CU_OK)
                                return;
                        if (auto_gig == NEG_FULL_AUTO){
                                cu_set_auto_gig(port_id, g_gig_auto);
                                ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_fiber_mode = g_gig_auto;
                                ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_mode_flag = 0;
                                if((stackId != MY_BOOTUP_STACK_ID) && IS_CHASSIS_STACK_EXIST(stackId))
                                        cu_set_stack_auto_gig(stackId);
                        }
                }
                else
                {
                        cu_set_auto_gig(port_id, NEG_FULL_AUTO);
                        ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_fiber_mode = NEG_FULL_AUTO;
                        ppLinkGigCtrl[stackId].port[PORT_TO_STACK_PORT(port_id)].gig_mode_flag = 1;
                        if((stackId != MY_BOOTUP_STACK_ID) && IS_CHASSIS_STACK_EXIST(stackId))
                                cu_set_stack_auto_gig(stackId);
                }
        }
}
#endif NO_GIG_ANA_SWITCH

#ifndef NO_GIG_ANA_SWITCH
void generate_gig_default_config_on_enet_if(struct cdb* sptr_cdb )
{
        PORT_ID port_id;

        if (!sptr_cdb->config_gen)      return;

        // handle gig-default
        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        if (is_mod_type_gig( g_mod2cpu[PORT_TO_MODULE_ID(port_id)].config_module_type ))
        {
                UINT8   auto_gig;
                PORT_ID pri_port_id = get_config_trunk_primary_port(port_id);   //g_sw_sys.trunk_config.trunk_entry[ cu_get_trunk_id(port_id,1) ].primary_port;
                if ( cu_get_auto_gig(pri_port_id, &auto_gig) == CU_OK &&
                         auto_gig != USER_GIG_DEFAULT )
                {
                        // need to generate config for the secondry ports
                        switch (auto_gig)
                        {
                                case NEG_OFF:
                                        set_port_neg_off(sptr_cdb);
                                        break;
                                case AUTO_GIG:
                                        set_port_auto_gig(sptr_cdb);
                                        break;
                                case NEG_FULL_AUTO:
                                        set_port_neg_full_auto(sptr_cdb);
                                        break;
                                default:
                                        break;
                        }
                }
        }
}
#endif NO_GIG_ANA_SWITCH

void cli_set_port_qos_override_tc(struct cdb* sptr_cdb)
{
    PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    enum BOOLEAN priority_forced = FALSE;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->config_gen)
    {
                if (cu_get_port_qos_priority_forced(port_id, 1, &priority_forced) == CU_OK)
                {
                        if (priority_forced)
                        {
                                ksprintf(cu_line_buf, " priority ignore-8021p\n");
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
        return;
    }
    if (sptr_cdb->no)
        {
                if (cu_set_port_qos_priority_forced(port_id, FALSE) != CU_OK)
                        uprintf("Error - cannot set interface %p priority force\n", port_id);
        }
    else
    {
      if(cu_get_config_trust_mode(port_id)) {
         uprintf("Error: Conflicts with Trust DSCP on port: %p\n", port_id);
         return;
      }
                if (cu_set_port_qos_priority_forced(port_id, TRUE) != CU_OK)
                        uprintf("Error - cannot set interface %p priority force\n", port_id);
    }
}

#define ARP_DEFAULT_PRIORITY 4
#define TIMEOUT_MIN 20
#define TIMEOUT_MAX 60


void cli_set_flash_timeout(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                                        return;
        sptr_cdb->dont_go_next = 1;
        if (sptr_cdb->config_gen) 
        {
                if ((get_flash_timeout_config())) {
                        ksprintf(cu_line_buf, "flash-timeout %d\n", (flash_get_timeout_value())/(60 * SECOND));
                wr_config(sptr_cdb, cu_line_buf);
                }
        } 
        else {
                if (sptr_cdb->no) //Restore the timeout to default
                {
                        set_timeout_value(FLASH_USE_TIMEOUT_VAL);
                        set_flash_timeout_config(FALSE);
                } else {
                        if (!valid_integer1_value_range(sptr_cdb, TIMEOUT_MIN, TIMEOUT_MAX))
                        return;
                        set_timeout_value((sptr_cdb->integer1*60) * SECOND);
                        set_flash_timeout_config(TRUE);
                }
        }
}
void cli_set_arp_priority (struct cdb* sptr_cdb)
{

        UINT8 priority=0;
        UINT8 device_id = 0;
        int rc, rc1;
        
        

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

                

        if (sptr_cdb->config_gen) 
        {
                if (ip.arp.is_arp_priority_set) 
                {
                ksprintf(cu_line_buf, "arp-internal-priority %d\n", ip.arp.configured_arp_priority);
                wr_config(sptr_cdb, cu_line_buf);
                }
        } 
        else {

                if (sptr_cdb->no) 
                {
                        if (ip.arp.is_arp_priority_set) 
                        {

                                /* restore the tc value to the default value for ARP */
                                sw_security_send_arp_hipri_rules((UINT8)ARP_DEFAULT_PRIORITY, 0); 

                                }

                } else {
                
                if (!valid_integer1_value_range(sptr_cdb, VAL_snSwPortInfoPortQos_level0, VAL_snSwPortInfoPortQos_level7))
                        return;
                
                sw_security_send_arp_hipri_rules(sptr_cdb->integer1, 1);                
        
                }
        }
        

}

void cli_set_port_qos(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 priority=0;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->config_gen == 0)
        {       /* not config gen */
                if (sptr_cdb->no)
                {
                        if (cu_set_port_qos_priority(port_id, SW_DFLT_PORT_PRIORITY) != CU_OK)
                                uprintf("Error - cannot set interface %p priority to default value %d.\n",
                                        port_id, SW_DFLT_PORT_PRIORITY);
                }
                else
                {
                        if (valid_integer1_value_range(sptr_cdb, VAL_snSwPortInfoPortQos_level0, VAL_snSwPortInfoPortQos_level7))
                        {
                            if (sflowEnabled)
                            {
                                        if (sptr_cdb->integer1 == SFLOW_TRAFFIC_CLASS)
                                        {
                                                /* This QOS profile is reserved for SFLOW internally */
                                                uprintf("Error -  priority %d is reserved for SFLOW.\n", sptr_cdb->integer1);
                                        }
                            }
                            if(IS_STACKING_ENABLED)
                            {
                                if(sptr_cdb->integer1 == VAL_snSwPortInfoPortQos_level7)
                                {
                                                priority = sptr_cdb->integer1 - 1; //Move it to Queue 6
                                }
                                }
                                else
                                {
                                        priority = sptr_cdb->integer1;
                            }
                            if (cu_set_port_qos_priority(port_id, (UINT8)sptr_cdb->integer1) != CU_OK)
                                        uprintf("Error - cannot set interface %p priority to %d.\n",
                                                port_id, sptr_cdb->integer1);
                        }
                }
        }
        else
        {
                /* config gen */
                if (cu_get_port_qos_priority(port_id, 1, &priority) == CU_OK)
                {
                        if (priority)
                        {
                                ksprintf(cu_line_buf, " priority %d\n", priority);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
        }
}

void cli_set_port_up_confirm(struct cdb* sptr_cdb)
{
        PORT_ID port_number=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 confirm_cnt=0;
        int default_val;
       if(!IS_PORT_DB_VALID(port_number))
                        return;  
        if ((SPTR_PORT_DB(port_number))->port_oper_info.speed == SPEED_10000)
        {
                if (sptr_cdb->config_gen == 0)
                        uprintf("Not for 10G port\n");
                return;
        }

        if ((SPTR_PORT_DB(port_number))->port_oper_info.speed == SPEED_1000)
                default_val = DEF_GIG_PORT_WAIT;
        else
                default_val = DEF_MEG_PORT_WAIT;

        if (sptr_cdb->config_gen == 0)
        {       /* not config gen */
                if (sptr_cdb->no)
                {
                        if (cu_set_port_up_confirm(port_number, default_val) != CU_OK)
                                uprintf("Error - cannot set interface %s %p port-up-confirm to default value %d.\n",
                                        get_port_type_str(port_number), get_port_num(port_number), SW_DFLT_PORT_PRIORITY);
                }
                else
                {
                        if (valid_integer1_value_range(sptr_cdb, 1, 10))
                        {
                                if (cu_set_port_up_confirm(port_number, (UINT8)sptr_cdb->integer1) != CU_OK)
                                        uprintf("Error - cannot set interface %s %p port-up-confirm to %d.\n",
                                                get_port_type_str(port_number), get_port_num(port_number), sptr_cdb->integer1);
                        }
                }
        }
        else
        {
                /* config gen */
                if (cu_get_port_up_confirm(port_number, 1, &confirm_cnt) == CU_OK)
                {
                        if (confirm_cnt != default_val)
                        {
                                ksprintf(cu_line_buf, " confirm-port-up %d\n", confirm_cnt);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
        }
}



/*
 * Function
 *   errdisable_set_global_recovery_timeout
 * Description:
 *   set the global errdisable interval;
 *
 */
void errdisable_set_global_recovery_timeout(struct cdb* sptr_cdb)
{
        extern UINT32 g_errdisable_recovery_pod_timeout;
        extern UINT8 errdisable_recovery_enable[ERRDISABLE_CAUSE_CNT];

        if (sptr_cdb->config_gen)
        {
                if( (g_errdisable_recovery_timeout == SW_DFLT_SWITCH_ERRDISABLE_TIMEOUT) &&
                        (g_errdisable_recovery_pod_timeout == SW_DFLT_SWITCH_ERRDISABLE_POD_TIMEOUT)
                  )
                        return;

                ksprintf(cu_line_buf, "errdisable recovery interval %d\n", g_errdisable_recovery_timeout);
                wr_config(sptr_cdb, cu_line_buf);
        }
        else
        {
                if (sptr_cdb->no)
                {
                        g_errdisable_recovery_timeout = SW_DFLT_SWITCH_ERRDISABLE_TIMEOUT;
                        g_errdisable_recovery_pod_timeout = SW_DFLT_SWITCH_ERRDISABLE_POD_TIMEOUT;
                }
                else
                {
                        if (sptr_cdb->integer1 >= CU_MIN_ERRDISABLE_TIMEOUT && sptr_cdb->integer1 <= CU_MAX_ERRDISABLE_TIMEOUT)
                        {
                                g_errdisable_recovery_timeout = sptr_cdb->integer1;
                                g_errdisable_recovery_pod_timeout = g_errdisable_recovery_timeout;

                        }
                        else
                                uprintf("Error - errdisable recovery timeout value is out of range, valid value should be within [%d, %d] seconds\n",
                                        CU_MIN_ERRDISABLE_TIMEOUT, CU_MAX_ERRDISABLE_TIMEOUT);
                }
        }


}


void switch_ageTime(struct cdb* sptr_cdb)
{
        UINT32 time;
        UINT32 max_time;

        if (sptr_cdb->config_gen)
        {
                time = cu_get_switch_age_time();

                if (time == SW_DFLT_SWITCH_AGE_TIME)
                        return;

                ksprintf(cu_line_buf, "mac-age %d\n", time);
                wr_config(sptr_cdb, cu_line_buf);
        }
        else
        {
                max_time = CU_MAX_SWITCH_AGE_TIME;
                if (sptr_cdb->no)
                        cu_set_switch_age_time(SW_DFLT_SWITCH_AGE_TIME);
                else
                {
                        if ((sptr_cdb->integer1 == 0)
                        ||  (sptr_cdb->integer1 >= CU_MIN_SWITCH_AGE_TIME
                        &&   sptr_cdb->integer1 <= max_time))
                                cu_set_switch_age_time(sptr_cdb->integer1);
                        else
                                uprintf("Error - %d not equal to 0 or between %d and %d\n",
                                        sptr_cdb->integer1,
                                        CU_MIN_SWITCH_AGE_TIME,
                                        max_time);
                }
        }
}

/*****************************************************************************/
/* config term                                                                                                                                    */
/*   no mac-movement notification threshold rate                                                                              */
/*****************************************************************************/
void cli_mac_move_notification_threshold_rate(struct cdb *sptr_cdb)
{
        UINT8 next_token;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                return;
        }

        next_token = tolower(end_of_token(sptr_cdb->token));

        if (next_token != '\0')
        {
                return;
        }

            sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                mac_move_notify_clear_threshold_rate_enable_flag();
                mac_move_notify_clear_threshold_rate_parameters();
                mac_move_notify_clear_notification_list();
        }
        else
        {
                uprintf("Incomplete command parameters:\n");
                uprintf(" mac-movement notification threshold-rate  <value> sampling-interval <value><cr>\n");
                return;
        }
}

/*****************************************************************************/
/* config term                                                                                                                                    */
/*   mac-movement notification threshold-rate <decimal> sampling-interval <decimal>                     */
/*****************************************************************************/
void cli_mac_move_notification_threshold_rate_decimal(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                return;
        }

        if (sptr_cdb->no)
        {
                mac_move_notify_clear_threshold_rate_enable_flag();
                mac_move_notify_clear_threshold_rate_parameters();
                mac_move_notify_clear_notification_list();
        }
        else
        {
                if ((sptr_cdb->integer1 < MIN_THRESHOLD_RATE) || (sptr_cdb->integer1 > MAX_THRESHOLD_RATE))
                                {
                                        uprintf("Error: Valid value for threshold rate is from %d to %d\n", MIN_THRESHOLD_RATE, MAX_THRESHOLD_RATE);
                                        return;
                                }
                else if ((sptr_cdb->integer2 < MIN_SAMPLING_INTERVAL) || (sptr_cdb->integer2 > MAX_SAMPLING_INTERVAL))
                {
                    uprintf("Error: Valid value for sampling interval is from %d to %d\n", MIN_SAMPLING_INTERVAL, MAX_SAMPLING_INTERVAL);
                                        return;
                }
                mac_move_notify_set_threshold_rate_enable_flag();
                mac_move_notify_set_threshold_rate_parameters(sptr_cdb->integer1, sptr_cdb->integer2);
        }
        return;
}

/*****************************************************************************/
/* config term                                                                                                                                    */
/*   no mac-movement notification interval-history                                                                            */
/*****************************************************************************/
void cli_mac_move_notification_interval_history(struct cdb *sptr_cdb)
{
        UINT8 next_token;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                return;
        }

        next_token = tolower(end_of_token(sptr_cdb->token));

        if (next_token != '\0')
        {
                return;
        }

            sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
        {
                mac_move_notify_clear_interval_history_enable_flag();
                mac_move_notify_clear_interval_history_parameters();
                mac_move_notify_clear_history_list();
                mac_move_notify_interval_history_stop_timer();
        }
        else
        {
                uprintf("Incomplete command parameters:\n");
                uprintf(" mac-movement notification threshold-rate  <value> sampling-interval <value><cr>\n");
                return;
        }
        return;
}

/*****************************************************************************/
/* config term                                                                                                                                    */
/*   mac-movement notification interval-history <decimal>                                                                */
/*****************************************************************************/
void cli_mac_move_notification_interval_history_decimal(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                return;
        }

        if (sptr_cdb->no)
        {
                mac_move_notify_clear_interval_history_enable_flag();
                mac_move_notify_clear_interval_history_parameters();
                mac_move_notify_clear_history_list();
                mac_move_notify_interval_history_stop_timer();
        }
        else
        {
                if ((sptr_cdb->integer1 < MIN_INTERVAL) || (sptr_cdb->integer1 > MAX_INTERVAL))
                {
                        uprintf("Valid value for interval is from %d to %d\n", MIN_INTERVAL, MAX_INTERVAL);
                        return;
                }
                mac_move_notify_set_interval_history_enable_flag();
                mac_move_notify_set_interval_history_parameters(sptr_cdb->integer1);
                mac_move_notify_interval_history_start_timer(sptr_cdb->integer1);
        }
        return;
}

/*****************************************************************************/
/*mac_move_notify_config_gen: Generates startup config based on current mac move notification     */
/*configuration                                                                                                                                   */
/*****************************************************************************/
void mac_move_notify_config_gen(struct cdb *sptr_cdb)
{
        unsigned char buf[256];

        if (mac_move_info.mac_move_notify_threshold_rate_enable)
        {
                ksprintf(buf, "mac-movement notification threshold-rate %d sampling-interval %d\n",
                        mac_move_info.threshold_rate, mac_move_info.sampling_interval);
                wr_config(sptr_cdb, buf);
        }

        if (mac_move_info.mac_move_notify_interval_history_enable)
        {
                ksprintf(buf, "mac-movement notification interval-history %d\n", mac_move_info.interval);
                wr_config(sptr_cdb, buf);
        }
        return;
}

/******************************************************************************/
/*cli__set_mac_notification_interval: Set interval for mac-move notification feature*/
/******************************************************************************/
void cli_set_mac_notification_interval(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                return;
        }

        if (sptr_cdb->no)
        {
                 mac_notification_clear_interval();
                         
        }
        else
        {
                if ((sptr_cdb->integer1 < MIN_MAC_NOTIFICATION_INTERVAL) || (sptr_cdb->integer1 > MAX_MAC_NOTIFICATION_INTERVAL))
                {
                        uprintf("Valid value for interval is from %d to %d\n", MIN_MAC_NOTIFICATION_INTERVAL, MAX_MAC_NOTIFICATION_INTERVAL);
                        return;
                }
                mac_notification_set_interval(sptr_cdb->integer1);
        }
        return;
}

void cli_set_mac_events_per_trap(struct cdb* sptr_cdb)
{

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                return;
        }
        if (sptr_cdb->no)
        {
                 mac_notification_clear_events_per_trap();
        }
        else
        {
                mac_notification_set_events_per_trap(sptr_cdb->integer1);
        }
        return;
}

extern SNMP_CLASS snmp;
extern MAC_NOTIFICATION_BUFFER mac_notification;
void mac_notification_config_gen(struct cdb *sptr_cdb)
{
        unsigned char buf[256];

        if (snmp.trap_mac_notification_enabled && (mac_notification.interval != DEFAULT_MAC_NOTIFICATION_INTERVAL))
        {
                ksprintf(buf, "mac-notification interval %d\n",mac_notification.interval);
                wr_config(sptr_cdb, buf);
        }

        return;
}

//Clear stats for mac-notification
void cli_reset_mac_notification_stat(struct cdb *sptr_cdb)
{
        mac_notification_clear_stat();
}
// FLOW_MAC
void flow_based_mac(struct cdb* sptr_cdb)
{
        UINT32 time;
#ifdef INCLUDE_MCT
    UINT32 i,port_number;
        extern enum BOOLEAN clusterlib_is_my_cluster_deployed();
#endif
        if (sptr_cdb->config_gen)
        {
                if (!is_mac_learning_flow_based())
                        return;

                ksprintf(cu_line_buf, "mac-learning-flow-based\n");
                wr_config(sptr_cdb, cu_line_buf);
        }
        else
        {

                if (sptr_cdb->no)
                {
                        if (!is_mac_learning_flow_based())
                                return;
                        set_mac_learning_flow_based(FALSE);
                        /* Disable  UnknownUC_to_CPU mode to be sent to CPU only */
                        sw_gi_set_unkown_uc_copy_to_cpu(0);
                        mac_action_request(MA_ALL_SYSTEM, MAC_FLUSH);
                        mac_force_action(); 
                }
                else
                {
                        if (is_mac_learning_flow_based())
                                return;

#ifdef SR_SWITCH_ROUTER
                        if ( cu_get_global_route_only() ||
                             !(is_mask_clear(g_sw_sys.route_only_mask)))
                        {
                                uprintf("Error - Flow Based Mac Learning cannot be Enabled with Route-Only Enabled\n");
                                return;
                        }
#endif SR_SWITCH_ROUTER
                        if (sw_pp_is_disable_learning_configured_on_any_port())
                        {
                                uprintf("Error - Flow Based Mac Learning cannot be Enabled when 'mac-learn-disable' is configured\n");
                                return;
                        }
#ifdef INCLUDE_MCT
                        #if 0
                        for (i = 0; i < g_hw_info.total_config_ports; i++)
                        {
                                port_number = sw_config_port_list[i];
                                if(port_number == BAD_PORT_ID)
                                        continue;
                                if (IS_PORT_ICL_PORT(port_number) || IS_PORT_CCEP_PORT(port_number))
                                {
                                        uprintf("Error - Flow Based Mac Learning cannot be Enabled on cluster ports: %p\n", port_number);
                        return;
                                }
                        }
#endif
                        if(clusterlib_is_my_cluster_deployed())
                        {
                                uprintf("Error - Flow Based Mac Learning cannot be Enabled when Cluster is in Deployed state\n");
                                return;
                        }
#endif

                        set_mac_learning_flow_based(TRUE);
                        /* Enable  UnknownUC_to_CPU mode to be sent to CPU only */
                        sw_gi_set_unkown_uc_copy_to_cpu(1);
                        mac_action_request(MA_ALL_SYSTEM, MAC_FLUSH);
                }
        }
}

void cli_set_no_max_vlans(struct cdb* sptr_cdb)
{
#ifdef NO_SYS_PAR
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
                        sptr_cdb->dont_go_next = 1;
                        sptr_cdb->integer1 = g_sw_sys.default_max_vlans;
                        cli_set_max_vlans(sptr_cdb);
                }
        }
#endif NO_SYS_PAR
}

void cli_set_max_vlans(struct cdb* sptr_cdb)
{
#ifdef NO_SYS_PAR
        int vlan_entry_cnt;

        /*
         * Config gen is directly handled by retrieve_running_config()
         * in parser.c. This command needs to be generated before all
         * other vlan commands are generated.
         */
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (!valid_integer1_value_range(sptr_cdb, 1, MAX_VLANS))
                        return;

                vlan_entry_cnt = cu_get_vlan_entry_config_cnt();

                if (vlan_entry_cnt > (int) sptr_cdb->integer1)
                {
                        uprintf("Error - %d existing configured VLANs is greater than the maximum defined\n", vlan_entry_cnt);
                        return;
                }

                cu_set_max_vlans((UINT16) sptr_cdb->integer1);

                if (g_sw_sys.init_in_progress == 0  && (!STACK_AM_I_SLAVE))
                {
                        uprintf("Maximum number of vlans to %d, which will take effect\n"
                                "on next power cycle. \n", sptr_cdb->integer1);
                        print_require_reload();
                }
        }
#endif NO_SYS_PAR
}

void set_user_node_cmd_filter(struct cdb* sptr_cdb)
{
        int i;
        struct node* sptr_node;
		unsigned int flag=(sptr_cdb->ui_port == CONSOLE_SESSION || IS_RCONSOLE_SESSION(sptr_cdb->ui_port)) ? ENABLE : DISABLE;
        struct io_port_cb *sptr_cb = &io_cb[sptr_cdb->ui_port];

        for (i=0; ;i++)
        {
                sptr_node = &user_execute[i];
                /*Allow "exit" command at console, if AAA is configured for login authentication,
                 * and AAA is activated for console too.*/
                if ((cu_aaa_is_console_session(sptr_cdb->ui_port)) && // CHEETAH_STACKING
                    cu_aaa_is_login_authen_enabled_for_console())
                        set_cmd_filter_flag(sptr_node, "exit", USER_EXEC_KEYWORD, DONT_PARSE, !flag);
				else if ((STACK_AM_I_SLAVE || STACK_AM_I_PE) && sptr_cb && (sptr_cb-> rconsole_connected))
                    set_cmd_filter_flag(sptr_node, "exit", USER_EXEC_KEYWORD, DONT_PARSE, !flag);
                else
                        set_cmd_filter_flag(sptr_node, "exit", USER_EXEC_KEYWORD, DONT_PARSE, flag);

                if ((sptr_node->type & LAST_ENTRY) == LAST_ENTRY)
                        break;
        }
}

void set_command_filter_for_each_parser_mode(struct cdb* sptr_cdb)
{
        set_user_node_cmd_filter(sptr_cdb);
}

#ifdef NOT_USED
/* commented out because we are using privilege level
 * in the user mode to permit/deny level 4 or above
 * commands
 */
void security_parser(UINT8 root_node, UINT8 action)
{
        SECURITY_PARSER_T *sptr_security_parser=&level5_user_security_table[0];

        /* Current code only parse USER_EXEC root_node, we can support
         * PRIV_EXEC and CONFIG root_node if needed in the future.
         */
        for (;;)
        {
                if (sptr_security_parser->keyword == NULL)
                        break;
                else
                {
                        if (action)
                        {
                                set_user_tree_node_flag(
                                        sptr_security_parser->keyword,
                                        sptr_security_parser->node_type, DONT_PARSE);
                        }
                        else
                        {
                                reset_user_tree_node_flag(
                                        sptr_security_parser->keyword,
                                        sptr_security_parser->node_type, DONT_PARSE);
                        }
                        sptr_security_parser++;
                }
        }
}
#endif NOT_USED

void parse_decimal_list(struct cdb* sptr_cdb, void (*call_back)(struct cdb *), char *help_string)
{
        char *sptr_invalid_token=NULL, *sptr_curr_token, *sptr_next_token;
        int i=-1, j=-1, k;

        if (sptr_cdb->help)
        {
                if (help_string == NULL)
                        help_string = "";
                print_helpstring2(7, "DECIMAL", help_string);
                options_printed[sptr_cdb->ui_port] = 1;
                sptr_cdb->dont_go_next = 1;
                return;
        }
        /* parse the decimal number list, call callback
         * function while parsing along the list
         */
        sptr_curr_token = sptr_next_token = sptr_cdb->token;
        while (*sptr_next_token != '\0')
        {
                i = j = -1;
                if ((i = cli_get_int(sptr_curr_token,1,&k)) == -1)
                {
                        sptr_invalid_token = sptr_curr_token;
                        break;
                }
                NEXT_TOKEN(sptr_next_token);
                if (isdigit(*sptr_next_token))
                {
                        sptr_cdb->integer1 = i;
                        sptr_cdb->num_of_integer = 1;
                        (*call_back)(sptr_cdb);
                        if (sptr_cdb->dont_go_next)
                                return;
                        i = -1;
                        sptr_curr_token = sptr_next_token;
                        continue;
                }
                if (tolower(*sptr_next_token) != 't')
                {
                        sptr_invalid_token = sptr_next_token;
                        break;
                }
#ifndef NO_MULTI_CONFIG_VLAN
                if (*(sptr_next_token+1) != 'o' && *(sptr_next_token+1) != ' ')
                {
                        sptr_invalid_token = sptr_next_token;
                        break;
                }
#endif NO_MULTI_CONFIG_VLAN
                NEXT_TOKEN(sptr_next_token);
                if ((j = cli_get_int(sptr_next_token,1,&k)) == -1)
                {
                        sptr_invalid_token = sptr_next_token;
                        break;
                }
                sptr_cdb->integer1 = i;
                sptr_cdb->integer2 = j;
                sptr_cdb->num_of_integer = 2;
                (*call_back)(sptr_cdb);
                if (sptr_cdb->dont_go_next)
                        return;
                i = j = -1;
                sptr_curr_token = sptr_next_token;
                NEXT_TOKEN(sptr_next_token);
                if (!isdigit(*sptr_next_token))
                        break;
                sptr_curr_token = sptr_next_token;
                continue;
        }
        if (sptr_invalid_token && *sptr_invalid_token != '\0')
        {
                uprintf("Invalid input -> %s\nType ? for a list\n", sptr_invalid_token);
                sptr_cdb->dont_go_next = 1;
        }
        if (i == -1)
                return;
        sptr_cdb->integer1 = i;
        if (j == -1)
        {
                sptr_cdb->num_of_integer = 1;
        }
        else
        {
                sptr_cdb->integer2 = j;
                sptr_cdb->num_of_integer = 2;
        }
        (*call_back)(sptr_cdb);
}

unsigned char *
cli_find_char(unsigned char *p, unsigned char c)
{
        if (p == NULL)
        return NULL;

        /* Look forward to search for the character. */
        while ((*p != c) && (*p != '\0'))
                ++p;
        return (*p == '\0') ? NULL : p;
}

char* search_string_in_line_and_move_pointer (char *line, char *pattern)
{
        while (*line == ' ')
                line++;
        while (*pattern != '\0')
        {
                if (*pattern != *line)
                        return NULL;
                pattern++;
                line++;
        }
        while (*line == ' ')
                line++;
        return line;
}


#ifdef SR_SWITCH_ROUTER
/* Required for bacward compatiablity */
void check_no_relay_bootp (struct cdb* sptr_cdb)
{
                if (sptr_cdb->config_gen)
                                return;

                if (sptr_cdb->no)
                {
                                set_udp_forward_broadcast_udp_port(FALSE,(UINT16)CLI_ENUM_BOOTPS);
                                sptr_cdb->dont_go_next = 1;
                }
}

void set_bootp_server(struct cdb* sptr_cdb)
{
#ifdef NOT_USED
                char temp1[] = "relay-bootp ";
#endif NOT_USED

                if (sptr_cdb->config_gen) {
                                                return;
                }
                else {

                                if (sptr_cdb->no)
                                {
                                                set_udp_forward_broadcast_udp_port(FALSE,(UINT16)CLI_ENUM_BOOTPS);
                                }
                                else
                                {
                                                if (! valid_integer1_value_range(sptr_cdb, 1, 15))
                                                                return;
#ifdef NOT_USED
                                                if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > 15)
                                                {
                                                                uprintf("Error - number of hops must be between 1 and 15\n");
                                                                return;
                                                }
#endif NOT_USED

                                                bootp.relay_agent.threshold_for_number_of_gateway_hops_field =
                                                                sptr_cdb->integer1;
                                                set_ip_helper_address_for_bootp_relay(sptr_cdb->ip1);
                                                g_sw_sys.copy_config_to_flash = TRUE;
                                }
                }
}
void
set_ip_helper_address_for_bootp_relay(UINT32 helper_address)
{
                UINT16 i;

                for ( i=0; i < MAX_NUMBER_OF_PORTS; i++)
                {
                        add_ip_helper_address((PORT_ID)i, 0, helper_address, FALSE);
                }
}
void
set_relayBootpMaxHops(struct cdb* sptr_cdb)
{
#ifdef NOT_USED
                char temp1[] = "bootp-relay-max-hops";
#endif NOT_USED

                if (sptr_cdb->config_gen)
                {
                                if (bootp.relay_agent.threshold_for_number_of_gateway_hops_field == BOOTP_DEFAULT_MAX_HOPS_COUNT)
                                                return;
#ifdef NOT_USED
                                wr_config(sptr_cdb, temp1);
                                ksprintf(cu_line_buf, " %d\n", bootp.relay_agent.threshold_for_number_of_gateway_hops_field);
                                wr_config(sptr_cdb, cu_line_buf);
#endif NOT_USED
                                ksprintf(cu_line_buf, "bootp-relay-max-hops %d\n", bootp.relay_agent.threshold_for_number_of_gateway_hops_field);
                                wr_config(sptr_cdb, cu_line_buf);
                                                return;
                }
                else
                {
                                if (sptr_cdb->no)
                                {
                                                bootp.relay_agent.threshold_for_number_of_gateway_hops_field = BOOTP_DEFAULT_MAX_HOPS_COUNT;
                                }
                                else
                                {
                                                if (! valid_integer1_value_range(sptr_cdb, 1, 15))
                                                                return;
#ifdef NOT_USED
                                                if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > 15)
                                                {
                                                                uprintf("Error - number of hops must be between 1 and 15\n");
                                                                return;
                                                }
#endif NOT_USED
                                                bootp.relay_agent.threshold_for_number_of_gateway_hops_field = sptr_cdb->integer1;
                                }
                }
}

void check_no_ip_metric(struct cdb* sptr_cdb)
{
                UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

                if (sptr_cdb->config_gen)
                                return;

                if (sptr_cdb->no)
                {
                                sptr_cdb->dont_go_next = 1;
                                ip_set_interface_metric(port_id, 0x01);
                }
}

void set_ip_metric(struct cdb* sptr_cdb)
{
                UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

                if (sptr_cdb->config_gen)
                {
                                if (IP_IP_PORT(port_id).config.metric != 0x01)
                                {
                                                ksprintf(cu_line_buf, " ip metric %d\n", IP_IP_PORT(port_id).config.metric);
                                                wr_config(sptr_cdb, cu_line_buf);
                                }
                }
                else
                {
                                if (!valid_integer1_value_range(sptr_cdb, 1, 16))
                                                return;
                                ip_set_interface_metric(port_id, (UINT8)sptr_cdb->integer1);
                }
}
#endif  /* SR_SWITCH_ROUTER */


/* cmd2.h */
/* exec cmds */

void clear_arp_one(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index = IPVRF_DEFAULT_VRF_IDX;

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        vrf_index = sptr_cdb->vrf_idx;

        free_ip_arp_entries_by_type(ARP_IP, sptr_cdb->ip1, 0xFFFFFFFF, vrf_index);
}

void clear_arp_ip_address_mask(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index = IPVRF_DEFAULT_VRF_IDX;

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        vrf_index = sptr_cdb->vrf_idx;
        free_ip_arp_entries_by_type(ARP_IP, sptr_cdb->ip1, sptr_cdb->ip2,vrf_index);    /* page mode print */
}

void clear_arp_enet_num(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index = IPVRF_DEFAULT_VRF_IDX;
        UINT32  port_number = sptr_cdb->if1-1;

        if (sptr_cdb->config_gen)
                return;

        if (!validate_interface_value(sptr_cdb, 1, ANY_INTERFACE))
                return;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        vrf_index = sptr_cdb->vrf_idx;

        free_ip_arp_entries_by_type(ARP_ENET, port_number, 0,vrf_index);
}

void clear_arp_mac_address_one(struct cdb* sptr_cdb)
{
        MAC_ADDRESS *p_mac;
        VRF_INDEX vrf_index = IPVRF_DEFAULT_VRF_IDX;
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        vrf_index = sptr_cdb->vrf_idx;
        p_mac = (MAC_ADDRESS *)sptr_cdb->mac2;

        p_mac->_ushort = 0xFFFF;
        p_mac->_ulong = 0xFFFFFFFF;
        free_ip_arp_entries_by_type(ARP_MAC, (UINT32)sptr_cdb->mac1, (UINT32)sptr_cdb->mac2,vrf_index); /* page mode print */
}

void clear_arp_mac_address_mask(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index = IPVRF_DEFAULT_VRF_IDX;
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        vrf_index = sptr_cdb->vrf_idx;
        free_ip_arp_entries_by_type(ARP_MAC, (UINT32)sptr_cdb->mac1, (UINT32)sptr_cdb->mac2, vrf_index);        /* page mode print */
}

void clear_arp(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index = IPVRF_DEFAULT_VRF_IDX;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        vrf_index = sptr_cdb->vrf_idx;

        free_ip_arp_entries_by_type(ARP_ALL, 0, 0,vrf_index);
}

void clear_counters(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        if (STACK_AM_I_SLAVE) {
           //CLI should be executed only from active
           return;
        }
        cu_clear_counters();

        stk_cmd_clear_bicast_cntrs();

}

void cli_clear_rate_counters(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                /* set flag to tell downstream function to clear rate counters
                 * for an interface
                 */
                sptr_cdb->flag1 = 1;
                return;
        }

        sptr_cdb->dont_go_next = 1;
        cu_clear_all_rate_counters();
}

// BUG 4060 fix: for the commands: "CLEAR STAT {ATM,POS,ETH} [port]", the command ignored the interface type,
// e.g. clear stat eth 3/1 would clear stats for port 3/1 even if it were an ATM or POS port.  The fix I used
// was to split the parsing path (see cmd2.h) and have 3 separate handlers (formerly there was only one, called
// cli_clear_interface_counters).  The 3 routines share a lot of common code, so they fan back into 1 handler,
// cli_clear_counters_common.   Goodsell 8/21/01

static void cli_clear_counters_common(struct cdb* sptr_cdb, int interface_type)
{
	PORT_ID port_index = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
    UINT16 trunk_group_id = INVALID_LOAD_SHARE_GROUP_ID;
	int i = 0;

        if (!validate_interface_value(sptr_cdb, 1, interface_type))
                return;

        if (sptr_cdb->flag1) // clear rate counters for this interface, include peak rate counters
                cu_clear_rate_counters(port_index, TRUE);

        else // clear all other counters for this interface
        {
                cu_clear_rate_absolute_counters(port_index);
                cu_clear_rate_counters(port_index, TRUE);

                if (!IS_PORT_DB_VALID(port_index)) return;

	 	if (IS_LAG_AP(port_index))
		{
			trunk_group_id = PORT_GROUP_ID(port_index);
			for(i=0; i<g_sw_load_group[trunk_group_id].config_ports ; i++)
			{
				cu_clear_ethernet_counters(g_sw_load_group[trunk_group_id].port_list[i]);
			}
		}
		else if ((interface_type==ENET_INTERFACE) && IS_PORT_ENET(port_index))
		{
#ifdef __PORT_EXTENSION__

	/* Send push to PE if we are a CB */
			if(g_portext_type == PORTEXT_TYPE_CB) {

            	pe_stat_push_send_clear_stat_port(port_index);
			}
#endif __PORT_EXTENSION__

                    cu_clear_ethernet_counters(port_index);
                    rmon_clearItfCounters(cu_PortId2IfIndex(port_index));

                }
        }
}

void cli_clear_eth_counters(struct cdb* sptr_cdb) { cli_clear_counters_common(sptr_cdb, ENET_INTERFACE); }

// end of bug 4060 fix

void clear_station(struct cdb* sptr_cdb)
{
#ifndef NO_MULTI_CONFIG_VLAN
        UINT16 vlan;
#endif NO_MULTI_CONFIG_VLAN

#ifdef SLAVE_SUPPORT
        extern void m5mp_msg_clear_all_mac_entries(void);
#endif SLAVE_SUPPORT

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

#ifdef SLAVE_SUPPORT
        m5mp_msg_clear_all_mac_entries ();
#endif SLAVE_SUPPORT
#ifndef NO_MULTI_CONFIG_VLAN
        if (sptr_cdb->mode == CONFIG_MVLAN || sptr_cdb->parent_mode == CONFIG_MVLAN)
        {
                for (vlan=MIN_VLAN_ID; vlan <= MAX_VLAN_ID; vlan++)
                {
                        if (is_vlan_id_mask_set(sptr_cdb, vlan))
                        {
                                sptr_cdb->integer1 = vlan;
                                clear_station_vlan(sptr_cdb);
                        }
                }
        }
        else
#endif NO_MULTI_CONFIG_VLAN
        mac_action_request(MA_ALL_SYSTEM, MAC_FLUSH);
        if (g_stacking_debug_flags == DEBUG_FDB_TABLE)
        {
                gi_new_addr_count = gi_new_addr_bad_count = 0;  // CHEETAH_STACKING
        }

}

extern MAC_NOTIFICATION_BUFFER mac_notification;
extern SNMP_CLASS snmp;
void clear_station_interface(struct cdb* sptr_cdb)
{
PORT_ID port;
int group_id = INVALID_LOAD_SHARE_GROUP_ID;
ENTRY_LOAD_SHARE_GROUP  *sptr_trunk;
int i;
MAC_ADDRESS mac_address = {0, 0} ;

    if (!validate_interface_value(sptr_cdb, 1, ANY_INTERFACE))
    {
        return;
    }

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                //Queue mac event REMOVE_ALL_MAC_ON_PORT as port is made down
                if(((SPTR_PORT_DB(port))->port_config.mac_notification_enabled )&& snmp.trap_mac_notification_enabled && (mac_notification.flush_type == MAC_EVENT_DEFAULT))
                {
                                mac_notification_validate_trunk_and_enqueue(&mac_address,0,port,MAC_EVENT_REMOVE_ALL_MAC_ON_PORT);
                                mac_notification.flush_type = MAC_EVENT_REMOVE_ALL_MAC_ON_PORT;
                }

        mac_action_request(MA_ALL_VLAN, MAC_FLUSH);
        group_id = trunk_group_id(port);
        if (group_id == INVALID_LOAD_SHARE_GROUP_ID)
        {
                MA_SET_PORT(port);
        }
        else
        {       /* trunk */
                sptr_trunk = &g_sw_sys.sw_load_group[group_id];
                for (i=0; i < HW_MAX_PORTS_PER_GROUP; i++)
                {
                        port = sptr_trunk->port_list[i];
                        if (IS_PORT_DB_VALID(port))
                        {
                                MA_SET_PORT(port);
                        }
                }
        }
}

void clear_station_vlan(struct cdb* sptr_cdb)
{
        VLAN_INDEX vlan_idx;
                VLAN_ENTRY *vlan_ptr;
                MAC_ADDRESS mac_address = {0, 0};
                PORT_MASK   port_mask[MAX_SLOT];

        mac_action_request(MA_ALL_PORT, MAC_FLUSH);
        vlan_idx = VLAN_IDX_FROM_VLAN_ID(sptr_cdb->integer1);
        if(vlan_idx != VLAN_INDEX_INVALID)
        {       
#ifdef PRIVATE_VLAN
                                if ( (hw_pvlan_support()== HW_PVLAN_SUPPORT_FCX) && (is_pvlan_enabled(sptr_cdb->integer1)))
                                {
                                                vlan_ptr = g_sptr_vlan_db+vlan_idx;
                                                vlan_ptr->pvlan_is_mac_flush_set = 1;
                                                MA_SET_VLAN_INDEX(VLAN_IDX_FROM_VLAN_ID(sptr_cdb->integer1));
                                                mac_force_action();
                                                vlan_ptr->pvlan_is_mac_flush_set = 0;
                                }
                                else
#endif /*PRIVATE_VLAN*/
                                vlan_ptr = g_sptr_vlan_db+vlan_idx;
                                if (vlan_ptr->vlan_inuse && snmp.trap_mac_notification_enabled)
                                {
                                                sw_hwmask_to_swmask(vlan_ptr->vlan_config.l2_portmask, port_mask);
                                                // Check if this vlan has any port with mac-notification enabled, if so enqueue event
                                                if(!is_exclusive(port_mask,mac_notification.mac_notification_port_mask))
                                                {
                                                                queue_mac_event(&mac_address,vlan_ptr->vlan_config.vlan_id,0,MAC_EVENT_REMOVE_ALL_MAC_ON_VLAN);
                                                }
                                                mac_notification.flush_type = MAC_EVENT_REMOVE_ALL_MAC_ON_VLAN;
                                }                                       
                                MA_SET_VLAN_INDEX(VLAN_IDX_FROM_VLAN_ID(sptr_cdb->integer1));
        }
}

void clear_station_module(struct cdb* sptr_cdb)
{
        int mod, i, total_ports, port_id;
                MAC_ADDRESS mac_address = {0, 0} ;

        mac_action_request(MA_ALL_VLAN, MAC_FLUSH);
        mod = sptr_cdb->integer1-1;
        total_ports = g_module[mod].number_of_ports;

        for (i=0; i < total_ports; i++)
        {
                port_id = MAKE_PORTID(mod, i);
                                if (!IS_PORT_DB_VALID(port_id))
                                        continue;
                                //Queue mac event REMOVE_ALL_MAC_ON_PORT as port is made down
                                if(((SPTR_PORT_DB(port_id))->port_config.mac_notification_enabled )&& snmp.trap_mac_notification_enabled && (mac_notification.flush_type == MAC_EVENT_DEFAULT))
                                {
                                                mac_notification_validate_trunk_and_enqueue(&mac_address,0,port_id,MAC_EVENT_REMOVE_ALL_MAC_ON_PORT);
                                                mac_notification.flush_type = MAC_EVENT_REMOVE_ALL_MAC_ON_PORT;
                                }
                MA_SET_PORT(port_id);
        }
}

void clear_station_address(struct cdb* sptr_cdb)
{
        extern MAC_STATION *mac_find_fast(MAC_ADDRESS *sptr_mac_addr, UINT16    vlan_id);
        int i;
        MAC_STATION * sptr_mac_entry;
        VLAN_ENTRY * vlan_entry;

        for (i = 0; i < g_sw_sys.max_vlans; i++) {
                vlan_entry = g_sptr_vlan_db+i;
                if (vlan_entry->vlan_inuse) {
                        sptr_mac_entry = mac_find_entry(0, (MAC_ADDRESS*)sptr_cdb->mac1,
                                vlan_entry->vlan_config.vlan_id);
                        if (sptr_mac_entry)
                        {
                                if (sptr_mac_entry->secure_bit || sptr_mac_entry->static_bit)
                                {
                                    uprintf("Error - Cannot clear %s Mac Address\n", (sptr_mac_entry->static_bit ? "Static" : "Secure"));
                                        continue;
                                }
                                mac_free_entry(sptr_mac_entry);
                        }
                }
        }
}

#ifdef SM_MASTER
void clear_arp_by_slot(struct cdb* sptr_cdb)
{
        int slot_index, slot_id;

        slot_id = sptr_cdb->integer1;
        if ((slot_index=sm_get_slave_index_by_slot_id(slot_id)) == 0)
        {
                uprintf("Error - invalid slot %d\n", slot_id);
                return;
        }

        if (g_sm_slave[slot_index].slave_ack)
        {
                fmp_set_command(slot_index, snRtClearArpCache, NULL, NULL, NULL);
        }
}

void clear_counters_by_slot(struct cdb* sptr_cdb)
{
        int slot_index, slot_id;

        slot_id = sptr_cdb->integer1;
        if ((slot_index=sm_get_slave_index_by_slot_id(slot_id)) == 0)
        {
                uprintf("Error - invalid slot %d\n", slot_id);
                return;
        }

        if (g_sm_slave[slot_index].slave_ack)
        {
                fmp_set_command(slot_index, snSwClearCounters, NULL, NULL, NULL);
        }
}

void clear_station_by_slot(struct cdb* sptr_cdb)
{
        int slot_index, slot_id;

        slot_id = sptr_cdb->integer1;
        if ((slot_index=sm_get_slave_index_by_slot_id(slot_id)) == 0)
        {
                uprintf("Error - invalid slot %d\n", slot_id);
                return;
        }

        if (g_sm_slave[slot_index].slave_ack)
        {
                fmp_set_command(slot_index, snFdbTableStationFlush, NULL, NULL, NULL);
        }
}

#endif SM_MASTER


void config_fromTerminal(struct cdb* sptr_cdb)
{
        if (sptr_cdb->mode == USER_EXEC)
        {
                uprintf("Error - privileged command.\n");
        }
        else
        {
#ifdef TANTO /* kkoch: remove after TANTO bringup */
                        if(!g_stacking_allow_all_slave_commands && is_pe_fully_controlled_by_cb())
                        {
                                        uprintf("\"configure term\" is not allowed because this PE is managed by the CB unit %u.\n",
                                                g_stacking.master);
                                        print_pe_unconfigure_instrunction();
                                        return;
                        }
                /* BUG: 21546 - Should warn about multiple users in config mode.*/
                if (config_term_user_count > 0)
                        uprintf("Warning: %d user(s) already in config mode.\n", config_term_user_count);
                /* delete this command line from command history */
                cancel_command_line(sptr_cdb->ui_port);
                sptr_cdb->check_sum1 = 0;
#if 0
		if(!STACK_AM_I_CB_ENABLE)
		{
			//Skipping check_sum1 generation when "spx cb-enable" is configured
                	if (generate_running_config_checksum(sptr_cdb)) return;
		}	
#endif
#endif
                set_cli_mode(sptr_cdb, CONFIG);
                sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
                config_term_user_count++;
                sptr_cdb->isInConfigMode = TRUE;


        }
}

extern enum BOOLEAN is_system_var_pre_parsed_in_startup_config();
void erase_startConfig(struct cdb* sptr_cdb)
{
        int stack_id, rm_status;
        UINT32 slave_ary[MAX_SYS_UNIT_NUM] = {0};

        if(!set_flash_use_in_progress())
        {
            return;
        }

        if (end_of_token(sptr_cdb->token) != '\0')
                {
            reset_flash_use_in_progress();
            return;
                }
        sptr_cdb->dont_go_next = 1;

        if(!STACK_AM_I_STANDALONE || STACK_AM_I_CB_AND_PE_NUM)  // CHEETAH_STACKING, BUG:89612, following is not required if it is STANDALONE unit
        {
                int ind = 0;
                        for (stack_id = 1; stack_id <= MAX_SYS_UNIT_NUM; stack_id++)
                        {
                                if(G_STACK_STATE(stack_id) == STACK_STATE_REMOTE)
                                        slave_ary[ind ++] = stack_id;
                        }
                        dnld_send_erase_startup_req(slave_ary, ind);
        }
        nt_delete_config_file();
#ifdef __DHCP_SERVER__
        if (dhcps_remove_lease_binding_database_from_flash() == PASS)
                {
                uprintf("dhcp server lease database is also removed\n");
                }
        else
                {
                uprintf("Error ?failed to remove dhcp server lease database\n");
                }
#endif /*__DHCP_SERVER__*/

#ifdef VERSION_08
        sys_flash_fremove (g_startup_config_old);
#endif
        sys_flash_fremove("startup-config.old");
		rm_status = remove_stacking_flash(0);
		rm_status |= remove_stacking_flash(1);
		if(rm_status)
        {
                uprintf("stacking/spx pe flash file is also removed\n");
        }
        reset_flash_use_in_progress();
}

void block_password(struct cdb* sptr_cdb, char *temp)
{
        char *p;
        char *q;
        int   n;
        char *password = NULL;
        char *pass = " ....";

        if (g_show_password && sptr_cdb->current_login_password_level == CU_SECURITY_LEVEL0)
                return;

        /* srepalle: bug 000360628, fix, don't show ospfv3 ipsec key in FIPS mode of operation */
#ifdef FIPS_PASSWD_MASK
        if((TRUE == cu_fips_get_status()) && ((cu_fips_get_enable_password_display()== FALSE)))
#else
        if(TRUE == cu_fips_get_status())        /* 364642, not to show password in fips mode */
#endif
        {
                /*if((password = strstr(temp, "esp sha1 encryptb64")) != NULL)
                        {
                          password += strlen("esp sha1 encryptb64");
                           *password = '\0';
                                }*/
                if((password = strstr(temp, "esp sha1 no-encrypt")) != NULL)
                {
                        password += strlen("esp sha1 no-encrypt");
                        *password = '\0';
                }
                /*else if((password = strstr(temp, "esp sha1")) != NULL) // fix: 364103, for esp sha1, when user issues, encryptb64, in command
                                 {
                                  password += strlen("esp sha1");
                          *password = '\0';
                                }*/
                else if((password = strstr(temp, "key 0")) != NULL)
                {
                    password += strlen("key 0");
                    *password = '\0';
                }
                 /* Skip this in case of NTP key as it will be integer associated with authentication command */
                else if(((password = strstr(temp, "key 1")) != NULL) && (!strncmp(temp," server",7)== 0))
                                {
                    password += strlen("key 1");
                    strncpy(password, pass, strlen(pass));
                    password += strlen(pass);
                   *password = '\0';
                }
                 /* Skip this in case of NTP key as it will be integer associated with authentication command */
                else if(((password = strstr(temp, "key 2")) != NULL) && (!strncmp(temp," server",7)== 0))
                                {
                    password += strlen("key 2");
                    strncpy(password, pass, strlen(pass));
                    password += strlen(pass);
                   *password = '\0';
                }

                else if((password = strstr(temp, "password 0")) != NULL)
                {
                    password += strlen("password 0");
                    *password = '\0';
                }
        }


        /* block username password, syntax is
         * username <string> [privilege <priv_val>] nopassword | password <encrypt_code> <string>
         * username <string> history <password1> <password2> <password3>
         */
        if (strncmp(temp, "username", 8) == 0)
        {
                q = temp;               /* q == "username" */
                next_token(&q); /* q == <string> */
                next_token(&q); /* q == "privilege" | "nopassword" | "password" */
                if (tolower(*q)=='p' && tolower(*(q+1))=='a')
                {
                        next_token(&q); /* q == <encrypt_code> */
                        for (n=0; n < 5; n++)
                                *q++ = '.';
                        *q = '\0';
                }
                else
                if (tolower(*q)=='p' && tolower(*(q+1))=='r')
                {
                        next_token(&q); /* q == <priv_val> */
                        next_token(&q); /* q == "nopassword" | "password" */
                        if (tolower(*q)=='p' && tolower(*(q+1))=='a')
                        {
                                next_token(&q); /* q == <encrypt_code> */
                                for (n=0; n < 5; n++)
                                        *q++ = '.';
                                *q = '\0';
                        }
                }
                else if (tolower(*q)=='h' && tolower(*(q+1))=='i')
                {
                        next_token(&q); /* q == <password1> */
                        for (n=0; n < 5; n++)
                                *q++ = '.';
                        *q = '\0';
                }

        }

        /* block telnet password */
        n=strlen(e_telnet_passwd);
        if (strncmp(temp, e_telnet_passwd, n) == 0)
        {
                q = &temp[n];
                for (n=0; n < 5; n++)
                        *q++ = '.';
                *q = '\0';
        }

        /* block super-user-password */
        n=strlen(e_superuser_passwd);
        if (strncmp(temp, e_superuser_passwd, n) == 0)
        {
                q = &temp[n];
                for (n=0; n < 5; n++)
                        *q++ = '.';
                *q = '\0';
        }

        /* block port-config-password */
        n=strlen(e_portconfig_passwd);
        if (strncmp(temp, e_portconfig_passwd, n) == 0)
        {
                q = &temp[n];
                for (n=0; n < 5; n++)
                        *q++ = '.';
                *q = '\0';
        }

        /* block read-only-password */
        n=strlen(e_readonly_passwd);
        if (strncmp(temp, e_readonly_passwd, n) == 0)
        {
                q = &temp[n];
                for (n=0; n < 5; n++)
                        *q++ = '.';
                *q = '\0';
        }

        /* block snmp read-only and read-write community strings */
        n=strlen(e_community);
        if (strncmp(temp, e_community, n) == 0)
        {
                int is_ro;

                p = &temp[n];
                q = temp;               /* q == "snmp-server" */
                next_token(&q); /* q == "community" */
                next_token(&q); /* q == string value || encryption code */
                next_token(&q); /* q == "ro" or "rw" || string value */
                if (!(tolower(*q) == 'r' && (tolower(*(q+1)) == 'o' || tolower(*(q+1)) == 'w')
                          && (*(q+2) == ' ' || *(q+2) == '\0')))
                        next_token(&q); /* q == "ro" or "rw" */
                /* mark down "ro" or "rw" before we modify */
                is_ro = (*(q+1) == 'o');

                sptr_cdb->string1[0] = 0;
                next_token(&q); /* q == acl_id || acl_name */
                if (*q != '\0')
                        strcpy(sptr_cdb->string1, q);

                for (n=0; n < 5; n++)
                        *p++ = '.';
                *p++ = ' ';
                *p++ = 'r';
                *p++ = (is_ro) ? 'o' : 'w';

                if (sptr_cdb->string1[0] != 0)
                {
                        *p++ = ' ';
                        n = strlen(sptr_cdb->string1);
                        strncpy(p, sptr_cdb->string1, n);
                        p += n;
                }

                *p = '\0';
        }

        /* block snmp trap community strings */
        n=strlen(e_trap);
        if (strncmp(temp, e_trap, n) == 0)
        {
                q = temp;               /* q == "snmp-server" */
                next_token(&q); /* q == "host" */
                next_token(&q); /* q == IP address */
                if (!strncmp("ipv6", q, 4)) /* if v6 address */
                        next_token(&q); /* q == "v6 address" */
                next_token(&q); /* q == "version" */
                next_token(&q); /* q == "v1", "v2c", "v3" */
                if (!strncmp(q, "v1", 2) || !strncmp(q, "v2c", 3) || strncmp(q, "v3", 2))
                {
                        next_token(&q); /* q == string value || null */
                        sptr_cdb->string1[0] = 0;
                        p = q;
                        if (*p == 0)
                                *p++ = ' ';
                        else
                        {
                                next_token(&q); /* q == encryption code */
                                next_token(&q); /* q == encrypted password */
                                if (((tolower(*q))=='p') && (tolower(*(q+1)) == 'o')) /* w == "port" */
                                        strcpy(sptr_cdb->string1, q); /* token */
                        }
                        for (n=0; n < 5; n++)
                                *p++ = '.';
                        if (sptr_cdb->string1[0])
                        {
                                *p++ = ' ';
                                n = strlen(sptr_cdb->string1);
                                strncpy(p, sptr_cdb->string1, n);
                                p += n;
                        }
                        q = p;
                        *q = '\0';
                }
        }
}

unsigned char *show_config_line(struct cdb* sptr_cdb, unsigned char* cp)
{
        int i;

        if (cp == NULL)
                return cp;
		memset(cu_line_buf, 0x00, sizeof(cu_line_buf));

        for (i=0; i < (CMD_LINE_SIZE-1); ++i)
        {
                if (i >= PRINT_LINE_SIZE-1)
                {
                        cu_line_buf[i] = 0;

                        /* block the password for now */
                        /* XXX encription to ASCII characters would be a better solution */
                        block_password(sptr_cdb, cu_line_buf);
                        uprintf("%s", cu_line_buf);
                        i = 0;
                }
                if (*cp == '\0')
                {
                        cp = NULL;
                        break;
                }
                else if (*cp == '\n')
                {
                        cp++;
                        break;
                }
                cu_line_buf[i] = *cp;
                cp++;
        }
        cu_line_buf[i] = 0;

        /* block the password for now */
        /* XXX encription to ASCII characters would be a better solution */
        block_password(sptr_cdb, cu_line_buf);
        /* An extra space was printing at the end of configuration since the last line is empty
         * with new optimized show run solution, this new line was adding more space, and it is not required 
         * at the end of each module.*/
        if(cu_line_buf[0])
            uprintf("%s\n", cu_line_buf);
        return cp;

}

void show_config_callback(
        UINT32 rcode,
        struct cdb* sptr_cdb,
        unsigned char* cp)
{
        int last_ch, line_cnt;
		int ui_port = sptr_cdb->ui_port;

        /* If user wants to abort, then call release_page_mode(). */
        if (rcode == 0)
        {
            if(show_tech_in_progress)
                show_tech_time_stamp_header(GT_FALSE, "show running-config", NULL, GT_ERROR); 
			    if(module_dat[sptr_cdb->ui_port].sh_run_in_progress)
                        cu_reset_show_run(sptr_cdb->ui_port);
                release_page_mode();
                free_config_buffer(sptr_cdb->buffer_base);
                // NOTE: The following memory freeing must be required, since the sptr_cdb is an
                // allocated memory in the design of the use of this callback path. If in case
                // it is not true for certain path, then that path must be fixed by allocating
                // memory (just like other paths), copying the parser's sptr_cdb into it, and
                // using the newly allocated memory for callback sptr_cdb reference.
                dy_free(sptr_cdb);
                return;
        }

        line_cnt = 0;

        /* Use page mode to display configuration buffer. */
        last_ch = 0;

        /* Only print LINES_PER_PAGE lines at a time. */
        while (last_ch == 0)
        {
                cp = show_config_line(sptr_cdb, cp);
                if (cp == NULL)
                        last_ch = 1;
                if (++line_cnt >= LINES_PER_PAGE)
                {
                        set_page_mode(show_config_callback, (UINT32)sptr_cdb, (UINT32)cp);
                        return;
                }
        }

        if(show_tech_in_progress)
           show_tech_time_stamp_header(GT_FALSE, "show running-config", NULL, GT_ERROR);

        /* Nothing else to print, call release_page_mode(). */
        release_page_mode();

        free_config_buffer(sptr_cdb->buffer_base);
        // NOTE: The following memory freeing must be required, since the sptr_cdb is an
        // allocated memory in the design of the use of this callback path. If in case
        // it is not true for certain path, then that path must be fixed by allocating
        // memory (just like other paths), copying the parser's sptr_cdb into it, and
        // using the newly allocated memory for callback sptr_cdb reference.
        dy_free(sptr_cdb);
		
        cu_show_run(ui_port);
}

void show_config_to_terminal(struct cdb* sptr_cdb, char *title)
{
        unsigned char* cp;
        int last_ch, line_cnt;
		int ui_port = sptr_cdb->ui_port;

        line_cnt = 0;

        if (title)
        {
                uprintf("%s", title);
                /* Include the 2 lines in header message. */
                line_cnt = 2;
        }

        cp = sptr_cdb->buffer_base;

        /* Use page mode to display configuration buffer. */
        last_ch = 0;

        /* Only print LINES_PER_PAGE lines at a time. */
        while (last_ch == 0)
        {
                cp = show_config_line(sptr_cdb, cp);
                if (cp == NULL)
                        last_ch = 1;

                 if (++line_cnt >= LINES_PER_PAGE)
                 {
                        set_page_mode(show_config_callback, (UINT32)sptr_cdb, (UINT32)cp);
                        return;
                 }
        }

        free_config_buffer(sptr_cdb->buffer_base);
        dy_free(sptr_cdb);

        cu_show_run(ui_port);
}

void sw_get_running_config(UINT8 **running_config_buffer, int* buf_len)
{
        struct cdb *my_cdb;
        UINT8 *buf;

        if ((my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb))) == NULL)
                return;
        if ((buf = get_config_buffer(0)) == NULL)
        {
                dy_free(my_cdb);
                return;
        }
        *buf = 0;
        my_cdb->buffer = buf;
        my_cdb->gen_to = GEN_TO_TERMINAL;
        my_cdb->write_mem_flag = 0;

        //if (retrieve_running_config(my_cdb) < 0)
        if (retrieve_all_module_config_new(my_cdb) < 0)
        {
                uprintf("please trim your configuration\n");
                free_config_buffer(buf);
                dy_free(my_cdb);
                return;
        }
        if(!my_cdb->config_buf_overflow)
        {
                *running_config_buffer = buf;
                *buf_len = (max_config_buffer_size - my_cdb->buffer_space_left);
                dy_free(my_cdb);                                
        }
        else
        {
                uprintf("sw_get_running_config: buffer overflow\n");
                free_config_buffer(buf);
                dy_free(my_cdb);
                *running_config_buffer = NULL;
                *buf_len = 0;
        }
        return;
}

// If fail, *buf_len = 0;
// The user must dy_free *running_config_buffer when done
void sw_get_running_config_for_stk_sync(UINT8 **running_config_buffer, int* buf_len)
{
        struct cdb *my_cdb;
        UINT8 *buf;

        *buf_len = 0;
        if ((my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb))) == NULL)
                return;
        if ((buf = dy_malloc(max_config_buffer_size)) == NULL)
        {
                uprintf("ERROR: Cannot allocate memory for stby sync\n");
                dy_free(my_cdb);
                return;
        }
        *buf = 0;
        my_cdb->buffer = buf;
        my_cdb->gen_to = GEN_TO_TERMINAL;
        my_cdb->write_mem_flag = 0;
        my_cdb->flexauth_user_filter = TRUE;

        //if (retrieve_running_config(my_cdb) < 0)
        if (retrieve_all_module_config_new(my_cdb) < 0)
        {
                uprintf("ERROR: Config too big for stby sync\n");
                dy_free(buf);
                dy_free(my_cdb);
                return;
        }
        if(!my_cdb->config_buf_overflow)
        {
                *running_config_buffer = buf;
                *buf_len = (max_config_buffer_size - my_cdb->buffer_space_left);
                dy_free(my_cdb);
        }
        else
        {
                uprintf("ERROR: stby sync config buffer overflow\n");
                dy_free(buf);
                dy_free(my_cdb);
                *running_config_buffer = NULL;
                *buf_len = 0;
        }
        return;
}

enum BOOLEAN sxr_is_running_config_too_large()
{
        UINT8 *pBuf;
        int msgLen = 0,bufLen=0,retVal=0,msgs=0;
        struct cdb *my_cdb;
        UINT8 *buf;

        if ((my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb))) == NULL)
                return TRUE;
        if ((buf = get_config_buffer(0)) == NULL)
        {
                dy_free(my_cdb);
                return TRUE;
        }

        *buf = 0;
        my_cdb->buffer = buf;
        my_cdb->gen_to = GEN_TO_TERMINAL;
        my_cdb->write_mem_flag = 0;

        //if (retrieve_running_config(my_cdb) < 0)
        if (retrieve_all_module_config_new(my_cdb) < 0)
        {
                free_config_buffer(buf);
                dy_free(my_cdb);
                return TRUE;
        }
        if(my_cdb->config_buf_overflow)
        {
                free_config_buffer(buf);
                dy_free(my_cdb);
                return TRUE;
        }

        free_config_buffer(buf);
        dy_free(my_cdb);
        return FALSE;
}

void do_write_running_config_to_terminal_with_param(
        struct cdb *sptr_cdb,
        int (*retrieve_running_config_func)(struct cdb*, void *),
        char *title,
        void *param)
{
        struct cdb *my_cdb;
        UINT8 *buf;

        if ((my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb))) == NULL)
                return;
        if ((buf = get_config_buffer(sptr_cdb->ui_port)) == NULL)
        {
                dy_free(my_cdb);
                return;
        }
        *buf = 0;
        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;
        sptr_cdb->sptr_cdb_saved = my_cdb;
        sptr_cdb->gen_to = GEN_TO_TERMINAL;

        sptr_cdb->write_mem_flag = 0;
        *my_cdb = *sptr_cdb;
        if ((*retrieve_running_config_func)(my_cdb, param) < 0)
        {
                uprintf("please trim your configuration\n");
                free_config_buffer(buf);
                if (sptr_cdb->sptr_cdb_saved)
                        dy_free(my_cdb);
                sptr_cdb->sptr_cdb_saved=0;
                return;
        }

        if(!my_cdb->config_buf_overflow)
        {
                show_config_to_terminal(my_cdb, title);
        }
        else
        {
                free_config_buffer(buf);
                if (sptr_cdb->sptr_cdb_saved)
                        dy_free(my_cdb);
                sptr_cdb->sptr_cdb_saved=0;
        }
}

void do_write_running_config_to_terminal(
        struct cdb *sptr_cdb,
        int (*retrieve_running_config_func)(struct cdb*),
        char *title)
{
        struct cdb *my_cdb;
        UINT8 *buf;

        if ((my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb))) == NULL)
                return;
        if ((buf = get_config_buffer(sptr_cdb->ui_port)) == NULL)
        {
                dy_free(my_cdb);
                return;
        }
        *buf = 0;
        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;
        sptr_cdb->gen_to = GEN_TO_TERMINAL;

        sptr_cdb->write_mem_flag = 0;
        *my_cdb = *sptr_cdb;
        if ((*retrieve_running_config_func)(my_cdb) < 0)
        {
                uprintf("please trim your configuration\n");
                free_config_buffer(buf);
                dy_free(my_cdb);
                return;
        }
        if(!my_cdb->config_buf_overflow)
        {
                show_config_to_terminal(my_cdb, title);
        }
        else
        {
                free_config_buffer(buf);
                dy_free(my_cdb);
        }
}

void write_runConfig_to_terminal(struct cdb* sptr_cdb)
{
        if (sptr_cdb->no)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        g_vlan_group_cmd = 0;

        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config,
                "Current configuration:\n!\n");
}

void show_running_config_physical_interface_callback(struct cdb* sptr_cdb)
{
        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config_physical_interface,
                NULL);
}

#ifdef SR_SWITCH_ROUTER
void show_running_config_router_interface_callback(struct cdb* sptr_cdb)
{

        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config_router_interface,
                NULL);
}
#endif SR_SWITCH_ROUTER

void show_running_config_interface(struct cdb* sptr_cdb)
{

        if (end_of_token(sptr_cdb->token) != '\0')
        {
                sptr_cdb->port_mask_callback = show_running_config_physical_interface_callback;
#ifdef SR_SWITCH_ROUTER
                sptr_cdb->router_port_callback = show_running_config_router_interface_callback;
#endif SR_SWITCH_ROUTER
                return;
        }
        sptr_cdb->dont_go_next = 1;
        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config_interface,
                NULL);
}

void show_running_config_vlan(struct cdb* sptr_cdb)
{

if (end_of_token(sptr_cdb->token) != '\0')
                 return;
          sptr_cdb->dont_go_next = 1;

#ifndef NO_MULTI_CONFIG_VLAN
        sptr_cdb->flag1 = 1; /* BUG: 72879 */
#endif NO_MULTI_CONFIG_VLAN

        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config_vlan,
                NULL);
}

void show_running_config_vrf(struct cdb* sptr_cdb)
{
#ifndef NO_MULTI_CONFIG_VLAN
        sptr_cdb->flag1 = 1; /* BUG: 72879 */
#endif NO_MULTI_CONFIG_VLAN

        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config_vrf,
                NULL);
}

void ping_callback(UINT32 reply_count, UINT32 param)
{
    ICMP_ECHO_INFO *echo_info = ip.icmp.echo_info[param];
        int old_ui_port;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = param;

        if (reply_count == 0)
        {
                if (echo_info->brief_mode)
                        uprintf("U\n");
                else
                        uprintf("No reply from remote host.\n");
        }
        else if (reply_count == 0xFFFFFFFF)
                uprintf("Ping in Progress.\n");
        else if (reply_count == 0xFFFFFFFE)
                uprintf("Ping self done.\n");
        else if (reply_count == 0xBBBBBBBB)
        {
                if (echo_info->brief_mode)
                        uprintf("I\n");
                else
                        uprintf("Ping aborted!\n");
        }
        else
        {
                if (echo_info->echo_reply_count > echo_info->echo_req_sent)
                {
                        /* more reply then sent, most be broadcase ping */
                        uprintf("A total of %d ping replies received.\n",echo_info->echo_reply_count);
                } else
                {
                   if (!echo_info->brief_mode)
                   {
                        if ((!echo_info->echo_mute) && (echo_info->echo_reply_count > 16) &&
                        (!echo_info->echo_bcast))
                                uprintf("Only the last 16 ping replies were printed.\n");
                   }
                   else
                           uprintf("\n");

                uprintf("Success rate is %d percent (%d/%d), round-trip min/avg/max=%d/%d/%d ms.\n",
                                ((((echo_info->echo_req_sent-echo_info->echo_reply_count)*100)%echo_info->echo_req_sent) == 0) ?
                                100 - (((echo_info->echo_req_sent-echo_info->echo_reply_count)*100)/echo_info->echo_req_sent) :
                                99 - (((echo_info->echo_req_sent-echo_info->echo_reply_count)*100)/echo_info->echo_req_sent),
                                echo_info->echo_reply_count, echo_info->echo_req_sent,
                                echo_info->echo_min_time, echo_info->echo_total_time/echo_info->echo_reply_count,
                                echo_info->echo_max_time
                                );
                }
                if ((echo_info->echo_verify) && echo_info->echo_reply_count)
                {
                        uprintf("Verified good pkt rate is %d percent (%d/%d).\n",
                                ((((echo_info->echo_reply_count-echo_info->echo_good_reply_count)*100)%echo_info->echo_reply_count) == 0) ?
                                100 - (((echo_info->echo_reply_count-echo_info->echo_good_reply_count)*100)/echo_info->echo_reply_count) :
                                99 - (((echo_info->echo_reply_count-echo_info->echo_good_reply_count)*100)/echo_info->echo_reply_count),
                                echo_info->echo_good_reply_count, echo_info->echo_reply_count);
                }
        }
        release_page_mode();
        g_uprintf_dest = old_ui_port;
}

#if 0
void dns_ping_callback(
        DNS_SESSION_CLASS *dns_ptr,
        UINT8 *sptr_answer,
        UINT8 answer_type,
        UINT8 status,
        UINT32 param)
{
        int old_ui_port;
        UINT32 resolved_address;
        int old_no_prompt_mode;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = g_ping_ui_port;

        switch (status)
        {
        case DNS_CALLBACK_NOERROR:
                /* DNS operation succeed
                 * release page mode initiated by DNS,
                 * but don't print the prompt
                 */
                old_no_prompt_mode = io_cb[g_ping_ui_port].no_prompt_mode;
                io_cb[g_ping_ui_port].no_prompt_mode = 1;
                release_page_mode();
                io_cb[g_ping_ui_port].no_prompt_mode = old_no_prompt_mode;
                resolved_address = *((UINT32 *)sptr_answer);
                if (ip.icmp.echo_info.wait_for_echo_reply == FALSE)
                        icmp_perform_ping(
                                ping_callback,
                                g_ping_ui_port,
                                resolved_address,               /* dest ip addr */
                                g_ping_source_ip,               /* source ip addr */
                                g_ping_count,                   /* count */
                                g_ping_timeout,                 /* timeout */
                                g_ping_data,                    /* data */
                                g_ping_extra,                   /* echo */
                                dns_ptr->sptr_cdb->vrf_idx      /* vrf index */
                                );
                break;
        case DNS_CALLBACK_TIMEOUT:
                /* DNS operation failed */
                uprintf("Ping timeout due to DNS query failure\n");
                break;
        case DNS_CALLBACK_ABORT:
                /* DNS operation aborted */
                uprintf("Ping aborted!\n");
                break;
        default:
                break;
        }

        g_uprintf_dest = old_ui_port;
}

void set_ping_tr_vrf(struct cdb *sptr_cdb)
{
        if (!cli_set_vrf(sptr_cdb->string1, sptr_cdb, TRUE))
                sptr_cdb->dont_go_next = 1;
}

void set_ping_ipv6_tr_vrf(struct cdb *sptr_cdb)
{
        sptr_cdb->afi = IP_IPV6_AFI;
        if (!cli_set_vrf(sptr_cdb->string1, sptr_cdb, TRUE))
                sptr_cdb->dont_go_next = 1;
}

void ping_Ip(struct cdb* sptr_cdb)
{
#ifdef LATER
        char c;
#endif
        char *cp;
        UINT32 ui;
        union icmp_echo_info_union extra;
        int i=0, k, bytes;
        UINT32 resolved_address;
        UINT32  brief_mode;
        UINT32  brief_mode_limit;

        if (sptr_cdb->help) /*59111*/
        {
                print_ping_options(sptr_cdb->ui_port);
                return;
        }

        if (!sptr_cdb->execute)
                return;

        if(sptr_cdb->ui_port >= MAX_IO_CB)
                return;

        /* set default value */
        // NIL3  IPVRF_DEFAULT_VRF_IDX is added as 1st arg
        if (sptr_cdb->ip1 && is_broadcast_address(sptr_cdb->vrf_idx,sptr_cdb->ip1))
                sptr_cdb->integer1 = 4;                 /* default count */
        else
                sptr_cdb->integer1 = 1;                 /* default count */
        sptr_cdb->integer2 = 5*SECOND;          /* default timeout */
        sptr_cdb->integer3 = 0x61626364;    /* default data "abcd" */
        extra.echo_extra_32 = 0;
        extra.breakdown.num_of_bytes = 16;                      /* default size */
        extra.breakdown.bytes_per_pattern = 4;          /* default pattern size */
        extra.breakdown.time_to_live = DEFAULT_TTL;      /* default time_to_live */
        extra.breakdown.no_frag = 0;                    /* default no fragment */
        extra.breakdown.verify = 0;                             /* default no verify */
        brief_mode = 0;
        brief_mode_limit = CMD_LINE_SIZE - 1;

#ifdef LATER
        c = end_of_token(sptr_cdb->token);
        if (c == '\0')
        {
        icmp_perform_ping(ping_callback,
                       sptr_cdb->ui_port,
                       sptr_cdb->ip1,
                       1);

#ifdef DEBUG
                uprintf("ping ip one time.\n");
                uprintf("ip = %x\n", sptr_cdb->ip1);
#endif
        } else if (c == '?')
        {
                uprintf("ping <ip addr> [count <num>] [timeout <msec>] [ttl <1-255>] [size <byte>]\n");
                uprintf("     [quiet] [verify] [data <1-to-4 byte hex#, e.g. abcdef00>] [brief]\n");
                options_printed[sptr_cdb->ui_port] = 1;

        } else
#endif
        {
                /* parse the ping command line */
                cp = sptr_cdb->token;
                /* skip ip address */
                NEXT_TOKEN(cp);
                while (*cp != '\0')
                {
                        /* convert the 1st two characters to lower case */
                        if (isupper(*cp))
                                *cp = tolower(*cp);
                        if (isupper(*(cp+1)))
                                *(cp+1) = tolower(*(cp+1));

                        i = 0;
                        if (*cp == 'c')
                        {
                                NEXT_TOKEN(cp);
                                i = cli_get_int(cp,1,&k);
                                if (i == -1)
                                        break;
                                /* save the value */
                                sptr_cdb->integer1 = i;
                                NEXT_TOKEN(cp);
                        } else if ((*cp == 't') && (*(cp+1) == 'i')) /* timeout */
                        {
                                NEXT_TOKEN(cp);
                                i = cli_get_int(cp,1,&k);
                                if (i == -1)
                                        break;
                                i = i/(1000/SECOND);    /* convert msec to time unit */
                                if (i == 0)
                                        i = 1;                          /* e.g. 5msec round up to 100 msec */
                                /* save the value */
                                sptr_cdb->integer2 = i;
                                NEXT_TOKEN(cp);
                        } else if ((*cp == 't') && (*(cp+1) == 't')) /* ttl */
                        {
                                NEXT_TOKEN(cp);
                                i = cli_get_int(cp,1,&k);
                                if ((i < 1) || (i > 255)) {
                                        break;
                                }
                                /* save the value */
                                extra.breakdown.time_to_live = i;
                                NEXT_TOKEN(cp);
                        } else if ((*cp == 's') && (*(cp+1) == 'i')) /* size */
                        {
                                NEXT_TOKEN(cp);
                                i = cli_get_int(cp,1,&k);
                                if (i == -1)
                                        break;
                                /* save the value */
                                extra.breakdown.num_of_bytes = i;
                                NEXT_TOKEN(cp);
#ifdef SR_SWITCH_ROUTER
                        } else if ((*cp == 's') && (*(cp+1) == 'o')) /* source */
                        {
                                NEXT_TOKEN(cp);
                                i = get_ip(cp,(UINT32 *)&sptr_cdb->ip2);
                                if (i == -1)
                                        break;
                                NEXT_TOKEN(cp);
#endif  /* SR_SWITCH_ROUTER */
                        } else if (*cp == 'd')
                        {
                                NEXT_TOKEN(cp);
                                ui = cli_get_hex(cp, &bytes);
                                if (bytes == 0)
                                {
                                        i = -1;
                                        break;
                                }
                                /* save the value */
                                sptr_cdb->integer3 = ui;
                                extra.breakdown.bytes_per_pattern = bytes;
                                NEXT_TOKEN(cp);
                        } else if ((*cp == 'n') && (*(cp+1) == 'o')) /* no-fragment */
                        {
                                /* save the value */
                                extra.breakdown.no_frag = 1;                    /* default was no fragment */
                                NEXT_TOKEN(cp);
                        } else if ((*cp == 'n') && (*(cp+1) == 'u')) /* numeric */
                        {
                                /* save the value */
                                extra.breakdown.numeric = 1;                    /* default was not numeric display */
                                NEXT_TOKEN(cp);
                        } else if (*cp == 'v')
                        {
                                /* save the value */
                                extra.breakdown.verify = 1;                             /* default was no verify */
                                NEXT_TOKEN(cp);
                        } else if (*cp == 'q')
                        {
                                /* save the value */
                                extra.breakdown.mute = 1;                               /* default was not mute */
                                NEXT_TOKEN(cp);
                        } else if (*cp == 'b')  /* brief mode */
                        {
                                brief_mode = 1;
                                NEXT_TOKEN(cp);
                                if (*cp == 'm')
                                {
                                        NEXT_TOKEN(cp);
                                        i = cli_get_int(cp,1,&k);
                                        if (i >= CMD_LINE_SIZE)
                                                i = -1;
                                        if (i == -1)
                                                break;
                                        brief_mode_limit = i;
                                        NEXT_TOKEN(cp);
                                }
                                else if (*cp == '?')
                                {
                                        i = -1;
                                        break;
                                }
                        } else
                        {
                                i = -1;
                                break;
                        }
                }

                if (i == -1)
                {
#ifdef NOT_USED
                        uprintf("ping <ip addr> [count <num>] [timeout <msec>] [ttl <1-255>] [size <byte>]\n");
                        uprintf("     [no-fragment] [quiet] [verify] [data <1-to-4 byte hex#, e.g. abcdef00>]\n");
#endif NOT_USED
#ifdef SR_SWITCH_ROUTER
                        uprintf("ping <ip addr> [source <ip addr>] [count <num>] [timeout <num 1-4294967294><msec>] [ttl <1-255>]\n"
                                        "     [verify] [quiet] [data <1-to-4 byte hex#, e.g. abcdef00>]\n"
                                        "     [numeric] [size <byte>] [brief [max-print-per-sec <num 0-2047>]]\n");
#else
                        uprintf("ping <ip addr> [count <num>] [timeout <num 1-4294967294><msec>] [ttl <1-255>] [verify]\n"
                                        "     [no-fragment] [quiet] [data <1-to-4 byte hex#, e.g. abcdef00>]\n"
                                        "     [numeric] [size <byte>] [brief [max-print-per-sec <num 0-2047>]]\n");
#endif  /* SR_SWITCH_ROUTER */
                        options_printed[sptr_cdb->ui_port] = 1;
                        return;
                }

#ifdef NOT_USED
                uprintf("ping %x count %d timeout %d TTL %d no-fragment %d\n",
                                        sptr_cdb->ip1,
                                        sptr_cdb->integer1,
                                        sptr_cdb->integer2,
                                        sptr_cdb->integer3);
                uprintf("no-frag %d verify %d data %x bytes %d\n",
                                        sptr_cdb->integer4,
                                        sptr_cdb->integer5,
                                        sptr_cdb->integer6,
                                        sptr_cdb->ip4);
#endif NOT_USED

                if (sptr_cdb->ip1)
                        icmp_perform_ping(
                                sptr_cdb->ui_port,
                                sptr_cdb->ip1,          /* dest ip addr */
                                sptr_cdb->ip2,          /* source ip addr */
                                sptr_cdb->integer1,     /* count */
                                sptr_cdb->integer2,     /* timeout */
                                sptr_cdb->integer3,     /* data */
                                extra.echo_extra_32,/* echo */
                                brief_mode,
                                brief_mode_limit,
                                sptr_cdb->vrf_idx       /* vrf index */
                                );
                else
                if (dns_resolve_name_to_ip(
                        sptr_cdb->string1,
                        &resolved_address,
                        sptr_cdb->ui_port) != DNS_OK)
                {
                        uprintf("Failed to initialize DNS request\n");
                }
                else
                {
                /* if an ssh session, response is handled in callback handler, as it's non-blocking */
                if (IS_SSH_CDBS_INDEX(g_cu_session))
                {
                        ssh.client[CDBS_TO_SSH_INDEX(g_cu_session)].scp_tftp_command = SSH_CU_PING_DNS_NAME_RESOLVED;
                        ssh.client[CDBS_TO_SSH_INDEX(g_cu_session)].icmp_info = extra;
                        ssh.client[CDBS_TO_SSH_INDEX(g_cu_session)].brief_mode = brief_mode;
                        ssh.client[CDBS_TO_SSH_INDEX(g_cu_session)].brief_mode_limit = brief_mode_limit;
                        return;
                }

                if (ip.icmp.echo_info[sptr_cdb->ui_port]->wait_for_echo_reply == FALSE)
                        icmp_perform_ping(
                                sptr_cdb->ui_port,
                                resolved_address,       /* dest ip addr */
                                sptr_cdb->ip2,          /* source ip addr */
                                sptr_cdb->integer1,     /* count */
                                sptr_cdb->integer1,     /* timeout */
                                sptr_cdb->integer1,     /* data */
                                extra.echo_extra_32,/* echo */
                                brief_mode,
                                brief_mode_limit,
                                sptr_cdb->vrf_idx       /* vrf index */
                                );
                }
        }

        /* This is the end of parsing */
        sptr_cdb->dont_go_next = 1;
}
#endif

void telnet_remote_callback(
        UINT32 rcode,
        UINT32 ui_port,
        UINT32 no_use2)
{

}

#if 0
void dns_telnet_callback(
        DNS_SESSION_CLASS *dns_ptr,
        UINT8 *sptr_answer,
        UINT8 answer_type,
        UINT8 status,
        UINT32 param)
{
        int old_ui_port;
        UINT32 resolved_address;
        int old_no_prompt_mode;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = g_telnet_caller_parameter;

        switch (status)
        {
        case DNS_CALLBACK_NOERROR:
                /* DNS operation succeed
                 * release page mode initiated by DNS,
                 * but don't print the prompt
                 */
                old_no_prompt_mode = io_cb[g_telnet_caller_parameter].no_prompt_mode;
                io_cb[g_telnet_caller_parameter].no_prompt_mode = 1;
                release_page_mode();
                io_cb[g_telnet_caller_parameter].no_prompt_mode = old_no_prompt_mode;
                resolved_address = *((UINT32 *)sptr_answer);
                uprintf("Remote Host IP address %I resolved\n", resolved_address);
                if (telnet_connect_to_remote_server(
                                resolved_address,
                                NULL,
                                g_telnet_caller_parameter,
                                IP6_NO_SUCH_PORT,
                                IPVRF_DEFAULT_VRF_IDX
                                ))
                {
                        set_page_mode_always(
                                telnet_remote_callback,
                                g_telnet_caller_parameter,
                                (UINT32)NO_MORE);
                        io_cb[g_telnet_caller_parameter].telnet_client = 1;
                }
                break;
        case DNS_CALLBACK_TIMEOUT:
                /* DNS operation failed */
                uprintf("Telnet timeout due to DNS query failure\n");
                break;
        case DNS_CALLBACK_ABORT:
                /* DNS operation aborted */
                uprintf("Telnet aborted!\n");
                break;
        default:
                break;
        }

        g_uprintf_dest = old_ui_port;
}

void dns6_telnet_callback(
        DNS_SESSION_CLASS *dns_ptr,
        UINT8 *sptr_answer,
        UINT8 answer_type,
        UINT8 status,
        UINT32 param)
{
        int old_ui_port;
        IPV6_ADDRESS resolved_address;
        int old_no_prompt_mode;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = g_telnet_caller_parameter;

        switch (status)
        {
        case DNS_CALLBACK_NOERROR:
                /* DNS operation succeed
                 * release page mode initiated by DNS,
                 * but don't print the prompt
                 */
                old_no_prompt_mode = io_cb[g_telnet_caller_parameter].no_prompt_mode;
                io_cb[g_telnet_caller_parameter].no_prompt_mode = 1;
                release_page_mode();
                io_cb[g_telnet_caller_parameter].no_prompt_mode = old_no_prompt_mode;
                resolved_address = *((IPV6_ADDRESS *)sptr_answer);

                uprintf("Remote Host IPv6 address %s resolved\n", ipv6_address_to_string (&resolved_address, NULL));
                if (telnet_connect_to_remote_server(
                                0,
                                &resolved_address,
                                g_telnet_caller_parameter,
                                IP6_NO_SUCH_PORT,
                                IPVRF_DEFAULT_VRF_IDX))
                {
                        set_page_mode_always( telnet_remote_callback, g_telnet_caller_parameter, (UINT32)NO_MORE);
                        io_cb[g_telnet_caller_parameter].telnet_client = 1;
                }

                break;

        case DNS_CALLBACK_TIMEOUT:
                /* DNS operation failed */
                uprintf("Telnet timeout due to DNS query failure\n");
                break;
        case DNS_CALLBACK_ABORT:
                /* DNS operation aborted */
                uprintf("Telnet aborted!\n");
                break;
        default:
                break;
        }

        g_uprintf_dest = old_ui_port;
        g_ip6_dns_aaaa = 0;
}
#endif

/*
 * this function should start the connection attempt, then return
 * should refrain from taking input while in progress, set some flag
 * to complish that, like ping or the show commands
 */
void telnet_remote(struct cdb* sptr_cdb)
{
        int old_ui_port;
        UINT8 usev4_dns_server = TRUE;
        UINT32 resolved_v4_addr;
        IPV6_ADDRESS resolved_v6_addr;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = sptr_cdb->ui_port;

        telnet.telnet_out_port = 0;

        sptr_cdb->dont_go_next = 1;
        if(telnet.enabled == DISABLED)
        {
                uprintf("telnet is disabled\n");
                return;
        }

        if (sptr_cdb->integer1)
        {
                telnet.telnet_out_port = sptr_cdb->integer1;

                if ((sptr_cdb->integer1 > 65535) || (sptr_cdb->integer1 < 1))
                {
                        uprintf("port number out of range\n");
                        return;
                }
        }

        if (sptr_cdb->ip1)
        {
                /* establish connection, timeout if can't */
                if (telnet_connect_to_remote_server(
                                sptr_cdb->ip1,
                                NULL,
                                sptr_cdb->ui_port,
                                IP6_NO_SUCH_PORT,
                                sptr_cdb->vrf_idx))
                {
                        set_page_mode_always(telnet_remote_callback, (UINT32)sptr_cdb->ui_port, (UINT32)NO_MORE);
                        io_cb[sptr_cdb->ui_port].telnet_client = 1;
                }
        }
#ifdef __IPV6__
        else
        if (sptr_cdb->num_of_ipv6 == 1)
        {
                UINT16 outgoing_interface;
                /* establish connection, timeout if can't */
#ifdef SR_SWITCH_ROUTER
                if (sptr_cdb->num_of_if == 1)
                        outgoing_interface = sptr_cdb->if1-1;
                else
                        outgoing_interface = IP6_NO_SUCH_PORT;
#else SR_SWITCH_ROUTER
                if (IP6_IS_ADDRESS_LINKLOCAL(sptr_cdb->ipv6_1.address))
                        outgoing_interface = 0;
                else
                        outgoing_interface = IP6_NO_SUCH_PORT;
#endif SR_SWITCH_ROUTER

                if (telnet_connect_to_remote_server(
                                0,
                                &sptr_cdb->ipv6_1,
                                sptr_cdb->ui_port,
                                outgoing_interface,
                                sptr_cdb->vrf_idx))
                {
                        set_page_mode_always(telnet_remote_callback, (UINT32)sptr_cdb->ui_port, (UINT32)NO_MORE);
                        io_cb[sptr_cdb->ui_port].telnet_client = 1;
                }
        }
#endif /*__IPV6__*/
        else
           {
                        if (sptr_cdb->flag2 && dns6_servers.num_name_server)  // First try the DNSv6 server if its available
                        {
                                if(dns6_resolve_name_to_ipv6(
                                                                        sptr_cdb->string1,
                                                                        &resolved_v6_addr,
                                                                        sptr_cdb->ui_port) != DNS_OK)
                                {
                                        usev4_dns_server = TRUE;
                                        uprintf("Failed to initialize V6-DNS request, Trying to Use v4-DNS server\n");
                                }
                                else
                                {
                                        if (telnet_connect_to_remote_server(
                                                        0,
                                                        &resolved_v6_addr,
                                                        sptr_cdb->ui_port,
                                                        sptr_cdb->num_of_if == 1 ? sptr_cdb->if1-1 : IP6_NO_SUCH_PORT,
                                                        sptr_cdb->vrf_idx))
                                        {
                                                set_page_mode_always(telnet_remote_callback, (UINT32)sptr_cdb->ui_port, (UINT32)NO_MORE);
                                                io_cb[sptr_cdb->ui_port].telnet_client = 1;
                                        }
                                        usev4_dns_server = FALSE;
                                }
                        }

                        if(usev4_dns_server)
                        {
                                if (dns_resolve_name_to_ip(
                                                                        sptr_cdb->string1,
                                                                        &resolved_v4_addr,
                                                                        sptr_cdb->ui_port) != DNS_OK)
                                {
                                        uprintf("Failed to initialize DNS request\n");
                                }

                                else
                                {
                                        if (telnet_connect_to_remote_server(
                                                        resolved_v4_addr,
                                                        NULL,
                                                        sptr_cdb->ui_port,
                                                        IP6_NO_SUCH_PORT,
                                                        sptr_cdb->vrf_idx))
                                        {
                                                set_page_mode_always(telnet_remote_callback, (UINT32)sptr_cdb->ui_port, (UINT32)NO_MORE);
                                                io_cb[sptr_cdb->ui_port].telnet_client = 1;
                                        }
                                }

                        }
           }
        g_ip6_dns_aaaa = 0; /* reset AAAA flag */
           sptr_cdb->dont_go_next = 1;
                        g_uprintf_dest = old_ui_port;
}

void telnet_remote_ve(struct cdb* sptr_cdb)
{
#ifdef SR_SWITCH_ROUTER
        VE_MAP_INDEX_TYPE internal_ve;

        if (sptr_cdb->integer1 > EXTERNAL_VE_MAX)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        internal_ve = external_ve_lookup(sptr_cdb->integer1 - 1);
        if (is_internal_ve_valid(internal_ve) == FALSE) {
                uprintf("Error - non-existent virtual interface %d\n", sptr_cdb->integer1);
                return;
        }

        sptr_cdb->num_of_if = 1;
        sptr_cdb->if1 = VID_TO_ROUTER_INT(internal_ve) + 1;
        sptr_cdb->num_of_integer = 0;
        sptr_cdb->integer1 = 0;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->flag2 = 1;
        telnet_remote(sptr_cdb);
#endif /* SR_SWITCH_ROUTER */
}

#if 0
//#ifdef __IP_TRACE_ROUTE__
void stop_TraceRouteIp(struct cdb* sptr_cdb)
{
        enum BOOLEAN return_value;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        return_value = ip_tr_abort_trace_route(sptr_cdb->ui_port);
        if (return_value == FALSE)
                {
                uprintf("There is no Trace Route Operation in progress! \n");
                }
        else
                {
                uprintf("Trace Route Operation aborted. \n");
                }
        ip_clear_dns_for_stop_trace();
}


void dns6_trace_route_callback(
        DNS_SESSION_CLASS *dns_ptr,
        UINT8 *sptr_answer,
        UINT8 answer_type,
        UINT8 status,
        UINT32 param)
{
        int old_ui_port;
        IPV6_ADDRESS resolved_address;
        int old_no_prompt_mode;

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = g_trace_caller_parameter;

        switch (status)
        {
        case DNS_CALLBACK_NOERROR:
                /* DNS operation succeed
                 * release page mode initiated by DNS,
                 * but don't print the prompt
                 */
                old_no_prompt_mode = io_cb[g_trace_caller_parameter].no_prompt_mode;
                io_cb[g_trace_caller_parameter].no_prompt_mode = 1;
                release_page_mode();
                io_cb[g_trace_caller_parameter].no_prompt_mode = old_no_prompt_mode;
                resolved_address = *((IPV6_ADDRESS *)sptr_answer);
                if (io_cb[g_trace_caller_parameter].page_mode)
                        io_cb[g_trace_caller_parameter].page_mode = 0;

                ip_tr_perform_trace_route(
                        g_trace_caller_parameter,
                        dns_ptr->sptr_cdb->vrf_idx,
                        0,
                        0,
                        &resolved_address,
                        g_outgoing_interface,
                        g_trace_start_ttl,
                        g_trace_end_ttl,
                        g_trace_timeout,
                        g_trace_no_name);
                break;

        case DNS_CALLBACK_TIMEOUT:
                uprintf("Trace Route timeout due to DNS query failure\n");
                break;
        case DNS_CALLBACK_ABORT:
                /* DNS operation aborted */
                uprintf("Trace Route aborted!\n");
                break;
        default:
                break;
        }

        g_uprintf_dest = old_ui_port;
        g_ip6_dns_aaaa = 0;
}


void dns_trace_route_callback(
        DNS_SESSION_CLASS *dns_ptr,
        UINT8 *sptr_answer,
        UINT8 answer_type,
        UINT8 status,
        UINT32 param)
        {
                int old_ui_port;
                UINT32 resolved_address;
                int old_no_prompt_mode;
                old_ui_port = g_uprintf_dest;
                g_uprintf_dest = g_trace_caller_parameter;

                switch (status)
                {
                case DNS_CALLBACK_NOERROR:
                        /* DNS operation succeed
                         * release page mode initiated by DNS,
                         * but don't print the prompt
                         */
                        old_no_prompt_mode = io_cb[g_trace_caller_parameter].no_prompt_mode;
                        io_cb[g_trace_caller_parameter].no_prompt_mode = 1;
                        release_page_mode();
                        io_cb[g_trace_caller_parameter].no_prompt_mode = old_no_prompt_mode;
                        resolved_address = *((UINT32 *)sptr_answer);

                        if (io_cb[g_trace_caller_parameter].page_mode)
                                io_cb[g_trace_caller_parameter].page_mode = 0;

                        ip_tr_perform_trace_route(
                        g_trace_caller_parameter,
                        dns_ptr->sptr_cdb->vrf_idx,
                        resolved_address,
                        g_trace_source_ip,
#ifdef __IPV6__
                        NULL,
                        0,
#endif /*__IPV6__*/
                        g_trace_start_ttl,
                        g_trace_end_ttl,
                        g_trace_timeout,
                        g_trace_no_name);
                break;

                case DNS_CALLBACK_TIMEOUT:
                        uprintf("Trace Route timeout due to DNS query failure\n");
                        break;
                case DNS_CALLBACK_ABORT:
                        /* DNS operation aborted */
                        uprintf("Trace Route aborted!\n");
                        break;
                default:
                        break;
                }

                g_uprintf_dest = old_ui_port;
        }

void trace_RouteIp_common(struct cdb* sptr_cdb, UINT8 trace_type)
{
        UINT32 trace_caller_parameter;
        UINT32 trace_start_ttl;
        UINT32 trace_end_ttl;
        UINT32 trace_timeout;
        UINT32 trace_no_name;
        UINT32 trace_source_ip;
        UINT8 usev4_dns_server = TRUE;
        UINT32 outgoing_interface;
        UINT8 maxNumNodeTraceRoute = getMaxNodeTraceRoute();
        UINT32 resolved_v4_addr;
        IPV6_ADDRESS resolved_v6_addr;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        trace_start_ttl = 0;
        trace_end_ttl = 0;
        trace_timeout = 0;
        trace_no_name = sptr_cdb->flag1;
        trace_caller_parameter = sptr_cdb->ui_port;
        trace_source_ip = sptr_cdb->ip2;
#ifdef __IPV6__

        if (sptr_cdb->flag2 == 1)
        {
#ifdef SR_SWITCH_ROUTER
                if (sptr_cdb->num_of_if == 1)
                                outgoing_interface = sptr_cdb->if1-1;
                else
                                outgoing_interface = IP6_NO_SUCH_PORT;
#else SR_SWITCH_ROUTER
                        if (IP6_IS_ADDRESS_LINKLOCAL(sptr_cdb->ipv6_1.address))
                                outgoing_interface = 0;
                        else
                                outgoing_interface = IP6_NO_SUCH_PORT;
#endif SR_SWITCH_ROUTER
        }
#endif /* __IPV6__*/

        switch (trace_type)
        {
                case 0: /* No option */
                        break;
                case 1: /* Min */
                {
                        if(sptr_cdb->integer1 > 255)
                        {
                                uprintf("ERROR - Maximum ttl value is 255\n");
                                return;
                        }
                        trace_start_ttl = sptr_cdb->integer1;
                        trace_end_ttl =  trace_start_ttl + maxNumNodeTraceRoute;
                        if(trace_end_ttl < sptr_cdb->integer1) // wrap around scenario
                                trace_end_ttl = 255;
                        break;
                }
                case 2: /* Max */
                {
                        if(sptr_cdb->integer1 > 255)
                        {
                                uprintf("ERROR - Maximum ttl value is 255\n");
                                return;
                        }
                        trace_end_ttl = sptr_cdb->integer1;
                        if(trace_end_ttl < maxNumNodeTraceRoute)
                                trace_start_ttl = 0;
                        else
                                trace_start_ttl = trace_end_ttl - maxNumNodeTraceRoute;

                        break;
                }
                case 3: /* Timeout */
                        trace_timeout = sptr_cdb->integer1;
                        break;
                case 4: /* MinMax */
                {
                        if(sptr_cdb->integer1 > 255 || sptr_cdb->integer2 > 255 )
                        {
                                uprintf("ERROR - Maximum ttl value is 255\n");
                                return;
                        }

                        trace_start_ttl = sptr_cdb->integer1;
                        trace_end_ttl = sptr_cdb->integer2;

                        if(trace_end_ttl - trace_start_ttl > maxNumNodeTraceRoute)
                        {
                                uprintf("Error - Maximum distance between MIN and MAX is %u - entry is %u\n",
                                                        maxNumNodeTraceRoute,trace_end_ttl - trace_start_ttl);
                                return;
                        }

                        break;
                }
                case 5: /* MinTimeout */
                {
                        if(sptr_cdb->integer1 > 255)
                        {
                                uprintf("ERROR - Maximum ttl value is 255\n");
                                return;
                        }

                        trace_start_ttl = sptr_cdb->integer1;
                        trace_end_ttl = trace_start_ttl + maxNumNodeTraceRoute;
                        if(trace_end_ttl < sptr_cdb->integer1) // wrap around scenario
                                trace_end_ttl = 255;
                        trace_timeout = sptr_cdb->integer2;
                        break;
                }
                case 6: /* MaxTimeout */
                {
                        if(sptr_cdb->integer1 > 255)
                        {
                                uprintf("ERROR - Maximum ttl value is 255\n");
                                return;
                        }

                        trace_end_ttl = sptr_cdb->integer1;
                        if(trace_end_ttl < maxNumNodeTraceRoute)
                                trace_start_ttl = 0;
                        else
                                trace_start_ttl = trace_end_ttl - maxNumNodeTraceRoute;

                        trace_timeout = sptr_cdb->integer2;
                        break;
                }
                case 7: /* MinMaxTimeout */
                {
                        if(sptr_cdb->integer1 > 255 || sptr_cdb->integer2 > 255 )
                        {
                                uprintf("ERROR - Maximum ttl value is 255\n");
                                return;
                        }

                        trace_start_ttl = sptr_cdb->integer1;
                        trace_end_ttl = sptr_cdb->integer2;
                        trace_timeout = sptr_cdb->integer3;

                        if(trace_end_ttl - trace_start_ttl > maxNumNodeTraceRoute)
                        {
                                uprintf("Error - Maximum distance between MIN and MAX is %u - entry is %u\n",
                                                        maxNumNodeTraceRoute,trace_end_ttl - trace_start_ttl);
                                return;
                        }

                        break;
                        }
        }

        if (sptr_cdb->ip1)
        {
                ip_tr_perform_trace_route(
                        trace_caller_parameter,
                        sptr_cdb->vrf_idx,
                        sptr_cdb->ip1,
                        trace_source_ip,
#ifdef __IPV6__
                        NULL,
                        0,
#endif /*__IPV6__*/
                        trace_start_ttl,
                        trace_end_ttl,
                        trace_timeout,
                        trace_no_name);
        }
#ifdef __IPV6__
        else if (sptr_cdb->flag2 == 1 && sptr_cdb->num_of_ipv6 != 0)
        {
                ip_tr_perform_trace_route(
                        trace_caller_parameter,
                        sptr_cdb->vrf_idx,
                        0,
                        0,
                        &sptr_cdb->ipv6_1,
                        outgoing_interface,
                        trace_start_ttl,
                        trace_end_ttl,
                        trace_timeout,
                        trace_no_name);
        }
#endif
        else
        {
                void (*dns_tracert_cb)(DNS_SESSION_CLASS *, UINT8 *, UINT8, UINT8, UINT32);

                if (sptr_cdb->flag2) {
                        dns_tracert_cb = dns6_trace_route_callback;
                        g_ip6_dns_aaaa = 1; /* Set AAAA flag for IPv6 DNS */
                } else {
                        dns_tracert_cb = dns_trace_route_callback;
                        g_ip6_dns_aaaa = 0;
                }
                 if (dns6.num_name_server && sptr_cdb->flag2 )  // First try the DNSv6 server if its available
                {
                        if(dns6_resolve_name_to_ipv6(
                                                                sptr_cdb->string1,
                                                                &resolved_v6_addr,
                                                                sptr_cdb->ui_port) != DNS_OK)
                        {
                                usev4_dns_server = TRUE;
                                uprintf("Failed to initialize V6-DNS request, Trying to Use v4-DNS server\n");
                        }
                        else
                        {
                                ip_tr_perform_trace_route(
                                        trace_caller_parameter,
                                        sptr_cdb->vrf_idx,
                                        0,
                                        0,
                                        resolved_v6_addr,
                                        outgoing_interface,
                                        trace_start_ttl,
                                        trace_start_ttl,
                                        trace_timeout,
                                        trace_no_name);
                                usev4_dns_server = FALSE;
                        }

                 }

                if (usev4_dns_server)
                {
                         if (dns_resolve_name_to_ip(
                                sptr_cdb->string1,
                                &resolved_v4_addr,
                                sptr_cdb->ui_port) != DNS_OK)
                        {
                                uprintf("Failed to initialize DNS request\n");
                        }
                        else
                        {
                                ip_tr_perform_trace_route(
                                        trace_caller_parameter,
                                        sptr_cdb->vrf_idx,
                                        resolved_v4_addr,
                                        trace_source_ip,
#ifdef __IPV6__
                                        NULL,
                                        0,
#endif /*__IPV6__*/
                                        trace_start_ttl,
                                        trace_end_ttl,
                                        trace_timeout,
                                        trace_no_name);
                        }
                }

        }
        sptr_cdb->dont_go_next = 1;
        g_ip6_dns_aaaa = 0; /* reset AAAA flag */
}


void trace_RouteIp(struct cdb* sptr_cdb)
{
        /* at this moment, sptr_cdb->num_of_ip can be 0 or 1,
         * make it 1 so that when trace_RouteIpSourceIp() is
         * called, sptr_cdb->ip2 is always the source ip
         */
        sptr_cdb->num_of_ip = 1;
        trace_RouteIp_common(sptr_cdb, 0);
}

#ifdef __IPV6__
void trace_RouteIpv6_ve(struct cdb* sptr_cdb)
{
        if (sptr_cdb->integer1 > MAX_ROUTER_INT)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        sptr_cdb->num_of_if = 1;
        sptr_cdb->if1 = VID_TO_ROUTER_INT(sptr_cdb->integer1);
        sptr_cdb->num_of_integer = 0;
        sptr_cdb->integer1 = 0;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->flag2 = 1;
        trace_RouteIp_common(sptr_cdb, 0);
}

/*
 * Work around: avoid calling trace_RouteIp_common() twice
 * with the first time without setting the vrf properly.
 */
void
trace_RouteIpv6_vrf(struct cdb* sptr_cdb)
{
        static nCalled = 0;

        if (++nCalled < 2)
        {
                return;
        }
        nCalled = 0;

        sptr_cdb->flag2 = 1;
        trace_RouteIp_common(sptr_cdb, 0);
}

void trace_RouteIpv6(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        /* Indicate this ipv6 trace route */
        sptr_cdb->flag2 = 1;
        trace_RouteIp_common(sptr_cdb, 0);
}
#endif __IPV6__

#ifdef SR_SWITCH_ROUTER
void trace_RouteIpSourceIp(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 0);
}
#endif /* SR_SWITCH_ROUTER */

void trace_RouteIpNoName(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 1;
        trace_RouteIp_common(sptr_cdb, 0);
}

void trace_RouteIpMin(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 1);
}

void trace_RouteIpMax(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 2);
}
void trace_RouteIpTimeout(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 3);
}
void trace_RouteIpMinMax(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 4);
}

void trace_RouteIpMinTimeout(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 5);
}
void trace_RouteIpMaxTimeout(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 6);
}
void trace_RouteIpMinMaxTimeout(struct cdb* sptr_cdb)
{
        trace_RouteIp_common(sptr_cdb, 7);
}

//#endif /*__IP_TRACE_ROUTE__*/
#endif

#ifdef __IPV6__
void telnet_remoteIpv6 (struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->flag2 = 1;
    telnet_remote (sptr_cdb);
}
#endif __IPV6__

#define DEFAULT_LOCK_ADDRESS_COUNT 8
#define MIN_LOCK_ADDRESS_COUNT 1
#define MAX_LOCK_ADDRESS_COUNT 2048

void check_lock_address(struct cdb* sptr_cdb)
{
        int i;
        PORT_ID port_id;
        UINT16 count=0;

        if (sptr_cdb->config_gen)
        {
                for (i=0; i < g_hw_info.total_config_ports; i++)
                {
                        port_id = sw_config_port_list[i];
                        if (!IS_PORT_ENET(port_id))
                                continue;

                        cu_get_lock_address(port_id, &count);

                        if (count != 0)
                        {
                                ksprintf(cu_line_buf, "lock-address %s %p", get_port_type_str(port_id),
										get_port_num(port_id));
                                wr_config(sptr_cdb, cu_line_buf);

                                if (count == DEFAULT_LOCK_ADDRESS_COUNT)
                                        wr_config(sptr_cdb, "\n");
                                else
                                {
                                        ksprintf(cu_line_buf, " addr-count %d\n", count);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }
                        }
                }
        }
        else
        { /* not config gen */
                if (end_of_token(sptr_cdb->token) == '\0')
                { /* end of line */
                        sptr_cdb->integer1 = DEFAULT_LOCK_ADDRESS_COUNT;
                        cli_set_lock_address(sptr_cdb);
                        sptr_cdb->dont_go_next = 1;
                }
        }
}

void cli_set_lock_address(struct cdb* sptr_cdb)
{
        PORT_ID port_id;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                /* port# = sptr_cdb->if1 , addr-count = sptr_cdb->integer1 */
                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                        return;

                port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                                if(!IS_PORT_DB_VALID(port_id))
                                                return;

                if (cli_port_is_stacking_port(sptr_cdb, port_id, FALSE, 0))
                        return;

                if (pms_is_enabled(port_id))
                {
                        uprintf("Error - Lock Address cannot be set on a port security enabled port %p\n", port_id);
                        return;
                }
#ifdef INCLUDE_MCT
                if (IS_PORT_ICL_PORT (port_id) || IS_PORT_CCEP_PORT (port_id))
                {
                        uprintf("Error - Lock Address cannot be set for cluster ports: %p\n", port_id);
                        return;
                }
#endif

                if (((int) sptr_cdb->integer1 < MIN_LOCK_ADDRESS_COUNT) ||
                        ((int) sptr_cdb->integer1 > MAX_LOCK_ADDRESS_COUNT))
                {
                        uprintf("Error - invalid address count, min %d to max %d.\n",
                                MIN_LOCK_ADDRESS_COUNT,
                                MAX_LOCK_ADDRESS_COUNT);
                        return;
                }

                if(IS_MAC_BASED_VLAN_ENABLED_ON_PORT(port_id))
                {
                        uprintf("Error: Lock Address cannot be set on a Mac Based Vlan enabled port \n");
                        return;
                }

                {
#ifdef LINK_AGGREGATION
                        LINK_AGGREGATION_INFO *lacp_port_ptr;

                        lacp_port_ptr = &(SPTR_PORT_DB(port_id)->port_config.lacp);

                        if (LACP_ENABLED(lacp_port_ptr))
                        {
                                uprintf("Error - Lock Address cannot be set on a LACP-enabled port\n");
                                return;
                        }
#endif LINK_AGGREGATION

                        if (trunk_port_state(port_id) != TRUNK_NONE)
                        {
                                uprintf("Error - Lock Address cannot be set on a Trunk Group\n");
                                return;
                        }
                }

                if(IS_MAC_AUTH_ENABLED_ON_PORT(port_id))
                {
                        uprintf("Error - Lock Address cannot be set on a mac-authentication enabled port\n");
                        return;
                }

                if(IS_DOT1X_PORT_ENABLED(port_id))
                {
                        uprintf("Error - Lock Address cannot be set on a dot1x enabled port\n");
                        return;
                }

                if (sptr_cdb->no)
                        cu_set_lock_address(port_id, 0);
                else
                        cu_set_lock_address(port_id, (UINT16) sptr_cdb->integer1);
        }
}

/* this function displays version in a contigous maner,
 * it is used during initialization
 */
void show_version()
{
        struct io_port_cb *sptr_cb = &io_cb[g_uprintf_dest];
        int skip_page_mode_saved = g_skip_page_mode;
        int no_prompt_mode_saved = sptr_cb->no_prompt_mode;

        g_skip_page_mode = 1;
        sptr_cb->no_prompt_mode = 1;

        cu_show_version();

        sptr_cb->no_prompt_mode = no_prompt_mode_saved;
        g_skip_page_mode = skip_page_mode_saved;
}

void show_ver(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        cu_show_version();
}

void show_one_unit_version(struct cdb* sptr_cdb)
{
    int unit_id;

    if(sptr_cdb->config_gen || sptr_cdb->no)
        return;

    if(end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

    unit_id = sptr_cdb->integer1;
    
    if(!(STK_ID_RANGE_CHECK(unit_id) || PE_ID_RANGE_CHECK(unit_id)))
    {
        uprintf("Invalid unit id %d\n", unit_id);
        return;
    }

    if(G_STACK_STATE(unit_id) < STACK_STATE_REMOTE)
    {
        uprintf("Unit %d does not exist\n", unit_id);
        return;
    }
    cu_show_one_unit_version(unit_id);
}
void dm_showver(struct cdb* sptr_cdb)
{
        g_show_realver = 1;
        show_ver(sptr_cdb);
        g_show_realver = 0;
}

void show_media_valid(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        show_media_valid_in_progress = GT_TRUE;
        show_media_valid_port_counter = 0;
        cu_print_show_media_valid_header();
        if (IS_FI_BCM())
        {
                cu_new_show_media(1,0,0);       
        }
        else
          cu_show_media();

}

void show_media(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
                show_media_in_progress = GT_TRUE;
                show_media_valid_in_progress = GT_FALSE;

#if defined(SIDEWINDER_LINUX)
        cu_show_media();
                show_media_in_progress = GT_FALSE;
#else
        cu_new_show_media(1,0,0);
#endif
}

void show_redundancy(struct cdb* sptr_cdb)
{
        return;
}


void show_system_monitoring(struct cdb* sptr_cdb)
{
        if(sm.sysMon_enable)
                {
                        uprintf ("System Monitoring (Sysmon) is: enabled\n");
                        uprintf ("Sysmon timer = %d minutes\n", sm.sysMon_timer);

                        return;
                }
        else
                        uprintf ("System Monitoring is: disabled\n");
                        uprintf ("Sysmon timer = %d minutes\n", sm.sysMon_timer);

                        return;
}

void show_chassis(struct cdb* sptr_cdb)
{

        if (sptr_cdb == NULL)
          return;

        if (sptr_cdb->config_gen)
          return;

        cu_chassisStackShow(sptr_cdb);

}

#ifdef SM_MASTER
void cli_report_slave_flash_hw(int slave_index)
{
        UINT32 unit_size=0;

        /* report Code flash type */
        if (fmp.fmp_agent_sys[slave_index-1].code_flash_device.manuf_id_GS == MANU_AMD)
        {
                if (fmp.fmp_agent_sys[slave_index-1].code_flash_device.kb_size_GS)
                        unit_size = (UINT32)(fmp.fmp_hw_info[slave_index-1].hw_info.code_flash_size/fmp.fmp_agent_sys[slave_index-1].code_flash_device.kb_size_GS);
                uprintf("Code Flash Type: AMD %s, Size: %d * %d = %d, Unit: %d\n",
                        fmp.fmp_agent_sys[slave_index-1].code_flash_device.devname_GS,
                        fmp.fmp_agent_sys[slave_index-1].code_flash_device.num_sectors,
                                fmp.fmp_agent_sys[slave_index-1].code_flash_device.sector_size,
                                fmp.fmp_agent_sys[slave_index-1].code_flash_device.kb_size_GS,
                                unit_size);
        }
        else
                uprintf("Unknown Code Flash device type\n");

        /* report Boot flash type */
        if (fmp.fmp_agent_sys[slave_index-1].config_flash_device.manuf_id_GS == MANU_ATMEL)
        {
                uprintf("Boot Flash Type: ATMEL %s, Size: %d * %d = %d\n",
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.devname_GS,
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.num_sectors,
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.sector_size,
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.kb_size_GS);
        }
        else if (fmp.fmp_agent_sys[slave_index-1].config_flash_device.manuf_id_GS == MANU_AMD)
        {
                uprintf("Boot Flash Type: AMD %s, Size: %d * %d = %d\n",
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.devname_GS,
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.num_sectors,
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.sector_size,
                                fmp.fmp_agent_sys[slave_index-1].config_flash_device.kb_size_GS);
        }
        else
                uprintf("Unknown Boot Flash device type\n");
}
#endif SM_MASTER

extern CHASSIS_STACK_SHOW_INFO          ChassisStackShowInfo[MAX_SYS_UNIT_NUM+1];
void cli_show_stacking_flash()
{
    int i, is_image_mismatch;
    char    version[32]={0};
    int     image_size, image_type;
    char    image_name[FLASH_FILE_NICK_NAME_LENGTH]={0};
    unsigned long free_space;

    SYS_IMAGE_VERSION boot_image;
    char patch[2] = {0, 0};

    FS_STATFS vbuf;

    for (i=1; i <= MAX_SYS_UNIT_NUM; i++)
    {
        is_image_mismatch = 0;
        if (is_stack_base_module_active(i)|| (PE_ID_RANGE_CHECK(i) && g_stk_oper_class.remote_state[i] == REG_STATE_SRT_NON_OPERATION))
        {
            //for matser unit
            if (i == MY_BOOTUP_STACK_ID)
            {
                uprintf("Stack unit %d:\n", i);
                image_size = get_code_version(FLASH_PRIMARY_IMG, version);
                image_type = get_flash_code_type(FLASH_PRIMARY_IMG);
                if (image_size)
                {
                    get_flash_code_name(FLASH_PRIMARY_IMG, image_name);
                    if (version[3] != 0)  //this is a patch release
                    {
                        if(version[3] & 0x80) // Check for Beta version.The external utility elfcomp does "version[3] | 0x80" while generating header for beta images.
                            patch[0] = 'B'; 
                        else
                            patch[0] = version[3] + 'a' - 1;

                        uprintf("  Compressed Pri Code size = %d, Version:%02d.%d.%02d%sT%x",
                        image_size, version[0], version[1], version[2], patch, image_type);
                    }
                    else
                    {
                        uprintf("  Compressed Pri Code size = %d, Version:%02d.%d.%02dT%x",          //366379
                                                                    image_size, version[0], version[1], version[2], image_type);
                    }

                    if (image_name[0])
                        uprintf(" (%s)\n", image_name);
                    else
                        uprintf("\n");
                }
                else
                    uprintf("  Pri Code Flash Empty\n");

                memset(version, 0, sizeof(version));
                image_size = get_code_version(FLASH_SECONDARY_IMG, version);
                image_type = get_flash_code_type(FLASH_SECONDARY_IMG);
                if (image_size)
                {
                    memset(patch, 0, sizeof(patch));
                    get_flash_code_name(FLASH_SECONDARY_IMG, image_name);
                    if (version[3] != 0)  //this is a patch release
                    {
                        if(version[3] & 0x80)// Check for Beta version.The external utility elfcomp does "version[3] | 0x80" while generating header for beta images.
                            patch[0] = 'B';
                        else
                            patch[0] = version[3] + 'a' - 1;

                        uprintf("  Compressed Sec Code size = %d, Version:%02d.%d.%02d%sT%0x",
                        image_size, version[0], version[1], version[2], patch, image_type);
                    }
                    else
                    {
                        uprintf("  Compressed Sec Code size = %d, Version:%02d.%d.%02dT%0x",
                        image_size, version[0], version[1], version[2], image_type);
                    }
                    if (image_name[0])
                        uprintf(" (%s)\n", image_name);
                    else
                        uprintf("\n");
                }
                else
                    uprintf("  Sec Code Flash Empty\n");

                memset(version, 0, sizeof(version));
                flash_get_boot_version(&boot_image);
                if (boot_image.length)
                {
                    uprintf("  Compressed Boot-Monitor Image size = %d, Version:%02d.%d.%02dT%0x\n", boot_image.length, boot_image.version[0], boot_image.version[1], boot_image.version[2], boot_image.type);
                    /*      if (boot_image.label[0])
                        uprintf(" (%s)\n", boot_image.label);
                    else
                        uprintf("\n"); */
                }
                else
                    uprintf("  Compressed Boot-Monitor Image size Flash Empty\n");

                flash_get_free_block_space(&vbuf);

                free_space = vbuf.f_bavail * vbuf.f_bsize;
                uprintf("  Code Flash Free Space = %d\n", free_space);
            }
            else
            {
                if (!STACK_AM_I_SLAVE && ((IS_CHASSIS_STACK_EXIST(i) && MODULE_EXIST(STACK_TO_BASE_MODULE(i))) || (PE_ID_RANGE_CHECK(i) && g_stk_oper_class.remote_state[i] == REG_STATE_SRT_NON_OPERATION)))
                {
                    if(g_stk_oper_class.remote_state[i] == REG_STATE_SRT_NON_OPERATION)
                        is_image_mismatch = 1;
                        
                    #ifdef __PORT_EXTENSION__
                    if (i >= PE_START_NUM) 
                    {
                        uprintf("SPX unit %d: %s\n", i, is_image_mismatch ? "(Non-operational State)" : "");
                    } 
                    else 
                    #endif
                    {
                        uprintf("Stack unit %d: %s\n", i, is_image_mismatch ? "(Non-operational State)" : "");
                    }

                    if (ChassisStackShowInfo[i].pri_build_size)
                    {
                        uprintf("  Compressed Pri Code size = %d, Version:%s", ChassisStackShowInfo[i].pri_build_size, ChassisStackShowInfo[i].pri_build_ver);
                        if (ChassisStackShowInfo[i].pri_build_file[0])
                            uprintf(" (%s)\n", ChassisStackShowInfo[i].pri_build_file);
                        else
                            uprintf("\n");
                    }
                    else
                        uprintf("  Pri Code Flash Empty\n");

                    if (ChassisStackShowInfo[i].sec_build_size)
                    {
                        uprintf("  Compressed Sec Code size = %d, Version:%s", ChassisStackShowInfo[i].sec_build_size, ChassisStackShowInfo[i].sec_build_ver);
                        if (ChassisStackShowInfo[i].sec_build_file[0])
                            uprintf(" (%s)\n", ChassisStackShowInfo[i].sec_build_file);
                        else
                            uprintf("\n");
                    }
                    else
                        uprintf("  Sec Code Flash Empty\n");

                    if (ChassisStackShowInfo[i].bootRom_build_size)
                        uprintf("  Compressed Boot-Monitor Image size = %d, Version:%s\n", ChassisStackShowInfo[i].bootRom_build_size, ChassisStackShowInfo[i].bootRom_build_ver);

                    uprintf("  Code Flash Free Space = %d\n", ChassisStackShowInfo[i].flash_free_size);
                }
            }
        }
    }
//#endif
}
#ifdef __PORT_EXTENSION__
/****************************************************************************************
 * Name: cli_show_flash_stacking_flash_group
 *
 * Description: This function displays the flash image information for a particular pe group keyed in by user.
 *           When there is inavlid group name, error is thrown on the respective session.
 *           This can be only executed by an Active controller.
 *
 * Input: pointer to cdbs structure.
 *
 * Return value: void
 *
 * ****************************************************************************************/
void cli_show_flash_stacking_flash_group(struct cdb* sptr_cdb)
{
	UINT8 pe_id_ary[PE_MAX_CHAIN_LEN] = {'0'};
	int i;
	if ((sptr_cdb->config_gen)|| (sptr_cdb->no))
		return;

	if (end_of_token(sptr_cdb->token) != '\0')
		return;
	sptr_cdb->dont_go_next = 1;
	if (IS_STACKING_ENABLED && !STACK_AM_I_MASTER && !STACK_AM_I_STANDALONE && !STACK_AM_I_CB_ENABLE)
	{
		uprintf("Error! This CLI operation is only allowed on the Active Controller\n");
		return;
	}    

	if( find_all_pe_id_from_a_pe_group(sptr_cdb->string1,&pe_id_ary) == -1)
	{
		uprintf("\nError: PE group %s does not exist\n",sptr_cdb->string1);
		return;
	}
	for(i=0;i<(PE_MAX_CHAIN_LEN);i++)
	{
		if(pe_id_ary[i])
		{
			sptr_cdb->integer1 = pe_id_ary[i];
			show_flash_stacking_flash_one_unit(sptr_cdb);
		}
	}
}
#endif __PORT_EXTENSION__
void show_flash_stacking_flash_one_unit(struct cdb* sptr_cdb)
{
        UINT8 unit;
        char    version[32]={0};
        int             image_size, image_type;
        char    image_name[FLASH_FILE_NICK_NAME_LENGTH]= {0};
        unsigned long free_space;
        SYS_IMAGE_VERSION boot_image;
        char patch[2] = {0, 0};
        FS_STATFS vbuf;

        if ((sptr_cdb->config_gen)|| (sptr_cdb->no))
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (!valid_integer1_value_range(sptr_cdb, START_STACKING_NUM, MAX_SYS_UNIT_NUM))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }

        sptr_cdb->dont_go_next = 1;

        unit = (UINT8)sptr_cdb->integer1;
        if (is_stack_base_module_active(unit))
        {
                uprintf("Stack unit %d:\n", unit);
                if (unit == MY_BOOTUP_STACK_ID)
                {
                        image_size = get_code_version(FLASH_PRIMARY_IMG, version);
                        image_type = get_flash_code_type(FLASH_PRIMARY_IMG);
                        if (image_size)
                        {
                                if (version[3] != 0)  //this is a patch release
                                {
                                        patch[0] = version[3] + 'a' - 1;
                                }
                                get_flash_code_name(FLASH_PRIMARY_IMG, image_name);
                                uprintf("  Compressed Pri Code size = %d, Version:%02d.%d.%02d%sT%x",
                                                        image_size, version[0], version[1], version[2], patch, image_type);
                                if (image_name[0])
                                        uprintf(" (%s)\n", image_name);
                                else
                                        uprintf("\n");
                        }
                        else
                                uprintf("  Pri Code Flash Empty\n");

                        memset(version, 0, sizeof(version));
                        image_size = get_code_version(FLASH_SECONDARY_IMG, version);
                        image_type = get_flash_code_type(FLASH_SECONDARY_IMG);
                        if (image_size)
                        {
                                memset(patch, 0, sizeof(patch));
                                if (version[3] != 0)  //this is a patch release
                                {
                                        patch[0] =  version[3] + 'a' - 1;
                                }
                                get_flash_code_name(FLASH_SECONDARY_IMG, image_name);
                                uprintf("  Compressed Sec Code size = %d, Version:%02d.%d.%02d%sT%0x",
                                                                image_size, version[0], version[1], version[2], patch, image_type);
                                if (image_name[0])
                                        uprintf(" (%s)\n", image_name);
                                else
                                        uprintf("\n");
                        }
                        else
                                uprintf("  Sec Code Flash Empty\n");

                        memset(version, 0, sizeof(version));
                        flash_get_boot_version(&boot_image);

                        if (boot_image.length)
                        {
                                uprintf("  Compressed Boot-Monitor Image size = %d, Version:%02d.%d.%02dT%0x\n",
                                                        boot_image.length, boot_image.version[0], boot_image.version[1],
                                                        boot_image.version[2], boot_image.type);
                                /*if (boot_image.label[0])
                                        uprintf(" (%s)\n", boot_image.label);
                                else
                                        uprintf("\n"); */
                        }
                        else
                                uprintf("  Compressed Boot-Monitor Image size Flash Empty\n");
                        flash_get_free_block_space(&vbuf);

                        free_space = vbuf.f_bavail * vbuf.f_bsize;

                        uprintf("  Code Flash Free Space = %d\n", free_space);
                }
                else
                {
                        if (ChassisStackShowInfo[unit].pri_build_size)
                        {
                                uprintf("  Compressed Pri Code size = %d, Version %s",
                                                   ChassisStackShowInfo[unit].pri_build_size, ChassisStackShowInfo[unit].pri_build_ver);
                                if (ChassisStackShowInfo[unit].pri_build_file[0])
                                        uprintf(" (%s)\n", ChassisStackShowInfo[unit].pri_build_file);
                                else
                                        uprintf("\n");
                        }
                        else
                                uprintf("  Pri Code Flash Empty\n");

                        if (ChassisStackShowInfo[unit].sec_build_size)
                        {
                                uprintf("  Compressed Sec Code size = %d, Version %s",
                                                    ChassisStackShowInfo[unit].sec_build_size, ChassisStackShowInfo[unit].sec_build_ver);
                                if (ChassisStackShowInfo[unit].sec_build_file[0])
                                        uprintf(" (%s)\n", ChassisStackShowInfo[unit].sec_build_file);
                                else
                                        uprintf("\n");
                        }
                        else
                                uprintf("  Sec Code Flash Empty\n");

                        if (ChassisStackShowInfo[unit].bootRom_build_size)
                                uprintf("  Compressed Boot-Monitor Image size = %d, Version %s\n",
                                                ChassisStackShowInfo[unit].bootRom_build_size, ChassisStackShowInfo[unit].bootRom_build_ver);

                        uprintf("  Code Flash Free Space = %d\n", ChassisStackShowInfo[unit].flash_free_size);
                }
        }
        else
        {
                uprintf("Error - stack unit %d does not exist.\n", unit);
        }
}

void show_flash_slot(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (sptr_cdb->integer1 - 1 == g_hw_info.cpu_module)
                cli_show_flash_by_slot(0);      /* show the active master */
}

void show_flash(struct cdb* sptr_cdb)
{
        int i;

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        if ((SHOW_BUF = sv_buf_alloc()) != NULL)
                redirect_output_to_display_buf();

        cli_show_stacking_flash();

        if (SHOW_BUF != NULL)
                sv_buf_display();
}


void cli_show_flash_by_slot(int slave_index)
{
        char    version[32] = {0};
        int             image, image_type, image_size;
        char    image_name[FLASH_FILE_NICK_NAME_LENGTH] =  {0}; // BUG 100610, klin
        int     sds_ver;
        unsigned long free_space;
                char patch[2] = {0, 0};
        SYS_IMAGE_VERSION boot_image;

        image = (slave_index == 0) ? FLASH_PRIMARY_IMG : FLASH_REMOTE_PRIMARY_IMG;
        image_size = get_code_version(image, version);
        image_type = get_flash_code_type(image);

        if (image_size)
        {
                get_flash_code_name(image, image_name);

                uprintf("  Compressed Pri Code size = %d, Version:%02d.%d.%02d",
                        image_size, version[0], version[1], version[2]);

                if (version[3] & 0x80)
                {
                        uprintf("B");
                                                // enable it if want to display beta build number
                        // uprintf("B%d", boot_image.version[3] & 0x7f);
                }
                else if (version[3] != 0)
                {
                        uprintf("%c", version[3] + 'a' - 1);
                }

                uprintf("T%0x", image_type);

                if (image_name[0])
                        uprintf(" (%s)\n", image_name);
                else
                        uprintf("\n");
        } else
        {
                uprintf("Pri Code Flash Empty\n");
        }

        memset(version, 0, sizeof(version));
        image = (slave_index == 0) ? FLASH_SECONDARY_IMG : FLASH_REMOTE_SECONDARY_IMG;
        image_size = get_code_version(image, version);
        image_type = get_flash_code_type(image);

        if (image_size)
        {
                get_flash_code_name(image, image_name);

                uprintf("  Compressed Sec Code size = %d, Version:%02d.%d.%02d",
                        image_size, version[0], version[1], version[2]);

                if (version[3] & 0x80)
                {
                        uprintf("B");
                        // enable it if want to display beta build number
                        // uprintf("B%d", boot_image.version[3] & 0x7f);
                }
                else if (version[3] != 0)
                {
                        uprintf("%c", version[3] + 'a' - 1);
                }

                uprintf("T%0x", image_type);

                if (image_name[0])
                        uprintf(" (%s)\n", image_name);
                else
                        uprintf("\n");
        } else
        {
                uprintf("Sec Code Flash Empty\n");
        }

        memset(&boot_image, 0, sizeof(SYS_IMAGE_VERSION));
        flash_get_boot_version(&boot_image);

        uprintf("Compressed Boot-Monitor Image size = %d, Version:%02d.%d.%02d",
                                boot_image.length, boot_image.version[0], boot_image.version[1], boot_image.version[2]);

        if (boot_image.version[3] & 0x80)
        {
                uprintf("B%d", boot_image.version[3] & 0x7f);
        }
        else if (boot_image.version[3])
        {
                uprintf("%c", boot_image.version[3] + 'a' - 1);
        }

        uprintf("T%0x", boot_image.type);
        uprintf(" (%s)\n", boot_image.label);

        free_space = ((slave_index == 0) ? sys_get_free_flash_block_space() : sxr_red_stby_flash_free_space());
        uprintf("Code Flash Free Space = %d\n", free_space);


}


void show_interfaces(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);
        sptr_cdb->port_mask_callback = show_int_common;
#ifdef SR_SWITCH_ROUTER
        sptr_cdb->router_port_callback = show_router_int_common;
#endif /*SR_SWITCH_ROUTER*/

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        /* show all interfaces */
        if (sptr_cdb->mode == CONFIG_MIF)
                cu_show_interface_page(1, sptr_cdb->mif_port_mask, NEXT_PORT_INDEX_INVALID);
        else
                cu_show_interface_page(1, NULL, NEXT_PORT_INDEX_INVALID);
}

void show_interfaces_stack_ports_brief(struct cdb* sptr_cdb)
{
        int bak;
       set_physical_view(sptr_cdb);
//      sptr_cdb->port_mask_callback = show_int_brief_common;
#ifdef SR_SWITCH_ROUTER
//      sptr_cdb->router_port_callback = show_router_int_brief_common;
#endif /*SR_SWITCH_ROUTER*/

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        print_port_type[sptr_cdb->ui_port] = ANY_PORT_TYPE;

        bak = debugGlobal.stacking.debug_official;
        debugGlobal.stacking.debug_official = 1; // display all sub ports
#ifdef MTOS
    // Test version of show interface brief, taking advantage of CLI using a separate thread.
    // If this CLI is running on the CLI thread, we can use "wait-for-MORE-blocking"; if it
    // is running on main-loop thread (such as, a TELNET session), we cannot.
    if (getCurTask()==1)
            cuShowInterfaceBrief((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0);
    else
#endif MTOS
                cu_show_interface_stack_ports_brief(1, ((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0), NEXT_PORT_INDEX_INVALID);
        debugGlobal.stacking.debug_official = bak;
}

void show_interfaces_brief(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);
        sptr_cdb->port_mask_callback = show_int_brief_common;
#ifdef SR_SWITCH_ROUTER
        sptr_cdb->router_port_callback = show_router_int_brief_common;
#endif /*SR_SWITCH_ROUTER*/

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        print_port_type[sptr_cdb->ui_port] = ANY_PORT_TYPE;

#ifdef MTOS
    // Test version of show interface brief, taking advantage of CLI using a separate thread.
    // If this CLI is running on the CLI thread, we can use "wait-for-MORE-blocking"; if it
    // is running on main-loop thread (such as, a TELNET session), we cannot.
    if (getCurTask()==1)
            cuShowInterfaceBrief((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0);
    else
#endif MTOS
                cu_show_interface_brief(1, ((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0), NEXT_PORT_INDEX_INVALID);
}

void show_interfaces_brief_wide(struct cdb* sptr_cdb)
{
        print_port_name_wide[sptr_cdb->ui_port]= GT_TRUE;

        set_physical_view(sptr_cdb);
        sptr_cdb->port_mask_callback = show_int_brief_common;
#ifdef SR_SWITCH_ROUTER
        sptr_cdb->router_port_callback = show_router_int_brief_common;
#endif /*SR_SWITCH_ROUTER*/

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        print_port_type[sptr_cdb->ui_port] = ANY_PORT_TYPE;

#ifdef MTOS
    // Test version of show interface brief, taking advantage of CLI using a separate thread.
    // If this CLI is running on the CLI thread, we can use "wait-for-MORE-blocking"; if it
    // is running on main-loop thread (such as, a TELNET session), we cannot.
    if (getCurTask()==1)
            cuShowInterfaceBrief((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0);
    else
#endif MTOS
                cu_show_interface_brief(1, ((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0), NEXT_PORT_INDEX_INVALID);

}

void show_interfaces_by_slot(struct cdb* sptr_cdb)
{
        int slot = sptr_cdb->integer1-1;
        PORT_ID port_index;
        int i;

        if (slot >= MAX_SLOT)
        {
                uprintf("Error - slot %d does not exist\n", sptr_cdb->integer1);
                return;
        }

        /* show all interfaces of one slot */
        if (MODULE_EXIST(slot) || MODULE_IS_CONFIGURED(slot))
        {
                for (i=0; i < MODULE_NUMBER_OF_PORTS(slot); i++)
                {
                        port_index = MAKE_PORTID(slot, i);
                        if(!IS_PORT_DB_VALID(port_index)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                continue;
                        set_mask_bit(sptr_cdb->port_mask1, port_index);
                }
                cu_show_interface_page(1, sptr_cdb->port_mask1, NEXT_PORT_INDEX_INVALID);
        }
        else
        {
                uprintf("Module in slot %d does not exist \n", sptr_cdb->integer1);
        }

}

void show_interfaces_by_stack(struct cdb* sptr_cdb)
{
        int stack = sptr_cdb->integer1;
        PORT_ID port_index;
        MODULE_ID module = MAKE_MODULE_ID(stack, 0);
        int i,j;

        if (!valid_integer1_value_range(sptr_cdb, START_STACKING_NUM, MAX_SYS_UNIT_NUM))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }
        sptr_cdb->stack_id = sptr_cdb->integer1;
        if (stack > MAX_SYS_UNIT_NUM || stack == 0 || !CONFIG_MODULE_EXIST(module))
        {
                uprintf("Error - stack unit %d does not exist\n", sptr_cdb->integer1);
                return;
        }

        for (j=0; j < MAX_LOCAL_SLOT; j++)
        {
        /* show all interfaces of one slot */
                if (MODULE_EXIST(module+j) || MODULE_IS_CONFIGURED(module+j))
                {
                        for (i=0; i < MODULE_NUMBER_OF_PORTS(module+j); i++)
                        {
                                port_index = MAKE_PORTID(module+j, i);
                                if(!IS_PORT_DB_VALID(port_index)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                        continue;
                                set_mask_bit(sptr_cdb->port_mask1, port_index);
                        }
                }
        }
        cu_show_interface_page(1, sptr_cdb->port_mask1, NEXT_PORT_INDEX_INVALID);
}
/****************************************************************************************
 * Name: show_interfaces_by_stack_group_name
 *
 * Description: This function displays the Port information in detailed mode for the devices under a particular 
 * 			 pe group keyed in by user.
 *			 When there is inavlid group name, error is thrown on the respective session.
 *			 This can be only executed by an Active controller.
 *
 * Input: pointer to cdbs structure.
 *
 * Return value: void
 *
 * ****************************************************************************************/

#ifdef __PORT_EXTENSION__
void show_interfaces_by_stack_group_name(struct cdb* sptr_cdb)
	{
		UINT8 pe_id_ary[PE_MAX_CHAIN_LEN] = {'0'};
		int i;
		if ((sptr_cdb->config_gen)|| (sptr_cdb->no))
			return;
	
		if (end_of_token(sptr_cdb->token) != '\0')
			return;
		sptr_cdb->dont_go_next = 1;
		if (IS_STACKING_ENABLED && !STACK_AM_I_MASTER && !STACK_AM_I_STANDALONE && !STACK_AM_I_CB_ENABLE)
		{
			uprintf("Error! this command is only allowed in Active Controller\n");
			return;
		}	 
	
		if( find_all_pe_id_from_a_pe_group(sptr_cdb->string1,&pe_id_ary) == -1)
		{
			uprintf("\nError: PE group %s does not exist\n",sptr_cdb->string1);
			return;
		}
		for(i=0;i<(PE_MAX_CHAIN_LEN);i++)
		{
			if(pe_id_ary[i])
			{
				sptr_cdb->integer1 = pe_id_ary[i];
				show_interfaces_by_stack(sptr_cdb);
			}
		}
	}
#endif __PORT_EXTENSION__


void show_interfaces_by_slot_brief(struct cdb* sptr_cdb)
{
        int slot = sptr_cdb->integer1-1;

        /* show all interfaces of one slot */
        if (MODULE_EXIST(slot))
        {
                /* 0==all ports, 1==ports of one slot, 2==one port */
                cu_show_interfaces(MAKE_PORTID(slot,0), 1, TRUE);
        }
        else
        {
                uprintf("Error : Invalid Slot Number\n");
        }
}

void show_interfaces_by_stack_brief(struct cdb* sptr_cdb)
{
        int stack = sptr_cdb->integer1;
        MODULE_ID module = MAKE_MODULE_ID(stack, 0);

        if (!valid_integer1_value_range(sptr_cdb, START_STACKING_NUM, MAX_SYS_UNIT_NUM))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }
        sptr_cdb->stack_id = sptr_cdb->integer1;
        /* show all interfaces of one slot */
        if (MODULE_EXIST(module) || MODULE_IS_CONFIGURED(module))
        {
                /* 0==all ports, 1==ports of one slot, 2==one port */
                cu_show_interfaces(MAKE_PORTID(module,0), 3, TRUE);
        }
}
/****************************************************************************************
 * Name: show_interfaces_by_stack_group_name_brief
 *
 * Description: This function displays the Port information in brief mode for a particular pe group keyed in by user.
 *			 When there is inavlid group name, error is thrown on the respective session.
 *			 This can be only executed by an Active controller.
 *
 * Input: pointer to cdbs structure.
 *
 * Return value: void
 *
 * ****************************************************************************************/

#ifdef __PORT_EXTENSION__
void show_interfaces_by_stack_group_name_brief(struct cdb* sptr_cdb)
	{
			UINT8 pe_id_ary[PE_MAX_CHAIN_LEN] = {'0'};
			int i;
			if ((sptr_cdb->config_gen)|| (sptr_cdb->no))
				return;
		
			if (end_of_token(sptr_cdb->token) != '\0')
				return;
			sptr_cdb->dont_go_next = 1;
			if (IS_STACKING_ENABLED && !STACK_AM_I_MASTER && !STACK_AM_I_STANDALONE && !STACK_AM_I_CB_ENABLE)
			{
				uprintf("Error! This CLI operation is only allowed on the Active Controller\n");
				return;
			}	 
		
			if( find_all_pe_id_from_a_pe_group(sptr_cdb->string1,&pe_id_ary) == -1)
			{
				uprintf("\nError: PE group %s does not exist\n",sptr_cdb->string1);
				return;
			}
			for(i=0;i<(PE_MAX_CHAIN_LEN);i++)
			{
				if(pe_id_ary[i])
				{
					sptr_cdb->integer1 = pe_id_ary[i];
					show_interfaces_by_stack_brief(sptr_cdb);
				}
			}
		}
#endif __PORT_EXTENSION__


#ifndef NO_MULTI_MIRROR

void gi_show_one_monitor_port(PORT_ID port)
{
        PORT_MASK mirror_mask[MAX_SLOT];

        clear_mask(mirror_mask);
                if(!IS_PORT_DB_VALID(port))
                        return;


        if ((SPTR_PORT_DB(port)->port_config.rx_mirror_port_id != PORT_INDEX_INVALID)
                        && (SPTR_PORT_DB(port)->port_config.being_monitored & CU_MONITOR_PORT_INPUT))
                set_mask_bit(mirror_mask, SPTR_PORT_DB(port)->port_config.rx_mirror_port_id);

        if (cu_show_port_list(mirror_mask, "  Input mirrored by\t", cu_line_buf, sizeof(cu_line_buf)))
                uprintf(cu_line_buf);

        clear_mask(mirror_mask);

        if ((SPTR_PORT_DB(port)->port_config.tx_mirror_port_id != PORT_INDEX_INVALID)
                        && (SPTR_PORT_DB(port)->port_config.being_monitored & CU_MONITOR_PORT_OUTPUT))
                set_mask_bit(mirror_mask, SPTR_PORT_DB(port)->port_config.tx_mirror_port_id);

        if (cu_show_port_list(mirror_mask, "  Output mirrored by\t", cu_line_buf, sizeof(cu_line_buf)))
                uprintf(cu_line_buf);

}

void gi_show_one_mirror_port(PORT_ID mirror_port)
{
        PORT_MASK monitor_mask[MAX_SLOT];
        PORT_ID port;
        UINT8 mode;
        UINT32 i;
        enum BOOLEAN input_mirror = FALSE;
        enum BOOLEAN output_mirror = FALSE;

        PORT_MASK monitor_mask_tx[MAX_SLOT];

        clear_mask(monitor_mask);
        clear_mask(monitor_mask_tx);

        uprintf("Mirror port %p\n", mirror_port);

        for (i=0; i < g_hw_info.total_config_ports; i++)
        {
                port = sw_config_port_list[i];
                                if(!IS_PORT_DB_VALID(port))
                                        continue;
                if ((SPTR_PORT_DB(port)->port_config.being_monitored & CU_MONITOR_PORT_INPUT) &&
                                (SPTR_PORT_DB(port)->port_config.rx_mirror_port_id == mirror_port)
                                )
                        set_mask_bit(monitor_mask, port);

                if ((SPTR_PORT_DB(port)->port_config.being_monitored & CU_MONITOR_PORT_OUTPUT) &&
                                (SPTR_PORT_DB(port)->port_config.tx_mirror_port_id == mirror_port)
                                )
                        set_mask_bit(monitor_mask_tx, port);
        }

        if (cu_show_port_list(monitor_mask, "  Input monitoring\t", cu_line_buf, sizeof(cu_line_buf)))
                uprintf(cu_line_buf);

        if (cu_show_port_list(monitor_mask_tx, "  Output monitoring\t", cu_line_buf, sizeof(cu_line_buf)))
                uprintf(cu_line_buf);

}


void show_one_monitor_port(PORT_ID port)
{
        gi_show_one_monitor_port(port);
}

void show_one_mirror_port(PORT_ID mirror_port)
{
        gi_show_one_mirror_port(mirror_port);
}

void show_mirror_ports(struct cdb* sptr_cdb)
{
        PORT_ID port;
        UINT8 flag;
        int i;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        flag = 0;

        if (sptr_cdb->if1)
        {
                port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

                if (sw_pp_is_port_mirror(port) == CU_MONITOR_PORT_OFF)
                        uprintf("Error - port %p is not a mirror port\n", port);
                else
                        show_one_mirror_port(port);

                return;
        }
        else
        {
                for (i = 0; i < g_hw_info.total_config_ports; i++)
                {
                        port = sw_config_port_list[i];

                        if (sw_pp_is_port_mirror(port) != CU_MONITOR_PORT_OFF)
                                show_one_mirror_port(port);
                }
        }
}

void show_monitor_ports(struct cdb* sptr_cdb)
{
        PORT_ID port,i;
        UINT8 mode;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->if1)
        {
                port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
                if (CU_OK != cu_get_being_monitored_port_mode(port, &mode))
                {
                        uprintf("Error - port %p is not a valid port\n", port);
                        return;
                }
                if (mode == CU_MONITOR_PORT_OFF)
                {
                        uprintf("Port %p is not monitored\n", port);
                        return;
                }

                show_one_monitor_port(port);
        }
        else
        {
                for (i=0; i < g_hw_info.total_config_ports; i++)
                {
                        port = sw_config_port_list[i];

                        if (CU_OK != cu_get_being_monitored_port_mode(port, &mode))
                                continue;
                        if (mode == CU_MONITOR_PORT_OFF)
                                continue;

                        uprintf("Monitored Port %p\n", port);
                        show_one_monitor_port(port);
                }
        }
}

#else NO_MULTI_MIRROR
void show_monitor_ports(struct cdb* sptr_cdb)
{
        int port;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (g_sw_sys.monitor_port == INVALID_MONITOR_PORT_NUMBER)
                uprintf("Mirror Interface:\tnone\n");
        else
                uprintf("Mirror Interface:\t%s %p\n", get_port_type_str(g_sw_sys.monitor_port), get_port_num(g_sw_sys.monitor_port));
        uprintf("Monitored Interfaces:\n");
        uprintf("\tBoth\t\tInput\t\tOutput\n");
        uprintf("\t---------------------------------------------------\n");

        for (port=0; port < g_hw_info.total_ports; port++)
        {
                PORT_ID port_id;
                UINT8 mode;

                port_id = sw_swport_list[port];
                if (!IS_PORT_ENET(port_id))
                        continue;
                if (CU_OK != cu_get_being_monitored_port_mode(port_id, &mode))
                        continue;
                switch (mode)
                {
                case CU_MONITOR_PORT_INPUT_OUTPUT:
                uprintf("\t%s %p\n", get_port_type_str(port_id), get_port_num(port_id));
                break;

                case CU_MONITOR_PORT_INPUT:
                uprintf("\t\t\t%s %p\n", get_port_type_str(port_id), get_port_num(port_id));
                break;

                case CU_MONITOR_PORT_OUTPUT:
                uprintf("\t\t\t\t\t%s %p\n", get_port_type_str(port_id), get_port_num(port_id));
                break;
                }
        }
}
#endif NO_MULTI_MIRROR

void show_default(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
         sptr_cdb->dont_go_next = 1;
         cu_show_all_default();
        }
}

void show_default_val(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        cu_show_all_default_val();
}


void show_startConfig(struct cdb* sptr_cdb)
{
        int result = 0;
        UINT32 handle = FLASH_MAX_ERR;
        UINT8 *buf;
        struct cdb      *my_cdb=NULL;

        if (sptr_cdb->config_gen)
          return;

#ifdef __PORT_EXTENSION__       
	if(STACK_AM_I_PE || STACK_AM_I_PE_ENABLE)
	{
		if(g_display_startup_config == 0)
		{
			print_config_from_spx_pe_boot();
			return;
		}
		uprintf("*** display startup configuration used in switch/router (not PE) ***\n");
	}
#endif __PORT_EXTENSION__       
        if ((my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb))) == NULL)
                return;
        if ((buf = get_config_buffer(sptr_cdb->ui_port)) == NULL)
        {
                dy_free(my_cdb);
                return;
        }
        *buf = 0;
        sptr_cdb->buffer = sptr_cdb->buffer_base = buf;
        sptr_cdb->gen_to = GEN_TO_TERMINAL;

        *my_cdb = *sptr_cdb;

        result = nt_read_config_file(sptr_cdb->buffer, max_config_size);

        if (result != 0) {
                if (result != -2)  /* -2 means empty config data */
                        uprintf("Error - failed to flash read.\n");
                free_config_buffer(sptr_cdb->buffer_base);
                dy_free(my_cdb);
                return; /* error */
        }


        /*****************************************************************/
        /*   This is only for scp. Since I don't want another copy of    */
        /*   this function.                                              */
        /*****************************************************************/
        if(!sptr_cdb->scp_in_progress)   /* for scp only */
        {
                uprintf("!\nStartup-config data location is flash memory\n!\n");
                show_config_to_terminal(my_cdb, "Startup configuration:\n!\n");
        }
        else
        {
                free_config_buffer(sptr_cdb->buffer_base);
                dy_free(my_cdb);
        }
}
void show_startConfig_pe(struct cdb* sptr_cdb)
{
	g_display_startup_config = 1;
	show_startConfig(sptr_cdb);
	g_display_startup_config = 0;
}

void show_arp_one(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        ip.arp.arp_cu_vrf_index[g_uprintf_dest] = sptr_cdb->vrf_idx;

#ifdef SR_SWITCH_ROUTER
        arp_print_table_by_ip(sptr_cdb->ip1, NULL);
#else
        cu_show_arp(sptr_cdb->ip1, 0);  /* show one ARP entry. */
#endif /* SR_SWITCH_ROUTER */
}

void show_arp_ip_address_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
#ifdef SR_SWITCH_ROUTER
        arp_print_table_by_ip(sptr_cdb->ip1, sptr_cdb->ip2);    /* page mode print */
#else
        cu_show_arp(sptr_cdb->ip1, sptr_cdb->ip2);
#endif /* SR_SWITCH_ROUTER */
}

void show_arp_enet_num(struct cdb* sptr_cdb)
{
        PORT_ID  port_number = sptr_cdb->if1-1;

        if (sptr_cdb->config_gen)
                return;

        if (!validate_interface_value(sptr_cdb, 1, ANY_INTERFACE))
                return;

#ifdef SR_SWITCH_ROUTER
        arp_print_table_by_enet(port_number);   /* page mode print */
#else
        cu_show_arp_by_enet(port_number);       /* show all ARP entries. */
#endif /* SR_SWITCH_ROUTER */
}

//#ifdef TANTO   //TBDTANTO
void show_tanto_unit_rear_module()
{
	int oper_mode = stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_OPER);
	int config_mode = stack_get_tanto_rear_module_info(NULL, TANTO_REAR_INFO_CONFIG);

	if(oper_mode <= 0){ //1 means running module
		uprintf("Failed to get operational rear module info \n");
		return;
	}

	if(config_mode <= 0){ //1 means running module
		uprintf("Failed to get configuration rear module info \n");
		return;
	}
	switch (oper_mode)
	{
		case TANTO_REAR_MODULE_STACK_100G:
			uprintf("The rear module operates in stacking mode with 100G speed.\n");
			break;
		case TANTO_REAR_MODULE_STACK_40G:
			uprintf("The rear module operates in stacking mode with 40G speed.\n");
			break;
		case TANTO_REAR_MODULE_UPLINK_100G:
			uprintf("The rear module operates in uplink mode with 100G speed. \n");
			break;
		case TANTO_REAR_MODULE_UPLINK_40G:
			uprintf("The rear module operates in uplink mode with 40G speed. \n");
			break;
		default:
			uprintf("Warning: Unknown rear module id (%x) !\n", oper_mode);
			break;
	}
	switch (config_mode)
	{
		case TANTO_REAR_MODULE_STACK_100G:
			uprintf("The rear module is configured in stacking mode with 100G speed.\n");
			break;
		case TANTO_REAR_MODULE_STACK_40G:
			uprintf("The rear module is configured in stacking mode with 40G speed.\n");
			break;
		case TANTO_REAR_MODULE_UPLINK_100G:
			uprintf("The rear module is configured in uplink mode with 100G speed. \n");
			break;
		case TANTO_REAR_MODULE_UPLINK_40G:
			uprintf("The rear module is configured in uplink mode with 40G speed. \n");
			break;
		default:
			uprintf("Warning: Unknown rear module id (%x) !\n", config_mode);
			break;
	}

}

void show_tanto_rear_module(struct cdb* sptr_cdb){
    if(sptr_cdb->config_gen)
        return;
    if (end_of_token(sptr_cdb->token) != '\0')
        return; /* cmd not for me */
    sptr_cdb->dont_go_next = 1;
   
    show_tanto_unit_rear_module();

}


//#endif //TANTO
	
	
	
	
	
	
	
void show_arp_mgmt_num(struct cdb* sptr_cdb)
{
        PORT_ID  port_number = sptr_cdb->integer1;

        if (sptr_cdb->config_gen)
                return;

        if ( port_number > MAX_PORT_PER_MGMT )
                return;

        port_number = mport_id_get();

        if ( BAD_PORT_ID == port_number )
                return;

#ifdef SR_SWITCH_ROUTER
        arp_print_table_by_enet(port_number); /* page mode print */
#else
        cu_show_arp_by_enet(port_number);       /* show all ARP entries. */
#endif /* SR_SWITCH_ROUTER */
}
// BUG:53084 arp watch dog reset
void show_arp_resource(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        cu_show_arp_resource();
}
void show_arp_mac_address_one(struct cdb* sptr_cdb)
{
        MAC_ADDRESS *p_mac;
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        ip.arp.arp_cu_vrf_index[g_uprintf_dest] = sptr_cdb->vrf_idx;


        sptr_cdb->dont_go_next = 1;
        p_mac = (MAC_ADDRESS *)sptr_cdb->mac2;

        p_mac->_ushort = 0xFFFF;
        p_mac->_ulong = 0xFFFFFFFF;
#ifdef SR_SWITCH_ROUTER
        arp_print_table_by_mac((MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2); /* page mode print */
#else
        cu_show_arp_by_mac((MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2);
#endif /* SR_SWITCH_ROUTER */
}

void show_arp_mac_address_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        ip.arp.arp_cu_vrf_index[g_uprintf_dest] = sptr_cdb->vrf_idx;

#ifdef SR_SWITCH_ROUTER
        arp_print_table_by_mac((MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2); /* page mode print */
#else
        cu_show_arp_by_mac((MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2);
#endif /* SR_SWITCH_ROUTER */
}

void show_arp (struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        ip.arp.arp_cu_vrf_index[g_uprintf_dest] = sptr_cdb->vrf_idx;

#ifdef SR_SWITCH_ROUTER
        //Cheetah_stacking, superX safe.
    if (STACK_AM_I_SLAVE) //87599
                return;
        arp_print_table(0xFFFF);                        /* page mode print */
#else
        cu_show_arp(0, 0);      /* show all ARP entries. */
#endif /* SR_SWITCH_ROUTER */
}

void show_arp_inspec(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

#ifdef SR_SWITCH_ROUTER
        arp_print_table(0xFFFF);                        /* page mode print */
#else
        cu_show_arp_inspec(0, 0);       /* show all ARP entries. */
#endif /* SR_SWITCH_ROUTER */
}
#ifdef SR_SWITCH_ROUTER
void show_static_arp_one(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        static_arp_print_table_by_ip(sptr_cdb->ip1, 0);
}

void show_static_arp_ip_address_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        static_arp_print_table_by_ip(sptr_cdb->ip1, sptr_cdb->ip2);     /* page mode print */
}

void show_static_arp_enet_num(struct cdb* sptr_cdb)
{
        int  port_number = sptr_cdb->if1-1;

        if (sptr_cdb->config_gen)
                return;

        if (!validate_interface_value(sptr_cdb, 1, ANY_INTERFACE))
                return;

        static_arp_print_table_by_enet(port_number);    /* page mode print */
}

void show_static_arp_mac_address_one(struct cdb* sptr_cdb)
{
        MAC_ADDRESS *p_mac;
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;
        p_mac = (MAC_ADDRESS *)sptr_cdb->mac2;

        p_mac->_ushort = 0xFFFF;
        p_mac->_ulong = 0xFFFFFFFF;

        static_arp_print_table_by_mac((MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2);  /* page mode print */
}

void show_static_arp_mac_address_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        static_arp_print_table_by_mac((MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2);  /* page mode print */
}
#endif
void show_static_arp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        //Cheetah_stacking
        if(STACK_AM_I_SLAVE) //87617
                return;

        static_arp_print_table(0xFFFF);                 /* page mode print */

        static_arp_inspect_print_table(1, TRUE, 0);
}


#ifdef SR_SWITCH_ONLY
/* following code for supporting display of l3 host entries
whne l3 switching is turned on
*/

void show_ip_l3cache_address_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        /* show all l3 host entries. matching address with mask */
        cu_show_ip_l3cache((UINT32 *) &sptr_cdb->ip1, (UINT32 *) &sptr_cdb->ip2);
}

void show_ip_l3cache_address(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        /* show all l3 host entries. matching address  */
        cu_show_ip_l3cache((UINT32 *) &sptr_cdb->ip1, (UINT32 *) NULL);
}

void show_ip_l3cache(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

#ifndef CACHE_ICMP_PROXY
#ifndef NETFLOW
        if (!g_ip_switch_enabled)
        {
                sptr_cdb->dont_go_next = 1;
                uprintf("command is valid only when ip switching is enabled\n");
                return;
        }
#endif NETFLOW
#endif


        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        /* show all l3 host entries */
        cu_show_ip_l3cache((UINT32 *)NULL, (UINT32 *)NULL );

}

#endif


#ifdef SR_SWITCH_ROUTER
void show_arp_with_index(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        if (cli_set_vrf((sptr_cdb->num_of_string == 0) ? NULL : sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                return;
        ip.arp.arp_cu_vrf_index[g_uprintf_dest] = sptr_cdb->vrf_idx;
        arp_print_table((UINT16)sptr_cdb->integer1);                    /* indexed print */
}

void show_static_arp_with_index(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        static_arp_print_table((UINT16)sptr_cdb->integer1);             /* indexed print */
}
#endif /* SR_SWITCH_ROUTER */

void show_vlan(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;
#ifndef NO_MULTI_CONFIG_VLAN
        sptr_cdb->vlan_entries_skip = 0;
        sptr_cdb->vlan_id_action_next = 0;
        if (sptr_cdb->mode == CONFIG_MVLAN)
        {
                cu_show_new_all_vlan(TRUE, PORT_INDEX_INVALID, sptr_cdb);
        }
        else
#endif NO_MULTI_CONFIG_VLAN
        cu_show_all_vlan(TRUE, PORT_INDEX_INVALID, 0);
}

/* ------- Target functions for the "show span commands - bug 7244 -------- */

/* target function for "show span" */
void show_stp_no_vlan(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and ports - non-detail mode */
        cu_show_span(sptr_cdb, 0, 0, 0, FALSE, FALSE, FALSE);
}
#ifdef INCLUDE_MCT
void show_cluster_stp_no_vlan(struct cdb* sptr_cdb)
{ UINT16 cluster_id;
  CLUSTER_ENTRY *p_cluster_entry;

        sptr_cdb->integer13 = 1;//This is to indicate that all STP call will be executed for the cluster.
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        cluster_id=sptr_cdb->integer1;

        //000470233- handle if cluster name is entered instead of id
        if(cluster_id == 0)
        {
                UINT8 *cluster_name = sptr_cdb->string1;
                
                // verify cluster name
                if (!validate_string_length(sptr_cdb, 1, 1, CLUSTER_MAX_NAME_LEN))
                        return;

                if((p_cluster_entry = clusterlib_get_entry_from_name(cluster_name)) == NULL)
                {
                        uprintf("cluster %s is not configured\n", cluster_name);
                        return;
                }
        }
        else if((p_cluster_entry = clusterlib_get_entry_from_id(cluster_id)) == NULL)
        {
                uprintf("cluster id %d is not configured\n", cluster_id);
                return;
        }
        /* show all vlans and ports - non-detail mode */
        cu_show_cluster_span(sptr_cdb, 0, 0, 0, FALSE, FALSE, FALSE);
}

/* target function for "show cluster XXX span detail" */
void show_cluster_stp_detail(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports in detail mode */
        cu_show_cluster_span(sptr_cdb, 0, 0, 0, TRUE, FALSE, FALSE);
}


/* target function for "show span detail vlan <id>" */
void show_cluster_stp_detail_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all ports of given vlan in detail mode */
        cu_show_cluster_span(sptr_cdb, sptr_cdb->integer2, 0, 0, TRUE, FALSE, FALSE);
}


/* target function for "show span vlan <id>" */
void show_cluster_stp_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* bug 11493 */
        if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > MAX_VLAN_ID) {
                uprintf("Error - %d is an invalid port-vlan id.\n", sptr_cdb->integer1);
                sptr_cdb->dont_go_next = 1;
                return;
        }

        /* show all ports of given vlan in non-detail mode */
        cu_show_cluster_span(sptr_cdb, sptr_cdb->integer2, 0, 0, FALSE, FALSE, FALSE);
}
#ifdef INCLUDE_802_1W

void show_cluster_rstp_no_vlan(struct cdb* sptr_cdb)
{
        UINT16 cluster_id;
        CLUSTER_ENTRY *p_cluster_entry;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        cluster_id=sptr_cdb->integer1;
        //000470233- handle if cluster name is entered instead of id
        if(cluster_id == 0)
        {
                UINT8 *cluster_name = sptr_cdb->string1;

                // verify cluster name
                if (!validate_string_length(sptr_cdb, 1, 1, CLUSTER_MAX_NAME_LEN))
                        return;

                if((p_cluster_entry = clusterlib_get_entry_from_name(cluster_name)) == NULL)
                {
                        uprintf("cluster %s is not configured\n", cluster_name);
                        return;
                }
        }
        else if((p_cluster_entry = clusterlib_get_entry_from_id(cluster_id)) == NULL)
        {
                uprintf("cluster id %d is not configured\n", cluster_id);
                return;
        }

        /* show all vlans and ports - non-detail mode */
        cu_show_cluster_span(sptr_cdb, 0, 0, 0, FALSE, TRUE, FALSE);
}

/* target function for "show 802-1w detail" */
void show_cluster_rstp_detail(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports in detail mode */
        cu_show_cluster_span(sptr_cdb, 0, 0, 0, TRUE, TRUE, FALSE);
}
/* target function for "show 802-1w vlan <id>" */
void show_cluster_rstp_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all ports of given vlan in non-detail mode */
        cu_show_cluster_span(sptr_cdb, sptr_cdb->integer2, 0, 0, FALSE, TRUE, FALSE);
}

/* target function for "show 802-1w detail vlan <id>" */
void show_cluster_rstp_detail_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all ports of given vlan in detail mode */
        cu_show_cluster_span(sptr_cdb, sptr_cdb->integer2, 0, 0, TRUE, TRUE, FALSE);
}
#endif

#endif
/* target function for "show span fast-uplink-span" */
void show_stp_no_vlan_uplink(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and ports - non-detail mode */
        cu_show_span(sptr_cdb, 0, 0, 0, FALSE, FALSE, TRUE);
}

/* target function for "show span <n>" */
void show_stp_skip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports but skip integer1 number
         * of entries before beginning to print - non-detail mode
         */
        cu_show_span(sptr_cdb, 0, 0, sptr_cdb->integer1, FALSE, FALSE, FALSE);
}

/* target function for "show span vlan <id>" */
void show_stp_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* bug 11493 */
        if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > MAX_VLAN_ID) {
                uprintf("Error - %d is an invalid port-vlan id.\n", sptr_cdb->integer1);
                sptr_cdb->dont_go_next = 1;
                return;
        }

        /* show all ports of given vlan in non-detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, 0, 0, FALSE, FALSE, FALSE);
}

/* target function for "show span vlan <id> fast-uplink-span" */
void show_stp_Id_uplink(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* bug 11493 */
        if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > MAX_VLAN_ID) {
                uprintf("Error - %d is an invalid port-vlan id.\n", sptr_cdb->integer1);
                sptr_cdb->dont_go_next = 1;
                return;
        }

        /* show all ports of given vlan in non-detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, 0, 0, FALSE, FALSE, TRUE);
}

/* target function for "show span vlan <id> pos/atm/ethernet <port number>" */
void show_stp_by_vlan_port(struct cdb* sptr_cdb)
{
        PORT_ID         port_id;
        UINT16          vlan_id;
        UINT8           if_type;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        switch (sptr_cdb->port_mask_type) {
                case POS : if_type = POS_INTERFACE; break;
                case ATM : if_type = ATM_INTERFACE; break;
                case ETHERNET : if_type = ENET_INTERFACE; break;
                case VLAG : if_type = LAG_INTERFACE; break;
                default : uprintf("Error - unknown interface type\n"); return;
        }

        if (!validate_interface_value(sptr_cdb, 1, if_type))
                return;

        /* show all ports of given vlan in non-detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, sptr_cdb->if1, 0, FALSE, FALSE, FALSE);
}

#ifndef __NO_PVST__
/* target function for "show span pvst-mode" */
void show_stp_pvst(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        cu_show_stp_pvst_mode();
}
#endif __NO_PVST__

void show_stp_rootguard(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        cu_show_root_guard();   /* 100179 - HAL function is created */
}


void show_stp_designatedguard(struct cdb* sptr_cdb)//000464738
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        cu_show_designated_guard();   /* 100179 - HAL function is created */
}


void show_stp_bpduguard(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        cu_show_bpdu_guard();   /* 100179 - HAL function is created */
}

#ifdef FI_PROTECTED_PORTS
void show_protected_ports(struct cdb* sptr_cdb)
{
         if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        cu_show_protected_ports();
}
#endif

/* target function for "show span detail" */
void show_stp_detail(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
#ifdef INCLUDE_MCT
        if(sptr_cdb->integer13)
        {
                cu_show_cluster_span(sptr_cdb, 0, 0, 0, TRUE, FALSE, FALSE);
                return;
        }
#endif

        /* show all vlans and all ports in detail mode */
        cu_show_span(sptr_cdb, 0, 0, 0, TRUE, FALSE, FALSE);
}

/* target function for "show span detail <n>" */
void show_stp_detail_skip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports but skip integer1 number
         * of entries before beginning to print in detail mode
         */
        cu_show_span(sptr_cdb, 0, 0, sptr_cdb->integer1, TRUE, FALSE, FALSE);
}

/* target function for "show span detail vlan <id>" */
void show_stp_detail_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all ports of given vlan in detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, 0, 0, TRUE, FALSE, FALSE);
}

#ifdef INCLUDE_802_1W
/* Target functions of IEEE 802.1W show commands */

/* target function for "show 802-1w" */
void show_rstp_no_vlan(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and ports - non-detail mode */
        cu_show_span(sptr_cdb, 0, 0, 0, FALSE, TRUE, FALSE);
}
/* target function for "show 802-1w <n>" */
void show_rstp_skip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports but skip integer1 number
         * of entries before beginning to print - non-detail mode
         */
        cu_show_span(sptr_cdb, 0, 0, sptr_cdb->integer1, FALSE, TRUE, FALSE);
}

/* target function for "show 802-1w vlan <id>" */
void show_rstp_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all ports of given vlan in non-detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, 0, 0, FALSE, TRUE, FALSE);
}

/* target function for "show 802-1w detail" */
void show_rstp_detail(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports in detail mode */
        cu_show_span(sptr_cdb, 0, 0, 0, TRUE, TRUE, FALSE);
}

/* target function for "show 802-1w detail <n>" */
void show_rstp_detail_skip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all vlans and all ports but skip integer1 number
         * of entries before beginning to print in detail mode
         */
        cu_show_span(sptr_cdb, 0, 0, sptr_cdb->integer1, TRUE, TRUE, FALSE);
}

/* target function for "show 802-1w detail vlan <id>" */
void show_rstp_detail_Id(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        /* show all ports of given vlan in detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, 0, 0, TRUE, TRUE, FALSE);
}
#endif INCLUDE_802_1W

/* target function for "show span detail vlan <id> pos/atm/ethernet <port number>" */
void show_stp_detail_by_vlan_port(struct cdb* sptr_cdb)
{
        PORT_ID         port_id;
        UINT16          vlan_id;
        UINT8           if_type;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        switch (sptr_cdb->port_mask_type) {
                case POS : if_type = POS_INTERFACE; break;
                case ATM : if_type = ATM_INTERFACE; break;
                case ETHERNET : if_type = ENET_INTERFACE; break;
                case VLAG: if_type = LAG_INTERFACE; break;
                default : uprintf("Error - unknown interface type\n"); return;
        }

        if (!validate_interface_value(sptr_cdb, 1, if_type))
                return;

        /* show all ports of given vlan in detail mode */
        cu_show_span(sptr_cdb, sptr_cdb->integer1, sptr_cdb->if1, 0, TRUE, FALSE, FALSE);
}

#ifndef NO_STATIC_MMAC
void show_mmac(struct cdb* sptr_cdb)
{
        UINT32 i;
        UINT32 mac_index;
        MAC_STATION *sptr_mac_entry;
        PORT_MASK temp_mask[MAX_SLOT];

        if(!sptr_cdb->config_gen)
        {
                mac_index = mac_find_entry_index((MAC_ADDRESS *)sptr_cdb->mac1, sptr_cdb->integer1);
                if(mac_index == MAC_INDEX_INVALID)
                {
                        uprintf("Error - no such MAC entry.\n");
                        return;
                }

                sptr_mac_entry = (MAC_STATION *)(g_sptr_mac_station_db + mac_index);

                if(!sptr_mac_entry->mmac_idx)
                {
                        uprintf("Error - not a MMAC entry.\n");
                        return;
                }

                uprintf("Primary port: %p\tFid: %8x\n",
                        sptr_mac_entry->port_number,
                        g_sw_sys.mmac_fid[sptr_mac_entry->mmac_idx]);

                if (cu_show_port_list(g_sw_sys.mmac_entry[sptr_mac_entry->mmac_idx].mmac_portmask, "SW Ports", cu_line_buf, sizeof(cu_line_buf)))
                        uprintf(cu_line_buf);
/* we need to remove mmac_fid */
//              sw_hwmask_to_swmask(g_fid_table[g_sw_sys.mmac_fid[sptr_mac_entry->mmac_idx]].fid_portmask, temp_mask);
//              if (cu_show_port_list(temp_mask, "HW Ports", cu_line_buf, sizeof(cu_line_buf)))
//                      uprintf(cu_line_buf);
        }
}
#endif NO_STATIC_MMAC

void show_station(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
#ifndef NO_MULTI_CONFIG_VLAN
                if (sptr_cdb->mode == CONFIG_MVLAN || sptr_cdb->parent_mode == CONFIG_MVLAN)
                {
                        show_mac_mvlan(sptr_cdb);
                }
                else
#endif NO_MULTI_CONFIG_VLAN
                /* show all mac addresses */
                cu_show_station(
                        0,
                        0,
                        (MAC_ADDRESS *) 0,
                        (MAC_ADDRESS *) 0);
        }
}

extern UINT8 g_show_station_all;
void show_station_all(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                g_show_station_all = 1;
                /* show all mac addresses */
                cu_show_station(
                        0,
                        0,
                        (MAC_ADDRESS *) 0,
                        (MAC_ADDRESS *) 0);
                g_show_station_all = 0;
        }
}

void show_mac_statistics(struct cdb *sptr_cdb)
{
        if (!sptr_cdb->config_gen) {
                cu_show_mac_statistics();
        }
}

void show_station_for_port(struct cdb* sptr_cdb)
{
        int slot;
        PORT_ID port;
#ifdef SM_MASTER
        PORT_ID slot_index, slot_port;
#endif SM_MASTER

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;

#ifdef SM_MASTER
                port = (int) sptr_cdb->integer1;
                sm_get_slot_and_port(port, &slot_index, (PORT_ID *)&slot_port);
                if (slot_index)
                {
                        if ((slot_port <= 0) || (slot_port > g_sm_slave[slot_index].slot_port_cnt-1))
                        {
                                uprintf("Error - invalid port number.\n");
                                return;
                        }
                }
                else
#endif SM_MASTER
#ifdef SM_MASTER
                if ((port < 1) || (port > cu_get_max_port(FMP_MASTER_SLOT)))
                {
                uprintf("Error - invalid port number.\n");
                return;
                }
#else
                /* BUG: 8832 need to be strict on what type of port user specifies */
                if (
                        ((sptr_cdb->flag1 == 3) && !validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                        )
                {
                uprintf("Error - invalid port number.\n");
                return;
                }
#endif SM_MASTER

                slot=INTERFACE_SLOT(sptr_cdb->if1);
                port=INTERFACE_PORT(sptr_cdb->if1);

                /* show all mac addresses for the requested port */
                cu_show_station(slot, port, (MAC_ADDRESS *) 0, (MAC_ADDRESS *) 0);
        }
}

void show_station_for_mgmt_port(struct cdb* sptr_cdb)
{
        int slot;
        PORT_ID port;


        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;


                port = (int) sptr_cdb->integer1;

                if (((sptr_cdb->flag1 != 6) && MAX_PORT_PER_MGMT < port ))
                {
                        uprintf("Error - invalid port number.\n");
                        return;
                }

                port = mport_id_get();

                if ( BAD_PORT_ID == port )
                        return;

                slot=INTERFACE_SLOT(PORT_ID_TO_INTERFACE(port));
                port=INTERFACE_PORT(PORT_ID_TO_INTERFACE(port));


                /* show all mac addresses for the requested port */
                cu_show_station(slot, port, (MAC_ADDRESS *) 0, (MAC_ADDRESS *) 0);
        }
}

void show_station_address(struct cdb* sptr_cdb)
{
        int slot;
        PORT_ID port;

        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;

                if ((int) sptr_cdb->num_of_if == 0)
                {
                        slot = 0;
                        port = 0;
                }
                else
                {
#ifdef SM_MASTER
                        port = (int) sptr_cdb->integer1;
                        if ((port < 1) || (port > cu_get_max_port(FMP_MASTER_SLOT)))
                        {
                        uprintf("Error - invalid port number.\n");
                        return;
                        }
#else
                        if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                                return;
#endif
                        slot=INTERFACE_SLOT(sptr_cdb->if1);
                        port=INTERFACE_PORT(sptr_cdb->if1);
                }
                /* if port number is 0, show the requested mac address
                 * from any ports; if port is a valid port number, show
                 * the requested mac address from that port.
                 */
                cu_show_station(slot, port, (MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) 0);
        }
}

void show_station_address_mask(struct cdb* sptr_cdb)
{
        int slot;
        PORT_ID port;

        if (sptr_cdb->config_gen)
          return;

        if ((int) sptr_cdb->num_of_integer == 0)
        {
                slot = 0;
                port = 0;
        }
        else
        {
#ifdef SM_MASTER
                port = (int) sptr_cdb->integer1;
                if ((port < 1) || (port > cu_get_max_port(FMP_MASTER_SLOT)))
                {
                uprintf("Error - invalid port number.\n");
                return;
                }
#else
                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                        return;
#endif
                slot=INTERFACE_SLOT(sptr_cdb->if1);
                port=INTERFACE_PORT(sptr_cdb->if1);
        }

        /* if port number is 0, show the requested mac address
         * with the applied address mask from any ports; if port
         * is a valid port number, show the requested mac address
         * with the applied address mask from that port.
         */
        cu_show_station(slot, port, (MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2);
}

/*
 * show_mac_vlan_address: display a particular mac entry for
 *                        a specific vlan.
 */
void show_mac_vlan_address (struct cdb* sptr_cdb)
{
    /*
     * verify input fields.
     */
    if ((sptr_cdb->config_gen)||
        (sptr_cdb->no))
        {
        return;
    }
    if (end_of_token(sptr_cdb->token) == '\0')
    {
        sptr_cdb->dont_go_next = 1;
        if (!valid_integer1_value_range(sptr_cdb, 1, CU_MAX_VLAN_ID_VAL))
        {
            return;
        }
        cu_show_mac_vlan(sptr_cdb->integer1, (MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) 0);
        if(is_mac_learning_flow_based())

                {
                        cu_show_flow_mac_on_devices(sptr_cdb->integer1, (MAC_ADDRESS *) sptr_cdb->mac1);
                }
    }
    return;
}

/*
 * show_mac_vlan_mask: displayss a list of mac entries
 *                     for specific vlan.
 */
void show_mac_vlan_mask (struct cdb* sptr_cdb)
{
    /*
     * verify input fields.
     */
    if ((sptr_cdb->config_gen)||
        (sptr_cdb->no))
        {
        return;
    }

    sptr_cdb->dont_go_next = 1;
    if (!valid_integer1_value_range(sptr_cdb, 1, CU_MAX_VLAN_ID_VAL))
    {
        return;
    }
    cu_show_mac_vlan(sptr_cdb->integer1, (MAC_ADDRESS *) sptr_cdb->mac1, (MAC_ADDRESS *) sptr_cdb->mac2);
    return;
}

/*
 * show_mac_vlan: this function gets called from CLI to display
 *                all mac entries specific to a particular vlan.
 */
void show_mac_vlan (struct cdb* sptr_cdb)
{
    /*
     * verify input fields.
     */
    if ((sptr_cdb->config_gen)||
        (sptr_cdb->no))
        {
        return;
    }
    if (end_of_token(sptr_cdb->token) == '\0')
    {
        sptr_cdb->dont_go_next = 1;
        if (!valid_integer1_value_range(sptr_cdb, 1, CU_MAX_VLAN_ID_VAL))
        {
            return;
        }
        /*
         * show mac table.
         */
        cu_show_mac_vlan(sptr_cdb->integer1,(MAC_ADDRESS *)0, (MAC_ADDRESS *)0);
    }
    return;
}

#ifndef NO_MULTI_CONFIG_VLAN
void show_mac_mvlan (struct cdb* sptr_cdb)
{
        /*
        * verify input fields.
        */
        if ((sptr_cdb->config_gen)||
                (sptr_cdb->no))
        {
                return;
        }
        if ((sptr_cdb->mode == CONFIG_MVLAN || sptr_cdb->parent_mode == CONFIG_MVLAN) &&
                (end_of_token(sptr_cdb->token) == '\0'))
        {
                sptr_cdb->dont_go_next = 1;
        /*
         * show mac table.
         */
                cu_show_mac_mvlan(sptr_cdb);
        }
        return;
}
#endif NO_MULTI_CONFIG_VLAN


//gets called after parsing of range of port numbers.
void show_statistics_common(struct cdb* sptr_cdb) // 73205
{
        cu_show_statistics_page(1, sptr_cdb->port_mask1, NEXT_PORT_INDEX_INVALID);
}
void show_statistics_common_callback(struct cdb* sptr_cdb) // 73205
{
        sptr_cdb->port_mask_callback = show_statistics_common;
        set_port_mask_type_enet(sptr_cdb);
}

void show_statistics_lag_callback(struct cdb* sptr_cdb) // 73205
{
        sptr_cdb->port_mask_callback = show_statistics_common;
        set_port_mask_type_vlag(sptr_cdb);
}

//gets called after "show statistics". The subsequence tokens are not yet parsed, eg. port ranges.
//calls show_statistics_common() after the port ranges are parsed, and port_mask1 is generated.
void show_statistics(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);
// 73205 We no longer needs callback.
//      sptr_cdb->port_mask_callback = show_statistics_common;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->mode == CONFIG_MIF)
                cu_show_statistics_page(1, sptr_cdb->mif_port_mask, NEXT_PORT_INDEX_INVALID);
        else
                cu_show_statistics_brief(NULL);
}

void show_statistics_brief_common(struct cdb* sptr_cdb) // 73205
{
        cu_show_statistics_brief(sptr_cdb->port_mask1);
        set_port_mask_type_enet(sptr_cdb);
}
void show_statistics_brief_common_callback(struct cdb* sptr_cdb) // 73205
{
        sptr_cdb->port_mask_callback = show_statistics_brief_common;
        set_port_mask_type_enet(sptr_cdb);
}

void show_statistics_brief(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);
//      sptr_cdb->port_mask_callback = show_statistics_brief_common; // 73205 no longer needed

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->mode == CONFIG_MIF)
                cu_show_statistics_brief(sptr_cdb->mif_port_mask);
        else
                cu_show_statistics_brief(NULL);
}

void show_statistics_stack_ports(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);
//      sptr_cdb->port_mask_callback = show_statistics_brief_common; // 73205 no longer needed

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        //if (sptr_cdb->mode == CONFIG_MIF)
        //      cu_show_statistics_brief(sptr_cdb->mif_port_mask);
        //else
        cu_show_statistics_stack_ports(sptr_cdb);
}
/*TR000569074 xwan*/
void show_statistics_spx_ports(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        cu_show_statistics_spx_ports(sptr_cdb);
}
static void show_statistics_by_slot_common(struct cdb* sptr_cdb, enum BOOLEAN brief)
{
        int slot = sptr_cdb->integer1-1;
        PORT_ID port_index;
        int i, j;

        if (sptr_cdb->stack_id == sptr_cdb->integer1)
        {
                MODULE_ID module;
                for (j=0; j < MAX_LOCAL_SLOT; j++)
                {
                        module = MAKE_MODULE_ID(sptr_cdb->stack_id, j);
                        if (MODULE_EXIST(module) || MODULE_IS_CONFIGURED(module))
                        {
                                for (i=0; i < MODULE_NUMBER_OF_PORTS(module); i++)
                                {
                                        port_index = MAKE_PORTID(module, i);
                                        if(!IS_PORT_DB_VALID(port_index)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                                continue;
                                        set_mask_bit(sptr_cdb->port_mask1, port_index);
                                }
                        }
                }
                if (brief)
                        cu_show_statistics_brief(sptr_cdb->port_mask1);
                else
                        cu_show_statistics_page(1, sptr_cdb->port_mask1, PORT_INDEX_INVALID);
        }
        else
        /* show all statistics of one slot */
        if (MODULE_EXIST(slot) || MODULE_IS_CONFIGURED(slot))
        {
                for (i=0; i < MODULE_NUMBER_OF_PORTS(slot); i++)
                {
                        port_index = MAKE_PORTID(slot, i);
                        if(!IS_PORT_DB_VALID(port_index)) // SIDEWINDER_BREAKOUT kklin, must check PORT_DB valid
                                continue;
                        set_mask_bit(sptr_cdb->port_mask1, port_index);
                }
                if (brief)
                        cu_show_statistics_brief(sptr_cdb->port_mask1);
                else
                        cu_show_statistics_page(1, sptr_cdb->port_mask1, PORT_INDEX_INVALID);
        }
        else
        {
                uprintf("Error : Invalid Slot Number\n");
        }
}

void show_statistics_by_slot(struct cdb* sptr_cdb)
{
        show_statistics_by_slot_common(sptr_cdb, FALSE);
}

void show_statistics_by_slot_brief(struct cdb* sptr_cdb)
{
        show_statistics_by_slot_common(sptr_cdb, TRUE);
}

void show_statistics_by_stack(struct cdb* sptr_cdb)
{
        if (!valid_integer1_value_range(sptr_cdb, START_STACKING_NUM, MAX_SYS_UNIT_NUM))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }
        sptr_cdb->stack_id = sptr_cdb->integer1;
        show_statistics_by_slot_common(sptr_cdb, FALSE);
}

void show_statistics_by_stack_brief(struct cdb* sptr_cdb)
{
        if (!valid_integer1_value_range(sptr_cdb, START_STACKING_NUM, MAX_SYS_UNIT_NUM))
        {
                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }
        sptr_cdb->stack_id = sptr_cdb->integer1;
        show_statistics_by_slot_common(sptr_cdb, TRUE);
}

void show_trunk(struct cdb* sptr_cdb)
{
        /* trunk telseon enhancement */
        UINT8 next_token;

        if (sptr_cdb->config_gen)
          return;

        next_token = tolower(end_of_token(sptr_cdb->token));

        if(sptr_cdb->help)
        {
                return;
        }

        if (!SET_TRUNK_FI_CLI_ONLY)
        {
                uprintf("CLI is in 8.0 LAG CLI only mode\n");
                return;
        }

        if (next_token == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                cu_show_trunk(INVALID_LOAD_SHARE_GROUP_ID);
        }
}

/* config cmds */
void boot_sys_config_gen(struct cdb* sptr_cdb)
{
        int i;
        char temp_p[] = "pri\n";                        /* primary */
        char temp_s[] = "sec\n";                        /* secondary */
        char temp_f[] = "boot sys fl ";         /* boot system flash */
#ifdef NOT_USED
        char temp_t[] = "boot sys tf ";         /* boot system tftp */
        char temp_b[] = "boot sys bo\n";        /* boot system bootp */
#endif NOT_USED

        /*
         * Notice that the BOOT code also searches for these "boot sys"
         * keywords from the configuration flash. Therefore, don't change
         * these syntax.
         * cli_parser_cmd_sys_boot_param() also uses "boot sys". Change
         * here must be reflected over there too.
         */
        if (sptr_cdb->config_gen != 0)
        { /* it's config gen */
                for (i = 0; i < MAX_BOOT_SEQ; i++)
                {
                        if (boot_seq[i] != BOOT_FROM_NONE)
                        {
                                switch(boot_seq[i])
                                {
                                case BOOT_FROM_FLASH_PRI:
                                        wr_config(sptr_cdb,temp_f);
                                        wr_config(sptr_cdb,temp_p);
                                        break;
                                case BOOT_FROM_FLASH_SEC:
                                        wr_config(sptr_cdb,temp_f);
                                        wr_config(sptr_cdb,temp_s);
                                        break;
                                case BOOT_FROM_TFTP:
                                        ksprintf(cu_line_buf, "boot sys tf %I %s\n",
                                                boot_ip,
                                                boot_file);
                                        wr_config(sptr_cdb, cu_line_buf);
                                        break;


                                case BOOT_FROM_BOOTP:
                                        wr_config(sptr_cdb, "boot sys bo\n");
                                        break;
                                }
                        }
                }
        }
}

int cu_get_port_speed(PORT_ID port, UINT8 config_f, enum PORT_SPEED *speedP);

static void set_if_speed_and_duplex(struct cdb* sptr_cdb)
{
    PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num), port_index2, port;
	UINT8 speed = sptr_cdb->integer1;
	UINT8 duplex =  sptr_cdb->integer2;
    int rc=0, i;
    lag_cb_t *cb;
    int stackId;

    if (sptr_cdb->config_gen)
        return;
    /*   TR000375908 Invalid input in FCX when no command is executed */

    if (end_of_token(sptr_cdb->token) != '\0')
        return;
    sptr_cdb->dont_go_next = 1;

	if(!IS_PORT_DB_VALID(port_id))   /*coverity 51346 */
		return;

    if( IS_SPX_PORT(port_id) && !g_sw_sys.init_in_progress && MODULE_IS_GOOD(PORT_TO_MODULE_ID(port_id)) )
    {
        uprintf("Error - speed-duplex is not allowed, Port %p is configured as an spx port\n", port_id);
        return;
    }

    /*Check for mode, because if this function is called from set_mif(), the port pair validation has already been done in set_mif().*/
    if(sptr_cdb->mode == CONFIG_IF || sptr_cdb->mode == CONFIG_IF_PE)
    {
        port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        if(!(g_sw_sys.init_in_progress || g_sw_sys.ext_init_in_progress || g_copy_tftp_runCfg) &&
                is_port_grouped_port(port_id))
        {
            port = get_paired_port(port_id);
            uprintf("Error: Port %p and its pair port %p must be configured at the same speed and duplex \n" , port_id, port);
            return;
        }
    }

    if((IS_FI_BCM()) && IS_PP_40G_PORT(port_id)) {
        uprintf("This CLI operation is not applicable to port %p\n", port_id);
        return;
    }
#ifdef SIDEWINDER_BREAKOUT
    if(is_breakout_set(get_main_port_from_sw_port(port_id)))
    {
        uprintf("This CLI operation is not applicable to breakout sub-port %p\n", port_id);
        return;
    }
#endif

    if(!g_sw_sys.init_in_progress && (speed == SPEED_1000))
    {
        if(SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_INVALID)
            pp_link_media_assign(port_id);

        if((SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC)//100-fx
                ||(SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC3_IR)//100-fx-IR
                ||(SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC3_LR))//100-fx-lr
        {
            uprintf("Error: This speed/clock setting is not allowed on port %p\n",port_id);
            return;
        }
    }


    stackId = PORT_TO_STACK_ID(port_id);
    if(IS_PP_GIG_FIBER_PORT(port_id))
    {
        //media type is only available after hotswap for remote unit 
        //So bypassing the media check here for remote ports
        if((( G_STACK_STATE(PORT_TO_STACK_ID(port_id)) == STACK_STATE_REMOTE) && (G_STK_REMOTE_STATE(PORT_TO_STACK_ID(port_id)) >= REG_STATE_MSR_FULLY_OPERATIONAL))
                || ( G_STACK_STATE(PORT_TO_STACK_ID(port_id)) == STACK_STATE_MYSELF))
        {

		if(SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_GIG_COPPER_GBIC) {
			if((speed==SPEED_10) && !IS_SPEED_SUPPORTED(port_id, sptr_cdb->integer1)) {
				uprintf("Speed 10m is not supported on port %p\n", port_id);
				return;
			}
		
			if((speed==SPEED_1000) && ((sptr_cdb->integer3 == PORT_CLOCK_MASTER) || (sptr_cdb->integer3 == PORT_CLOCK_SLAVE))) {
				uprintf("Master/Slave config is not supported on Copper SFP port %p\n", port_id);
				return;
			}
		}
		


            else
            {
            	//1G fiber port without GBIC does not support speed change
                uprintf("ERROR: speed-duplex setting is not allowed on 1G fiber port %p\n", port_id);
				return;
            }
        }
    } 



#ifdef SPATHA
#ifndef FI_EEE_MGMT
    if(((duplex == PORT_HDX) && (speed == SPEED_100)) ||
            (speed == SPEED_10))
    {
        if(SPTR_PORT_DB(port_id)->port_config.eee_enabled)
        {               
            uprintf("Disable EEE feature on port %p to configure this speed\n",port_id);
            return;
        }
    }
#endif  
#endif
				

				
    /* On a 10G Port 'speed-duplex 1000-full' is not supported for 10G Media */
    if (IS_PP_10G_PORT(port_id) && (speed == SPEED_1000))
    {
        /* Note: Add any New 10G Media to below checklist */
        if ((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_SR) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_LR) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_ER) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_SW) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_LW) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_EW) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_ZR) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_ZRD) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_LRM) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_MMF) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_USR) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_CABLE) ||
                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_ACTIVE_COPPER) ||
		(SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_BiDi_BXU) ||
		(SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_BiDi_BXD))
        {
            uprintf("INFO: %p: Optics <-> Speed mismatch, replace with SFP optic\n", port_id);
			//For development purpose, allowing configuring 1G speed on a 10G optic in a 10G port
#ifndef ALLOW_SPEED_1000_IN_10GSFPP
     /* TR 617814: PM, HW, SW decide to allow the 10G optics to set and configure 1G speed regardless the rate available
          * or link establish. This change is requested by several ISPs. The INFO: with warning will be kept. 
          */
//            return;
#endif
        }
    }
	if(!IS_SPEED_SUPPORTED(port_id, speed))
	{	
		uprintf("This speed setting is not applicable to port %p\n", port_id);
        return; 					
    }

	if((sptr_cdb->integer2 == PORT_HDX)&& (!IS_HALF_DUPLEX_SUPPORTED(port_id)))
	{	
        uprintf("Half-duplex is not applicable to port %p \n", port_id);
        return; 					
    }


    if(hal_is_pp_link_x10g_fiber_port(port_id))
    {
           
	//clock setting CLIs are not supproted on 10G fiber port even with GBIC
		if(sptr_cdb->integer3 != PORT_CLOCK_NONE)
		{
			uprintf("Error: Only 10g-full and 1000-full are allowed on port %p\n", port_id);
			return;
		}
       
       

        if(speed == SPEED_10000)
        {
            /* The license check should happen only in master and it should be performed only after the
             * initial config spec is pushed into the slaves.
             */
            if((!STACK_AM_I_MEMBER) && (!g_sw_sys.init_in_progress) && (!IS_LAG_AP(port_id)))
            {
                rc = cu_isPoDLicenseAcquired(port_id);
                if(rc == 0)
                {
                    if(!STACK_AM_I_SLAVE)
                        uprintf("PoD: No license present for port %p\n",port_id);
                    ksprintf ((char*)cu_line_buf, "PoD: No license present for port %p\n",port_id);
                    cu_logging_generic(cu_line_buf, TRUE, CU_LOGGING_TYPE_INFORMATIONAL);
                    return;
                }
            }

           
            
        }
    }

    /* Check if the port is part of a trunk that contains fiber port as its member. If such a port is found, prevent speed settings to be applied to the original port */
    cb = GET_LAG_BY_PORT(port_id);
    if (cb)
    {
        for (i=0; i < cb->lag_num_ports; i++)
        {
            port_index2 = cb->lag_ports[i];
			
            if ((SPTR_PORT_DB(port_index2)->port_oper_info.gbic_copper != 1) && (IS_PP_GIG_FIBER_PORT(port_index2)))
            {
                uprintf("Error: Speed change for LAG port %p is not allowed as it has member port(s) that are fiber port(s)\n", port_id);
                return;
            }
			if(!IS_SPEED_SUPPORTED(port_index2, speed))
			{
                uprintf("Error: Speed change for LAG port %p is not allowed as it has member port(s) %p that does not support this speed\n", port_id, port_index2);
                return;
            }

			//Only 10G speed is supported on LRM Adapter Port - Handling LAG ports
			if (sptr_cdb->integer1 == SPEED_1000 && hal_fluffy_module_present_get(port_index2))
			{
				if (!sptr_cdb->config_gen)
				{
					uprintf("Only 10G speed is supported on this LRM adapter Port %p\n",port_index2);
				}
				return;
			}

        }
    }

#ifdef __PORT_EXTENSION__ 
    if( is_spx_port_speed_allowed() && is_port_pe_stk_port(port_id))
    {
        if(STACK_AM_I_PROVISIONAL_PE)
        {
            set_spx_port_speed(port_id, sptr_cdb->integer1);
            return;
        }
        else if(STACK_AM_I_PE)
        {
            set_spx_port_speed(port_id, sptr_cdb->integer1);
        }
    }
#endif __PORT_EXTENSION__

    cu_set_if_speed_and_duplex(port_id,
            sptr_cdb->integer1, sptr_cdb->integer2,
            sptr_cdb->integer3, sptr_cdb->cli_cmd);
    return;
}

void config_gen_if_mdi_mode(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        char temp1[] = " mdi-mdix ";
        char temp2[] = "mdi\n";
        char temp3[] = "mdix\n";
        enum PORT_MDI_MDIX mode;
		

		if(sptr_cdb->config_gen==0){
			if(check_is_virtual(port_id,"MDI-MDIX"))
				return;
		}
        
		if (sptr_cdb->config_gen)
        { /* config gen */
                if (cu_get_port_mdi_mode(port_id, 1, &mode) != CU_OK)
                        return;

                if (mode != PORT_MDI_AUTO)
                {
                        switch (mode)
                        {
                        case PORT_MDI:
                                wr_config(sptr_cdb, temp1);
                                wr_config(sptr_cdb, temp2);
                                break;
                        case PORT_MDIX:
                                wr_config(sptr_cdb, temp1);
                                wr_config(sptr_cdb, temp3);
                                break;
                        }
                }
        }
        else
        { /* not config gen */
                set_if_mdi_to_default_value(sptr_cdb);
        }
}

void config_gen_if_speed_and_duplex(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        char temp1[] = " speed-duplex ";
        char temp2[] = "10-full\n";
        char temp3[] = "10-half\n";
        char temp4[] = "100-full\n";
        char temp5[] = "100-half\n";
        char temp6[] = "10G-full\n";
                

        char str_master[] = "1000-full-master\n";
        char str_slave[] = "1000-full-slave\n";
        char str_auto[] = "1000-full-auto-master-slave\n";
        char temp7[] = "1000-full\n";
        
		char str_5g_full[] = "5g-full\n";		
		char str_5g_master[] = "5g-full-master\n";
		char str_5g_slave[] = "5g-full-slave\n";

		char str_2500_full[] = "2500-full\n";
		char str_2500_master[] = "2500-full-master\n";
		char str_2500_slave[] = "2500-full-slave\n";

        char str_master_10g[] = "10g-full-master\n";
        char str_slave_10g[] = "10g-full-slave\n";
    	char str_1000[] = "1000\n";
        enum PORT_CLOCK_MASTER_SLAVE clock;
        enum PORT_SPEED default_speed;
        enum PORT_SPEED speed;
        enum PORT_HDX_FDX duplex;
                int stackId = PORT_TO_STACK_ID(port_id);

        if (sptr_cdb->config_gen)
        { /* config gen */

                if (is_pp_link_x10g_cx4_port(port_id))
                {
                        if (is_pp_link_x10g_cx4_port_speed10G(port_id))
                        {
                                wr_config(sptr_cdb, temp1);
                                wr_config(sptr_cdb, temp6);
                        }
                        return;
                }

                cu_get_default_port_speed(port_id, &default_speed);
                if (cu_get_port_speed(port_id, 1, &speed) != CU_OK || is_port_stacking_port_and_stack_enable(port_id))
                        return;
                if (cu_get_port_duplex_mode(port_id, 1, &duplex) != CU_OK)
                        return;

                                if((default_speed == speed) && (duplex == PORT_FDX) &&
				    (speed != SPEED_2500))
                                        return;

                if (speed != default_speed || duplex == PORT_HDX || speed == SPEED_2500)
                {
                        switch (speed)
                        {
                        case SPEED_10:
                                wr_config(sptr_cdb, temp1);
                                if (duplex == PORT_FDX)
                                        wr_config(sptr_cdb, temp2);
                                else if (duplex == PORT_HDX)
                                        wr_config(sptr_cdb, temp3);
                                break;
                        case SPEED_100:
#if 0
                                                                if(IS_SPATHA())
                                                                {
                                                                         /* This speed setting is not allowed in Spatha for 48F base module ports and 4GF module ports
                                                                                but 100-fx is allowed as result of which "speed-duplex 100-full" als getting written into
                                                                                config file along wiht 100-fx. */
                                                                        int type = get_spatha_module_type(PORT_TO_STACK_ID(port_id) , PORT_TO_MODULE_ID(port_id));
                                                                        if ((type == GS_SPATHA_STACK_BASE_48GF) || (type == GS_SPATHA_STACK_MOD_4GF))
                                                                                break;
                                                                }
#endif
				/* do not bother about speed-duplex if media type is fx */
				pp_link_media_assign(port_id);
                                if (SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_BIDI ||
                                    SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC ||
                                    SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC3_SR ||
                                    SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC3_IR ||
                                    SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_100BASE_FX_OC3_LR) {
					break;
				}

                                if (SPTR_PORT_DB(port_id)->port_config.fx_100 == 1) {
				/* if the optic is not 100-FX but still '100-fx' is set then 
				 * do not write anything in the running config 
				 */
					ksprintf(cu_line_buf, " 100-fx\n");
					wr_config(sptr_cdb, cu_line_buf);
					break;
				}

                                wr_config(sptr_cdb, temp1);
                                if (duplex == PORT_FDX)
                                        wr_config(sptr_cdb, temp4);
                                else if (duplex == PORT_HDX)
                                        wr_config(sptr_cdb, temp5);
                                break;
                        case SPEED_1000:
						if(hal_is_pp_link_copper_port(port_id))
						{
							wr_config(sptr_cdb, temp1);

							
								if (cu_get_port_clock(port_id, 1, &clock) != CU_OK)
									return;

								if ( PORT_CLOCK_MASTER == clock ) {
									wr_config(sptr_cdb, str_master);
								}else if ( PORT_CLOCK_SLAVE == clock ) {
									wr_config(sptr_cdb, str_slave);
								}
								else  //if clock is in auto mode and speed in forced mode
									wr_config(sptr_cdb, temp7);
						}
						else if(hal_is_pp_link_x10g_fiber_port(port_id))
						{
                            wr_config(sptr_cdb, temp1);
							wr_config(sptr_cdb, temp7);
						}
						else if(SPTR_PORT_DB(port_id)->port_oper_info.media_type == MEDIA_TYPE_1000BASE_TX) {
							wr_config(sptr_cdb, temp1);
							wr_config(sptr_cdb, temp7);
						}

					break;
				    
                            case SPEED_10000:
                                                                   
                           if(hal_is_pp_link_x10g_copper_port(port_id))//10GC copper ports supports 10G AUTO mode      //valid for sidewinder 48C, 10G ports on
                            {
                                if (cu_get_port_clock(port_id, 1, &clock) != CU_OK)
                                        return;

                                                                                  
                                wr_config(sptr_cdb, temp1);

                                if ( PORT_CLOCK_MASTER == clock ) {
                                        wr_config(sptr_cdb, str_master_10g);
                                } else if ( PORT_CLOCK_SLAVE == clock ) {
                                        wr_config(sptr_cdb, str_slave_10g);
                                } 
                                else
                                        wr_config(sptr_cdb, temp6);
                        	}
                            else if(hal_is_pp_link_x10g_fiber_port(port_id))
                            {
                                    wr_config(sptr_cdb, temp1);
                                    wr_config(sptr_cdb, temp6);
                            }
                                                            
                            break;
							 case SPEED_5000:
                                                                   
                           if(hal_is_pp_link_x10g_multigig_port(port_id)){
					
					if (cu_get_port_clock(port_id, 1, &clock) != CU_OK)
                        return;                                                                               
                      
					wr_config(sptr_cdb, temp1);

                    if ( PORT_CLOCK_MASTER == clock ) {
                            wr_config(sptr_cdb, str_5g_master);
                    } else if ( PORT_CLOCK_SLAVE == clock ) {
                            wr_config(sptr_cdb, str_5g_slave);
                    } 
                    else //AUTO clock
                            wr_config(sptr_cdb, str_5g_full);
				}
                                                            
                            break;
                            case SPEED_2500:
				if (hal_is_pp_link_2_5gig_port(port_id)) {
					if (cu_get_port_clock(port_id, 1, &clock) != CU_OK) return;

					if (PORT_CLOCK_MASTER == clock ) {
						wr_config(sptr_cdb, temp1);
						wr_config(sptr_cdb, str_2500_master);
					} else if ( PORT_CLOCK_SLAVE == clock ) {
						wr_config(sptr_cdb, temp1);
						wr_config(sptr_cdb, str_2500_slave);
					}
					else if (speed != default_speed)
					{
						wr_config(sptr_cdb, temp1);
						wr_config(sptr_cdb, str_2500_full);
					}
				}
				else if(hal_is_pp_link_x10g_multigig_port(port_id)){

					if (cu_get_port_clock(port_id, 1, &clock) != CU_OK)
                        return;                                                                               

					wr_config(sptr_cdb, temp1); 

                    if ( PORT_CLOCK_MASTER == clock ) {
                            wr_config(sptr_cdb, str_2500_master);
                    } else if ( PORT_CLOCK_SLAVE == clock ) {
                            wr_config(sptr_cdb, str_2500_slave);
                    } 
                    else //AUTO clock
                            wr_config(sptr_cdb, str_2500_full);
				}
                            break;
                        }
                }
        }
        else
        { /* not config gen */
                if ( is_pp_link_x10g_port(port_id))
        {

            if(!is_system_turboiron() &&  !is_pp_link_x10g_cx4_port(port_id)&&(!is_pp_link_x10g_sfpp_port(port_id)))
                    {
                            uprintf(" Failed : port %p is not a gigabit or cx4 port\n", port_id);
                        return;
            }
                }
                set_if_speed_and_duplex_to_default_value(sptr_cdb);
        }
}

int pp_link_slave_stack_10g_lfs_set( PORT_ID port, UINT8 lfs_enable )
{
        int stackId =  PORT_TO_STACK_ID(port);

        send_ipc_slave_gig_link_ctrl_table(stackId);
        return LINK_OK;
}

void set_port_10g_lfs(struct cdb *sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 lfs_enable;

        int stackId = PORT_TO_STACK_ID(port_id);

        if (sptr_cdb->config_gen)
        {
                if (cu_get_port_10g_lfs(port_id, &lfs_enable) != CU_OK)
                        return;

                if (lfs_enable == 1)
                        wr_config(sptr_cdb," link-fault-signaling\n");
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                sptr_cdb->dont_go_next = 1;


#ifdef SIDEWINDER_LINUX //have to use compiler flag whenever accessing a macro from chassis_stk_SW.h
                if(( chassisStackIsSIDEWINDER_48XGC(PORT_TO_STACK_ID(port_id)) && (PORT_TO_MODULE_ID_LOCAL(port_id) == 0)))
                {
                        uprintf("link-fault-signaling not allowed on 10GBASE-T port %p \n", port_id);
                        return;
                }

                if(get_spatha_module_type(PORT_TO_STACK_ID(port_id), PORT_TO_MODULE_ID(port_id)) == GS_SPATHA_STACK_MOD_4XGC)
                {
                        uprintf("link-fault-signaling not allowed on 10GBASE-T port %p \n", port_id);
                        return;
                }

				 if(IS_PP_GIG_FIBER_PORT(port_id))
                {
                        uprintf("link-fault-signaling not allowed on Gig fiber port %p \n", port_id);
                        return;
                }

#endif //SIDEWINDER_LINUX



                if((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_COPPER) || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_10GBASE_ACTIVE_COPPER)
                        || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_4X10G_XLPPI) || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_1GBASE_ACTIVE_CABLE))
                {
                        uprintf("link-fault-signaling not allowed on 10G Copper port %p \n", port_id);
                        return;
                }
                if(IS_FI_BCM() && IS_PP_40G_PORT(port_id)) {
                        uprintf("The link-fault-signaling is not allowed on 40G port %p .\n", port_id);
                        return;
                }
                if (SPEED_AUTO == SPTR_PORT_DB(port_id)->port_config.speed ||
                    SPEED_1000 == SPTR_PORT_DB(port_id)->port_config.speed )
                {
                        // if empty and set to LINK_MEDIA_INVALD, then it won't return 1 in hal_is_pp_link_x10g_sfpp_port(), speed became 1G
                        // then it displayed below message even speed is set to 10G default
                                        if(SPTR_PORT_DB(port_id)->port_oper_info.media_type != LINK_MEDIA_INVALID)
                        uprintf("link-fault-signaling not allowed on 1G Copper or 1G Fiber port %p\n", port_id);
                        return;
                }

                if (sptr_cdb->no) {
                        cu_set_port_10g_lfs(port_id, 0);
                } else {
                        cu_set_port_10g_lfs(port_id, 1);
                }
        }
}

void cli_mif_port_set_10g_lfs(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_port_10g_lfs);
}

/*
                        set_mif_mdi

                        set_mif_mdix

                        set_mif_auto_mdi_mdix
*/

#ifndef STMT
#define STMT(_s )   do { _s  } while ( 0 )
#endif // STMT

//is_pp_link_x10g_port always returns 1 for APs since all the speed set are valid on it
#define INTF_CFG_10G_CHECK(_p)     STMT( if ( is_pp_link_x10g_port((_p)->if_num-1) ) { if (!_p->config_gen) uprintf("This CLI operation is not applicable to port %p\n", (_p)->if_num-1); return; } )


#define INTF_CFG_40G_CHECK(_p)     STMT( if ( is_pp_link_x40g_port((_p)->if_num-1) ) { if (!_p->config_gen && !IS_LAG_AP((_p)->if_num-1)) uprintf("This CLI operation is not applicable to port %p\n", (_p)->if_num-1); return; } )


#define INTF_CFG_100G_CHECK(_p)     STMT( if ( is_pp_link_x100g_port((_p)->if_num-1) ) { if (!_p->config_gen && !IS_LAG_AP((_p)->if_num-1)) uprintf("This CLI operation is not applicable to port %p\n", (_p)->if_num-1); return; } )

void set_if_mdi(struct cdb* sptr_cdb)
{
        INTF_CFG_10G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = PORT_MDI;
        set_if_mdi_mode(sptr_cdb);
}

void set_if_mdix(struct cdb* sptr_cdb)
{
        INTF_CFG_10G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = PORT_MDIX;
        set_if_mdi_mode(sptr_cdb);
}

void set_if_auto_mdi_mdix(struct cdb* sptr_cdb)
{
        INTF_CFG_10G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = PORT_MDI_AUTO;
        set_if_mdi_mode(sptr_cdb);
}

void set_if_speedAuto_full_duplex(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

		if(is_port_grouped_port(port_id)){  //Spatha 2.5G ports can't support auto mode
			if (!sptr_cdb->config_gen)
        	{
             	uprintf("This CLI operation is not applicable to 2.5G port %p\n", sptr_cdb->if_num-1);
        	}
        	return;
		}
		if(!hal_is_pp_link_x10g_copper_port(port_id))//10GC copper ports supports 10G AUTO mode 

        INTF_CFG_10G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = SPEED_AUTO;
        sptr_cdb->integer2 = PORT_FDX;

        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed10_full_duplex(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        INTF_CFG_10G_CHECK( sptr_cdb );
        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = SPEED_10;
        sptr_cdb->integer2 = PORT_FDX;

		if(is_port_grouped_port(port_id)){  //Spatha 2.5G ports can't support 10-Full Duplex 
			if (!sptr_cdb->config_gen)
        	{
             	uprintf("This CLI operation is not applicable to 2.5G port %p\n", sptr_cdb->if_num-1);
        	}
        	return;
		}

        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed10_half_duplex(struct cdb* sptr_cdb)
{
		PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        INTF_CFG_10G_CHECK( sptr_cdb );
        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = SPEED_10;
        sptr_cdb->integer2 = PORT_HDX;
		

		if(is_port_grouped_port(port_id)){  //Spatha 2.5G ports can't support 10-Half Duplex
			if (!sptr_cdb->config_gen)
        	{
             	uprintf("This CLI operation is not applicable to 2.5G port %p\n", sptr_cdb->if_num-1);
        	}
        	return;
		}

        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed100_full_duplex(struct cdb* sptr_cdb)
{
	PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
	int stackId = PORT_TO_STACK_ID(port_id);


	INTF_CFG_40G_CHECK( sptr_cdb );
    INTF_CFG_100G_CHECK( sptr_cdb );
	
	sptr_cdb->integer1 = SPEED_100;
	sptr_cdb->integer2 = PORT_FDX;
	
	if((chassisStackIsSIDEWINDER(stackId) &&
		hal_is_pp_link_x10g_copper_port(port_id)))
		sptr_cdb->integer3 = PORT_CLOCK_AUTO;

	set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed100_half_duplex(struct cdb* sptr_cdb)
{
		PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
		
        INTF_CFG_10G_CHECK( sptr_cdb );
        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );
        sptr_cdb->integer1 = SPEED_100;
        sptr_cdb->integer2 = PORT_HDX;
		


		if(is_port_grouped_port(port_id)){  //Spatha 2.5G ports can't support 100-Half Duplex
			if (!sptr_cdb->config_gen)
        	{
             	uprintf("This CLI operation is not applicable to 2.5G port %p\n", sptr_cdb->if_num-1);
        	}
        	return;
		}

        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed100_downlink(struct cdb* sptr_cdb)
{
        sptr_cdb->integer2 = SPEED_100;
        if (sptr_cdb->config_gen)
        {
                //sptr_cdb->dont_go_next = 1;
                return;
        }
}

void set_if_speed10_downlink(struct cdb* sptr_cdb)
{
        sptr_cdb->integer2 = SPEED_10;
        if (sptr_cdb->config_gen)
        {
                //sptr_cdb->dont_go_next = 1;
                return;
        }

}

void set_if_speed1000_uplink(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = SPEED_1000;
        return 0;
}

/*
 * Name   : allow_speed_on_pe_or_provisional_pe_mode
 * Desc   : Function used to verify SICA unit with provisional mode or PE mode
 * Params : PORT_ID port_id
 * Return : int 
 */
int allow_speed_on_pe_or_provisional_pe_mode(PORT_ID port_id)
{
	if( is_in_pe_or_provisional_pe_mode() && !is_pe_csp_operational(MY_BOOTUP_STACK_OR_PE_ID))
	{
		if( (IS_SICA() && !(is_valid_sica_second_module_port(port_id, STACK_PORT_VERIFY_CONFIG_SPX))) )
		{
			if (IS_LAG_AP(port_id))
			{
				return 1;
			}
			uprintf("Error - This CLI operation is not allowed on interface %p\n", port_id);
			return 0;
		}
	}

	return 1;
}
void set_if_speed10G_full_duplex(struct cdb* sptr_cdb)
{
    PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

    //To allow SICA licensed port speed change on SICA unit with provisional mode or PE mode.
    if( !allow_speed_on_pe_or_provisional_pe_mode(port_id) )
    {
        return; 
    }

    if (!is_pp_link_x10g_cx4_port(port_id) && !is_pp_link_x10g_port(port_id) &&
            !is_pp_link_x10g_stack_port(port_id))
    {
        if (!sptr_cdb->config_gen)
            uprintf(" Error : port %p is not a 10G port\n", INTERFACE_TO_PORT_ID(sptr_cdb->if_num));
        return;
    }

    sptr_cdb->integer1 = SPEED_10000;
    sptr_cdb->integer2 = PORT_FDX;

    if(hal_is_pp_link_x10g_copper_port(port_id))//10GC copper ports supports 10G AUTO mode 
        sptr_cdb->integer3 = PORT_CLOCK_AUTO;
    else
        sptr_cdb->integer3 = PORT_CLOCK_NONE;//fiber port does not support clock setting

    set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed10G_full_duplex_master(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT32 board_type;
        int stackId = PORT_TO_STACK_ID(port_id);


        if (!sptr_cdb->config_gen)        
    {
#ifdef SIDEWINDER_BREAKOUT
                if(is_breakout_set(get_main_port_from_sw_port(port_id)))
                {
                        uprintf("This CLI operation is not applicable to breakout sub-port %p\n", port_id);
                        return;
                }
#endif
                 if(!hal_is_pp_link_x10g_copper_port(port_id))//10GC copper ports supports 10G AUTO mode 
                {
                        uprintf(" Error : This CLI operation is valid only on 10G copper ports\n");
                        return;
                }
        }


        sptr_cdb->integer1 = SPEED_10000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_MASTER;

        set_if_speed_and_duplex(sptr_cdb);
}
void set_if_speed10G_full_duplex_slave(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        int stackId = PORT_TO_STACK_ID(port_id);


        if (!sptr_cdb->config_gen)        
    {
#ifdef SIDEWINDER_BREAKOUT
                        if(is_breakout_set(get_main_port_from_sw_port(port_id)))
                        {
                                uprintf("This CLI operation is not applicable to breakout sub-port %p\n", port_id);
                                return;
                        }
#endif
                if(!hal_is_pp_link_x10g_copper_port(port_id))//10GC copper ports supports 10G AUTO mode 
                {
                        uprintf(" Error : This CLI operation is valid only on 10G copper ports\n");
                        return;
                }
        }

        
      

        sptr_cdb->integer1 = SPEED_10000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_SLAVE;

        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed5G_full_duplex(struct cdb* sptr_cdb)
{
    PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

   	
    sptr_cdb->integer1 = SPEED_5000;
    sptr_cdb->integer2 = PORT_FDX;
	sptr_cdb->integer3 = PORT_CLOCK_AUTO;

   

    set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed5G_full_duplex_master(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT32 board_type;
        int stackId = PORT_TO_STACK_ID(port_id);

		
        sptr_cdb->integer1 = SPEED_5000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_MASTER;

        set_if_speed_and_duplex(sptr_cdb);
}
void set_if_speed5G_full_duplex_slave(struct cdb* sptr_cdb)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        int stackId = PORT_TO_STACK_ID(port_id);

      
        sptr_cdb->integer1 = SPEED_5000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_SLAVE;

        set_if_speed_and_duplex(sptr_cdb);
}


void set_if_speed1000_full_duplex_master(struct cdb* sptr_cdb)
{
                PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        //INTF_CFG_10G_CHECK( sptr_cdb );
        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );

        sptr_cdb->integer1 = SPEED_1000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_MASTER;

        set_if_speed_and_duplex(sptr_cdb);
}


void set_if_speed1000_full_duplex_slave(struct cdb* sptr_cdb)
{
                PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        //INTF_CFG_10G_CHECK( sptr_cdb );
        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );

        sptr_cdb->integer1 = SPEED_1000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_SLAVE;
        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed1000_full_duplex_auto(struct cdb* sptr_cdb)
{
        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );
                INTF_CFG_10G_CHECK( sptr_cdb );
        
        sptr_cdb->integer1 = SPEED_1000;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_AUTO;
        set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed1000_full_duplex(struct cdb* sptr_cdb)
{
    PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    int stackId = PORT_TO_STACK_ID(port_id);
	UINT32 rfi_on = 0;

    //To allow SICA licensed port speed change on SICA unit with provisional mode or PE mode.
    if( !allow_speed_on_pe_or_provisional_pe_mode(port_id) )
    {
        return; 
    }

    INTF_CFG_40G_CHECK( sptr_cdb );
    INTF_CFG_100G_CHECK( sptr_cdb );
	//Only 10G speed is supported on LRM Adapter
	if (hal_fluffy_module_present_get(port_id))
	{
		if (!sptr_cdb->config_gen)
		{
			uprintf("Only 10G speed is supported on LRM adapter\n");
		}
		return;
	}

	//LFS Feature is not allowed at 1000mbps, So when LFS is enabled don't allowed 1000-full config 
	if(LINK_OK == pp_link_802_3ae_rfi_get(port_id, &rfi_on))
	{
		if(rfi_on)
		{
			if (!sptr_cdb->config_gen)
			{
				uprintf("Speed configuration 1000-full is invalid because LFS is enabled on port %p \n",port_id);
			}
			return;

		}
	}
	

//this CLI is applicable for all 1G, 10G, and 2.5 G ports but will be blocked for 1G fiber port with SFP media in set_if_speed_dupex(), so no check is required here

    sptr_cdb->integer1 = SPEED_1000;
    sptr_cdb->integer2 = PORT_FDX;
	if(hal_is_pp_link_fiber_port(port_id))//fiber port does not support clock
		sptr_cdb->integer3 = PORT_CLOCK_NONE;
	else
    	sptr_cdb->integer3 = PORT_CLOCK_AUTO;
    set_if_speed_and_duplex(sptr_cdb);
}

void set_if_speed2500_full_duplex(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );
       

        sptr_cdb->integer1 = SPEED_2500;
        sptr_cdb->integer2 = PORT_FDX;
        sptr_cdb->integer3 = PORT_CLOCK_AUTO;
        set_if_speed_and_duplex(sptr_cdb);
}


void set_if_speed2500_full_duplex_master(struct cdb* sptr_cdb)
{
	PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

	INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );



	sptr_cdb->integer1 = SPEED_2500;
	sptr_cdb->integer2 = PORT_FDX;
	sptr_cdb->integer3 = PORT_CLOCK_MASTER;
	set_if_speed_and_duplex(sptr_cdb);
} /* set_if_speed2500_full_duplex_master */

void set_if_speed2500_full_duplex_slave(struct cdb* sptr_cdb)
{
	PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

	INTF_CFG_40G_CHECK( sptr_cdb );
        INTF_CFG_100G_CHECK( sptr_cdb );


	sptr_cdb->integer1 = SPEED_2500;
	sptr_cdb->integer2 = PORT_FDX;
	sptr_cdb->integer3 = PORT_CLOCK_SLAVE;
	set_if_speed_and_duplex(sptr_cdb);
} /* set_if_speed2500_full_duplex_slave */

void set_ip_acl_udp_1024(struct cdb* sptr_cdb)
{
        extern UINT8 ip_acl_udp_1024;

        if (sptr_cdb->config_gen)
        {
                if (ip_acl_udp_1024)
                        wr_config(sptr_cdb, "ip acl-permit-udp-1024\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip_acl_udp_1024 = FALSE;
                else
                        ip_acl_udp_1024 = TRUE;
        }
}

#ifdef SR_SWITCH_ROUTER


/***************************************************************************
Release 6.6 and before, IRDP is default to be ON.
Beyond 6.6, IRDP is default to be OFF.
***************************************************************************/
void set_ip_irdp(struct cdb* sptr_cdb)
{
#ifdef NOT_USED
        char temp[] = "ip irdp\n";
#endif NOT_USED

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->mode != CONFIG)
                {
                        uprintf("Error: \"ip irdp\" is allowed only in Global Configuration mode\n");
                        return;
                }

                if (sptr_cdb->no)
                {
                        ICMP_RA_INTERFACE *raP;
                        IP_PORT_DB_ENTRY *portP;
                        UINT16 port_number;

                        ip.icmp.perform_router_advertisement = FALSE;
                        if (ip.icmp.icmp_timer_id)
                        {
                                sv_cancel_timer(ip.icmp.icmp_timer_id);
                                ip.icmp.icmp_timer_id = NULL;
                        }

                        for (portP = ip_port_db_list_head; portP != NULL; portP = portP->next)
                        {
                                port_number = portP->port_number;
                                if ((raP = (ICMP_RA_INTERFACE *)IP_IP_PORT(port_number).config.sptr_irdp) != NULL)
                                {
                                        icmp_ra_delete_timer(raP);
                                        dy_free(raP);
                                        IP_IP_PORT(port_number).config.sptr_irdp = NULL;
                                }
                        }

                }
                else
                {
                        ip.icmp.perform_router_advertisement = TRUE;
                        icmp_initialize();
                }
        } else {
                if (ip.icmp.perform_router_advertisement == FALSE)
                        return;
#ifdef NOT_USED
                wr_config(sptr_cdb, temp);
#endif NOT_USED
                wr_config(sptr_cdb, "ip irdp\n");
        }
}

void set_ip_source_route(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (!ip.source_route_enabled)
                {
                        wr_config(sptr_cdb, "no ip source-route\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                        ip.source_route_enabled = FALSE;
                else
                        ip.source_route_enabled = TRUE;
        }
}


//#ifdef BROADCAST_ZERO
void set_ip_broadcast_zero(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                /* if version is newer then 06.0.00, the default directed broadcast
                 * enable value is FALSE; older than 06.0.00, default is TRUE
                 */
                if (ip.broadcast_zero)
                {
                                wr_config(sptr_cdb, "ip broadcast-zero\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                        ip.broadcast_zero = FALSE;
                else
                        ip.broadcast_zero = TRUE;
        }
}
//#endif

void set_ip_dbcast(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                /* if version is newer then 06.0.00, the default directed broadcast
                 * enable value is FALSE; older than 06.0.00, default is TRUE
                 */
                if (ip.directed_bcast_fwd_enabled)
                {
                                wr_config(sptr_cdb, "ip directed-broadcast\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                        ip.directed_bcast_fwd_enabled = FALSE;
                else
                        ip.directed_bcast_fwd_enabled = TRUE;
        }
}

extern IP_BYHOST_ROUTE_TABLE ip_byhost_route_table;

void config_gen_ip_load_sharing(struct cdb* sptr_cdb)
{
        int i;

        if (!gRtm.load_sharing_enabled)
        {
                wr_config(sptr_cdb, "no ip load-sharing\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (gRtm.ipv4_max_equal_cost_paths != IP_DEFAULT_MAX_EQUAL_COST_PATHS)
        {
                ksprintf(cu_line_buf, "ip load-sharing %d\n", gRtm.ipv4_max_equal_cost_paths);
                wr_config(sptr_cdb, cu_line_buf);
        }

        if (gRtm.host_based_ecmp)
                wr_config(sptr_cdb, "ip load-sharing by-host\n");

        if (!gRtm.lru_port_based_ecmp)
                wr_config(sptr_cdb, "no ip load-sharing by-port\n");

        for (i=0; i<ip_byhost_route_table.count; i++)
        {
                ksprintf(cu_line_buf, "ip load-sharing route-by-host %I/%d\n", ip_byhost_route_table.routes[i].net, MASK2PREFIX_LENGTH(ip_byhost_route_table.routes[i].mask));
                wr_config(sptr_cdb, cu_line_buf);
        }
}

/* global variable - help string for ip-load-sharing
* this is set dynamically based on the parameter
*/
UINT8 ip_load_sharing_help_string[80];

void enable_ip_load_sharing(struct cdb* sptr_cdb)
{
        UINT32 no_of_path = IP_DEFAULT_MAX_EQUAL_COST_PATHS;
        ITC_ERROR err = ITC_OK;
        UINT8 enable;

         if (sptr_cdb->help)
         {
                /* dynamically change the help string to reflect the valid range
                *for the expected decimal input
                */
                ksnprintf(ip_load_sharing_help_string,
                        sizeof(ip_load_sharing_help_string),
                        "<2-%d> paths, default is 4",
                        fndry_system_parameters[MAX_ECMP_INDEX].current);
                        return;
        }

        if (sptr_cdb->config_gen == 0)
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;
                sptr_cdb->dont_go_next = 1;

                /* not config gen */
                if (sptr_cdb->num_of_integer != 0)
                {
                        if (sptr_cdb->no)
                        {
                                no_of_path = IP_DEFAULT_MAX_EQUAL_COST_PATHS;
                                enable = (UINT8)gRtm.load_sharing_enabled;
                        }
                        else
                        {
                                        /* max vlaue provded for range is taken from System max value of MAX_ECMP paths that can be configured now. 
                                                                this change is reqquired as part of dynamic change in ECMP size in Sidewinder and SPATHA*/
                                
                                if (valid_integer1_value_range(sptr_cdb, IP_MIN_MAX_EQUAL_COST_PATHS, fndry_system_parameters[MAX_ECMP_INDEX].current) != TRUE)
                                        return;
                                no_of_path = sptr_cdb->integer1;
                                enable = !sptr_cdb->no;
                        }
                }
                else
                        enable = !sptr_cdb->no;

                rtm_ipv4_cu_load_share(cu_get_current_itc_context(), enable, no_of_path);
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                config_gen_ip_load_sharing(sptr_cdb);
        }
}


void enable_ip_proxy_arp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
                        ip.arp.proxy_arp_enabled = FALSE;
                }
                else
                {
                        ip.arp.proxy_arp_enabled = TRUE;
                }
        } else {
                if (ip.arp.proxy_arp_enabled)
                {
                        wr_config(sptr_cdb, "ip proxy-arp\n");
                }
        }
}

void enable_ip_rarp(struct cdb* sptr_cdb)
{
#ifdef NOT_USED
        char temp[] = "no ip rarp\n";
#endif NOT_USED

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
                        ip.rarp.server_enabled = FALSE;
                }
                else
                {
                        ip.rarp.server_enabled = TRUE;
                }
        } else {
                if (ip.rarp.server_enabled)
                        return;
#ifdef NOT_USED
                wr_config(sptr_cdb, temp);
#endif NOT_USED
                wr_config(sptr_cdb, "no ip rarp\n");
        }
}

void set_ip_forwardProtocol_Udp(struct cdb* sptr_cdb)
{
        int i;
        UINT32 default_udp_ports_bit_mask = 0;

        char temp1[] = "no ip forward-protocol udp\n";
        char temp2[] = "ip forward-protocol udp \n";
        char temp3[] = "no ip forward-protocol udp ";
        char temp4[] = "ip forward-protocol udp ";
        char temp6[] = "dns\n";
        char temp9[] = "tacacs\n";
        char temp10[] = "tftp\n";
        char temp11[] = "time\n";
#ifdef OLD
        char temp5[] = "bootpc\n";
        char temp7[] = "discard\n";
        char temp8[] = "dnsix\n";
        char temp10[] = "echo\n";
        char temp11[] = "mobile-ip\n";
        char temp14[] = "ntp\n";
/*      char temp8[] = "rip\n";    */
        char temp15[] = "snmp\n";               /* snmpquery */
        char temp16[] = "snmp-trap\n";          /* snmptrap */
        char temp18[] = "talk\n";
#endif /* OLD */

        if (sptr_cdb->config_gen)
        {
                if (ip.udp.forward_udp_broadcast == FALSE)
                {
                        wr_config(sptr_cdb, temp1);
                        return;
                }
                /* examine each udp port for which the forwarding is enabled */
                for (i = 0; i < UDP_MAXIMUM_NUM_UDP_PORTS_FOR_UDP_FORWARDING; i++)
                {
                                                /* if udp port is not programmed, skip */
                        if (ip.udp.udp_port_list_for_forwarding_udp_bcast[i].udp_port == 0)
                                continue;

                                                /* if udp port is not programmed through the "ip forward-protocol udp", skip */
                        if (0 == (ip.udp.udp_port_list_for_forwarding_udp_bcast[i].appl_bitmask & UDP_FWD_CMD_MASK))
                                continue;                                                               
                        else
                        {
                                switch (ip.udp.udp_port_list_for_forwarding_udp_bcast[i].udp_port)
                                {
                                        case CLI_ENUM_DOMAIN:
                                                default_udp_ports_bit_mask |= UDP_PORT_DOMAIN_PORT_BIT;
                                                break;
                                        case CLI_ENUM_TFTP_PORT:
                                                default_udp_ports_bit_mask |= UDP_PORT_TFTP_PORT_BIT;
                                                break;
                                        case CLI_ENUM_TACACS:
                                                default_udp_ports_bit_mask |= UDP_PORT_TACACS_PORT_BIT;
                                                break;
                                        case CLI_ENUM_TIME:
                                                default_udp_ports_bit_mask |= UDP_PORT_TIME_PORT_BIT;
                                                break;
#ifdef NOT_USED
                                        case CLI_ENUM_RIP:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp8);
                                                break;
#endif /*NOT_USED*/
                                        default:
                                                wr_config(sptr_cdb, temp4);
                                                l4_port_to_name(ip.udp.udp_port_list_for_forwarding_udp_bcast[i].udp_port,
                                                                L4_UDP | L4_HELPER,
                                                                cu_line_buf, FALSE/*display int*/);
                                                wr_config(sptr_cdb, cu_line_buf);
                                                wr_config(sptr_cdb, "\n");
                                                break;

#ifdef OLD
                                        case CLI_ENUM_BOOTPC:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp5);
                                                break;
                                        case CLI_ENUM_DISCARD:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp7);
                                                break;
                                        case CLI_ENUM_DNSIX:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp8);
                                                break;
                                        case CLI_ENUM_ECHO:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp10);
                                                break;
                                        case CLI_ENUM_MOBILE_IP:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp11);
                                                break;
                                        case CLI_ENUM_NTP:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp14);
                                                break;
                                        case CLI_ENUM_SNMP:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp15);
                                                break;
                                        case CLI_ENUM_SNMPTRAP:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp16);
                                                break;
                                        case CLI_ENUM_TALK:
                                                wr_config(sptr_cdb, temp4);
                                                wr_config(sptr_cdb, temp18);
                                                break;
                                        default:
                                                /* last and unknown port */
#ifdef NOT_USED
                                                wr_config(sptr_cdb, temp4);
                                                ksprintf(cu_line_buf, "%d\n",ip.udp.udp_port_list_for_forwarding_udp_bcast[i].udp_port);
                                                wr_config(sptr_cdb, cu_line_buf);
#endif NOT_USED
                                                ksprintf(cu_line_buf, "%s%d\n",
                                                        temp4,
                                                        ip.udp.udp_port_list_for_forwarding_udp_bcast[i].udp_port);
                                                wr_config(sptr_cdb, cu_line_buf);
                                                break;
#endif /* OLD */
                                } /*SWITCH */
                        } /*if-else */
                } /* end of for loop of all udp ports */

                /* check for default ports, if they are not set then create config for them */

                /* BOOTPS, NETBIOS_NS and  NETBIOS_DGM default behavior changes. By default is will be disabled.
                                Features like DHCP-relay,DHCP-server or DHCP-Assist can enable this port, Bit mask is used to track the changes */
                if ((default_udp_ports_bit_mask & UDP_PORT_DOMAIN_PORT_BIT)  != UDP_PORT_DOMAIN_PORT_BIT)
                {
                        wr_config(sptr_cdb, temp3);
                        wr_config(sptr_cdb, temp6);
                }
                if ((default_udp_ports_bit_mask & UDP_PORT_TACACS_PORT_BIT)  != UDP_PORT_TACACS_PORT_BIT)
                {
                        wr_config(sptr_cdb, temp3);
                        wr_config(sptr_cdb, temp9);
                }
                if ((default_udp_ports_bit_mask & UDP_PORT_TFTP_PORT_BIT)  != UDP_PORT_TFTP_PORT_BIT)
                {
                        wr_config(sptr_cdb, temp3);
                        wr_config(sptr_cdb, temp10);
                }
                if ((default_udp_ports_bit_mask & UDP_PORT_TIME_PORT_BIT)  != UDP_PORT_TIME_PORT_BIT)
                {
                        wr_config(sptr_cdb, temp3);
                        wr_config(sptr_cdb, temp11);
                }
                sptr_cdb->dont_go_next = 1;
        } /* end of config gen */
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return; /* cmd not for me */

                if (sptr_cdb->no)
                {
                        /* Disable udp broadcast forwarding */
                        ip.udp.forward_udp_broadcast = FALSE;
                        /* Clear all udp ports */
                        for (i = 0; i < UDP_MAXIMUM_NUM_UDP_PORTS_FOR_UDP_FORWARDING; i++)
                        {
                                                /* Remove the UDP BC port */
                                                delete_udp_forward_bcast_port_by_index (i, UDP_FWD_CMD_MASK);                   
                    }
                }
                else
                {
                        ip.udp.forward_udp_broadcast = TRUE;
                                        
                        /* setup default udp ports for which packet are forwarded by default */
                        udp_set_up_default_udp_forwarding_port();
                }
                 sptr_cdb->dont_go_next = 1;
        }
}

void
set_ip_forwardProtocol_UdpPortUnknown(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
                        /*  remove the udp port from the port list */
                        set_udp_forward_broadcast_udp_port(FALSE,(UINT16)sptr_cdb->integer1);
                }
                else
                {
                        if (! valid_integer1_value_range(sptr_cdb, 1, 0xffff))
                                return;
#ifdef NOT_USED
                        if (sptr_cdb->integer1 < 1 || sptr_cdb->integer1 > 0xFFFF)
                        {

                                uprintf("Error - UDP Port Number must be between 1 and 65535 inclusive \n");
                                return;
                        }
#endif NOT_USED
                        set_udp_forward_broadcast_udp_port(TRUE,(UINT16)sptr_cdb->integer1);
                }
        }
        else
        { /* config gen */
                /* Do nothing */
        }
}

void
set_ip_forwardProtocol_UdpPort(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no)
                {
                        /*  remove the udp port from the port list */
                        set_udp_forward_broadcast_udp_port(FALSE,(UINT16)sptr_cdb->integer1);
                }
                else
                {
                        set_udp_forward_broadcast_udp_port(TRUE,(UINT16)sptr_cdb->integer1);
                }
        }
}

void
set_ip_forwardProtocol_UdpBootpc(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_BOOTPC;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}

void
set_ip_forwardProtocol_UdpBootps(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_BOOTPS;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpDiscard(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_DISCARD;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpDnsix(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_DNSIX;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}

void
set_ip_forwardProtocol_UdpDomain(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_DOMAIN;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpEcho(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_ECHO;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpMobileIp(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_MOBILE_IP;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}

void
set_ip_forwardProtocol_UdpNetbiosDgm(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_NETBIOS_DGM;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpNetbiosNs(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_NETBIOS_NS;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpNtp(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_NTP;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
#ifdef NOT_USED
void
set_ip_forwardProtocol_UdpRip(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_RIP;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
#endif /*NOT_USED*/
void
set_ip_forwardProtocol_UdpSnmp(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_SNMP;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpSnmptr(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_SNMPTRAP;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpTacacs(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_TACACS;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpTalk(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_TALK;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpTftp(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_TFTP_PORT;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}
void
set_ip_forwardProtocol_UdpTime(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = CLI_ENUM_TIME;
        set_ip_forwardProtocol_UdpPort(sptr_cdb);
}

void check_ip_helperAddress(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        int entry_number;

        if (sptr_cdb->config_gen)
        {
                /* config gen */
                for (entry_number =0; entry_number < UDP_MAXIMUM_NUM_OF_HELPER_ADDRESSES_PER_PORT; entry_number++)
                {
                        if (IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].entry_valid == FALSE)
                                continue;
                        else
                        {
                                if(!IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].unicast)
                                        ksprintf(cu_line_buf, " ip helper-address %d %I\n",
                                                entry_number+1,
                                                IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].address);
                                else
                                        ksprintf(cu_line_buf, " ip helper-address %d %I unicast\n",
                                                entry_number+1,
                                                IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].address);

                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
        }
}

/*****************************************************************************
 * Function: cli_set_ip_helperAddress
 *
 * Params: struct cdb* sptr_cdb -CLI node
 *                 enum BOOLEAN unicastOpt - unicast option (TRUE means unicast option present)
 * Returns: VOID
 * 
 * Purpose: This function will be used to add/delete the ip helper address or unicast option to the port.
 *               This function is called in the CLI flow
 *****************************************************************************/ 
static void cli_set_ip_helperAddress(struct cdb* sptr_cdb, enum BOOLEAN unicastOpt)
{
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    UINT32 entry_number = (sptr_cdb->integer1) - 1;
    int i;

        /* config gen handled in other function*/
    if (sptr_cdb->config_gen != 0)
                return;

        /* cmd not for me */
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
                                
        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->help)
                return;

        if (!valid_integer1_value_range(sptr_cdb,1,UDP_MAXIMUM_NUM_OF_HELPER_ADDRESSES_PER_PORT))
                return;

        if (sptr_cdb->no)
        {   
                /* Node not exist */
                if ((FALSE == IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].entry_valid) ||
                        (IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].address != sptr_cdb->ip1))
                {       
                        uprintf("Error - Helper address is not configured.\n");
                        return;
                }               

                if (unicastOpt)
                {                               
                        /* Reset the unicast option */
                        IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].unicast = FALSE;
                        return;
                }

                delete_ip_helper_address (port_id, entry_number);
                }
                else
                {
                        /* not no */
                        if ((sptr_cdb->ip1 == 0) || (sptr_cdb->ip1 == 0xFFFFFFFF))
                        {
                                uprintf("Error - Helper Address of 0.0.0.0 and 255.255.255.255 are not supported.\n");
                                return;
                        }
                
                        for (i= 0; i <UDP_MAXIMUM_NUM_OF_HELPER_ADDRESSES_PER_PORT; i++)
                        {
                        /* Node already exist */
                        if ((IP_UDP_HELPER_ADDR(port_id).helper_address[i].entry_valid == TRUE) &&
                (IP_UDP_HELPER_ADDR(port_id).helper_address[i].address == sptr_cdb->ip1))
                        {
                                if (unicastOpt)
                                {
                                        /* Set the unicast option and return */
                        IP_UDP_HELPER_ADDR(port_id).helper_address[entry_number].unicast = TRUE;
                                        return;
                                }

                                /* Same config, discard the cmd */
                                if (i == entry_number)
                                {
                                        return;
                                }
                                
                                /* Duplicate address, return */
                                uprintf("Error - Duplicate Helper Address.\n");
                                return;
                        }
        }

                add_ip_helper_address(port_id, entry_number, sptr_cdb->ip1, unicastOpt);
        }
        return;
}

/*****************************************************************************
 * Function: set_ip_helperAddressUnicast
 *
 * Params: struct cdb* sptr_cdb -CLI node
 * Returns: VOID
 * 
 * Purpose: This function will be used to add/delete the ip helper address or/and unicast option to the port.
 *               This function is called in the CLI flow "ip helper x.x.x.x unicast"
 *****************************************************************************/ 
void set_ip_helperAddressUnicast(struct cdb* sptr_cdb)
{
        cli_set_ip_helperAddress(sptr_cdb, TRUE);
}

/*****************************************************************************
 * Function: set_ip_helperAddress
 *
 * Params: struct cdb* sptr_cdb -CLI node
 * Returns: VOID
 * 
 * Purpose: This function will be used to add/delete the ip helper address to the port.
 *               This function is called in the CLI flow "ip helper x.x.x.x"
 *****************************************************************************/ 
void set_ip_helperAddress(struct cdb* sptr_cdb)
{
        cli_set_ip_helperAddress(sptr_cdb, FALSE);
}

#endif /* SR_SWITCH_ROUTER */


/* cmd1.h */

/* exec cmds */
void disable(struct cdb* sptr_cdb)
{
        set_cli_mode(sptr_cdb, USER_EXEC);
        default_current_login_password_level(sptr_cdb, 1);
}

/* Exit to user level from config level */
/* Utilize existing code for exiting to priv level */
void disable1(struct cdb* sptr_cdb)
{
        if (sptr_cdb->no == 0)
        {
            end_config(sptr_cdb);
            disable(sptr_cdb);
        }
}

void enable(struct cdb* sptr_cdb)
{
        int index;
/*      524629 kklin: This bug fix must consider security.
        When the master rconsoles to a standby or member, it will be in privileged mode.
        The rconsole from the master to any unit should not require password to do "enable" 
        because master "rconsole" is executed in "enabled" mode.
        The problem is that when the it executes "exit", and "enable" again. 
        The standby ask for a password, and the password is 
        printed and not accepted. The fix is to always allow "enable" 
        for the rconsole from active to member or standby.
        standby/member local console is by default in enabled mode, so no need to check password
        regardless of rconsole or not. IS_RCONSOLE_SESSION(sptr_cdb->ui_port) 

        This may not be necessary. It is done in cli_check_password(). But I keep the code just 
        to cover untested cases.
*/
        if (STACK_AM_I_SLAVE)
        {
                set_cli_mode(sptr_cdb, PRIV_EXEC);
                sptr_cdb->current_login_password_level = CU_SECURITY_LEVEL0;
        }
        else
        if (g_access_control.level_password[CU_SECURITY_LEVEL0][0] == 0)
        {
                set_cli_mode(sptr_cdb, PRIV_EXEC);
                sptr_cdb->current_login_password_level = CU_SECURITY_LEVEL0;
                uprintf("No password has been assigned yet...\n");
        }
        else
        {
                index = cu_get_level_password_privilege(sptr_cdb->token);

                if (index >= 0)
                {
                        set_cli_mode(sptr_cdb, PRIV_EXEC);
                        sptr_cdb->current_login_password_level = index;
                }
                else
                {
                        uprintf("Error - incorrect password.\n");
                                                ksprintf(cu_line_buf,"Security: Access to PRIVILEGED EXEC is rejected for %s session due to Incorrect username or password\n",get_session_name(sptr_cdb->ui_port));
                                                cu_logging_generic(cu_line_buf, TRUE, CU_LOGGING_TYPE_INFORMATIONAL);
                }
        }
        /* delete this command line from command history */
        cancel_command_line(sptr_cdb->ui_port);
}

void cli_check_password(struct cdb* sptr_cdb)
{
        /* 34584 */
        // CHEETAH_STACKING
        if(!is_mgmt_active())
                ;
        else
        if (cu_aaa_is_console_session(sptr_cdb->ui_port) && !cu_aaa_is_enable_authen_enabled_for_console())
                ;
        else if (g_priv_aaa_enabled)
        {
                UINT8 first_method = cu_aaa_get_first_method_for_feature(AAA_FEATURE_ENABLE);
                if (first_method !=AAA_METHOD_NONE)
                {
                        if (first_method==AAA_METHOD_ENABLE)
                        {
                                aaa.session[sptr_cdb->ui_port].user_name[0]=0;
                                sptr_cdb->user_name[0]=0;
                                set_cli_mode(sptr_cdb, CLI_ENABLE_PASSWORD);
                        }
                        else if (first_method==AAA_METHOD_LINE)
                        {
                                aaa.session[sptr_cdb->ui_port].user_name[0]=0;
                                sptr_cdb->user_name[0]=0;
                                set_cli_mode(sptr_cdb, CLI_LINE_PASSWORD);
                        }
                        else if (aaa.enable_use_implicit_user == TRUE &&
                                 sptr_cdb->user_name[0])
                        {
                                strcpy(aaa.session[sptr_cdb->ui_port].user_name, sptr_cdb->user_name);
                                set_cli_mode(sptr_cdb, CLI_PASSWORD);
                        }
                        else
                                set_cli_mode(sptr_cdb, CLI_LOGIN);
                        sptr_cdb->dont_print_hostname = TRUE;
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
        }

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;

                if (
/*      524629 kklin: This bug fix must consider security.
        When the master rconsoles to a standby or member, it will be in privileged mode.
        The rconsole from the master to any unit should not require password to do "enable" 
        because master "rconsole" is executed in "enabled" mode.
        The problem is that when the it executes "exit", and "enable" again. 
        The standby ask for a password, and the password is 
        printed and not accepted. The fix is to always allow "enable" 
        for the rconsole from active to member or standby.
        standby/member local console is by default in enabled mode, so no need to check password
        regardless of rconsole or not. IS_RCONSOLE_SESSION(sptr_cdb->ui_port) 
*/
                                        (STACK_AM_I_SLAVE) ||
                                        g_access_control.level_password[CU_SECURITY_LEVEL0][0] == 0)
                {
                        UINT8 priv_level = 0;
                        set_cli_mode(sptr_cdb, PRIV_EXEC);

                        if((priv_level = cu_aaa_get_current_privilege(sptr_cdb->ui_port)) && cu_aaa_is_valid_user_for_context(sptr_cdb->ui_port))
                        {
                                if(cu_aaa_is_console_session(sptr_cdb->ui_port))
                                {
                                        if(cu_aaa_get_console_flag())
                                                sptr_cdb->current_login_password_level = priv_level;
                                        else
                                                sptr_cdb->current_login_password_level = CU_SECURITY_LEVEL0;
                                }
                                else
                                        sptr_cdb->current_login_password_level = priv_level;
                        }
                        else
                                sptr_cdb->current_login_password_level = CU_SECURITY_LEVEL0;
                        uprintf("No password has been assigned yet...\n");
                                                cu_logging_user_login(sptr_cdb->ui_port , sptr_cdb->user_name, 0, 1);
                        print_exec_banner();
                        if (!aaa_is_command_in_buffer(sptr_cdb->ui_port))
                                io_cb[sptr_cdb->ui_port].cmd_line[0][0] = '\0';
                }
                else
                {
                        set_cli_mode(sptr_cdb, CLI_PASSWORD);
                        sptr_cdb->dont_print_hostname = TRUE;
                }
    }
}

// CHEETAH_STACKING
static BOOLEAN32 session_logout_internal(
        struct cdb* sptr_cdb, BOOLEAN32 is_logout)
{
        if (IS_SSH_CDBS_INDEX(sptr_cdb->ui_port))
        {
                ssh.client[CDBS_TO_SSH_INDEX(sptr_cdb->ui_port)].termination_cause = PW_ADMIN_RESET;
                sshm_CTRL_Close_Connection(ssh.client[CDBS_TO_SSH_INDEX(sptr_cdb->ui_port)].tcb_handle);
                return TRUE;
        }
        else
        if (IS_TELNET_CDBS_INDEX(sptr_cdb->ui_port))
        {
                telnet.client[CDBS_TO_TELNET_INDEX(sptr_cdb->ui_port)].termination_cause = PW_USER_REQUEST;
                telnet_close_connection(telnet.client[CDBS_TO_TELNET_INDEX(sptr_cdb->ui_port)].tcb_handle);
                return TRUE;
        }
		else
        if (IS_RCONSOLE_SESSION(sptr_cdb->ui_port) && (STACK_AM_I_SLAVE||STACK_AM_I_PE))
        {
                rconsole_server_request_stop_cli_redirection(sptr_cdb->ui_port);
                return TRUE;
        }
        else
        if (cu_aaa_is_console_session(sptr_cdb->ui_port) && cu_aaa_is_login_authen_enabled_for_console() && !(g_stacking.rconsole_off))
        {
                cu_aaa_set_account_termination_reason(sptr_cdb->ui_port, PW_USER_REQUEST);
                if (!aaa_close_exec_session(sptr_cdb->ui_port, cli_aaa_accounting_callback, sptr_cdb->ui_port))
                {
                    print_prelogin_message_on_console(sptr_cdb->ui_port);
                    return TRUE;
                }
        }
        else
        if( cu_aaa_is_login_authen_enabled_for_console() && g_stacking.rconsole_off && is_mgmt_active())
        {
                cu_aaa_set_account_termination_reason(sptr_cdb->ui_port, PW_USER_REQUEST);
                if (!aaa_close_exec_session(sptr_cdb->ui_port, cli_aaa_accounting_callback, sptr_cdb->ui_port) &&
							 sptr_cdb->ui_port < MAX_IO_CB) //coverity 42531
                {
                     print_prelogin_message_on_console(sptr_cdb->ui_port);
                     return TRUE;
                }
        }
        else
        if (is_logout)
        {
                if (sptr_cdb->isInConfigMode)
                        end_config(sptr_cdb);

                disable(sptr_cdb);
        }

        return FALSE;
}

void session_exit(struct cdb* sptr_cdb)
{
        session_logout_internal(sptr_cdb, FALSE);
}

BOOLEAN32 session_logout(struct cdb* sptr_cdb)
{
        return session_logout_internal(sptr_cdb, TRUE);
}

int get_boot_source_from_boot_param()
{
                switch(sil_get_boot_source()){
                    case SIL_BOOT_SOURCE_PRIMARY:
                        return BOOTPARAM_PRI;
                        break;
                    case SIL_BOOT_SOURCE_SECONDARY:
                        return BOOTPARAM_SEC;
                        break;
                    case SIL_BOOT_SOURCE_TFTP:
                        return BOOTPARAM_TFTP;
                        break;
                    default:
                        return 0;
                }

}
/*-------------------------------------------------------------------------**
**                                                                         **
** This function should only be call by the xxx_confirm_callback function. **
**                                                                         **
**-------------------------------------------------------------------------*/
void special_reload(UINT32 ui_port)
{
    UINT32 boot_source = 0;
                if ( (sptr_flash_cb)
                                )
                {
                        uprintf("System is performing a Flash write operation, please try later\n");
                        return;
                }

        //bipin: talk to AAA only when I am active or standalone
        if (!STACK_AM_I_SLAVE) {
        UINT32 next_session_id;

        aaa.shutdown_in_progress = TRUE;
        //If system accounting is configured, do it now. After AAA is done, call the function special_reload() again
        if (cli_request_system_accounting(ui_port, FALSE))
                return;
        else
        {
                //Start EXEC Accnt STOP from the first active console/telnet/ssh session.
                next_session_id = aaa_get_next_active_session(0xffffffff);
                if (cli_request_exec_accounting_stop_all(next_session_id))
                        return;
        }
        }

                #ifndef PV_CHANGES
        /* shutdown the license library */
                CleanupLicense();
#endif PV_CHANGES

        g_sxr_peer_reset_not_reqd = 1;


/* Ask for confirmation only for active or standalone units */
         if ((STACK_AM_I_MASTER) || (STACK_AM_I_STANDALONE)) {


                if ((!download_check()) && (user_warned ==0))
                {

                        
                        uprintf("\nYou are about to downgrade to a 7.x version, please issue 'downgrade_to 7.x' to avoid errors \n "
                                                                          "enter 'y' to continue, 'n' to abort \n");
                                
                                
                        set_confirm_mode(download_check_confirm_callback,0,2);
                                 
                        return;
        
                                 
                } else {
        
                        
                }  
         }


        if (STACK_AM_I_MASTER || (!STACK_AM_I_SLAVE && STACK_AM_I_CB_AND_PE_NUM))
        {
                //uprintf("Halt and reboot\n");
                //sys_sleep(2);
                //uprintf_flush();
                //flush_output();
                diag_on = 0; // Goodsell, 11/30/01, fixing bug 5730 -- if diag_on, slave CPUs did not get reset

                if (g_boot_sys_flash)
                {
                        if (g_Need_To_Send_boot_Req)
                        {
                                dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_BOOT, g_boot_sys_from_image);
                                        g_Need_To_Send_boot_Req = FALSE;
                        }
                }
                        else
                        {
                                boot_source = get_boot_source_from_boot_param();
                                dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_SPL_RELOAD, boot_source);
                        }
                        return;
        }
#ifdef FI_LOAM
		/* Sending dying gasp on LOAM enabled local ports
		 * to indicate peer about this Units reload
		 */
		link_oam_send_link_down_event_all_ports(LOAM_DYING_GASP_EVENT);
		delay_ms(1000);
#endif

		cu_cold_reset_now(TRUE);
}

/*----------------------------------------------------------------------**
**                                                                      **
** This function is called to check if the running config is different  **
** from the saved config data. It return 0 if they are the same, return **
** 1 if they are not the same, and return 2 if we can't even get enough **
** system resource to retrieve the config data                          **
**                                                                      **
** If in PE or provisional PE and runntime config is diff, ret 3        **
**----------------------------------------------------------------------*/
int is_config_data_changed(UINT32 ui_port)
{
        struct cdb *my_cdb, *sptr_cdb;
        int rcode;
        int len = 0, i = 0;
        UINT16 running_cksum, *u16ptr = NULL;
        UINT8 *u8ptr1, *u8ptr2;
        int ver_len, offset;
        UINT8* buf;

#ifdef __PORT_EXTENSION__       
                if(is_in_pe_or_provisional_pe_mode())
                {
                        if(check_pe_boot_same_as_runntime_config(0) == 0)
                                return 1;
                        else
                                return 0;
                }
#endif // __PORT_EXTENSION__    

        my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb));
        if (!my_cdb)
        {
                return(2);
        }

        sptr_cdb = &cdbs[ui_port];
        *my_cdb = *sptr_cdb;
        buf = get_config_buffer(my_cdb->ui_port);
        if (buf == 0)
        {
                //uprintf("Failed to get config buffer, abort.\n");
                dy_free(my_cdb);
                return 2;
        }
        my_cdb->buffer = my_cdb->buffer_base = buf;
        my_cdb->gen_to = GEN_TO_FLASH;
	//        if (retrieve_running_config(my_cdb)<0)
	/*000606363 - running config to be consistent with startup, the show flag to reset
	 * no need to show anything*/
	my_cdb->show = 0;
	if( retrieve_all_module_config_new(my_cdb) < 0)
        {
                uprintf("Running-config to startup-config abort.\n");
                free_config_buffer(my_cdb->buffer_base);
                dy_free(my_cdb);
                return(2);
        }

    {
        {
                        int file;
                        FLASH_FILE_INFO info;
                    UINT8 *config_data = NULL;

            len = strlen(my_cdb->buffer_base);

            file = flash_fopen(g_startup_config_filename, "r");

            if (file == 0)
            {
                rcode = 2;
            }
            else
            {
                                flash_get_file_info(file, &info);

                config_data = (unsigned char*)dy_malloc(info.length + 2);
                if (config_data != NULL)
                {
		if(g_parser_debug)	
			debug_uprintf("\n\n info.length =%d \t len=%d  \n\n",info.length,len);
                    if (info.length == len)
                    {
                        if
                        (
                            flash_fread
                            (
                                file,
                                config_data,
                                info.length
                            ) == info.length
                        )
                        {
                                if (len & 1)
                            {
                                len++;
                            }
                                len /= 2;

                                *(UINT16 *)(my_cdb->buffer_base + info.length) = 0;
                                *(UINT16 *)(config_data + info.length) = 0;

                                i = 0;
                                u8ptr1 = my_cdb->buffer_base;
                                ver_len = 0;
                                offset = 0;
                                while (i < len*2)
                                {
                                        /* check the beginning of the line for "ver" */
                                        if (*u8ptr1=='v' && *(u8ptr1+1)=='e' && *(u8ptr1+2)=='r')
                                        {
                                                /* record the offset */
                                                offset = u8ptr1 - my_cdb->buffer_base;
                                                /* find the length of this line */
                                                while (*u8ptr1 != '\n')
                                                {
                                                        ver_len++;
                                                        if (i++ >= len*2)
                                                                break;
                                                        u8ptr1++;
                                                }
                                                break;
                                        } else
                                        {
                                                /* skip the reset of the line */
                                                while (*u8ptr1 != '\n')
                                                {
                                                        if (i++ >= len*2)
                                                                break;
                                                        u8ptr1++;
                                                }

                                                /* skip '\n' */
                                                i++;
                                                u8ptr1++;
                                        }
                                }
                                if (ver_len)
                                {
                                        /* copy to the same location in the running config */
                                        u8ptr2 = config_data;
                                        memcpy((char *)my_cdb->buffer_base+offset, u8ptr2+offset, ver_len);
                                }

                                /* calculate the check-sum */
                                if
                            (
                                config_cksum((UINT16 *)my_cdb->buffer_base, len) !=
                                config_cksum((UINT16 *)config_data, len)
                            )
                            {
                                        rcode = 1;
                            }
                                else
                            {
                                        rcode = 0;
                            }
                        }
                        else
                        {
                            rcode = 2;
                        }
                    }
                    else
                    {
                        rcode = 1;
                    }
                }
                else
                {
                    rcode = 2;
                }

                                free_config_buffer(my_cdb->buffer_base);
                dy_free(my_cdb);
                if (config_data != NULL)
                {
                    dy_free(config_data);
                }
                flash_fclose(file);

                return rcode;
            }
        }
    }
        free_config_buffer(my_cdb->buffer_base);
        dy_free(my_cdb);
        return(2);
}

/*----------------------------------------------------------------------------**
**                                                                            **
** This function is called after the second confirmation of "reload" command. **
**                                                                            **
**----------------------------------------------------------------------------*/
void reload_confirm2_callback(UINT32 yes, UINT32 ui_port, UINT32 param3)
{
        if (yes)
        {
                         release_confirm_mode();
                /* insist on reload */
                special_reload(ui_port);
        } else
        {
                          release_confirm_mode();
                if (param3 == 1)
                        uprintf("Please save the running config and try reload again\n");
                else if (param3 == 2)
                        uprintf("Please try again later\n");
        }
       
}

void downgrade_confirm_callback(UINT32 yes, UINT32 ui_port, UINT32 param3)
{
        int old_ui_port;
                int file;
        
        if (yes)
        {
                
           
                   file = flash_fopen(g_startup_config_legacy, "r");
                        if (file != 0)
                {
                        flash_fclose(file);
                        sys_flash_fremove(g_startup_config_filename );
                        
                        flash_rename(g_startup_config_legacy, g_startup_config_filename);
                        uprintf("\n The config has been downgraded , Please reload with 7.x image without issuing a write memory \n ");
                } else {
                        uprintf("\nStartup-config.legacy does not exist, Could not restore 7.x config \n ");
                        file = flash_fopen(g_startup_config_filename, "r");
                        if (file != 0)
                                flash_fclose(file);
                        sys_flash_fremove(g_startup_config_filename );
                        
                        }
                downgrade_cli_issued = 1;

                                
        }
                
        release_confirm_mode();
        //g_uprintf_dest = old_ui_port;
}

void passwd_encryption_type_change_confirm_callback(UINT32 yes, UINT32 enable, UINT32 encryption_type)
{
        if (yes)
        {
                release_confirm_mode();
            cu_set_password_encryption_type(enable,encryption_type);
        } 
        else
        {
                release_confirm_mode();                            
        }
}

/*---------------------------------------------------------------------------**
**                                                                           **
** This function is called after the first confirmation of "reload" command. **
**                                                                           **
**---------------------------------------------------------------------------*/
void reload_confirm_callback(UINT32 yes, UINT32 ui_port, UINT32 param3)
{
        int old_ui_port;

        //old_ui_port = g_uprintf_dest;
        //g_uprintf_dest = ui_port;

        if (yes)
        {
        	if(STACK_AM_I_SLAVE == 0 && STACK_AM_I_PE == 0) // kklin, not on member or PE
        	{
				int rcode;
				rcode = is_config_data_changed(ui_port); // move this inside yes to save time.
                if (rcode == 1)
                {
                        uprintf("Running Config data has been changed. Do you want to continue\nthe reload without saving the running config? ");
                        set_confirm_mode(reload_confirm2_callback, ui_port, 1);
                        return;
                } else if (rcode == 2)
                {
                        uprintf("Could not verify if the Running Config data has been changed.\nDo you want to continue the reload anyway? ");
                        set_confirm_mode(reload_confirm2_callback, ui_port, 2);
                        return;
                } 
        	}
			release_confirm_mode();
			special_reload(ui_port);
        }
                else{
                        /* Reset the flags*/
                        g_boot_sys_flash = FALSE;
                        release_confirm_mode();
                        }
       // release_confirm_mode();
        //g_uprintf_dest = old_ui_port;
}

void cli_sys_restart_config(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                if (!sptr_cdb->no && reload_config_secs)
                {
                        wr_config(sptr_cdb, reload_config_string);
                        return;
                }
        }
        else
        {
                /*
                 * To prevent the user accidentally reboot the system,
                 * we require the user to enter the whole command.
                 */
                if (strncmp(sptr_cdb->token, "killme", 6) != 0)
                {
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
                if (sptr_cdb->help)
                        return;
                if (sptr_cdb->no)
                {
                        if (g_reboot_timer != (SV_TIMER_TOKEN_T)0)
                        {
                                sv_cancel_timer(g_reboot_timer);
                                g_reboot_timer = (SV_TIMER_TOKEN_T)0;
                                reload_secs = 0;
                                reload_location = 0;
                        }
                        reload_config_secs = 0;
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
        }
}

int fips_verify_image_with_signature(int flash_id)
{
        if(flash_id == PRIMARY){
                uprintf("FIPS: primary image verification is going to be called\n");
                if(fifips_SHVerifyHeaderFooter((char *)hal_get_flash_file_name_primary(), (char *) "primary.sig",0,0) != CU_OK)
                        {
                                uprintf("FIPS: primary image verification failed\n");
                                return FALSE;
                        } else  {
                                uprintf("FIPS: primary image verification passed\n");
                                return TRUE;
                        }
        }
        else if(flash_id == SECONDARY){
                uprintf("FIPS: secondary image verification is going to be called\n");
                if(fifips_SHVerifyHeaderFooter((char *)hal_get_flash_file_name_secondary(),(char *)"secondary.sig",0,0) != CU_OK)
                        {
                                uprintf("FIPS: secondary image verification failed\n");
                                return FALSE;
                        } else  {
                                uprintf("FIPS: secondary image verification passed\n");
                                return TRUE;
                        }
        }
        return FALSE;
}

void debug_func1(UINT8* addr, UINT8 value)
{
        kprintf("debug_func1 invoked\n");
        if (addr != NULL)
        {
                *addr = value;
                kprintf("addr = 0x%x, value = 0x%x, 0x%x\n", addr, *addr, *(UINT32 *)addr);
        }
        else
        {
                kprintf("Address was NULL\n");
        }
        return;
}

extern void execute_confirm_callback(UINT32 yes, UINT32 ui_port, UINT32 param3);

void debug_func(struct cdb* sptr_cdb)
{
        UINT32 sptr_cdb_addr;
        struct cdb *sptr_cdb1 = NULL;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        sptr_cdb1 = (struct cdb *)kmalloc(sizeof(struct cdb), DramHeapID);

        if(NULL == sptr_cdb1)
                return;
        
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                        
                sptr_cdb->dont_go_next = 1;
                kprintf("sptr_cdb->ui_port = 0x%x, sptr_cdb->integer1 = 0x%x\n, sptr_cdb->integer2 = 0x%x, sptr_cdb->integer3=0x%x\n", 
                                sptr_cdb->ui_port, sptr_cdb->integer1, sptr_cdb->integer2, sptr_cdb->integer3);
        
                memcpy(sptr_cdb1, sptr_cdb, sizeof(struct cdb));
                sptr_cdb_addr = (UINT32) sptr_cdb1;
                uprintf("WARNING:  This command is for DEBUG USE only and may potentially cause a System Crash or High CPU!!!\nDo you want to continue?  (y/n)");
                set_confirm_mode(execute_confirm_callback,sptr_cdb->ui_port,sptr_cdb_addr);
        }
	kfree(sptr_cdb1);
        return;
}

void cli_config_downgrade(struct cdb* sptr_cdb)
{
                int i, temp;
                int retval = FALSE;
                
                if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
            return;
        }
        
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                
            sptr_cdb->dont_go_next = 1;

            uprintf("This CLI operation will delete the current configuration. Are you sure? ");
            set_confirm_mode(downgrade_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
        }
}


void cli_sys_restart(struct cdb* sptr_cdb)
{
                int i, temp;
                int retval = FALSE;
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        
		if(provisional_mode_reload_check() == 0) // kklin, Provisional mode can only reload to PE mode
		{
			sptr_cdb->dont_go_next = 1;
			return;
		}

        if(poedrvIsFwUpgradeInProgress())
        {
                sptr_cdb->dont_go_next = 1;
                uprintf("Please reload the system after PoE firmware upgrade is complete.\n");
                return;
        }

        if (is_tftp_busy()) { 
                sptr_cdb->dont_go_next = 1;
                uprintf("Error : copy tftp operation is in progress. Please try again.\n");                                                                                                                                                                                                                                   
                return;                                                                                                                                                                                                                                                                                                    
        } 
  
        if(is_flash_use_in_progress()) {                                                                                          
              sptr_cdb->dont_go_next = 1;            
              uprintf("Error : Flash access is in progress. Please try again.\n");                          
              return;                                                                                                                           
        }         

                if (cu_aaa_get_console_flag()) {
                        uprintf("Warning: Console login authentication is enabled, Please make sure users are configured\n");
                }

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                 g_boot_sys_from_image = 0;
                sptr_cdb->dont_go_next = 1;
#if 0
                                /* Verify fips signature before reload in fips is enabled
                                 * warn the user if fips verification fails*/
                                if (cu_fips_get_status())
                                {
                                        for (i = 0; i < MAX_BOOT_SEQ; i++)
                                        {
                                                if (boot_seq[i] == BOOT_FROM_FLASH_PRI)
                                                {
                                                        temp = PRIMARY;
                                                        break;
                                                }

                                                if (boot_seq[i] == BOOT_FROM_FLASH_SEC)
                                                {
                                                        temp = SECONDARY;
                                                        break;
                                                }

                                                if (boot_seq[i] == BOOT_FROM_NONE)
                                                        break;
                                        }
                                        if (temp == SECONDARY)
                                                retval = fips_verify_image_with_signature(SECONDARY);
                                        else
                                        {
                                                        /* if not secondary then boot from primary, even default case
                                                           when "boot sys flash pri/sec" is not configured) */
                                                        retval = fips_verify_image_with_signature(PRIMARY);
                                        }

                                        if(!retval)
                                        {
                                                uprintf("FIPS: Fatal-Error: Software load test FAILED; do you want to continue?");
                                                set_confirm_mode(reload_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
                                                return;
                                        }
                                }
#endif
                                uprintf("Are you sure? ");

                set_confirm_mode(reload_confirm_callback, (UINT32)sptr_cdb->ui_port, 0);
        }
}

/*----------------------------------------------------------------**
**                                                                **
** This is a "reload" function without interactive confirmation.  **
** Mainly used by test scripts that do not want the confirmation. **
**                                                                **
**----------------------------------------------------------------*/
void cli_sys_restart_yes(struct cdb* sptr_cdb)
{
        UINT32 boot_source = 0;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if(poedrvIsFwUpgradeInProgress())
        {
                sptr_cdb->dont_go_next = 1;
                uprintf("Please reload the system after PoE firmware upgrade is complete.\n");
                return;
        }

        if (is_tftp_busy()) {
                sptr_cdb->dont_go_next = 1;
                uprintf("Error : copy tftp operation is in progress. Please try again.\n");
                return;
        }

        if (is_flash_use_in_progress()) {
                sptr_cdb->dont_go_next = 1;
                uprintf("Error : Flash access is in progress. Please try again.\n");
                return;
        }

        /*
         * To prevent the user accidentally reboot the system,
         * we require the user to enter the whole command.
         */

        if (strncmp(sptr_cdb->token, "reload-yes", 10) != 0)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;

                if (sptr_flash_cb)
                {
                        uprintf("System is performing a Flash write operation, please try later\n");
                        return;
                }

                if (STACK_AM_I_MASTER || STACK_AM_I_CB_AND_PE_NUM){
                        boot_source = get_boot_source_from_boot_param();
                        if(dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_SPL_RELOAD, boot_source)) // 573019 If return 1, it setup a timer to reload
                        	return;
                }

                write_log_crc();

				print_reboot_and_cold_reset_now();

        }
}

void show_relipc(struct cdb* sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                show_relipc_info();
                sptr_cdb->dont_go_next = 1;
        }

}


extern UINT32 module_mask;
extern enum BOOLEAN enable_switch_fabric (UINT32 switchingFabricSlot);

void cli_enable_system_monitoring(struct cdb* sptr_cdb)
{
        if (sm.sysMon_enable == TRUE)
                uprintf("system Monitor has already enabled\n");

        else {
                sm.SysMon_sv_token = sv_set_timer_event(sm.sysMon_timer*60*SECOND, REPEAT_TIMER, system_monitoring, 0,"sysMon Timer");
                sm.sysMon_enable = TRUE;
                }
        show_system_monitoring(sptr_cdb);
}

void cli_disable_system_monitoring(struct cdb* sptr_cdb)
{
        if (sm.sysMon_enable == FALSE)
                uprintf ("system Monitor has already disabled\n");

        else {
                sv_cancel_timer(sm.SysMon_sv_token);
                sm.SysMon_sv_token = NULL;
                sm.sysMon_enable = FALSE;
                }
        show_system_monitoring(sptr_cdb);

}
void cli_set_system_monitoring_timer(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                        return;
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;
                sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->integer1 <=0 || sptr_cdb->integer1 >60){
                uprintf ("Sysmon timer should be between 1 to 60 minutes\n");
                return;
                }
        else
                if(sm.sysMon_timer == sptr_cdb->integer1)
                        return;

                sm.sysMon_timer = sptr_cdb->integer1;
                if (sm.sysMon_enable == TRUE){
                        sv_cancel_timer(sm.SysMon_sv_token);  // cancel timer first before enable a new timer.
                        sm.SysMon_sv_token = sv_set_timer_event(sm.sysMon_timer*60*SECOND, REPEAT_TIMER, system_monitoring, 0,"sysMon Timer");
                        }
}


void cli_sys_fast_restart(struct cdb* sptr_cdb)
{
        /*
         * To prevent the user accidentally reboot the system,
         * we require the user to enter the whole command.
         */
#ifdef SIDEWINDER_LINUX
        if (strncmp(sptr_cdb->token, "fastreload", 10) == 0)
        {
#else
        if (strncmp(sptr_cdb->token, "fast-reload", 11) == 0)
        {
#endif
                uprintf("Fast Halt and reboot\n");
                uprintf_flush();
                flush_output();
                sys_sleep(2); // 1 tick is 25ms
#ifdef SIDEWINDER_LINUX
                if(sil_is_hv_enable()) {
                        /* Running on Hypervisor so can do quick reset */
                        sil_set_fast_reload(1);
                        cli_sys_restart(sptr_cdb);
                } else
                        uprintf("Fast reload not supported \n");

                return;
#endif
#ifndef NO_FDRY_HW
                if (boot_code_version_ok(1))
                {
                        {
                        UINT32 next_session_id;

                        aaa.shutdown_in_progress = TRUE;
                        //If system accounting is configured, do it now. After AAA is done, call the function special_reload() again
                        if (cli_request_system_accounting(sptr_cdb->ui_port, FALSE))
                                return;
                        else
                        {
                                //Start EXEC Accnt STOP from the first active console/telnet/ssh session.
                                next_session_id = aaa_get_next_active_session(0xffffffff);
                                if (cli_request_exec_accounting_stop_all(next_session_id))
                                        return;
                        }
                        }

                        cu_shutdown_software_subsystems();
                        fast_hw_reset();
                }
#endif
        }
}

void cli_upgrade_to_router(struct cdb* sptr_cdb)
{
        if (strncmp(sptr_cdb->token, "ug2router", 9) == 0)
        {
                change_boot_name();
        }

}

/* config cmds */
void end_config(struct cdb* sptr_cdb)
{
        if (sptr_cdb->no == 0)
        {
                if (sptr_cdb->vlan_group_id) {
                        //Bug: 344086 We don't remove to sync to standby
                        //free_vlan_group_entry(sptr_cdb->vlan_group_id, FALSE);
                        sptr_cdb->vlan_group_id = 0;
                }
                //check_running_config_change(sptr_cdb);
                cli_log_config_changed(sptr_cdb->ui_port, FALSE);
#ifndef NO_MULTI_CONFIG_VLAN
                if (sptr_cdb->mode == CONFIG_MVLAN || sptr_cdb->parent_mode == CONFIG_MVLAN)
                {
                        sptr_cdb->mvlan_action_func = NULL;
                        sptr_cdb->parent_mode = PRIV_EXEC;/* BUG:71864 */
                        clear_vlan_id_mask(sptr_cdb);
                }
#endif NO_MULTI_CONFIG_VLAN

#ifdef SR_SWITCH_ROUTER
                //FINIL3
                if (sptr_cdb->mode == CONFIG_IP_VRF || sptr_cdb->mode == CONFIG_IPV4_VRF || sptr_cdb->mode == CONFIG_IPV6_VRF)
                {
                        vrf_set_address_family_mode(sptr_cdb, 0);
                }

                cli_reset_vrf_mode(sptr_cdb);
#endif SR_SWITCH_ROUTER

                set_cli_mode(sptr_cdb, PRIV_EXEC);
                if (config_term_user_count)
                        config_term_user_count--;
                sptr_cdb->isInConfigMode = FALSE;
#ifdef MPLS
                mpls_clear_session_lock(g_uprintf_dest);
#endif MPLS
        }
}

void exit_to_config(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                set_cli_mode(sptr_cdb, CONFIG);
                sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
        }
}

void exit_config(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no)
                {
                        sptr_cdb->dont_go_next = 1;
                        return;
                }

                if (end_of_token(sptr_cdb->token) == '\0')
                {
                        stk_sync_cmd(sptr_cdb->ui_port, sptr_cdb->line_status, sptr_cdb->line);
                        cli_reset_vrf_mode(sptr_cdb);

#ifdef SR_SWITCH_ROUTER
                        if (sptr_cdb->mode == CONFIG_IF_DVMRP_TUNNEL
#ifdef __PIM__
                        ||  sptr_cdb->mode == CONFIG_IF_PIM_TUNNEL
#endif /* __PIM__ */
#ifndef __NO_VRRPE__
                        ||  sptr_cdb->mode == CONFIG_VRRPE_ROUTER_ID
#endif __NO_VRRPE__
                        ||  sptr_cdb->mode == CONFIG_VRRP_ROUTER_ID
                        /* TR000344868 : to return back to ve terminal when exited from ipv6 vrrp vrid*/
                        ||  sptr_cdb->mode == CONFIG_VRRP6_ROUTER_ID)
                        {
                                sptr_cdb->vrid = 0;
                                sptr_cdb->vrtr_index = VSRP_INDEX_INVALID;
#ifndef NO_VSRRP
                                if (g_vrrp_class.vsrp_enabled)
                                        set_cli_mode(sptr_cdb, sptr_cdb->parent_mode);
                                else
#endif NO_VSRRP
                                if (is_physical_port(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                                        set_cli_mode(sptr_cdb, CONFIG_IF);
                                else
                                        set_cli_mode(sptr_cdb, CONFIG_VIF);
                        }
                        else
#ifdef MPLS
                        if ((sptr_cdb->mode == CONFIG_MPLS_STATIC)
                        || (sptr_cdb->mode == CONFIG_MPLS_PATH)
                        || (sptr_cdb->mode == CONFIG_MPLS_LSP)
                        || (sptr_cdb->mode == CONFIG_MPLS_INTERFACE)
                        || (sptr_cdb->mode == CONFIG_MPLS_RSVP)         /* RSVP_CLI */
                        || (sptr_cdb->mode == CONFIG_MPLS_POLICY)       /* POLICY_CLI */
                        || (sptr_cdb->mode == CONFIG_MPLS_VLL))
                        {
                                set_cli_mode(sptr_cdb, CONFIG_MPLS_ROUTER);
                                mpls_clear_session_lock(g_uprintf_dest);
                        }
                        else
                        if ((sptr_cdb->mode == CONFIG_MPLS_LSP_SECPATH))
                        {
                                set_cli_mode(sptr_cdb, CONFIG_MPLS_LSP);
                                //mpls_clear_session_lock(g_uprintf_dest);
                        }
                        else
//#ifdef DRAFT_MARTINI
                        if (sptr_cdb->mode == CONFIG_MPLS_VLL_TAGGED)
                        {
                                set_cli_mode(sptr_cdb, CONFIG_MPLS_VLL);
                        }
                        else
//#endif DRAFT_MARTINI
#endif MPLS
#endif /* SR_SWITCH_ROUTER */
#ifdef M_RING
                        if (sptr_cdb->mode == CONFIG_MRP)
                        {
                                set_cli_mode(sptr_cdb, CONFIG_VLAN);
                        }
                        else
#endif M_RING
#ifdef FI_LOAM
                        if (sptr_cdb->mode == CONFIG_LOAM)
                        {
                           set_cli_mode(sptr_cdb,CONFIG);
                        }
                        else
#endif FI_LOAM

#ifdef WEBAUTH_2_0
                        if (sptr_cdb->mode == CONFIG_VLAN_WEBAUTH)
                        {
                                set_cli_mode(sptr_cdb, CONFIG_VLAN);
                        }
                        else
                        if (sptr_cdb->mode == CONFIG_CAPTIVE_PORTAL)
                        {
                                set_cli_mode(sptr_cdb, CONFIG);
                        }
                        else
#endif

                        if (sptr_cdb->mode == CONFIG_LOCAL_USERDB)
                        {
                          set_cli_mode(sptr_cdb, CONFIG);
                        }
                        else

#ifndef NO_PROTO_VLANS
                        if (((sptr_cdb->mode == CONFIG_VLAN_PROTO) ||
                                 (sptr_cdb->mode == CONFIG_VLAN_NR_PROTO)) &&
                            sptr_cdb->from_port_vlan)
                        {
#ifndef NO_MULTI_CONFIG_VLAN
                                if (sptr_cdb->parent_mode == CONFIG_MVLAN)
                                        set_cli_mode(sptr_cdb, CONFIG_MVLAN);
                                else
#endif NO_MULTI_CONFIG_VLAN
                                set_cli_mode(sptr_cdb, CONFIG_VLAN);
                                sptr_cdb->sub_vlan_type = L2_VLAN_INDEX;
                        }
                        else
#endif /* NO_PROTO_VLANS */

#ifdef SR_SWITCH_ONLY
#ifndef NO_VSRRP
                        if (sptr_cdb->mode == CONFIG_VRRPE_ROUTER_ID)
                        {
#ifndef NO_MULTI_CONFIG_VLAN
                                if (sptr_cdb->parent_mode == CONFIG_MVLAN)
                                {
                                        set_cli_mode(sptr_cdb, CONFIG_MVLAN);
                                }
                                else
                                {
#endif NO_MULTI_CONFIG_VLAN
                                set_cli_mode(sptr_cdb, CONFIG_VLAN);
#ifndef NO_MULTI_CONFIG_VLAN
                                }
#endif NO_MULTI_CONFIG_VLAN
                        }
                        else
#endif NO_VSRRP
#endif SR_SWITCH_ONLY
            if (sptr_cdb->mode == CONFIG_IF_VLAN)
            {
                set_cli_mode(sptr_cdb, CONFIG_IF);
            }
            else
            if (sptr_cdb->mode == CONFIG_PORT_SECURITY_IF)
            {
                set_cli_mode(sptr_cdb, CONFIG_IF);
            }
            else if (sptr_cdb->mode == CONFIG_PORT_SECURITY_MIF)
            {
                set_cli_mode(sptr_cdb, CONFIG_MIF);
            }
            else if (sptr_cdb->mode == CONFIG_NTP_IF)
            {
                    set_cli_mode(sptr_cdb, CONFIG_NTP);
            }
#ifdef INCLUDE_MCT
                        else if (sptr_cdb->mode == CONFIG_CLUSTER_CLIENT)
            {
                set_cli_mode(sptr_cdb, CONFIG_CLUSTER);
            }
#endif INCLUDE_MCT
                        else if (sptr_cdb->mode == CONFIG_IP_VRF || sptr_cdb->mode == CONFIG_IPV4_VRF || sptr_cdb->mode == CONFIG_IPV6_VRF)
                        {
#ifdef SR_SWITCH_ROUTER
                                vrf_set_address_family_mode(sptr_cdb, 0);
#endif SR_SWITCH_ROUTER
                                set_cli_mode(sptr_cdb, CONFIG);
                        }
#ifdef __MACSEC_ENABLE__
                        else if ( sptr_cdb->mode == CONFIG_DOT1X_MKA_GROUP )
                        {
                            set_cli_mode(sptr_cdb,  CONFIG_DOT1X_MKA);
                        }
                        else if ( sptr_cdb->mode == CONFIG_DOT1X_MKA_IF )
                        {
                            set_cli_mode(sptr_cdb,  CONFIG_DOT1X_MKA); 
                        }
#endif __MACSEC_ENABLE__
            else if (sptr_cdb->mode != CONFIG)
                        {
#ifndef NO_MULTI_CONFIG_VLAN
                                if (sptr_cdb->mode == CONFIG_MVLAN)
                                {
                                        sptr_cdb->parent_mode = CONFIG;
                                        sptr_cdb->mvlan_action_func = NULL;
                                        clear_vlan_id_mask(sptr_cdb);
                                }
#endif NO_MULTI_CONFIG_VLAN
                                set_cli_mode(sptr_cdb, CONFIG);
                                sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;

                                if(sptr_cdb->vlan_group_id)
                                {
                                        //Bug: 344086 We don't remove to sync to standby
                                        //free_vlan_group_entry(sptr_cdb->vlan_group_id, FALSE);
                                        sptr_cdb->vlan_group_id = 0;
                                }
                        }
                        else
                        {
                                //check_running_config_change(sptr_cdb);
                                cli_log_config_changed(sptr_cdb->ui_port, FALSE);
                                set_cli_mode(sptr_cdb, PRIV_EXEC);
                                if (config_term_user_count)
                                        config_term_user_count--;
                                sptr_cdb->isInConfigMode = FALSE;


                        }
                        sptr_cdb->dont_go_next = 1;
                }
        }
}

enum BOOLEAN is_hostname_configed = FALSE;
void preset_hostname(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {	
             	sptr_cdb->dont_go_next = 1;
		/* If no hostname is configured*/
		if(strcmp(snmp.sys_name,g_sw_sys.cptr_def_hostname)==0)
			return;
		/* The HostName should be added startup config only if it configured manually. */
		if(sptr_cdb->show || (FALSE == snmp.is_dynamic_sys_name)) 	// 640714
		{
                	if (snmp.sys_name[0])
				if(TRUE == snmp.is_dynamic_sys_name)
	                        	ksprintf(cu_line_buf, "hostname %s dynamic\n", make_quoted_string(snmp.sys_name));
				else
	                        	ksprintf(cu_line_buf, "hostname %s\n", make_quoted_string(snmp.sys_name));
					
                	else
				if(TRUE == snmp.is_dynamic_sys_name)
                        		ksprintf(cu_line_buf, "hostname \"\" dynamic\n");
				else
                        		ksprintf(cu_line_buf, "hostname \"\"\n");

                	wr_config(sptr_cdb, cu_line_buf);
		}
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if (!sptr_cdb->help)
                        {
                                cu_set_sys_name(g_sw_sys.cptr_def_hostname);
                                is_hostname_configed = FALSE;
                        }
                }
        }
}

void set_hostname(struct cdb* sptr_cdb)
{
        if (sptr_cdb->no) //If NO then just return. Fixes TR000365992
      return;

        if (strlen(sptr_cdb->string1) <= CU_MAX_SYS_NAME_LEN)
        {
                cu_set_sys_name(sptr_cdb->string1);
#ifdef __ISIS_HOST_NAME__
                isis_set_local_host_name((char *)sptr_cdb->string1);
#endif
                is_hostname_configed = TRUE;
        }
        else
                uprintf("Error: Out of bounds - maximum hostname length is %d\n", CU_MAX_SYS_NAME_LEN);
}

void set_no_flag(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no)
                {
                        /*
                         * Handle "no no" case. Set sptr_cdb->dont_go_next to
                         * 1 so that we don't loop back to &config[0] array
                         * again.
                         */
                        uprintf("no no is a do-nothing command.\n");
                        sptr_cdb->dont_go_next = 1;
                }
                else
                {
                        /* BUG: 10314 "no" command is not handled properly if we force
                         * exit vlan-group CLI mode if this "no" is a incomplete command.
                         */
                        if ((end_of_token(sptr_cdb->token) == '\0') && g_vlan_group_cmd)
                                g_vlan_group_cmd = 0;

                        sptr_cdb->no = 1;
                }
        }
}
void set_show_flag(struct cdb* sptr_cdb) // 70334
{
        /* Allow stacking ports to be specified in show commands */
        sptr_cdb->stacking_ports_allowed = TRUE;
#ifdef __PORT_EXTENSION__
        sptr_cdb->spx_ports_allowed = TRUE;
#endif __PORT_EXTENSION__

        if (g_sw_sys.init_in_progress)
        {
                /* Do not parse "show" commands during bootup i.e. if they exist in the startup config */
                /* Bug# 72821 */

                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no)
                {
                        /*
                         * Handle "no show" case. Set sptr_cdb->dont_go_next to
                         * 1 so that we don't loop back to &config[0] array
                         * again.
                         */
                        sptr_cdb->dont_go_next = 1;
                }
                else
                {
                        sptr_cdb->show = 1;
                }
        }
}

void set_cdb_flag1_prio(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen != 0)
                return;
        if (sptr_cdb->integer2 > 7)
        {
                uprintf("Error - priority can be between 0 and 7\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }
        sptr_cdb->flag1 = sptr_cdb->integer2 + 2;
        sptr_cdb->num_of_integer--;
}

void set_cdb_flag1_ipc_rate_limit(struct cdb* sptr_cdb)
{
        set_cdb_flag1(sptr_cdb);
}

void reset_cdb_flag1_ipc_rate_limit(struct cdb* sptr_cdb)
{
        reset_cdb_flag1(sptr_cdb);
}

void set_cdb_flag1_only(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 1;
}

void set_cdb_flag1(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 1;
        sptr_cdb->flag2 = 0;
}

void reset_cdb_flag1(struct cdb* sptr_cdb)
{
        sptr_cdb->flag1 = 0;
        sptr_cdb->flag2 = 0;
}


#ifdef SR_SWITCH_ONLY
//#if (!defined(L3_NO_FILTER) || defined(MAC_FILTER))
void set_integer3_eq(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_EQUALS);
}

void set_integer3_gt(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_MORETHAN);
}

void set_integer3_lt(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_LESSTHAN);
}

void set_integer3_neq(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_NOT_EQUALS);
}

void set_integer3_range(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_RANGE);
}
//#endif
#endif /* SR_SWITCH_ONLY */

#ifdef SR_SWITCH_ROUTER
void set_integer3_eq(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_EQUALS);
}

void set_integer3_gt(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_MORETHAN);
}

void set_integer3_lt(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_LESSTHAN);
}

void set_integer3_neq(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_NOT_EQUALS);
}

void set_integer3_range(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        set_integer(sptr_cdb, 3, IP_FILTER_OPERATOR_RANGE);
}

#ifdef __ISIS__
void set_integer2_isis(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen != 0)
                return;
        set_integer(sptr_cdb, 2, RIP_IMPORT_PROTOCOL_ISIS);
#if 0
        if (end_of_token(sptr_cdb->token) == '\0')
                rip_redistribution(sptr_cdb);
#endif
}
#endif /*__ISIS__*/
void check_matchMetric(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen != 0)
                return;
        if (sptr_cdb->num_of_integer == 3) {
                sptr_cdb->integer4 = sptr_cdb->integer3;
                sptr_cdb->integer3 = 0;
                sptr_cdb->num_of_integer = 4;
        }
#if 0
        rip_redistribution(sptr_cdb);
#endif
}
#endif /* SR_SWTICH_ROUER */

/*
 *  L3 VLAN By Protocol and L3 VLAN By IP Subnet
 */


void set_integer(struct cdb* sptr_cdb, int int_num, int value)
{
        switch (int_num) {
        case 1:
                sptr_cdb->integer1 = value;
                sptr_cdb->num_of_integer = 1;
                break;
        case 2:
                sptr_cdb->integer2 = value;
                sptr_cdb->num_of_integer = 2;
                break;
        case 3:
                sptr_cdb->integer3 = value;
                sptr_cdb->num_of_integer = 3;
                break;
        case 4:
                sptr_cdb->integer4 = value;
                sptr_cdb->num_of_integer = 4;
                break;
        }
}

#if 0
void cli_config_gen_password_change_mode(struct cdb* sptr_cdb)
{
        char temp1[] = "password-change ";
        char temp2[] = "any\n";
        char temp3[] = "console-cli\n";
        char temp4[] = "telnet-cli\n";

        if (sptr_cdb->config_gen)
        {
                /* default is "cli", which does not need to generate. */
                switch (g_sw_sys.password_change_mode)
                {
                case PASSWORD_CHANGE_BY_ANY:
                wr_config(sptr_cdb, temp1);
                wr_config(sptr_cdb, temp2);
                break;
                case PASSWORD_CHANGE_BY_CONSOLE_CLI:
                wr_config(sptr_cdb, temp1);
                wr_config(sptr_cdb, temp3);
                break;
                case PASSWORD_CHANGE_BY_TELNET_CLI:
                wr_config(sptr_cdb, temp1);
                wr_config(sptr_cdb, temp4);
                break;
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if (sptr_cdb->help)
                                return;
                        sptr_cdb->dont_go_next = 1;
                        sptr_cdb->integer1 = PASSWORD_CHANGE_BY_CLI;
                        cli_set_password_change_mode(sptr_cdb);
                }
        }
}

void cli_set_password_change_mode(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                switch (g_sw_sys.password_change_mode)
                {
                case PASSWORD_CHANGE_BY_CONSOLE_CLI:
                        if (sptr_cdb->ui_port != 0)
                        {
                        uprintf("Error - please modify access-change by serial port console.\n");
                        return;
                        }
                        break;
                case PASSWORD_CHANGE_BY_TELNET_CLI:
                        if (sptr_cdb->ui_port == 0)
                        {
                        uprintf("Error - please modify access-change by telnet.\n");
                        return;
                        }
                        break;
                }
                g_sw_sys.password_change_mode = (enum PASSWORD_CHANGE_MODE)
                                                                                sptr_cdb->integer1;
        }
}

void cli_set_password_change_mode_to_any(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = PASSWORD_CHANGE_BY_ANY;
        cli_set_password_change_mode(sptr_cdb);
}

void cli_set_password_change_mode_to_cli(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = PASSWORD_CHANGE_BY_CLI;
        cli_set_password_change_mode(sptr_cdb);
}

void cli_set_password_change_mode_to_console(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = PASSWORD_CHANGE_BY_CONSOLE_CLI;
        cli_set_password_change_mode(sptr_cdb);
}

void cli_set_password_change_mode_to_telnet(struct cdb* sptr_cdb)
{
        sptr_cdb->integer1 = PASSWORD_CHANGE_BY_TELNET_CLI;
        cli_set_password_change_mode(sptr_cdb);
}

int verify_permit_to_change_password(struct cdb* sptr_cdb)
{
        /* check how user login to CLI */
        switch (g_sw_sys.password_change_mode)
        {
        case PASSWORD_CHANGE_BY_CONSOLE_CLI:
        if (sptr_cdb->ui_port != 0)
        {
                uprintf("Error - can't change password in telnet.\n");
                return 0;
        }
        break;

        case PASSWORD_CHANGE_BY_TELNET_CLI:
        if (sptr_cdb->ui_port == 0)
        {
                uprintf("Error - can't change password in console.\n");
                return 0;
        }
        break;
        }

        /* only level 0 user can change password */
        if (sptr_cdb->current_login_password_level != CU_SECURITY_LEVEL0)
        {
                uprintf("Error - only privilege 0 user can change password.\n");
                return 0;
        }

        return 1;
}
#endif 0

#ifdef FIPS_PASSWD_MASK
void telnet_password_callback(UINT32 yes, UINT32 ui_port, UINT32 param3 )
{
        int retval=CU_OK;
        struct io_port_cb *sptr_cb = &io_cb[ui_port];
        struct cdb *sptr_cdb = &cdbs[ui_port];

        sptr_cdb->num_of_integer = 0;
        memcpy(sptr_cdb->string1, sptr_cb->page_mode_cmd_line, PARSER_STRING_LEN );
        cli_set_telnet_encrypted_password(sptr_cdb);

        /* delete this command line from command history */
        cancel_command_line(sptr_cdb->ui_port);
        release_confirm_mode();
}
#endif


void cli_reset_telnet_password_for_undo(struct cdb* sptr_cdb)
{
#ifdef FIPS_PASSWD_MASK
        /* need to Enter key before entering the password if password masking is enabled  -bug 275917 */
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                /* password must be entered interactively from the CLI and allowed on
                * the command line only from startup config file and/or tftp/scp copy */
                if (!g_sw_sys.init_in_progress && ( g_local_access_control.password_masking_enabled ||
                ( cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE)) ) )
                {
                        uprintf("Error - password masking enabled: <cr> required before entering ASCII string.\n");
                        sptr_cdb->dont_go_next = 1;
                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                        return;
                }
        }
#endif
        //Fix 3563: if this is undo command without any help request, then cleanup the password.
        if (sptr_cdb->no && sptr_cdb->help==FALSE)
        {
                                        if(telnet.access_password[0] == 0)
                                        {
                                                uprintf("Error - cannot delete line password. \n");
                                                        sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                                return;
                                        }
                        telnet.access_password[0] = 0;
                                                cancel_command_line(sptr_cdb->ui_port);
                                                send_PasswordUpdate_trap(CU_LINE_SUPER, 0, sptr_cdb->ui_port, CU_DEL);
                        sptr_cdb->dont_go_next = TRUE;
#ifdef FIPS_PASSWD_MASK
                        return;
        }
#else
        }
        return;
#endif

#ifdef FIPS_PASSWD_MASK
        /* need to Enter key before entering the password if password masking is enabled  -bug 275917 */
        if (  !g_sw_sys.init_in_progress && !(okay_to_accept_password() ) )
        {
                if (sptr_cdb->config_gen)
                        return;

                sptr_cdb->dont_go_next = 1;
                uprintf("Enter password: ");
                //set_interactive_page_mode_params(7, superuser_password_callback, (UINT32)sptr_cdb->ui_port, g_local_access_control.password_masking_enabled);
                set_interactive_page_mode_params(7, telnet_password_callback, (UINT32)sptr_cdb->ui_port, 1);
        }
#endif
}

void cli_set_telnet_encrypted_password(struct cdb* sptr_cdb)
{
        int operation=CU_MOD;
        if (sptr_cdb->config_gen)
        {
                if (telnet.access_password[0] == 0)
                        return;
                ksprintf(cu_line_buf, "%s%d %s\n",
                        e_telnet_passwd, telnet.encription_method, telnet.access_password);
                wr_config(sptr_cdb, cu_line_buf);
                return;
        }
        else
        {
                //Fix 3563: No need to wait till the last token for "no".
                //if (sptr_cdb->no)
                //{
                //      telnet.access_password[0] = 0;
                //      return;
                //}
                /* This command starts the telnet listener, so in case of FIPS enabled, don't execute this command */
                if (cu_fips_get_status())
                {
                        uprintf("FIPS: This CLI operation cannot be executed in FIPS mode of operation\n");
                        sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                        return;
                }
                if (sptr_cdb->num_of_integer == 0)
                        sptr_cdb->integer1 = GLOBAL_ENCRYPTION;
                else
                {
                        if (sptr_cdb->integer1 != NO_ENCRYPTION
                        &&  sptr_cdb->integer1 != MD5_ENCRYPTION
                        &&  sptr_cdb->integer1 != MD5_SALT_ENCRYPTION
                        &&  sptr_cdb->integer1 != SHA1_SALT_ENCRYPTION
                        &&  sptr_cdb->integer1 != SHA256_SALT_ENCRYPTION)
                        {
                                                                uprintf("Error - encryption type must be %d, %d, %d, %d or %d\n",
                                                                                                        NO_ENCRYPTION,SHA1_SALT_ENCRYPTION,SHA256_SALT_ENCRYPTION,MD5_ENCRYPTION, MD5_SALT_ENCRYPTION);
                                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                                return;
                        }
                }
                
                if (cli_find_char(sptr_cdb->string1, ' ') != NULL)
                {
                        uprintf("Error - password cannot contain space character.\n");
                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                        return;
                }
                if (!sptr_cdb->string1[0] && telnet.access_password[0])
                        operation=CU_DEL;
                else if (sptr_cdb->string1[0] && !telnet.access_password[0])
                        operation=CU_ADD;
                telnet.encription_method = cu_encrypt(
                                                                        telnet.access_password,
                                                                        sptr_cdb->string1,
                                                                        (UINT8)sptr_cdb->integer1);

                send_PasswordUpdate_trap(CU_LINE_SUPER, 0, sptr_cdb->ui_port, operation);
        }
                cancel_command_line(sptr_cdb->ui_port);
}

void cli_set_telnet_clear_text_password(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (CU_OK != cu_verify_user_password(NULL, sptr_cdb->string1))
        {
                        sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                return;
        }
        cli_set_telnet_encrypted_password(sptr_cdb);
}

void config_gen_level_password(struct cdb* sptr_cdb)
{
        UINT8 *password;

        /* Config gen all levels of password in here */
        if (!sptr_cdb->config_gen)
                return;

        if (g_access_control.level_password[CU_SECURITY_LEVEL0][0] != 0)
        {
                ksprintf(
                        cu_line_buf,
                        "%s%d %s\n",
                        e_superuser_passwd,
                        g_access_control.encription_method[CU_SECURITY_LEVEL0],
                        g_access_control.level_password[CU_SECURITY_LEVEL0]);
                wr_config(sptr_cdb, cu_line_buf);
        }

        if (g_access_control.encription_method[CU_SECURITY_LEVEL4] == MD5_ENCRYPTION
        || g_access_control.encription_method[CU_SECURITY_LEVEL4] == MD5_SALT_ENCRYPTION
        || g_access_control.encription_method[CU_SECURITY_LEVEL4] == SHA1_SALT_ENCRYPTION
        || g_access_control.encription_method[CU_SECURITY_LEVEL4] == SHA256_SALT_ENCRYPTION
        )
                password = default_encrypted_level4_password;
        else
                password = CU_DEFAULT_LEVEL4_PASSWORD;
        if (strcmp(g_access_control.level_password[CU_SECURITY_LEVEL4], password) &&  (g_access_control.level_password[CU_SECURITY_LEVEL4][0] != '\0'))// check for first char '\0' or strlen=0

        {
                ksprintf(
                        cu_line_buf,
                        "%s%d %s\n",
                        e_portconfig_passwd,
                        g_access_control.encription_method[CU_SECURITY_LEVEL4],
                        g_access_control.level_password[CU_SECURITY_LEVEL4]);
                wr_config(sptr_cdb, cu_line_buf);
        }

        if (g_access_control.encription_method[CU_SECURITY_LEVEL5] == MD5_ENCRYPTION
        || g_access_control.encription_method[CU_SECURITY_LEVEL5] == MD5_SALT_ENCRYPTION
                || g_access_control.encription_method[CU_SECURITY_LEVEL5] == SHA1_SALT_ENCRYPTION
                || g_access_control.encription_method[CU_SECURITY_LEVEL5] == SHA256_SALT_ENCRYPTION
                )
                password = default_encrypted_level5_password;
        else
                password = CU_DEFAULT_LEVEL5_PASSWORD;
        if ((strcmp(g_access_control.level_password[CU_SECURITY_LEVEL5], password)) && (g_access_control.level_password[CU_SECURITY_LEVEL5][0] != '\0')) // check for first char '\0' or strlen=0

        {
                ksprintf(
                        cu_line_buf,
                        "%s%d %s\n",
                        e_readonly_passwd,
                        g_access_control.encription_method[CU_SECURITY_LEVEL5],
                        g_access_control.level_password[CU_SECURITY_LEVEL5]);
                wr_config(sptr_cdb, cu_line_buf);
        }
}

int send_enable_password_update_logtrap(int aKind, UINT8 aSession, int aOperation)
{
        int tOpKind;
        if (aKind == CU_SECURITY_LEVEL0)        tOpKind=CU_ENABLE_SUPER;
        else if (aKind == CU_SECURITY_LEVEL4) tOpKind=CU_ENABLE_PORT_CONFIG;
        else if (aKind == CU_SECURITY_LEVEL5) tOpKind=CU_ENABLE_READ_ONLY;
        else return 0;
        send_PasswordUpdate_trap(tOpKind, 0, aSession, aOperation);
        return 0;
}

char temp_parser_string_line[PARSER_STRING_LEN];
void superuser_password_callback(UINT32 yes, UINT32 ui_port, UINT32 param3)
{
        int retval=CU_OK;
        struct io_port_cb *sptr_cb = &io_cb[ui_port];
        struct cdb *sptr_cdb = &cdbs[ui_port];
        char temp[PARSER_STRING_LEN];
        UINT8 encrypted_password[CU_MAX_LENGTH_OF_PASSWORD+1];
        UINT8 encription_method;
        int i;

                if (!MP_IS_ACTIVE())
                        return;

        if (!verify_permit_to_change_password(sptr_cdb))
                return;

        if (sptr_cdb->integer1 != CU_SECURITY_LEVEL0
        &&  g_access_control.level_password[CU_SECURITY_LEVEL0][0] == 0)
        {
                uprintf("Error - assign super-user password first\n");
                return;
        }

        if (cli_find_char(sptr_cb->page_mode_cmd_line, ' ') != NULL)
        {
                uprintf("Error - password cannot contain space character.\n");
                release_confirm_mode();
                return;
        }

        if (CU_OK != cu_verify_user_password(NULL, sptr_cb->page_mode_cmd_line))
        {
                sptr_cdb->dont_go_next = 1;
                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                release_confirm_mode();
                return;
        }

        if (sptr_cdb->num_of_integer == 1)
                sptr_cdb->integer2 = GLOBAL_ENCRYPTION;
        else
        {
                if (sptr_cdb->integer2 != NO_ENCRYPTION
                &&  sptr_cdb->integer2 != MD5_ENCRYPTION
                &&  sptr_cdb->integer2 != MD5_SALT_ENCRYPTION
                                &&      sptr_cdb->integer2 != SHA1_SALT_ENCRYPTION
                                &&      sptr_cdb->integer2 != SHA256_SALT_ENCRYPTION
                                )
                                {
                                                uprintf("Error - encryption type must be %d, %d, %d, %d or %d\n",
                                                         NO_ENCRYPTION,SHA1_SALT_ENCRYPTION,SHA256_SALT_ENCRYPTION, MD5_ENCRYPTION, MD5_SALT_ENCRYPTION);                         
                        release_confirm_mode();
                        return;
                }
        }

                /* Level 0 password can be empty or valid. Other level
                 * passwords must be valid.
                 */
                if (sptr_cdb->integer1 != CU_SECURITY_LEVEL0
                &&  sptr_cb->page_mode_cmd_line[0] == 0)
                {
                        uprintf("Error - password cannot be empty.\n");
                        release_confirm_mode();
                        return;
                }

                encription_method = cu_encrypt(encrypted_password, sptr_cb->page_mode_cmd_line, (UINT8)sptr_cdb->integer2);

                for (i=CU_SECURITY_LEVEL0; i < CU_MAX_LEVELS_OF_PASSWORD; i++)
                {
                        if (i > CU_SECURITY_LEVEL0 && i < CU_SECURITY_LEVEL4)
                                continue;
                        if (i == (int)sptr_cdb->integer1)
                                continue;
                        if (strcmp(g_access_control.level_password[i], encrypted_password) == 0)
                        {
                                uprintf("Error - duplicate password.\n");
                                break;
                        }
                }
                if (i == CU_MAX_LEVELS_OF_PASSWORD)
                {
                        int operation=CU_MOD;
                        if (!encrypted_password[0] && g_access_control.level_password[sptr_cdb->integer1])
                                operation=CU_DEL;
                        else if (encrypted_password[0])
                                operation=CU_ADD;

                        g_access_control.encription_method[sptr_cdb->integer1] = encription_method;
                        strcpy(g_access_control.level_password[sptr_cdb->integer1], encrypted_password);
                        (void)send_enable_password_update_logtrap(sptr_cdb->integer1, sptr_cdb->ui_port, operation);

                        //CHEETAH_STACKING
#ifndef SIDEWINDER_LINUX 
                        if (sptr_cdb->integer1 == CU_SECURITY_LEVEL0)
                        {
                                memcpy(g_stk_auth_info.level_password[0][0], g_access_control.level_password[sptr_cdb->integer1], CU_MAX_LENGTH_OF_PASSWORD);
                                memcpy(g_stk_auth_info.level_password[1][0], g_access_control.level_password[sptr_cdb->integer1], CU_MAX_LENGTH_OF_PASSWORD);
                                g_stk_auth_info.level_password[0][0][CU_MAX_LENGTH_OF_PASSWORD] = NULL;
                                g_stk_auth_info.level_password[1][0][CU_MAX_LENGTH_OF_PASSWORD] = NULL;
                                g_stk_auth_info.encription_method[0][0] = encription_method;
                                g_stk_auth_info.encription_method[1][0] = encription_method;
                        }
#endif
                }

        /* hide all the user exec commands if superuser
         * password was set. Unhide them if superuser
         * password was not set.
         */
#ifdef NOT_USED
        /* commented out because we are using privilege level
         * in the user mode to permit/deny level 4 or above
         * commands
         */
        if (g_access_control.level_password[CU_SECURITY_LEVEL0][0] != 0)
                security_parser(USER_EXEC, TRUE);
        else
                security_parser(USER_EXEC, FALSE);
#endif NOT_USED

                        /* Sync to standby */
                                if ( sptr_cdb->line == NULL ) 
                                {
                                        memset(temp_parser_string_line,0,PARSER_STRING_LEN);
                                        strncat(temp_parser_string_line,"enable ", 7);
                                        strncat(temp_parser_string_line," password", 9);
                                        sptr_cdb->line = (char*)&temp_parser_string_line;
                                }
                                memcpy(sptr_cdb->string1, sptr_cb->page_mode_cmd_line, PARSER_STRING_LEN);
                                strncat(sptr_cdb->line," ",1);
                                strncat(sptr_cdb->line,sptr_cdb->string1,strlen(sptr_cdb->string1));
                                send_masked_comamnd_to_stby(sptr_cdb, sptr_cdb->curr_node_array);
        /* delete this command line from command history */
        cancel_command_line(sptr_cdb->ui_port);
        release_confirm_mode();
}

void set_level_0_password(struct cdb* sptr_cdb)
{
#if 0
        /* need to Enter key before entering the password if password masking is enabled  -bug 275917 */
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                /* password must be entered interactively from the CLI and allowed on
                * the command line only from startup config file and/or tftp/scp copy */
#ifdef FIPS_PASSWD_MASK
                if (!g_sw_sys.init_in_progress && ( g_local_access_control.password_masking_enabled ||
                ( cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE)) ) )
#else
                if (!g_sw_sys.init_in_progress && g_access_control.user_password_masking)
#endif
                {
                        uprintf("Error - password masking enabled: <cr> required before entering ASCII string.\n");
                        sptr_cdb->dont_go_next = 1;
                        return;
                }
        }
#endif
                if ( is_this_standby() && (g_access_control.user_password_masking) )
                 {
                         if ( end_of_token (sptr_cdb->token) != '\0')
                         {
                                 return;
                         } 
                 }
                

        if (sptr_cdb->no && !sptr_cdb->help)
        {
                sptr_cdb->dont_go_next = TRUE;
                if (strcmp(g_access_control.level_password[CU_SECURITY_LEVEL4], CU_DEFAULT_LEVEL4_PASSWORD)
                ||  strcmp(g_access_control.level_password[CU_SECURITY_LEVEL5], CU_DEFAULT_LEVEL5_PASSWORD))
                {
                        uprintf("Error - delete other passwords first, delete super-user password last\n");
                        return;
                }
                                if(g_access_control.level_password[CU_SECURITY_LEVEL0][0] == 0)
                                {
                                uprintf("Error - cannot delete super-user password. \n");
                                        sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                    return;
                                }
                g_access_control.level_password[CU_SECURITY_LEVEL0][0] = 0;
#ifndef SIDEWINDER_LINUX                
                g_stk_auth_info.level_password[0][0][0] = NULL; //CHEETAH_STACKING
                g_stk_auth_info.level_password[1][0][0] = NULL;
#endif
                /* delete this command line from command history */
                cancel_command_line(sptr_cdb->ui_port);
                                send_PasswordUpdate_trap(CU_ENABLE_SUPER, 0, sptr_cdb->ui_port, CU_DEL);
                return;
        }
        else
        {
                /* need to Enter key before entering the password if password masking is enabled  -bug 275917 */
                 if (end_of_token(sptr_cdb->token) != '\0')
                        {
                                /* password must be entered interactively from the CLI and allowed on
                                * the command line only from startup config file and/or tftp/scp copy */
#ifdef FIPS_PASSWD_MASK
                                if (!g_sw_sys.init_in_progress && ( g_local_access_control.password_masking_enabled ||
                                ( cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE)) ) )
#else
                                if (!g_sw_sys.init_in_progress && g_access_control.user_password_masking)
#endif
                                {
                                        uprintf("Error - password masking enabled: <cr> required before entering ASCII string.\n");
                                        sptr_cdb->dont_go_next = 1;
                                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                                        return;
                                }
                        }

                sptr_cdb->integer1 = CU_SECURITY_LEVEL0;
                sptr_cdb->num_of_integer++;
                config_gen_level_password(sptr_cdb);
        }

        /* need to Enter key before entering the password if password masking is enabled  -bug 275917 */
        //
        //if (!g_sw_sys.init_in_progress  && ( g_local_access_control.password_masking_enabled ||
        //(cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE)) ) )
#ifdef FIPS_PASSWD_MASK
        if (  !g_sw_sys.init_in_progress && !(okay_to_accept_password() ) )
#else
        if (!g_sw_sys.init_in_progress  && g_access_control.user_password_masking)
#endif

        {
                if (sptr_cdb->config_gen)
                        return;

                sptr_cdb->dont_go_next = 1;
                                
                                if (MP_IS_ACTIVE())
                       uprintf("Enter password: ");
#ifdef FIPS_PASSWD_MASK
                set_interactive_page_mode_params(7, superuser_password_callback, (UINT32)sptr_cdb->ui_port, 1);
#else
                set_interactive_page_mode_params(7, superuser_password_callback, (UINT32)sptr_cdb->ui_port, g_access_control.user_password_masking);
#endif
        }
}

#ifdef FIPS_PASSWD_MASK
void level_password_callback(UINT32 yes, UINT32 ui_port, UINT32 param3 )
{
        int retval=CU_OK;
        struct io_port_cb *sptr_cb = &io_cb[ui_port];
        struct cdb *sptr_cdb = &cdbs[ui_port];

        sptr_cdb->num_of_integer = 1;
        sptr_cdb->integer1 = GLOBAL_ENCRYPTION;
        memcpy(sptr_cdb->string1, sptr_cb->page_mode_cmd_line, PARSER_STRING_LEN );
         cli_set_level_encrypted_password(sptr_cdb);

        /* delete this command line from command history */
        cancel_command_line(sptr_cdb->ui_port);
        release_confirm_mode();
}
#endif


void set_level_4_password(struct cdb* sptr_cdb)
{

#ifdef FIPS_PASSWD_MASK
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                if (!g_sw_sys.init_in_progress &&
                ( cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE) ) )
                {
                        uprintf("Error - password masking enabled: <cr> required before entering ASCII string.\n");
                        sptr_cdb->dont_go_next = 1;
                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                        return;
                }
        }
#endif
        if (sptr_cdb->no && !sptr_cdb->help)
        {
                g_access_control.encription_method[CU_SECURITY_LEVEL4] = NO_ENCRYPTION;
                strcpy(g_access_control.level_password[CU_SECURITY_LEVEL4], CU_DEFAULT_LEVEL4_PASSWORD);
                /* delete this command line from command history */
                cancel_command_line(sptr_cdb->ui_port);
                sptr_cdb->dont_go_next = TRUE;
        }
        else
        {
                sptr_cdb->integer1 = CU_SECURITY_LEVEL4;
                sptr_cdb->num_of_integer++;
        }
#ifdef FIPS_PASSWD_MASK
        if (!g_sw_sys.init_in_progress  &&
        (cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE) ) )
        {
                if (sptr_cdb->config_gen)
                        return;

                sptr_cdb->dont_go_next = 1;

                uprintf("Enter password: ");
                set_interactive_page_mode_params(7, level_password_callback, (UINT32)sptr_cdb->ui_port, 1);
        }
#endif
}

void set_level_5_password(struct cdb* sptr_cdb)
{
#ifdef FIPS_PASSWD_MASK
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                if (!g_sw_sys.init_in_progress &&
                ( cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE) ) )
                {
                        uprintf("Error - password masking enabled: <cr> required before entering ASCII string.\n");
                        sptr_cdb->dont_go_next = 1;
                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                        return;
                }
        }
#endif
        if (sptr_cdb->no && !sptr_cdb->help)
        {
                g_access_control.encription_method[CU_SECURITY_LEVEL5] = NO_ENCRYPTION;
                strcpy(g_access_control.level_password[CU_SECURITY_LEVEL5], CU_DEFAULT_LEVEL5_PASSWORD);
                /* delete this command line from command history */
                cancel_command_line(sptr_cdb->ui_port);
                sptr_cdb->dont_go_next = TRUE;
        }
        else
        {
                sptr_cdb->integer1 = CU_SECURITY_LEVEL5;
                sptr_cdb->num_of_integer++;
        }
#ifdef FIPS_PASSWD_MASK
        if (!g_sw_sys.init_in_progress  &&
        (cu_fips_get_status () && (cu_fips_get_enable_password_display() == FALSE) ) )
        {
                if (sptr_cdb->config_gen)
                        return;

                sptr_cdb->dont_go_next = 1;

                uprintf("Enter password: ");
                set_interactive_page_mode_params(7, level_password_callback, (UINT32)sptr_cdb->ui_port, 1);
        }
#endif
}

void cli_set_level_encrypted_password(struct cdb* sptr_cdb)
{
        int i;
        UINT8 encrypted_password[CU_MAX_LENGTH_OF_PASSWORD+1];
        UINT8 encription_method;

        if (sptr_cdb->config_gen)
                return;

        if (!verify_permit_to_change_password(sptr_cdb))
                return;

        if (sptr_cdb->integer1 != CU_SECURITY_LEVEL0
        &&  g_access_control.level_password[CU_SECURITY_LEVEL0][0] == 0)
        {
                uprintf("Error - assign super-user password first\n");
                return;
        }

        //Bug fix 3563.
        //if (sptr_cdb->no)
        //{
        //      switch (sptr_cdb->integer1)
        //      {
        //      case CU_SECURITY_LEVEL0:
        //      if (strcmp(g_sw_sys.level_password[CU_SECURITY_LEVEL4], CU_DEFAULT_LEVEL4_PASSWORD)
        //      ||  strcmp(g_sw_sys.level_password[CU_SECURITY_LEVEL5], CU_DEFAULT_LEVEL5_PASSWORD))
        //      {
        //              uprintf("Error - delete other passwords first, delete super-user password last\n");
        //              return;
        //      }
        //      g_sw_sys.level_password[CU_SECURITY_LEVEL0][0] = 0;
        //      break;
//
        //      case CU_SECURITY_LEVEL4:
        //      g_sw_sys.encription_method[CU_SECURITY_LEVEL4] = NO_ENCRYPTION;
        //      strcpy(g_sw_sys.level_password[CU_SECURITY_LEVEL4], CU_DEFAULT_LEVEL4_PASSWORD);
        //      break;
//
        //      case CU_SECURITY_LEVEL5:
        //      g_sw_sys.encription_method[CU_SECURITY_LEVEL5] = NO_ENCRYPTION;
        //      strcpy(g_sw_sys.level_password[CU_SECURITY_LEVEL5], CU_DEFAULT_LEVEL5_PASSWORD);
        //      break;
        //      }
        //}
        //else

        //if (!g_local_access_control.password_masking_enabled &&
                //( cu_fips_get_status () && (cu_fips_get_enable_password_display() == TRUE)) )
                if ( is_this_standby() && (g_access_control.user_password_masking) )
                                {
                                        if ( end_of_token (sptr_cdb->token) != '\0')
                                        {
                                                return;
                                        } 
                                        else 
                                        {
                                                encription_method = cu_encrypt(encrypted_password, sptr_cdb->string1, (UINT8)sptr_cdb->integer2);
                                                g_access_control.encription_method[sptr_cdb->integer1] = encription_method;
                                                strcpy(g_access_control.level_password[sptr_cdb->integer1], encrypted_password);
                                                return;
                                        }
                                }
                                if (end_of_token(sptr_cdb->token) != '\0')
                                {
                                        /* password must be entered interactively from the CLI and allowed on
                                         * the command line only from startup config file and/or tftp/scp copy */
#ifdef FIPS_PASSWD_MASK
                                        if (!g_sw_sys.init_in_progress && !g_copy_tftp_acl_in_progress && ( g_access_control.user_password_masking ||
                                                (cu_fips_get_status() && (cu_fips_get_enable_password_display() == FALSE) )  ) ) 
#else
                                                if (!g_sw_sys.init_in_progress && !g_copy_tftp_acl_in_progress && g_access_control.user_password_masking)
#endif
                                        {
                                                uprintf("Error - password masking enabled: <cr> required before entering ASCII string.\n");
                                                sptr_cdb->dont_go_next = 1;
                                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                                        }
                
                                        return;
                                }
#ifdef FIPS_PASSWD_MASK
        if ( okay_to_accept_password() )
#else
        if (!g_access_control.user_password_masking)
#endif

        {
                if (CU_OK != cu_verify_user_password(NULL, sptr_cdb->string1))
                {
                                sptr_cdb->error = UNSPECIFIED_PARSE_ERROR;
                        return;
                }

                if (sptr_cdb->num_of_integer == 1)
                        sptr_cdb->integer2 = GLOBAL_ENCRYPTION;
                else
                {
                        if (sptr_cdb->integer2 != NO_ENCRYPTION
                        &&  sptr_cdb->integer2 != MD5_ENCRYPTION
                        &&  sptr_cdb->integer2 != MD5_SALT_ENCRYPTION
                                                &&      sptr_cdb->integer2 != SHA1_SALT_ENCRYPTION
                                            &&  sptr_cdb->integer2 != SHA256_SALT_ENCRYPTION
                                                )
                                                {
                                                        uprintf("Error - encryption type must be %d, %d, %d, %d or %d\n",
                                                          NO_ENCRYPTION,SHA1_SALT_ENCRYPTION,SHA256_SALT_ENCRYPTION, MD5_ENCRYPTION, MD5_SALT_ENCRYPTION);
                                return;
                        }
                }

                if (cli_find_char(sptr_cdb->string1, ' ') != NULL)
                {
                        uprintf("Error - password cannot contain space character.\n");
                        return;
                }

                /* Level 0 password can be empty or valid. Other level
                 * passwords must be valid.
                 */
                if (sptr_cdb->integer1 != CU_SECURITY_LEVEL0
                &&  sptr_cdb->string1[0] == 0)
                {
                        uprintf("Error - password cannot be empty.\n");
                        return;
                }

                encription_method = cu_encrypt(encrypted_password, sptr_cdb->string1, (UINT8)sptr_cdb->integer2);

                for (i=CU_SECURITY_LEVEL0; i < CU_MAX_LEVELS_OF_PASSWORD; i++)
                {
                        if (i > CU_SECURITY_LEVEL0 && i < CU_SECURITY_LEVEL4)
                                continue;
                        if (i == (int)sptr_cdb->integer1)
                                continue;
                        if (strcmp(g_access_control.level_password[i], encrypted_password) == 0)
                        {
                                uprintf("Error - duplicate password.\n");
                                break;
                        }
                }
                if (i == CU_MAX_LEVELS_OF_PASSWORD)
                {
                        int operation=CU_MOD;
                        if (!encrypted_password[0] && g_access_control.level_password[sptr_cdb->integer1])
                                operation=CU_DEL;
                        else if (encrypted_password[0])
                                operation=CU_ADD;

                        g_access_control.encription_method[sptr_cdb->integer1] = encription_method;
                        strcpy(g_access_control.level_password[sptr_cdb->integer1], encrypted_password);
                        (void)send_enable_password_update_logtrap(sptr_cdb->integer1, sptr_cdb->ui_port, operation);

                        //CHEETAH_STACKING
#ifndef SIDEWINDER_LINUX
                        if (sptr_cdb->integer1 == CU_SECURITY_LEVEL0)
                        {
                                memcpy(g_stk_auth_info.level_password[0][0], g_access_control.level_password[sptr_cdb->integer1], CU_MAX_LENGTH_OF_PASSWORD);
                                memcpy(g_stk_auth_info.level_password[1][0], g_access_control.level_password[sptr_cdb->integer1], CU_MAX_LENGTH_OF_PASSWORD);
                                g_stk_auth_info.level_password[0][0][CU_MAX_LENGTH_OF_PASSWORD] = NULL;
                                g_stk_auth_info.level_password[1][0][CU_MAX_LENGTH_OF_PASSWORD] = NULL;
                                g_stk_auth_info.encription_method[0][0] = encription_method;
                                g_stk_auth_info.encription_method[1][0] = encription_method;
                        }
#endif

                }

        /* hide all the user exec commands if superuser
         * password was set. Unhide them if superuser
         * password was not set.
         */
#ifdef NOT_USED
        /* commented out because we are using privilege level
         * in the user mode to permit/deny level 4 or above
         * commands
         */
        if (g_access_control.level_password[CU_SECURITY_LEVEL0][0] != 0)
                security_parser(USER_EXEC, TRUE);
        else
                security_parser(USER_EXEC, FALSE);
#endif NOT_USED

        /* delete this command line from command history */
        cancel_command_line(sptr_cdb->ui_port);
        return;
        }

        /* need to Enter key before entering the password if password masking is enabled  -bug 275917 */
        sptr_cdb->dont_go_next = 1;

        uprintf("Enter password: ");
#ifdef FIPS_PASSWD_MASK
        set_interactive_page_mode_params(7, superuser_password_callback, (UINT32)sptr_cdb->ui_port, 1);
#else
        set_interactive_page_mode_params(7, superuser_password_callback, (UINT32)sptr_cdb->ui_port, g_access_control.user_password_masking);
#endif

}

void cli_set_level_clear_text_password(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        cli_set_level_encrypted_password(sptr_cdb);
}

void cli_set_encrypted_secret(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        sptr_cdb->integer1 = CU_SECURITY_LEVEL0;
        sptr_cdb->num_of_integer++;
        cli_set_level_encrypted_password(sptr_cdb);
}

void cli_set_clear_text_secret(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        cli_set_encrypted_secret(sptr_cdb);
}

void page_display(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        io_cb[sptr_cdb->ui_port].skip_page_mode = 0;
        uprintf("Enable page display mode\n");
}

void stop_page_display(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        io_cb[sptr_cdb->ui_port].skip_page_mode = 1;
        uprintf("Disable page display mode\n");
}

void skip_page_display(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_skip_page_mode == 0)
                        return;
                wr_config(sptr_cdb, "enable skip-page-display\n");
        }
        else
        {
                if (sptr_cdb->no)
                        g_skip_page_mode = 0;
                else
                        g_skip_page_mode = 1;
        }
}
void set_min_password_length(int min_passwd_length)
{
        if ( !cu_fips_get_admin_state())   
                g_access_control.min_password_length = min_passwd_length;                           
        else
                {
                        if(min_passwd_length < CU_FIPS_MIN_LENGTH_OF_PASSWORD)
                                uprintf("Password length out of range in FIPS mode. Valid range %d-%d\n", CU_FIPS_MIN_LENGTH_OF_PASSWORD, CU_MAX_LENGTH_OF_PASSWORD);
                        else
                                g_access_control.min_password_length = min_passwd_length; 
                }
}

int get_min_password_length()
{
        return g_access_control.min_password_length;
}


void cli_set_min_password_length(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                        if ( !cu_fips_get_admin_state())
                        {
                        if (get_min_password_length()==CU_MIN_LENGTH_OF_PASSWORD)
                        return;
                        }
                                else
                                {
                                        if (get_min_password_length()==CU_FIPS_MIN_LENGTH_OF_PASSWORD)
                        return;
                                }
                ksprintf(cu_line_buf, "enable password-min-length %d\n", g_access_control.min_password_length);
                wr_config(sptr_cdb, cu_line_buf);
        }
        else
        {
                if (sptr_cdb->no)
                {
                        sptr_cdb->dont_go_next = 1;
                                        if(cu_fips_get_admin_state())
                                set_min_password_length(CU_FIPS_MIN_LENGTH_OF_PASSWORD);
                                                else
                                                        set_min_password_length(CU_MIN_LENGTH_OF_PASSWORD);

                }
                else
        {
                        if(cu_fips_get_admin_state())
                        {
                        if (sptr_cdb->integer1>=CU_FIPS_MIN_LENGTH_OF_PASSWORD &&
                                sptr_cdb->integer1 <= CU_MAX_LENGTH_OF_PASSWORD)
                                g_access_control.min_password_length = sptr_cdb->integer1;
                        else
                                                                uprintf("Password length out of range. Valid range %d-%d\n", CU_FIPS_MIN_LENGTH_OF_PASSWORD, CU_MAX_LENGTH_OF_PASSWORD);
                        }
                                else
                                {
                                        if (sptr_cdb->integer1>=CU_MIN_LENGTH_OF_PASSWORD &&
                                sptr_cdb->integer1 <= CU_MAX_LENGTH_OF_PASSWORD)
                                g_access_control.min_password_length = sptr_cdb->integer1;
                        else
                                                                uprintf("Password length out of range. Valid range %d-%d\n", CU_MIN_LENGTH_OF_PASSWORD, CU_MAX_LENGTH_OF_PASSWORD);
                                }
            }
        }
        return;
}

void show_password(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_show_password == 0)
                        return;

                wr_config(sptr_cdb, "enable password-display\n");
        }
        else
        {
                if (sptr_cdb->no)
                        g_show_password = 0;
                else
                {
                        if (cu_fips_get_admin_state())
                        {
                                uprintf("FIPS Error: 'enable password-display' operation is not allowed when system is running in FIPS mode.\n");
                                return;
                        }

                        g_show_password = 1;
                }
        }
}

#ifdef TOS_BASED_QOS

int validate_dscp(struct cdb* sptr_cdb, int start, int end)
{
        int i, val;

        if(start < 1 || end > 8 || start > end)
                return 1; /* nothing to check */

		//Removing the last condition of -1 since the for loop will
        //execute between the values 1 and 8. Since -1 will hit only for i=9.
        for(i = start; i <= end; i++)
        {
                val = (i == 1)? sptr_cdb->integer1: (i == 2)? sptr_cdb->integer2:
                        (i == 3)? sptr_cdb->integer3: (i == 4)? sptr_cdb->integer4:
                        (i == 5)? sptr_cdb->integer5: (i == 6)? sptr_cdb->integer6:
                        (i == 7)? sptr_cdb->integer7: sptr_cdb->integer8;
		//The val < 0 is already checked and the condition val < 0 will not occur.
                if(val >= TOS_MAX_DSCP)
                {
                        uprintf("Invalid DSCP value. Valid values are 0 to 63.\n");
                        return 0;
                }
        }
        return 1;
}

int validate_ipprec(int val)
{
        if((val < 0) || (val >= TOS_MAX_IP_PRECEDENCE))
        {
                uprintf("Invalid IP Precedence value. Valid values are 0 to 7.\n");
                return 0;
        }
        return 1;
}

int validate_priority(int val)
{
        if((val < 0) || (val >= TOS_MAX_PRIORITY))
        {
                uprintf("Invalid Priority. Valid values are 0 to 7.\n");
                return 0;
        }
        return 1;
}

int validate_dscp_val(int val)
{
        if((val < 0) || (val >= TOS_MAX_DSCP))
        {
                uprintf("Invalid DSCP value. Valid values are 0 to %d.\n", TOS_MAX_DSCP);
                return 0;
        }
        return 1;
}

void cli_show_tos_qos_info_page(UINT32 rc, UINT32 paging, UINT32 pagenum)
{
        UINT32 i,j,k;
        char port_string[8];
        PORT_ID         port;
        UINT8           vpt[8];
#ifdef SR_SWITCH_ROUTER
        IP_PORT_DB_ENTRY *portP;
#endif

        if(rc == 0)
        {
                release_page_mode();
                return;
        }

        switch(pagenum)
        {
        case 0:
                set_page_mode(cli_show_tos_qos_info_page, TRUE, pagenum+1);
                return;
        case 1:

                uprintf("DSCP-->Traffic-Class map: (DSCP = d1d2: 00, 01...63)\n\n");
                uprintf("     d2|  0   1   2   3   4   5   6   7   8   9 \n");
                uprintf("  d1   |                                        \n");
                uprintf("  -----+----------------------------------------\n");
				/*coverity 23056: Invalid coverity , since k=6 will not validate the loop
				 * */
                for(k = 0, j = 0; k <= 5; k++, j = k*10)
                        uprintf("   %d   |  %d   %d   %d   %d   %d   %d   %d   %d   %d   %d \n", k,
                                g_tos_map_dscp_to_priority[j+0], g_tos_map_dscp_to_priority[j+1],
                                g_tos_map_dscp_to_priority[j+2], g_tos_map_dscp_to_priority[j+3],
                                g_tos_map_dscp_to_priority[j+4], g_tos_map_dscp_to_priority[j+5],
                                g_tos_map_dscp_to_priority[j+6], g_tos_map_dscp_to_priority[j+7],
                                g_tos_map_dscp_to_priority[j+8], g_tos_map_dscp_to_priority[j+9]);
                uprintf("   6   |  %d   %d   %d   %d                         \n\n",
                        g_tos_map_dscp_to_priority[60], g_tos_map_dscp_to_priority[61],
                        g_tos_map_dscp_to_priority[62], g_tos_map_dscp_to_priority[63]);


                k = pp_get_tc_vpt_mapping(DesignatedPpDevNum, // all devices have same config, so try one that always exist
                                          vpt);

                if (k == 8) {
                        uprintf("Traffic-Class-->802.1p-Priority map (use to derive DSCP--802.1p-Priority):\n\n");
                        uprintf("Traffic | 802.1p\n");
                        uprintf("Class   | Priority\n");
                        uprintf("--------+---------\n");
                        for (k = 0; k < 8; k++) /*KATARA_L2*/
                                uprintf("   %d    |    %d\n", (k), vpt[k]);
                        uprintf("--------+---------\n\n");
                }

                show_8to4_queue_mapping();
                release_page_mode();

                return;
        }
}

void show_tos_qos_info(struct cdb* sptr_cdb)
{
        if(!sptr_cdb->config_gen &&
           end_of_token(sptr_cdb->token) == '\0' &&
           cli_find_char(sptr_cdb->token, '?') == NULL)
                cli_show_tos_qos_info_page(1, TRUE, 0);
}

#define SET_PORT_QOS    1
#define SET_PORT_MARK   2
#define SET_PORT_TRUST  3

void tos_qos_pre_init()
{
        int i;
        UINT32  total_ports;
        PORT_ID port;

        for (i=0; i<TOS_MAX_IP_PRECEDENCE; i++)
        {
                g_tos_map_ip_prec_to_dscp[i] = TOS_DEFAULT_DSCP(i);
        }

        for (i=0; i<TOS_MAX_COS; i++)
        {
                g_tos_map_cos_to_dscp[i] = TOS_DEFAULT_DSCP(i);
        }

        for (i=0; i<TOS_MAX_DSCP; i++)
        {
                g_tos_map_dscp_to_priority[i] = TOS_DEFAULT_PRIORITY(i);
        }

        for (i=0; i<TOS_MAX_DSCP; i++)
        {
                g_tos_map_dscp_to_dscp[i] = TOS_DEFAULT_DSCP2DSCP(i);
        }
        tos_based_qos_init = 1;
}


void cli_tos_qos_set_port_now(UINT32 if_num, int type, int val, int force)
{
}

void tos_qos_init_group_port(UINT32 if_num, int type, int val)
{
        if(IS_PORT_DB_VALID(if_num) && trunk_port_state(if_num) == TRUNK_PRIMARY)
        {
                UINT32 group_id, k;

                group_id = trunk_group_id(if_num);
                cli_tos_qos_set_port_now(if_num, type, val, 0);

                for (k = 0; k < g_sw_load_group[group_id].config_ports; k++)
                {
                        cli_tos_qos_set_port_now(g_sw_load_group[group_id].port_list[k], type, val, 0);
                }
        }
        else {
                cli_tos_qos_set_port_now(if_num, type, val, 0);
        }

}

void tos_qos_post_init()
{
        UINT32 i;
        PORT_ID port;
#ifdef SR_SWITCH_ROUTER
        IP_PORT_DB_ENTRY *portP;
#endif

        /* because of startup timing, some ports of the ve or trunk may not be
           logically group yet.  We walk through the interface(s) once more to
           ensure all the ports that are part of ve or trunk will get set to
           correct nat state. */
#ifdef SR_SWITCH_ROUTER
        for (portP = ip_port_db_list_head; portP != NULL; portP = portP->next)
        {
                i = portP->port_number;
                port = i;
#else
        for (i = 0; i < g_hw_info.total_ports; i++)
        {
                port = sw_swport_list[i];
                if (!IS_PORT_ENET(port))
                        continue;

#endif SR_SWITCH_ROUTER
                if ( i >= sw_l4_tos_total_port) {
                        /* TBD: slave insertion.  we need to increase the tos_port struct.  skip for now. */
                        continue;
                }
                if(tos_enable(port))
                {
                        tos_qos_init_group_port(port, SET_PORT_QOS, 1);
                        if(tos_mark(port) != TOS_MARK_NONE)
                                tos_qos_init_group_port(port, SET_PORT_MARK, tos_mark(port));
                        if(tos_trust_level(port) != TOS_TRUST_DEFAULT)
                                tos_qos_init_group_port(port, SET_PORT_TRUST, tos_trust_level(port));
                }
        }
}

#if defined(SR_SWITCH_ROUTER)
/*
   when a new router int is created or deleted or if there is a change of port membership
   for a virtual port, then this method will be called.
   This method will set the QoS status of each of the physical ports that are
   members of this virtual i/f.
*/
void tos_qos_refresh_virtual_if(UINT32 router_int, PORT_MASK *old_member_mask, PORT_MASK *new_member_mask)
{
        if(is_virtual_port(router_int) && tos_based_qos_init &&
                router_int < sw_l4_tos_total_port && tos_enable(router_int) != 0)
        {
                UINT32 i;

                if (new_member_mask && !is_mask_equal(old_member_mask, new_member_mask)) {
                        /* if a port is removed from this ve, reset it's QoS prop */
                        for(i = 0; i < g_hw_info.max_port; i++)
                                if (( is_member(old_member_mask, i) && !is_member(new_member_mask,i) ) ||
                                    ( !is_member(old_member_mask, i) && is_member(new_member_mask,i) )
                                   )
                                {
                                        tos_enable(i) = 0;
                                        tos_mark(i) = TOS_MARK_NONE;
                                        tos_trust_level(i) = TOS_TRUST_DEFAULT;
                                        if(is_member(old_member_mask, i) && !is_member(new_member_mask,i))
                                        {
#if defined(SR_SWITCH_ROUTER) && defined(FOUNDRY_NAT)
                                                ip_toggle_interface_hw_fwd_state_no_filt_check(i, HW_L3_FWD_ON, TRUE);
#endif
                                        }
                                }
                }

                /* if the virtual port is removed, then automatically reset it's properties */
                if(!new_member_mask)
                {
                        tos_enable(router_int) = 0;
                        tos_mark(router_int) = TOS_MARK_NONE;
                        tos_trust_level(router_int) = TOS_TRUST_DEFAULT;
#if defined(SR_SWITCH_ROUTER) && defined(FOUNDRY_NAT)
                        ip_toggle_interface_hw_fwd_state_no_filt_check(router_int, HW_L3_FWD_ON, TRUE);
#endif
                }
#if defined(SR_SWITCH_ROUTER) && defined(FOUNDRY_NAT)
                else
                        ip_toggle_interface_hw_fwd_state_no_filt_check(router_int, HW_L3_FWD_OFF, TRUE);
#endif
        }
}
#endif

void cli_tos_qos_set_group_port(struct cdb* sptr_cdb, UINT32 type, int trust_or_mark)
{
    int if_num = sptr_cdb->if_num - 1;
        UINT32 i;
        UINT32 val;

        if (end_of_token(sptr_cdb->token) == '\0' &&
            cli_find_char(sptr_cdb->token, '?') == NULL)
        {
                if(sptr_cdb->config_gen)
                {
                        /* If current value is not the default value, then generate command */
                        if(type == SET_PORT_QOS && tos_enable(if_num))
                                wr_config(sptr_cdb, " qos-tos\n");
                        else if(type == SET_PORT_MARK)
                        {
                                if(tos_mark(if_num) & TOS_MARK_COS)
                                        wr_config(sptr_cdb, " qos-tos mark cos\n");
                                if(tos_mark(if_num) & TOS_MARK_DSCP)
                                        wr_config(sptr_cdb, " qos-tos mark dscp\n");

                                sptr_cdb->dont_go_next = 1;
                        }
                        /* for trust-level we shouldn't come here */
                }
                else
                {
                        sptr_cdb->dont_go_next = 1;

                        if(if_num < 0 /* || if_num >= g_hw_info.total_ports */){
                                uprintf("Error - Invalid interface.\n");
                                return;
                        }

                        if((type == SET_PORT_MARK || type == SET_PORT_TRUST) && !tos_enable(if_num))
                        {
                                uprintf("First enable QoS on this port with the qos command.\n");
                                return;
                        }


                        if(type == SET_PORT_TRUST)
                                val = (sptr_cdb->no)? TOS_TRUST_DEFAULT: trust_or_mark;
                        else if(type == SET_PORT_MARK)
                                val = (trust_or_mark == TOS_MARK_NONE)? TOS_MARK_NONE:
                                        ((sptr_cdb->no)? (tos_mark(if_num) & ~trust_or_mark):
                                         (tos_mark(if_num) | trust_or_mark));
                        else
                                val = (sptr_cdb->no)? 0: 1;


                        if(trunk_port_state(if_num) == TRUNK_PRIMARY)
                        {
                                UINT32 group_id, k;

                                group_id = trunk_group_id(if_num);
                                cli_tos_qos_set_port_now(if_num, type, val, 0);

                                for (k = 0; k < g_sw_load_group[group_id].config_ports; k++)
                                        cli_tos_qos_set_port_now(g_sw_load_group[group_id].port_list[k], type, val, 0);
                        }
                        else
                                cli_tos_qos_set_port_now(if_num, type, val, 0);
                }
        }
}

void cli_tos_qos_set_port_qos(struct cdb* sptr_cdb)
{
        cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_QOS, -1);
}

void cli_tos_qos_set_mark_cos(struct cdb* sptr_cdb)
{
        cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_MARK, TOS_MARK_COS);
}

void cli_tos_qos_set_mark_dscp(struct cdb* sptr_cdb)
{
        cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_MARK, TOS_MARK_DSCP);
}

void cli_tos_qos_set_trust_cos(struct cdb* sptr_cdb)
{
        cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_TRUST, TOS_TRUST_COS);
}

void cli_tos_qos_set_trust_ipprec(struct cdb* sptr_cdb)
{
        cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_TRUST, TOS_TRUST_IPPREC);
}

void cli_tos_qos_set_trust_dscp(struct cdb* sptr_cdb)
{
        cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_TRUST, TOS_TRUST_DSCP);
}

void cli_tos_qos_check_mark(struct cdb* sptr_cdb)
{
        if(sptr_cdb->config_gen) /* during the config gen, we will ignore the third param */
                cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_MARK, TOS_MARK_NONE);
}

void cli_tos_qos_check_trust(struct cdb* sptr_cdb)
{
        if(sptr_cdb->config_gen)
        {
                UINT32 if_num = sptr_cdb->if_num - 1;

          /* If current value is not the default value, then generate command */
           switch (tos_trust_level(if_num))
           {
                case TOS_TRUST_COS:
                        wr_config(sptr_cdb, " qos-tos trust cos\n");
                        break; /* this is the default */
                case TOS_TRUST_IPPREC:
                        wr_config(sptr_cdb, " qos-tos trust ip-prec\n");
                        break;
                case TOS_TRUST_DSCP:
                        wr_config(sptr_cdb, " qos-tos trust dscp\n");
                        break;
                case TOS_TRUST_NONE:
                default:
                        /* MPK flag error - shouldn't be here */
/*                      uprintf("Error - check-trust.\n"); */
                        break;
                }
                sptr_cdb->dont_go_next = 1;
        }
        else if(sptr_cdb->no){ /* reset to the default value */
                cli_tos_qos_set_group_port(sptr_cdb, SET_PORT_TRUST, TOS_TRUST_DEFAULT);
        }

}

void cli_tos_qos_map_cos_to_dscp(struct cdb* sptr_cdb)
{
        UINT32 i;

        if (end_of_token(sptr_cdb->token) == '\0' &&
            cli_find_char(sptr_cdb->token, '?') == NULL)
        {
                sptr_cdb->dont_go_next = 1;
                if (sptr_cdb->no) /* set to default values */
                {
                        for (i=0; i<TOS_MAX_COS; i++)
                        {
                                g_tos_map_cos_to_dscp[i] = TOS_DEFAULT_DSCP(i);
                        }
                }
                else
                {
                        if (validate_dscp(sptr_cdb, 1, 8))
                        {
                                g_tos_map_cos_to_dscp[0] = sptr_cdb->integer1;
                                g_tos_map_cos_to_dscp[1] = sptr_cdb->integer2;
                                g_tos_map_cos_to_dscp[2] = sptr_cdb->integer3;
                                g_tos_map_cos_to_dscp[3] = sptr_cdb->integer4;
                                g_tos_map_cos_to_dscp[4] = sptr_cdb->integer5;
                                g_tos_map_cos_to_dscp[5] = sptr_cdb->integer6;
                                g_tos_map_cos_to_dscp[6] = sptr_cdb->integer7;
                                g_tos_map_cos_to_dscp[7] = sptr_cdb->integer8;
                        }
                }
        }
}

void cli_tos_qos_map_ipprec_to_dscp(struct cdb* sptr_cdb)
{
        UINT32 i;

        if (end_of_token(sptr_cdb->token) == '\0' &&
            cli_find_char(sptr_cdb->token, '?') == NULL)
        {
                sptr_cdb->dont_go_next = 1;
                if (sptr_cdb->no) /* set to default values */
                {
                        for (i=0; i<TOS_MAX_IP_PRECEDENCE; i++)
                        {
                                g_tos_map_ip_prec_to_dscp[i] = TOS_DEFAULT_DSCP(i);
                        }
                }
                else
                {
                        if (validate_dscp(sptr_cdb, 1, 8))
                        {
                                g_tos_map_ip_prec_to_dscp[0] = sptr_cdb->integer1;
                                g_tos_map_ip_prec_to_dscp[1] = sptr_cdb->integer2;
                                g_tos_map_ip_prec_to_dscp[2] = sptr_cdb->integer3;
                                g_tos_map_ip_prec_to_dscp[3] = sptr_cdb->integer4;
                                g_tos_map_ip_prec_to_dscp[4] = sptr_cdb->integer5;
                                g_tos_map_ip_prec_to_dscp[5] = sptr_cdb->integer6;
                                g_tos_map_ip_prec_to_dscp[6] = sptr_cdb->integer7;
                                g_tos_map_ip_prec_to_dscp[7] = sptr_cdb->integer8;
                        }
                }
        }
}

void cli_tos_qos_check_map_cos_to_dscp(struct cdb* sptr_cdb)
{
        UINT32 i;

        if(sptr_cdb->config_gen)
        {
                /* If current values are not the default values, then generate command */
                for (i=0; i<TOS_MAX_COS; i++)
                {
                        if(g_tos_map_cos_to_dscp[i] != TOS_DEFAULT_DSCP(i))
                                break;
                }

                if(i != TOS_MAX_IP_PRECEDENCE)
                {
                        ksprintf(cu_line_buf,
                                "qos-tos map cos-dscp %d %d %d %d %d %d %d %d\n",
                                g_tos_map_cos_to_dscp[0],
                                g_tos_map_cos_to_dscp[1],
                                g_tos_map_cos_to_dscp[2],
                                g_tos_map_cos_to_dscp[3],
                                g_tos_map_cos_to_dscp[4],
                                g_tos_map_cos_to_dscp[5],
                                g_tos_map_cos_to_dscp[6],
                                g_tos_map_cos_to_dscp[7]);
                        wr_config(sptr_cdb, cu_line_buf);
                }

                sptr_cdb->dont_go_next = 1;
        }
        else if(sptr_cdb->no){
                cli_tos_qos_map_cos_to_dscp(sptr_cdb);
        }
}

void cli_tos_qos_check_map_ipprec_to_dscp(struct cdb* sptr_cdb)
{
        UINT32 i;

        if(sptr_cdb->config_gen)
        {
                /* If current values are not the default values, then generate command */
                for (i=0; i<TOS_MAX_IP_PRECEDENCE; i++)
                {
                        if(g_tos_map_ip_prec_to_dscp[i] != TOS_DEFAULT_DSCP(i))
                                break;
                }

                if(i != TOS_MAX_IP_PRECEDENCE)
                {
                        ksprintf(cu_line_buf,
                                "qos-tos map ip-prec-dscp %d %d %d %d %d %d %d %d\n",
                                g_tos_map_ip_prec_to_dscp[0],
                                g_tos_map_ip_prec_to_dscp[1],
                                g_tos_map_ip_prec_to_dscp[2],
                                g_tos_map_ip_prec_to_dscp[3],
                                g_tos_map_ip_prec_to_dscp[4],
                                g_tos_map_ip_prec_to_dscp[5],
                                g_tos_map_ip_prec_to_dscp[6],
                                g_tos_map_ip_prec_to_dscp[7]);
                        wr_config(sptr_cdb, cu_line_buf);
                }

                sptr_cdb->dont_go_next = 1;
        }
        else if(sptr_cdb->no){
                cli_tos_qos_map_ipprec_to_dscp(sptr_cdb);
        }
}
enum BOOLEAN chk_not_sflow_tc (int priority)
{
    if (sflowEnabled && (priority == SFLOW_TRAFFIC_CLASS))
        {
                /* This QOS profile is reserved for SFLOW internally */
                uprintf("Error -  Priority %d is reserved for sFLOW.\n", priority);
                return FALSE;
    }
        return TRUE;
}

void cli_tos_qos_map_dscp_to_priority(struct cdb* sptr_cdb, UINT32 nvals, UINT32 reset)
{
        UINT32  i;

    if (end_of_token(sptr_cdb->token) != '\0' ||
            cli_find_char(sptr_cdb->token, '?') != NULL)
                return;

        if(reset && !sptr_cdb->no)
                return;

        sptr_cdb->dont_go_next = 1;

                if (STACK_AM_I_STANDBY && IS_SIDEWINDER_SYS()) 
                {
                return;
        }
        if (sptr_cdb->no) /* set to default values */
        {

                if((nvals == 8 && !validate_dscp(sptr_cdb, 1, 8)) ||
                   (nvals == 7 && !validate_dscp(sptr_cdb, 1, 7)) ||
                   (nvals == 6 && !validate_dscp(sptr_cdb, 1, 6)) ||
                   (nvals == 5 && !validate_dscp(sptr_cdb, 1, 5)) ||
                   (nvals == 4 && !validate_dscp(sptr_cdb, 1, 4)) ||
                   (nvals == 3 && !validate_dscp(sptr_cdb, 1, 3)) ||
                   (nvals == 2 && !validate_dscp(sptr_cdb, 1, 2)) ||
                   (nvals == 1 && !validate_dscp(sptr_cdb, 1, 1)))
                        return;

                 switch(nvals) /* MPK default values used here should be same as in sw_init.c */
                 {
                        case 8:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer8] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer8);
                        case 7:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer7] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer7);
                        case 6:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer6] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer6);
                        case 5:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer5] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer5);
                        case 4:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer4] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer4);
                        case 3:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer3);
                        case 2:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer2);
                        case 1:
                                g_tos_map_dscp_to_priority[sptr_cdb->integer1] = TOS_DEFAULT_PRIORITY(sptr_cdb->integer1);
                                break;
                        case 0: /* reset all values */
                                for (i=0; i<TOS_MAX_DSCP; i++)
                                        g_tos_map_dscp_to_priority[i] = TOS_DEFAULT_PRIORITY(i);
                                break;
                        default:
                                uprintf("Error - map-dscp-priority-no.\n");
                                break;
                 }
        }
        else
        {
        if(nvals == 8 && validate_dscp(sptr_cdb, 1, 8) && validate_priority(sptr_cdb->integer9)
                        && chk_not_sflow_tc (sptr_cdb->integer9))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer5] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer6] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer7] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer8] =
                                sptr_cdb->integer9;
                else if(nvals == 7 && validate_dscp(sptr_cdb, 1, 7) && validate_priority(sptr_cdb->integer8)
                        && chk_not_sflow_tc (sptr_cdb->integer8))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer5] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer6] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer7] =
                                sptr_cdb->integer8;
                else if(nvals == 6 && validate_dscp(sptr_cdb, 1, 6) && validate_priority(sptr_cdb->integer7)
                        && chk_not_sflow_tc (sptr_cdb->integer7))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer5] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer6] =
                                sptr_cdb->integer7;
                else if(nvals == 5 && validate_dscp(sptr_cdb, 1, 5) && validate_priority(sptr_cdb->integer6)
                        && chk_not_sflow_tc (sptr_cdb->integer6))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer5] =
                                sptr_cdb->integer6;
                else if(nvals == 4 && validate_dscp(sptr_cdb, 1, 4) && validate_priority(sptr_cdb->integer5)
                        && chk_not_sflow_tc (sptr_cdb->integer5))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer4] =
                                sptr_cdb->integer5;
                else if(nvals == 3 && validate_dscp(sptr_cdb, 1, 3) && validate_priority(sptr_cdb->integer4)
                        && chk_not_sflow_tc (sptr_cdb->integer4))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer3] =
                                sptr_cdb->integer4;
                else if(nvals == 2 && validate_dscp(sptr_cdb, 1, 2) && validate_priority(sptr_cdb->integer3)
                        && chk_not_sflow_tc (sptr_cdb->integer3))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_priority[sptr_cdb->integer2] =
                                sptr_cdb->integer3;
                else if(nvals == 1 && validate_dscp(sptr_cdb, 1, 1) && validate_priority(sptr_cdb->integer2)
                        && chk_not_sflow_tc (sptr_cdb->integer2))
                        g_tos_map_dscp_to_priority[sptr_cdb->integer1] =
                                sptr_cdb->integer2;

                        switch(nvals) /* MPK default values used here should be same as in sw_init.c */
                        {
                        case 8:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer8])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer8] = FALSE;
                        case 7:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer7])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer7] = FALSE;
                        case 6:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer6])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer6] = FALSE;
                        case 5:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer5])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer5] = FALSE;
                        case 4:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer4])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer4] = FALSE;
                        case 3:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer3])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer3] = FALSE;
                        case 2:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer2])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer2] = FALSE;
                        case 1:
                                if(g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer1])
                                        g_tos_sflow_mapped_dscp_to_priority[sptr_cdb->integer1] = FALSE;
                        }

                }
        sw_refresh_gi_qos_tos_setting();
}

void cli_tos_qos_map_dscp_to_priority_num1(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 1, 0);
}

void cli_tos_qos_map_dscp_to_priority_num2(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 2, 0);
}

void cli_tos_qos_map_dscp_to_priority_num3(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 3, 0);
}

void cli_tos_qos_map_dscp_to_priority_num4(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 4, 0);
}

void cli_tos_qos_map_dscp_to_priority_num5(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 5, 0);
}

void cli_tos_qos_map_dscp_to_priority_num6(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 6, 0);
}

void cli_tos_qos_map_dscp_to_priority_num7(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 7, 0);
}

void cli_tos_qos_map_dscp_to_priority_num8(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 8, 0);
}


void cli_tos_qos_reset_map_dscp_to_priority_num1(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 1, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num2(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 2, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num3(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 3, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num4(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 4, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num5(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 5, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num6(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 6, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num7(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 7, 1);
}

void cli_tos_qos_reset_map_dscp_to_priority_num8(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_priority(sptr_cdb, 8, 1);
}


void cli_tos_qos_check_map_dscp_to_priority(struct cdb* sptr_cdb)
{
        UINT32 i;
        char temp1[] = "qos-tos map dscp-priority";

        if(sptr_cdb->config_gen)
        {
                UINT32 priority, j;
                UINT32 count[8] = {0, 0, 0, 0, 0, 0, 0, 0};
                UINT32 vals[8][64];

                for(i = 0; i < TOS_MAX_DSCP; i++)
                {
                        priority = g_tos_map_dscp_to_priority[i];

                        if(priority != TOS_DEFAULT_PRIORITY(i))
                        {

                                if (sflowEnabled && (g_tos_sflow_mapped_dscp_to_priority[i] == TRUE) && (priority == MAPPED_TRAFFIC_CLASS))
                                        continue;
                                vals[priority][(count[priority])++] = i;
                                                                continue;


                        }
                }


                for(i = 0, j = 0; i <= 7; i++, j = 0)
                {
                        while(count[i])
                        {
                                if(count[i] >= 8)
                                {
                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d %d %d %d to %d\n", temp1,
                                                vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                vals[i][j+4], vals[i][j+5], vals[i][j+6], vals[i][j+7], i);
                                                wr_config(sptr_cdb, cu_line_buf);
                                        count[i] -= 8;
                                        j += 8;
                                        continue;
                                }
                                                                else if(count[i] == 7)
                                                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d %d %d to %d\n", temp1,
                                                                                vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                                                vals[i][j+4], vals[i][j+5], vals[i][j+6], i);
                                                                else if(count[i] == 6)
                                                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d %d to %d\n", temp1,
                                                                                vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                                                vals[i][j+4], vals[i][j+5], i);
                                                                else if(count[i] == 5)
                                                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d to %d\n", temp1,
                                                                                vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                                                vals[i][j+4], i);
                                                                else if(count[i] == 4)
                                                                        ksprintf(cu_line_buf, "%s %d %d %d %d to %d\n", temp1,
                                                                                vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3], i);
                                                                else if(count[i] == 3)
                                                                        ksprintf(cu_line_buf, "%s %d %d %d to %d\n", temp1,
                                                                                vals[i][j], vals[i][j+1], vals[i][j+2], i);
                                                                else if(count[i] == 2)
                                                                        ksprintf(cu_line_buf, "%s %d %d to %d\n", temp1,
                                                                                vals[i][j], vals[i][j+1], i);
                                                                else if(count[i] == 1)
                                                                        ksprintf(cu_line_buf, "%s %d to %d\n", temp1, vals[i][j], i);
                                                                else
                                                                        /* MPK flag error - shouldn't be here */
                                                                        uprintf("Error - check-map-dscp-priority.\n");

                                wr_config(sptr_cdb, cu_line_buf);
                                break;
                        }
                }

                sptr_cdb->dont_go_next = 1;
        }
        else if (sptr_cdb->no)
        {
                cli_tos_qos_map_dscp_to_priority(sptr_cdb, 0, 0);
        }
}

void cli_tos_qos_map_dscp_to_dscp(struct cdb* sptr_cdb, UINT32 nvals, UINT32 reset)
{
        UINT32 i;

        if (end_of_token(sptr_cdb->token) != '\0' ||
            cli_find_char(sptr_cdb->token, '?') != NULL)
                return;

        if(reset && !sptr_cdb->no)
                return;

        sptr_cdb->dont_go_next = 1;
        if (sptr_cdb->no) /* set to default values */
        {

                if((nvals == 7 && !validate_dscp(sptr_cdb, 1, 7)) ||
                   (nvals == 6 && !validate_dscp(sptr_cdb, 1, 6)) ||
                   (nvals == 5 && !validate_dscp(sptr_cdb, 1, 5)) ||
                   (nvals == 4 && !validate_dscp(sptr_cdb, 1, 4)) ||
                   (nvals == 3 && !validate_dscp(sptr_cdb, 1, 3)) ||
                   (nvals == 2 && !validate_dscp(sptr_cdb, 1, 2)) ||
                   (nvals == 1 && !validate_dscp(sptr_cdb, 1, 1)))
                        return;

                switch(nvals) /* MPK default values used here should be same as in sw_init.c */
                {
                case 7:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer7] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer7);
                case 6:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer6] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer6);
                case 5:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer5] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer5);
                case 4:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer4] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer4);
                case 3:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer3] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer3);
                case 2:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer2] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer2);
                case 1:
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] = TOS_DEFAULT_DSCP2DSCP(sptr_cdb->integer1);
                        break;
                case 0: /* reset all values */
                        for (i=0; i<TOS_MAX_DSCP; i++)
                                g_tos_map_dscp_to_dscp[i] = TOS_DEFAULT_DSCP2DSCP(i);
                        break;
                default:
                        uprintf("Error - map-dscp-priority-no.\n");
                        break;
                }
        }
        else
        {
                if(nvals == 7 && validate_dscp(sptr_cdb, 1, 7) && validate_dscp_val(sptr_cdb->integer8))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer5] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer6] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer7] =
                                sptr_cdb->integer8;
                else if(nvals == 6 && validate_dscp(sptr_cdb, 1, 6) && validate_dscp_val(sptr_cdb->integer7))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer5] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer6] =
                                sptr_cdb->integer7;
                else if(nvals == 5 && validate_dscp(sptr_cdb, 1, 5) && validate_dscp_val(sptr_cdb->integer6))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer4] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer5] =
                                sptr_cdb->integer6;
                else if(nvals == 4 && validate_dscp(sptr_cdb, 1, 4) && validate_dscp_val(sptr_cdb->integer5))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer3] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer4] =
                                sptr_cdb->integer5;
                else if(nvals == 3 && validate_dscp(sptr_cdb, 1, 3) && validate_dscp_val(sptr_cdb->integer4))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer2] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer3] =
                                sptr_cdb->integer4;
                else if(nvals == 2 && validate_dscp(sptr_cdb, 1, 2) && validate_dscp_val(sptr_cdb->integer3))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                g_tos_map_dscp_to_dscp[sptr_cdb->integer2] =
                                sptr_cdb->integer3;
                else if(nvals == 1 && validate_dscp(sptr_cdb, 1, 1) && validate_dscp_val(sptr_cdb->integer2))
                        g_tos_map_dscp_to_dscp[sptr_cdb->integer1] =
                                sptr_cdb->integer2;
        }

}

void cli_tos_qos_map_dscp_to_dscp_num1(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 1, 0);
}

void cli_tos_qos_map_dscp_to_dscp_num2(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 2, 0);
}

void cli_tos_qos_map_dscp_to_dscp_num3(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 3, 0);
}

void cli_tos_qos_map_dscp_to_dscp_num4(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 4, 0);
}

void cli_tos_qos_map_dscp_to_dscp_num5(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 5, 0);
}

void cli_tos_qos_map_dscp_to_dscp_num6(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 6, 0);
}

void cli_tos_qos_map_dscp_to_dscp_num7(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 7, 0);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num1(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 1, 1);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num2(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 2, 1);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num3(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 3, 1);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num4(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 4, 1);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num5(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 5, 1);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num6(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 6, 1);
}

void cli_tos_qos_reset_map_dscp_to_dscp_num7(struct cdb* sptr_cdb)
{
        cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 7, 1);
}

#if 0
void cli_tos_qos_check_map_dscp_to_dscp(struct cdb* sptr_cdb)
{
        UINT32 i;
        char temp1[] = "qos-tos map dscp-priority";

        if(sptr_cdb->config_gen)
        {
                UINT32 priority, j;
                UINT32 count[8] = {0, 0, 0, 0, 0, 0, 0, 0};
                UINT32 vals[8][64];

                for(i = 0; i < TOS_MAX_DSCP; i++)
                {
                        priority = g_tos_map_dscp_to_dscp[i];

                        if(priority != TOS_DEFAULT_DSCP2DSCP(i))
                                vals[priority][(count[priority])++] = i;
                }


                for(i = 0, j = 0; i <= 7; i++, j = 0)
                {
                        while(count[i])
                        {
                                if(count[i] >= 7)
                                {
                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d %d %d to %d\n", temp1,
                                                vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                vals[i][j+4], vals[i][j+5], vals[i][j+6], i);
                                        wr_config(sptr_cdb, cu_line_buf);
                                        count[i] -= 7;
                                        j += 7;
                                        continue;
                                }
                                else if(count[i] == 6)
                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d %d to %d\n", temp1,
                                                 vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                 vals[i][j+4], vals[i][j+5], i);
                                else if(count[i] == 5)
                                        ksprintf(cu_line_buf, "%s %d %d %d %d %d to %d\n", temp1,
                                                 vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3],
                                                 vals[i][j+4], i);
                                else if(count[i] == 4)
                                        ksprintf(cu_line_buf, "%s %d %d %d %d to %d\n", temp1,
                                                 vals[i][j], vals[i][j+1], vals[i][j+2], vals[i][j+3], i);
                                else if(count[i] == 3)
                                        ksprintf(cu_line_buf, "%s %d %d %d to %d\n", temp1,
                                                 vals[i][j], vals[i][j+1], vals[i][j+2], i);
                                else if(count[i] == 2)
                                        ksprintf(cu_line_buf, "%s %d %d to %d\n", temp1,
                                                 vals[i][j], vals[i][j+1], i);
                                else if(count[i] == 1)
                                        ksprintf(cu_line_buf, "%s %d to %d\n", temp1, vals[i][j], i);
                                else
                                        /* MPK flag error - shouldn't be here */
                                        uprintf("Error - check-map-dscp-priority.\n");

                                wr_config(sptr_cdb, cu_line_buf);
                                break;
                        }
                }

                sptr_cdb->dont_go_next = 1;
        }
        else if (sptr_cdb->no)
        {
                cli_tos_qos_map_dscp_to_dscp(sptr_cdb, 0, 0);
        }
}
#endif
#endif TOS_BASED_QOS

UINT8 g_save_debug_cmd = FALSE;
void save_debug_cmd(struct cdb* sptr_cdb)
{
         int i;
         if (!sptr_cdb->config_gen)
         {
                 g_save_debug_cmd = (!(sptr_cdb->no));
         }
}

// debug ip pim show
int cli_config_gen_pim_debug_cmd(struct cdb* sptr_cdb, UINT8 afi)
{
#ifdef __IP_MULTICAST__
        DEBUG_PIM* p_dbg = ((afi == IP_IPV4_AFI) ? &debugGlobal.ip.pim : &debugGlobal.ipv6.pim6);

        int display=0;
        char str[64];
        char* prefix = ((afi == IP_IPV4_AFI) ? "debug ip pim" : "debug ipv6 pim");

        if (sptr_cdb->debug != 0 && sptr_cdb->debug != DEBUG_SHOW)
                return 0;
        if (!(g_save_debug_cmd && (sptr_cdb->config_gen)))
                return 0;


        if (p_dbg->add_del_enable)
        {
                ksprintf(cu_line_buf,"%s add-del-oif %s\n", prefix, ((p_dbg->add_del_enable ==3) ? "stack" : ""));
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }

#ifdef SR_SWITCH_ROUTER
        if (p_dbg->scal)
        {
                ksprintf(cu_line_buf,"%s scaling\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if (p_dbg->rp)
        {
                ksprintf(cu_line_buf,"%s rp\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if (p_dbg->bootstrap)
        {
                ksprintf(cu_line_buf,"%s bootstrap\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if (p_dbg->slib)
        {
                ksprintf(cu_line_buf,"%s sync-lib\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if (p_dbg->event)
        {
                ksprintf(cu_line_buf,"%s event\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->ipc)
        {
                ksprintf(cu_line_buf,"%s ipc\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->join_prune_stack)
        {
                ksprintf(cu_line_buf,"%s join-prune\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->optimization)
        {
                ksprintf(cu_line_buf,"%s optimization\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->nbr_change)
        {
                ksprintf(cu_line_buf,"%s nbr-change %s\n", prefix,
                                (mcast_addr_any(&p_dbg->nbr_addr) ? "" : mcast_print_addr(&p_dbg->nbr_addr)));
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->regproc)
        {
                ksprintf(cu_line_buf,"%s regproc\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->route_change)
        {
                ksprintf(cu_line_buf,"%s route-change\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
#else
        if(p_dbg->level)
        {
                ksprintf(cu_line_buf,"%s level %d\n", prefix, p_dbg->level);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
#endif SR_SWITCH_ROUTER

        if(! mcast_addr_any(&p_dbg->source_address))
        {
                ksprintf(cu_line_buf,"%s source %s\n", prefix, mcast_print_addr(&p_dbg->source_address));
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(! mcast_addr_any(&p_dbg->group_address))
        {
                ksprintf(cu_line_buf,"%s group %s\n", prefix, mcast_print_addr(&p_dbg->group_address));
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }

#ifdef SR_SWITCH_ROUTER
        if(p_dbg->vrf_index != IPVRF_INVALID_VRF_IDX)
        {
                ksprintf(cu_line_buf,"%s vrf %d\n", prefix, p_dbg->vrf_index);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->timer_type)
        {
                ksprintf(cu_line_buf,"%s timer-type %d; ! %s\n", prefix, p_dbg->timer_type, mcast_decode_timer_type(NULL, p_dbg->timer_type));
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->direct_call)
        {
                ksprintf(cu_line_buf,"%s direct-call\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->pimrateupdate)
        {
                ksprintf(cu_line_buf,"%s rate-update\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(! mcast_addr_any(&p_dbg->packet_source) || ! mcast_addr_any(&p_dbg->packet_group))
        {
                ksprintf(cu_line_buf,"%s packet %s %s %d\n",
                                        prefix,
                                        mcast_print_addr(&p_dbg->packet_source), mcast_print_addr(&p_dbg->packet_group),
                                        p_dbg->packet_rate);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
                // FASTIRON BEG
        if(p_dbg->fdb)
        {
                ksprintf(cu_line_buf,"%s fdb\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
        if(p_dbg->hash)
        {
                ksprintf(cu_line_buf,"%s hash\n", prefix);
                wr_config(sptr_cdb, cu_line_buf);
                display++;
        }
                // FASTIRON END
#endif SR_SWITCH_ROUTER

        //  TODO: BIDIR_CLI revisit on 5.3
        // if(sptr_cdb->debug != DEBUG_ALL)
                // display += cli_print_ip_pim_bidir_debug(sptr_cdb);

        return (display);
#else
                return 0;
#endif
}


UINT8 g_save_xtrace = FALSE;
void save_xtrace_level(struct cdb* sptr_cdb)
{
         int i;
         if (!sptr_cdb->config_gen)
         {
                 g_save_xtrace = (!(sptr_cdb->no));
         }
}

void cli_config_gen_xtrace(struct cdb* sptr_cdb)
{
         int i;
         if (g_save_xtrace && (sptr_cdb->config_gen))
         {

                  for ( i = 0; i < NUM_TRACE_MODULES; i++)
                  {
                                if(g_trace_level[i])
                                {
                                         ksprintf(cu_line_buf, "xtrace %d %d\n", i, g_trace_level[i]   );
                                         wr_config(sptr_cdb, cu_line_buf);
                                }

                  }//for
         }
}


void cli_config_gen_global_stp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.stp_enabled != SW_DFLT_STP_OPER_MODE)
                {
#ifdef INCLUDE_802_1S //73922
                   if(!g_mstp_mode)
                   {
                        ksprintf(cu_line_buf, "%sglobal-stp\n",
                                g_sw_sys.stp_enabled == ENABLE ? "" : "no ");
                        wr_config(sptr_cdb, cu_line_buf);
                   }
#else
                        ksprintf(cu_line_buf, "%sglobal-stp\n",
                                g_sw_sys.stp_enabled == ENABLE ? "" : "no ");
                        wr_config(sptr_cdb, cu_line_buf);
#endif // INCLUDE_802_1S
                }
        }
}

//#ifdef __FAST_SPAN__
void sw_fast_span(struct cdb* sptr_cdb)
{
    int fast_span, slot, port;
    PORT_MASK exclude_port_mask[MAX_SLOT];
    PORT_ID port_number;
    enum BOOLEAN exclude_not_empty = FALSE;
          
    if (sptr_cdb->config_gen)
    {
        if (!g_sw_sys.fast_span)
            wr_config(sptr_cdb, "no fast port-span\n");
        else 
        {
            for (slot = 0; slot < g_hw_info.max_mod; slot++) 
            {
                PORT_MASK_ZERO (exclude_port_mask[slot]);

				/* Loop through all the module and populate the port mask. */
                if ((MODULE_IS_GOOD(slot) && MODULE_IS_ENET(slot)) ||
				    ((slot >= LAG_START_SLOT) && (slot < LAG_END_SLOT) && (MODULE_IS_CONFIGURED(slot))))			       
                {
                    for (port = 0; port < MODULE_NUMBER_OF_PORTS(slot); port++)     
                    {
                        port_number = MAKE_PORTID(slot, port);
                        if(!IS_PORT_DB_VALID(port_number))
                            continue;
                        if (!SPTR_PORT_DB(port_number)->port_config.fast_span) 
                        {
                            PORT_MASK_SET (exclude_port_mask[slot], port);
                            exclude_not_empty = TRUE;
                        }
                    }
                }
            }
     
            if (exclude_not_empty) 
            {
                wr_config(sptr_cdb, "fast port-span exclude ");
                cu_makePortMask2CfgStrShort_cfgGen (exclude_port_mask, cu_line_buf, sizeof(cu_line_buf));
                wr_config(sptr_cdb, cu_line_buf);
                wr_config(sptr_cdb, "\n");
            }
        }
        sptr_cdb->dont_go_next = 1;
    } 
    else 
    {
        if ((sptr_cdb->no) && (end_of_token(sptr_cdb->token) == '\0')) 
        {
            fast_span = 0;
            fs_exclude_all();
        }
        else
            fast_span = 1;

        sw_vlan_update_fast_span(fast_span);
        if (end_of_token(sptr_cdb->token) == '\0')
            sptr_cdb->dont_go_next = 1;
    }
}
//#endif /* __FAST_SPAN__ */

// Maocheng++: 2013/10/02, please do not merge this API from any where to martini, this is my true intention to keep this API like this, 
void cli_enable_bdpu_flood (struct cdb* sptr_cdb)
{
        MAC_ADDRESS IEEE_802_1D_reserved_mac_BPDU = {0x0180c200, 0x0000};
        MAC_ADDRESS IEEE_802_1D_reserved_mac_mask_BPDU = {0xFFFFFFFF, 0xFFFF};

        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.bdpu_flood)
                {
                        wr_config (sptr_cdb,"bpdu-flood-enable\n");
                }
        }
        else
        {
                if(is_system_turboiron ())
                {
                        uprintf("Error : BPDU Flooding is not Supported on this platform\n");
                        return;
                }

                if (sptr_cdb->no)
                {
                        // 2012/05/24, disable BPDU flood, it means the BPDU will be HW-FORWARDED, update the MAC range filter for BPDU from CTRL to FWD, and also update the default STG's STP state from STP-FWDING -> STP-DISABLE;

                        if (g_sw_sys.bdpu_flood!=DISABLE)
                        {

#ifdef INCLUDE_MCT
                                if (IS_CLUSTER_CONFIGURED()!=NULL)
                                        sw_pp_set_dflt_stg_STPDISABLE(TRUE);

                                {
                                        if(sw_update_mac_range_filter( &IEEE_802_1D_reserved_mac_BPDU, &IEEE_802_1D_reserved_mac_mask_BPDU, PP_MAC_RANGE_CNTL,PP_MAC_RANGE_DROP, 0, PP_MAC_RANGE_FILTER_PRIORITY_IEEE_RESERVE_MCAST))
                                        {
                                                uprintf("Failed to REMOVE the CTRL mac range filter for IEEE 802.1D reserved macs (BPDU)\n");
                                        }

                                        if(sw_update_mac_range_filter( &IEEE_802_1D_reserved_mac_BPDU, &IEEE_802_1D_reserved_mac_mask_BPDU, PP_MAC_RANGE_FRWRD,PP_MAC_RANGE_DROP, 1, PP_MAC_RANGE_FILTER_PRIORITY_IEEE_RESERVE_MCAST))
                                        {
                                                uprintf("Failed to enable the FWD mac range filter for IEEE 802.1D reserved macs (BPDU)\n");
                                        }

                                }
#endif
                                g_sw_sys.bdpu_flood = DISABLE;
                        }
                }
                else
                {
                        // 2012/05/24, enable BPDU flood, it means the BPDU will be SW-FORWARDED, update the MAC range filter to TRAP the BPDU and also default STG's STP state can no longer be STP-DISABLED.
                        if (g_single_stp_enabled || g_mstp_mode)
                        {
                                uprintf ("Error - Not allowed if MSTP or Single Span is configured.\n");
                                return;
                        }
                        if (g_sw_sys.bdpu_flood!=ENABLE)
                        {
#ifdef INCLUDE_MCT
                                /*changing the hardware STP state in STG 0 from DISABLE to FORWARDING*/
                                sw_pp_set_dflt_stg_STPDISABLE(FALSE);

                                {
                                        if(sw_update_mac_range_filter( &IEEE_802_1D_reserved_mac_BPDU, &IEEE_802_1D_reserved_mac_mask_BPDU, PP_MAC_RANGE_FRWRD,PP_MAC_RANGE_DROP, 0, PP_MAC_RANGE_FILTER_PRIORITY_IEEE_RESERVE_MCAST))
                                        {
                                                uprintf("Failed to REMOVE the mac range filter for IEEE 802.1D reserved macs (BPDU)\n");
                                        }

                                        if(sw_update_mac_range_filter( &IEEE_802_1D_reserved_mac_BPDU, &IEEE_802_1D_reserved_mac_mask_BPDU, PP_MAC_RANGE_CNTL,PP_MAC_RANGE_DROP, 1, PP_MAC_RANGE_FILTER_PRIORITY_IEEE_RESERVE_MCAST))
                                        {
                                                uprintf("Failed to enable CTRL the mac range filter for IEEE 802.1D reserved macs (BPDU)\n");
                                        }

                                }
#endif
                                g_sw_sys.bdpu_flood = ENABLE;
                                uprintf ("Warning - Any received untagged BPDUs will now be flooded to all the ports.\n");
                        }
                }
        }
}


void cli_set_global_stp(struct cdb* sptr_cdb)
{
        /*
         * This command is hiden from user input. It is used to
         * store the global spanning-tree state for the NMS.
         * Therefore, we only read this command from startup
         * configuration file. We don't allow user to change it
         * by CLI.
         */
        if (sptr_cdb->config_gen == 0)
        {
                if (g_sw_sys.init_in_progress)
                {
                        if (sptr_cdb->no)
                                g_sw_sys.stp_enabled = DISABLE;
                        else
                                g_sw_sys.stp_enabled = ENABLE;
                }
        }
}

#ifndef NO_PROTO_VLANS
void cli_set_global_protocol_vlan(struct cdb* sptr_cdb)
{
        /* "global-protocol-vlan" has been removed. We
         * keep this empty function in here as a place
         * holder function to handle startup config
         * containing this command.
         */
}
#endif /* NO_PROTO_VLANS */


void cli_set_global_tag(struct cdb* sptr_cdb)
{
        /* "global-tag" has been removed. We keep this
         * empty function in here as a place holder
         * function to handle startup config containing
         * this command.
         */
}

void set_mif(struct cdb* sptr_cdb, UINT8 interface_type, void *pv_func(struct cdb* sptr_cdb))
{
        PORT_ID port_id,port;

        int i,port_count=0;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
	/*check speed-duplex command. Because, only the speed-duplex command is to be handled on 2.5 gig*/
	if(strstr(sptr_cdb->cli_expanded_cmd,"speed-duplex"))
	{
		for (i=0; i < g_hw_info.total_config_ports; i++)
		{
			port_id = sw_config_port_list[i];
			/* check whether the port_id is a part of 2.5 gig port pair */
			if(is_port_grouped_port(port_id))
			{
				port = get_paired_port(port_id);
				/*now check, the port pair is also present in multiple interfcae. If not return*/
				if((is_member(sptr_cdb->mif_port_mask, port_id) && !(is_member(sptr_cdb->mif_port_mask, port))))
				{
					uprintf("Error: Both port %p and its pair port %p must be configured at the same speed. \n" , port_id, port);
					return;
				}
			}

		}
	}

        if (have_trunk_port_in_interface_config( sptr_cdb ))
                // error, bug#11668
                return;

        /* validate for overlap with static mmac ports here */
        if (cu_gi_check_static_mmac_lacp_port_overlap(sptr_cdb->mif_port_mask, 0) != CU_OK)
        {
                uprintf("Error - cannot use the interface group to configure static mmac ports.\n");
                return;
        }

        for (i=0; i < g_hw_info.total_config_ports; i++)
        {
                port_id = sw_config_port_list[i];
                /* sptr_cdb->mif_port_mask are all ethernet ports,
                 * don't need to check port ethernet type
                 */

                if (!is_member(sptr_cdb->mif_port_mask, port_id))
                        continue;
                if (interface_type)
                        sptr_cdb->if_num = port_id + 1;
                else
                        sptr_cdb->if1 = port_id + 1;
                pv_func(sptr_cdb);
                if(!(++port_count % 10))
                {
                        KICK_WATCHDOG;
                }
        }
}
#ifdef SR_SWITCH_ROUTER
void set_mif_route_only(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_if_route_only);
}
#endif

void set_mif_down(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_down);
}

void set_mif_up(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_up);
}

void set_mif_speed_and_duplex_to_default_value(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed_and_duplex_to_default_value);
}

void set_mif_mdi(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_mdi);
}

void set_mif_mdix(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_mdix);
}

void set_mif_auto_mdi_mdix(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_auto_mdi_mdix);
}
void set_mif_speedAuto_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speedAuto_full_duplex);
}

void set_mif_speed10_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed10_full_duplex);
}

void set_mif_speed10_half_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed10_half_duplex);
}

void set_mif_speed100_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed100_full_duplex);
}

void set_mif_speed100_half_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed100_half_duplex);
}

void set_mif_speed10G_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed10G_full_duplex);
}
void set_mif_speed10G_full_duplex_master(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed10G_full_duplex_master);
}

void set_mif_speed10G_full_duplex_slave(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed10G_full_duplex_slave);
}

void set_mif_speed5G_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed5G_full_duplex);
}
void set_mif_speed5G_full_duplex_master(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed5G_full_duplex_master);
}

void set_mif_speed5G_full_duplex_slave(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed5G_full_duplex_slave);
}

void set_mif_speed1000_full_duplex_master(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed1000_full_duplex_master);
}

void set_mif_speed1000_full_duplex_slave(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed1000_full_duplex_slave);
}

void set_mif_speed1000_full_duplex_auto(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed1000_full_duplex_auto);
}

void set_mif_speed1000_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed1000_full_duplex);
}

void set_mif_speed2500_full_duplex_master(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed2500_full_duplex_master);
}


void set_mif_speed2500_full_duplex_slave(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed2500_full_duplex_slave);
}

void set_mif_speed2500_full_duplex(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_speed2500_full_duplex);
}

enum BOOLEAN neg_on_multi_interface = FALSE;
void set_mif_port_flow_control_neg_on(struct cdb* sptr_cdb)
{
#if 0
        if(sptr_cdb->no && IS_PORT_DB_VALID(INTERFACE_TO_PORT_ID(sptr_cdb->if_num)))
                uprintf("Error - 'no flow-control neg-on' is not supported\n");
#endif

        neg_on_multi_interface = TRUE;
        set_mif(sptr_cdb, TRUE, (void *)set_port_flow_control_neg_on);
        neg_on_multi_interface = FALSE;
}

void set_mif_flow_control(struct cdb* sptr_cdb)
{
        if(!sptr_cdb->integer1)
                flw_ctl_print = 1;
        set_mif(sptr_cdb, TRUE, (void *)set_port_flow_control);
}

void set_mif_flow_control_tx(struct cdb* sptr_cdb)
{

        set_mif(sptr_cdb, TRUE, (void *)set_port_flow_control_tx);

}
void set_mif_flow_control_rx(struct cdb* sptr_cdb)
{

        set_mif(sptr_cdb, TRUE, (void *)set_port_flow_control_rx);

}
void set_mif_flow_control_txrx(struct cdb* sptr_cdb)
{

        set_mif(sptr_cdb, TRUE, (void *)set_port_flow_control_txrx);

}

void set_mif_port_auto_gig(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_port_auto_gig);
}
void set_mif_port_name(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_if_port_name);
}
void preset_mif_port_name(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)preset_if_port_name);
}
#ifndef NO_GIG_ANA_SWITCH
void set_mif_port_neg_off(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_port_neg_off);
}

void set_mif_port_neg_full_auto(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_port_neg_full_auto);
}
#endif NO_GIG_ANA_SWITCH

void set_mif_stp_port_control(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        set_mif(sptr_cdb, TRUE, (void *)set_stp_port_control);
}

#ifndef NO_PORT_LOOPBACK_DETECTION
void mif_set_interface_loop_detection(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_interface_loop_detection);
}

void mif_set_interface_loop_detection_shutdown_disable(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)set_interface_loop_detection_shutdown_disable);
}

#endif NO_PORT_LOOPBACK_DETECTION
void set_mif_qos_priority(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_port_qos);
}
void set_mif_qos_override_tc(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_port_qos_override_tc);
}
void set_mif_port_up_confirm(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_port_up_confirm);
}

void set_mif_being_monitored_port(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_being_monitored_port);
}

void set_mif_acl_based_mirroring(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_acl_based_mirroring);
}

void set_mif_acl_deny_logging(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_if_deny_logging);
}

void set_mif_being_monitored_port_in_out(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_being_monitored_port_in_out);
}

void set_mif_being_monitored_port_in_only(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_being_monitored_port_in_only);
}

void set_mif_acl_based_inbound_mirroring(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_acl_based_inbound_mirroring);
}

void set_mif_being_monitored_port_out_only(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_being_monitored_port_out_only);
}

void check_mif_lock_addr_cnt(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, FALSE, (void *)check_lock_address);
}

void set_mif_lock_addr_cnt(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, FALSE, (void *)cli_set_lock_address);
}

#ifdef DHCP_ASSIST
void set_mif_dhcp_list(struct cdb* sptr_cdb)
{
#ifdef __DHCP_SERVER__
        if (is_dhcps_running () == TRUE)
                {
                uprintf("Error: cannot enable this feature while the DHCP-Server is enabled\n");
                return;
                }
#endif /*__DHCP_SERVER__*/

        set_mif(sptr_cdb, TRUE, (void *)set_if_dhcp_list);
}
#endif /* DHCP_ASSIST */

void clear_if_counter(struct cdb* sptr_cdb)
{
        PORT_ID port_index;
        int slot, port;

        if (sptr_cdb->config_gen)
                return;
        else
        {
                if (sptr_cdb->if_num == 0)
                        return;

                slot = INTERFACE_SLOT(sptr_cdb->if_num);
                port = INTERFACE_PORT(sptr_cdb->if_num);
                #ifdef NOT_USED
                /*
                 * we should not clear the global time stamp since it represents all the ports
                 */
                /* g_port_stats_clear_time_stamp=g_time_counter; */
                #endif NOT_USED
                        if (MODULE_EXIST(slot-1) == FALSE)
                                return;
                        port_index = MAKE_PORTID(slot-1,port-1);
                                                if(!IS_PORT_DB_VALID(port_index))
                                                    return;

                        cu_clear_rate_absolute_counters(port_index);
                        cu_clear_rate_counters(port_index, TRUE);
                        cu_clear_ethernet_counters(port_index);
                        memset(&((SPTR_PORT_DB(port_index))->ip_stat_cnt),0,sizeof(PORT_IP_STATS));
#ifdef SR_SWITCH_ROUTER
                        memset(&((SPTR_PORT_DB(port_index))->ipx_stat_cnt),0,sizeof(PORT_IPX_STATS));
#endif /* SR_SWITCH_ROUTER */
                        rmon_clearItfCounters(cu_PortId2IfIndex(port_index));
        }
}

void set_mif_clear_counter(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)clear_if_counter);
}

void set_lacp_port_ind_disable_config_gen(struct cdb* sptr_cdb)
{
        PORT_ID port_index = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT16  port_vlan_id;

        if (!sptr_cdb->config_gen)
                return;

        if (!IS_PORT_DB_VALID(port_index) || !is_lacp_port(port_index))
                return;

        sptr_cdb->dont_go_next = 1;
        if ((SPTR_PORT_DB(port_index))->port_config.disable_by_user)
        {
                                wr_config(sptr_cdb, " disable\n");
        }
}

void set_if_up(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8  port = INTERFACE_PORT(sptr_cdb->if_num) - 1;
        UINT8 slot = INTERFACE_SLOT(sptr_cdb->if_num) - 1;
        enum PORT_COMMANDS partition;
        UINT16 trunk_id;

    if (!IS_PORT_DB_VALID(port_id))
        return;

		trunk_id = cu_get_trunk_id(port_id, 1);
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no == 0)
                {
                        cu_set_port_up_down(sptr_cdb->ui_port,port_id, PORT_ENABLE);
						//if (trunk_id != INVALID_LOAD_SHARE_GROUP_ID && is_trunk_primary_port(port_id))
						//		g_sw_sys.sw_load_group[trunk_id].trunk_disable = 0;
                }
                else
                {
						/*Blocking “no enable” for ZTP and spx-port/lag, Defect TR000608161*/
						if( IS_ZTP_PORT(port_id) || IS_SPX_PORT(port_id) )
						{
                            uprintf("Error - Cannot disable spx-port or spx-lag or zero-touch-port, port:%p\n",port_id);
							return; 
						}
                        cu_set_port_up_down(sptr_cdb->ui_port,port_id, PORT_DISABLE);
                        //if (trunk_id != INVALID_LOAD_SHARE_GROUP_ID && is_trunk_primary_port(port_id))
                        //        g_sw_sys.sw_load_group[trunk_id].trunk_disable = 1;
                }
        }
        else
        { /* config gen */
                /* get the user configured port enable state */
                if (cu_get_port_partition(port_id, 1, &partition) != CU_OK)
                        return;
#ifdef BUILD_ISP
                /* for ISP build, port was disabled by default */
                if (partition == PORT_ENABLE)
                {
                        /******* Fan Trunk enhancement ********/
                        if(trunk_port_state(port_id)==TRUNK_NONE || is_lacp_port(port_id))
                        {
                                wr_config(sptr_cdb, " enable\n");
                        }
                }
#else
                if (partition != PORT_ENABLE)
                {
                        /******* Fan Trunk enhancement ********/
                        if (trunk_port_state(port_id)==TRUNK_NONE)
                        {
                                wr_config(sptr_cdb, " disable\n");
                        }
						else if (g_sw_sys.sw_load_group[trunk_id].trunk_disable)
						{
							wr_config(sptr_cdb, " disable\n");
						}
                }
#endif BUILD_ISP
        }
}

void set_if_down(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8  port = INTERFACE_PORT(sptr_cdb->if_num) - 1;
        UINT8 slot = INTERFACE_SLOT(sptr_cdb->if_num) - 1;
        UINT16  trunk_id;
        int stackId = PORT_TO_STACK_ID(port_id);

    if (!IS_PORT_DB_VALID(port_id))
        return;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
#if 0
                if (IS_STACKING_PORT(stackId,  port_id))
                {
                        uprintf("Error: Can't disable stacking port %p\n", port_id);
                        return;
                }
#endif
                if (debugGlobal.stacking.sync_rel_msg_level || (debug_port_ctrl>=1 && PORTCTRL_DEBUG_PORTS(port_id)))
                                uprintf("set_if_down if_num = %d\n", sptr_cdb->if_num);

                trunk_id = cu_get_trunk_id(port_id, 1);
                if (sptr_cdb->no == 0)
                {
                        if ((debug_port_ctrl>=1 && PORTCTRL_DEBUG_PORTS(port_id)))
                                        uprintf("set_if_down if_num = %d -> cu_set_port_up_down(port=%p,PORT_DISABLE)\n", sptr_cdb->if_num, port_id);
                        if(is_port_stack_enabled(port_id))
                        {
                            uprintf("Error - Cannot disable a stacking port: %p\n", port_id);
                            return;
                        }
						/*Blocking “disable” for ZTP and spx-port/lag, Defect TR000608161*/
						if( IS_ZTP_PORT(port_id) || IS_SPX_PORT(port_id) )
						{
                            uprintf("Error - Cannot disable spx-port or spx-lag or zero-touch-port, port:%p\n", port_id);
							return; 
						}
						cu_set_port_up_down(sptr_cdb->ui_port,port_id, PORT_DISABLE);
						//if (trunk_id != INVALID_LOAD_SHARE_GROUP_ID && is_trunk_primary_port(port_id))
						//		g_sw_sys.sw_load_group[trunk_id].trunk_disable = 1;
                }
                else
                {
                        if ((debug_port_ctrl>=1 && PORTCTRL_DEBUG_PORTS(port_id)))
                                        uprintf("set_if_down if_num = %d -> cu_set_port_up_down(port=%p,PORT_ENABLE)\n", sptr_cdb->if_num, port_id);
						cu_set_port_up_down(sptr_cdb->ui_port,port_id, PORT_ENABLE);
						//if (trunk_id != INVALID_LOAD_SHARE_GROUP_ID && is_trunk_primary_port(port_id))
						//		g_sw_sys.sw_load_group[trunk_id].trunk_disable = 0;
                }
        }
}


#ifdef SR_SWITCH_ROUTER
void set_ve_carrier_delay(struct cdb* sptr_cdb)
{
        IP_PORT_ERROR err_no = IP_PORT_OK;
        UINT8 current_carrier_delay = 0, new_carrier_delay = 0;
    PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    PORT_ID ve_port_number;
        UINT16 vid=ROUTER_INT_TO_VID(port_id);

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    if(IS_MGMT_PORT(port_id))
        return;

    sptr_cdb->dont_go_next = 1;
    
        if (sptr_cdb->config_gen)
    {
                if(!IS_IP_PORT_DB_VALID(port_id))
                        return;
        if (!IS_IP_PORT_DELAY_CONFIG_DB_VALID())
            return;

        current_carrier_delay = IP_PORT_DELAY_CONFIG_DB(port_id).delay_notification_timer;
        if (current_carrier_delay > 0)
        {
            ksprintf(cu_line_buf," delay-notifications %d\n", current_carrier_delay);
            wr_config(sptr_cdb, cu_line_buf);
        }
        return;
    }
        if (!IS_IP_PORT_DB_VALID(port_id))
        {
                uprintf ("Error - Interface %P is not a valid IP port \n", port_id);
                return;
        }
        if (!IS_IP_PORT_DELAY_CONFIG_DB_VALID())
    {
        uprintf ("Error - Not a valid IP PORT DELAY DB  \n"); 
           return;
        }
         /*introduce a check to check whether it is a VE or not.. if not VE return thrwoing an error.
                evaluate the range of Integer to be inbetween 1 to 60 */
    if (!valid_integer1_value_range(sptr_cdb, 1, 60))
        return;
        current_carrier_delay = IP_PORT_DELAY_CONFIG_DB(port_id).delay_notification_timer;
        new_carrier_delay = sptr_cdb->integer1;
        if (sptr_cdb->no)
        {
                 /*if the value sent in CLI is not same as the value configured return an error saying  this value is not configured.*/
                if(current_carrier_delay == 0)
                {
                        return; /*no need to do any thing.*/
                }
                else if (current_carrier_delay != new_carrier_delay)
                {
                        uprintf ("Error - Not a configured delay-notification \n");  /*add VE number also in error msg*/
                        return;
                }
                else
                {       /*before deleting check if there is any down event is already tirggered and in the middle of expiry
                                in such case, cancel the timer and notify down event if none of the ports are in active state */
                        if(IP_PORT_DELAY_CONFIG_DB(port_id).delay_notification_timer_id)
                        {
                                cancel_ve_delay_timer(port_id);
                        }
                        new_carrier_delay = 0;
                }
        }
        else
        {
                if(current_carrier_delay == new_carrier_delay)
                {
                        return;  /*no need to do any thing just return*/
                }
                else if(current_carrier_delay > 0)
                {
                        uprintf ("Error - Remove existing delay notify %d on this VE \n",current_carrier_delay);
                        return;
                }
        }
        IP_PORT_DELAY_CONFIG_DB(port_id).delay_notification_timer = new_carrier_delay;
        return;
}

void clear_ip_mac_config_on_interface(UINT16 port_id)
{
    MAC_ADDRESS *current_mac_address;
    /*remove ip-mac configuration from the interface if any exists*/
    if(IS_IP_PORT_MAC_CONFIG_VALID(port_id))
    {
        current_mac_address = &IP_PORT_MAC_CONFIG_DB(port_id).mac_address;
        ip_mac_add_delete(current_mac_address,port_id, TRUE);
    }

    return;
}

extern void ip_mac_add_delete (MAC_ADDRESS *ip_mac_address, PORT_ID port_id, UINT8 remove);
void ip_mac_default_vlan_id_change (MAC_ADDRESS *ip_mac_address, enum BOOLEAN remove)
{
	PORT_ID port_id;

	UINT16 router_vid;

	router_vid = sw_find_configured_router_interface_from_l2_vlan(SW_DFLT_VLAN_ID);

	if (!router_vid)
	{
		return;
	}

        port_id = (VID_TO_ROUTER_INT(router_vid)-1);

	if (remove)
	{
		if (!IS_IP_PORT_MAC_CONFIG_VALID(port_id))
			return;

		ip_mac_address->_ulong = IP_PORT_MAC_CONFIG_DB(port_id).mac_address._ulong;
		ip_mac_address->_ushort = IP_PORT_MAC_CONFIG_DB(port_id).mac_address._ushort;

		ip_mac_add_delete (ip_mac_address, port_id, TRUE);

	}
	else
	{
		if (!IS_IP_PORT_DB_VALID(port_id))
			return;
		ip_mac_add_delete (ip_mac_address, port_id, FALSE);

	}
}
void cli_set_ip_mac_address(struct cdb* sptr_cdb)
{
    IP_PORT_ERROR err_no = IP_PORT_OK;
    MAC_ADDRESS *current_mac_address, *new_mac_address;
    int i;
    UINT16 duplicate_port = PORT_INDEX_INVALID;
    UINT8 port_buf[MAX_PORT_ID_STRING_LEN];
    PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    if(IS_MGMT_PORT(port_id))
        return;

    sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->config_gen)
    {
        if(!(IS_IP_PORT_DB_VALID(port_id) || IS_IP6_PORT_DB_CONFIG_VALID(port_id)))
            return;
        if (!IS_IP_PORT_MAC_CONFIG_DB_VALID())
            return;

        /*write configuration into running config*/
                if (IP_PORT_MAC_CONFIG_DB(port_id).mac_valid)
                {
                        ksprintf(cu_line_buf," ip-mac %m \n",&IP_PORT_MAC_CONFIG_DB(port_id).mac_address);
            wr_config(sptr_cdb, cu_line_buf);
                }
        return;
    }

    if (!(STACK_AM_I_MASTER || STACK_AM_I_STANDBY || STACK_AM_I_STANDALONE))
	    return;

    if (!(IS_IP_PORT_DB_VALID(port_id) || IS_IP6_PORT_DB_CONFIG_VALID(port_id)))
    {
        uprintf ("Error - Interface %P is not a valid IP port \n", port_id);
        return;
    }
    if (!IS_IP_PORT_MAC_CONFIG_DB_VALID())
    {
        uprintf ("Error - IP PORT MAC DB is not initalised \n");
       return;
    }
    /*check if the port is VE or physical port, if it is physical port, check if it is part of any vlan,
 	*in that case we should reject ip-mac configuration on physical port as it is part of vlan*/
    if((!is_virtual_port (port_id)))
    {
  	    if(is_member(g_vport_member_mask, port_id)) {
        	uprintf("IP-MAC cannot be applied on a physical port that is part of a VE\n");
			return;
		 }
		 if(PORT_MODE(port_id) == TAGGED) {
			 uprintf("IP-MAC cannot be applied to a tagged port\n");
			 return;
		}
    }
     /*check to evaluate MAC_ADDRESS*/
    if(!ip_mac_valid_mac_address((MAC_ADDRESS *)sptr_cdb->mac1, sptr_cdb->afi))
    {
    	return;
    }
    current_mac_address = &IP_PORT_MAC_CONFIG_DB(port_id).mac_address;
    new_mac_address = (MAC_ADDRESS *)sptr_cdb->mac1;
    if (sptr_cdb->no)
    {
         /*if the value sent in CLI is not same as the value configured return an error saying  this value is not configured.*/
	if (!is_ip_port_db_and_ip_mac_valid(port_id))
	{
	    uprintf ("Error - No IP MAC address configured\n");
            return; /*no need to do any thing.*/
	}
        else if (compare_mac_address(current_mac_address, new_mac_address ) != 0)
        {
            uprintf ("Error - This value is not configured as IP MAC address \n");  /*add port number also in error msg*/
            return;
        }
        else
        {
            /*update MY_STATION_TCAM and all IP related info*/
        	ip_mac_add_delete(current_mac_address, port_id, sptr_cdb->no);
        }
    }
    else
    {
	if (is_ip_port_db_and_ip_mac_valid(port_id) && (compare_mac_address(current_mac_address, new_mac_address ) != 0))
	{
		uprintf ("Error: Remove existing IP-MAC on this interface to configure new one\n");
		return;
	}
    else if( (STACK_AM_I_STANDALONE || STACK_AM_I_MASTER ) && 
        (NUMBER_OF_IP_PORT_MAC_ENTRIES == fndry_system_parameters[MAX_IP_MAC_INDEX].        current))
    {
        uprintf("Exceeded maximum number of IP-MAC entries:%d on this system \n",           NUMBER_OF_IP_PORT_MAC_ENTRIES);
        return;
    }
	else if( ((STACK_AM_I_STANDBY ) && ( !g_sw_sys.init_in_progress )) &&
        ( NUMBER_OF_IP_PORT_MAC_ENTRIES == fndry_system_parameters[MAX_IP_MAC_INDEX].current))
	{
		uprintf("Exceeded maximum number of IP-MAC entries:%d on this system \n", NUMBER_OF_IP_PORT_MAC_ENTRIES);
		return;
	}
        else
        {
	    if (compare_mac_address(new_mac_address, &g_virtual_mac_addr) == 0)
	    {
		    uprintf("Error: IP-MAC cannot be same as stack mac %m\n", new_mac_address);
		    return;
	    }
	    if (is_ip_mac_in_any_of_stack_unit(new_mac_address))
	    {
		    return;
	    }
	    if (!g_sw_sys.init_in_progress && 
			    (is_ip_mac_duplicate(new_mac_address, &duplicate_port) == TRUE))
	    {
		   interface_print_name(duplicate_port, port_buf);
		   uprintf ("\nError : ip-mac %m already configured on %s\n",new_mac_address, port_buf);
		   return;
	    }
            /*update MY_STATION_TCAM and all IP related info*/
            ip_mac_add_delete(new_mac_address, port_id, sptr_cdb->no);
    	}
     }

	 /* update all IPv6 related info */
    if(IS_IP6_PORT_DB_VALID(port_id) && (ip6.sptr_port_config[port_id].ip6_enabled == TRUE))
    {
        ip_mac_update_ipv6_processing(port_id);
    }
    if (STACK_AM_I_SLAVE || g_sw_sys.init_in_progress)
	    return;

    /* send gratious ARP for all the IP addresses present on this IP_PORT,
     * so that all the devices in the LAN can learn new ARP for these IPs
     * in case of add/delete ip_mac,  active unit will send the gratious ARP
     * sending gratious ARP to primary  aswell as secodnary addressses.
     */
	for (i=0; i<IP_ADDR_COUNT(port_id); i++)
	{
		ip_send_gratuitous_arp_request(port_id, IP_ADDR_TBL(port_id)[i].ip_address);
	}

    return;
}
void set_if_bandwidth(struct cdb* sptr_cdb)
{
        IP_PORT_ERROR err_no = IP_PORT_OK;
        UINT32 new_bandwidth, old_bandwidth, default_bw = 0, vid = 0;           
        PORT_ID port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        PORT_ID ve_port_number;
        PORT_MASK member_mask[MAX_SLOT] = {0};

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if(IS_MGMT_PORT(port_id))
                return;

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->config_gen)
        {       
                if (!IS_IP_PORT_DB_VALID(port_id))
                        return;
                
                old_bandwidth = cu_get_interface_bandwidth(port_id, TRUE, FALSE);
                if (old_bandwidth >  0)
                {
                        ksprintf(cu_line_buf," bandwidth %d\n", old_bandwidth);
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (!IS_IP_PORT_DB_VALID(port_id))
        {
                uprintf ("Error - Interface %P is not a valid IP port\n");
                return;
        }

        if (is_loopback_port(port_id))
        {
                uprintf ("Error - Interface bandwidth cannot be configured on loopback ports\n");
                return;
        }

#if 0 // Why not support v6 tunnels?? For now enable v6 tunnel config too
        if (is_gre_ip_tunnel_port(port_id))
        {
                if (g_tunnel_table && g_tunnel_table[tunnel_id].tunnel_mode != TUNNEL_MODE_IP_OVER_IP)
                {       
                        uprintf("Error - Interface bandwidth cannot be configured on non-GRE tunnels\n");
                        return;
                }
        }
#endif 

        if (is_physical_port(port_id) && is_trunk_secondary_port(port_id))
        {
                uprintf("Error - Interface bandwidth cannot be configured on secondary port of LAG\n", sptr_cdb->integer1);
                return;
        }

        if (!valid_integer1_value_range(sptr_cdb, 1, 100000000))
                return;

        new_bandwidth = sptr_cdb->integer1;
        old_bandwidth = cu_get_interface_bandwidth(port_id, TRUE, FALSE);
        cu_get_port_bw(port_id, &default_bw);
        default_bw = default_bw * 1000;
                        
        if(sptr_cdb->no)
        {
                if (old_bandwidth > 0  && old_bandwidth != new_bandwidth)
                {
                        
                        uprintf("Error - This value does not match the configured interface bandwidth %d\n", old_bandwidth);
                        return;
                }
                else if (old_bandwidth == 0)
                {
                        uprintf("Error - unable to execute CLI operation because interface bandwidth is not found\n");
                        return;
                }

                /* FI: Just set bandwidth to 0 if not configured.
                
                cu_get_port_bw(port_id, &if_bandwidth);
                if_bandwidth = if_bandwidth * 1000;// cu_get_port_bw set bandwidth in mbps and needs to be converted to kbps.
                */

                new_bandwidth = 0;
                
        }
        else 
        {
                if (new_bandwidth == default_bw)
                {       
                        uprintf("Error - cannot add or remove default value\n");
                        return;
                }

                if (old_bandwidth == new_bandwidth)
                {
                        uprintf("Error - Interface bandwidth is already set to %d Mbps\n", new_bandwidth);
                        return;
                }
        }

        fitrace(L3_INTERFACE_TRACE_UTILITY, FITRACE_L3INTERFACE_BANDWIDTH, TRACE_CONTROL_FLOW, 
                "\nCLI set if bandwidth: Old b/w: %d, New b/w: %d, Operation: %s\n",
                old_bandwidth, new_bandwidth, (sptr_cdb->no ? "Remove" : "Add/Modify"));
                

        IP_IP_PORT(port_id).config.if_bandwidth = new_bandwidth;
        IP_IP_PORT(port_id).config.if_bandwidth_config = !sptr_cdb->no;
        
        if (is_physical_port(port_id))
        {       
                /* Update the ospf (v3) cost of ve interfaces that this port may associated with */
                for (vid = 0; vid < MAX_ROUTER_INT; vid++)
                {
                        ve_port_number = VID_TO_ROUTER_INT(vid);
                        l2_router_int_to_config_mask(ve_port_number, member_mask);
                        if (!is_mask_clear(member_mask) && is_member(member_mask, port_id))
                        {
#ifdef __OSPF__         
                                ospf_interface_update_cost(ve_port_number); 
#endif __OSPF__
#ifdef __OSPFV3__
                                ospf6_cu_update_if_path_cost_for_if_bandwidth(ve_port_number);
#endif __OSPFV3__
                        }
                }
        }

#ifdef __OSPF__                 
        ospf_interface_update_cost(port_id);
#endif __OSPF__
#ifdef __OSPFV3__
        ospf6_cu_update_if_path_cost_for_if_bandwidth(port_id);
#endif __OSPFV3__

}

#endif SR_SWITCH_ROUTER

// 65920, root guard and bpdu guard
void set_if_admin_root_guard(struct cdb* sptr_cdb)
{
        UINT8 desgn_guard;
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);


        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
            if (!IS_PORT_DB_VALID(port_id))
            {
                return;
            }
                if (sptr_cdb->no == 0)
                {
                        /*uprintf("set_if_admin_root_guard: pid=%d enable\n", port_id);*/
                cu_get_port_designated_guard (port_id, 1,&desgn_guard);
                if (desgn_guard)
                {
                    uprintf("Root guard cannot be set on Designated guard enabled port.\n");
                    return;
                }
                        cu_set_port_stp_root_guard(/*sptr_cdb->ui_port,*/port_id, TRUE);
                }
                else
                {
                        /*uprintf("set_if_admin_root_guard: pid=%d disable\n", port_id);*/
                        cu_set_port_stp_root_guard(/*sptr_cdb->ui_port,*/port_id, FALSE);
                }
        }
        else
        { /* config gen */
                /* get the user configured port enable state */

            if (!IS_PORT_DB_VALID(port_id))
                  return;

            if (SPTR_PORT_DB(port_id)->port_config.stp_admin_rootguard)
            {
              wr_config(sptr_cdb, " spanning-tree root-protect\n");
            }
        }
}

//000464738
extern void cu_set_port_stp_designated_guard(PORT_ID port_id, enum BOOLEAN adminDesigGuard); 
void set_if_admin_designated_guard(struct cdb* sptr_cdb)
{
        UINT8 root_guard;
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);


        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (!IS_PORT_DB_VALID(port_id))
                {
                        return;
                }
                if (sptr_cdb->no == 0)
                {
                        //uprintf("set_if_admin_designated_guard: port=%p enable\n", port_id);
                        cu_get_port_root_guard (port_id, 1,&root_guard);
                        if (root_guard)
                        {
                                uprintf("Designated guard cannot be set on Root guard enabled port.\n");
                                return;
                        }
                        cu_set_port_stp_designated_guard(port_id, TRUE);
                }
                else
                {
                        //uprintf("set_if_admin_designated_guard: port=%p disable\n", port_id);
                        cu_set_port_stp_designated_guard(port_id, FALSE);
                }
        }
        else
        { /* config gen */
                /* get the user configured port enable state */

                if (!IS_PORT_DB_VALID(port_id))
                        return;

                if (SPTR_PORT_DB(port_id)->port_config.stp_admin_designatedguard)
                {
                        wr_config(sptr_cdb, " spanning-tree designated-protect\n");
                }
        }
}


void set_mif_admin_root_guard(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = sptr_cdb->no ? 0 : 1;
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_mif(sptr_cdb, TRUE, (void *)set_if_admin_root_guard);
        }
}

//000464738 
void set_mif_admin_designated_guard(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = sptr_cdb->no ? 0 : 1;
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_mif(sptr_cdb, TRUE, (void *)set_if_admin_designated_guard);
        }
}

/*### PV_CHANGES removed #ifndef to #ifdef*/

void set_bpduguard(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no == 0)
                {
                        cu_set_switch_bpduguard (TRUE);
                }
                else
                {
                        cu_set_switch_bpduguard(FALSE);
                }
        }
        /* 66497
maocheng++: running configuration create is done in retrieve_running_config()
         * just like single stp
         */
}
/* 02/14/2007, maocheng++ 65920 */
void set_if_admin_bpduguard(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
            if (!IS_PORT_DB_VALID(port_id))
            return;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */

                if (sptr_cdb->no == 1)
                {
                        cu_set_port_bpdu_guard(port_id, PORT_BPDUGUARD_DISABLED);
                }
                else
                {
                        cu_set_port_bpdu_guard(port_id, PORT_BPDUGUARD_ENABLED);
                }

        }
        else
        { /* config gen */
                /* get the user configured port enable state */

            if (SPTR_PORT_DB(port_id)->port_config.admin_bpduguard==PORT_BPDUGUARD_ENABLED)
            {
              wr_config(sptr_cdb, " stp-bpdu-guard\n");
            }
        }
}

/* 02/14/2007, maocheng++ 65920 */
void set_mif_admin_bpduguard(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = sptr_cdb->no ? 0 : 1;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_mif(sptr_cdb, TRUE, (void *)set_if_admin_bpduguard);
        }
}


// kamat has changed this function. Diff from superX.
void set_if_admin_bpduguard_enable(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */

                if (sptr_cdb->no == 1)
                {
                        cu_set_port_bpdu_guard(port_id, PORT_BPDUGUARD_DISABLED);
                }
                else
                {
                        cu_set_port_bpdu_guard(port_id, PORT_BPDUGUARD_ENABLED);
                }

        }
        else
        { /* config gen */
                /* get the user configured port enable state */

            if (!IS_PORT_DB_VALID(port_id))
                  return;

            if (SPTR_PORT_DB(port_id)->port_config.admin_bpduguard==PORT_BPDUGUARD_ENABLED)
            {
              wr_config(sptr_cdb, " stp-bpdu-guard\n");
            }
        }
}

void set_if_admin_bpduguard_disable(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
            if (!IS_PORT_DB_VALID(port_id))
                     return;

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */

                if (sptr_cdb->no == 1)
                {
                        /*uprintf("set_if_admin_root_guard: pid=%d enable\n", port_id);*/
                        uprintf("'no spanning-tree bpdu-guard disable' is not a valid command\n");
                }
                else
                {
                        cu_set_port_bpdu_guard(port_id, PORT_BPDUGUARD_DISABLED);
                }

        }
        else
        { /* config gen */
                /* get the user configured port enable state */

            if (SPTR_PORT_DB(port_id)->port_config.admin_bpduguard==PORT_BPDUGUARD_DISABLED)
            {
              wr_config(sptr_cdb, " spanning-tree bpdu-guard disable\n");
            }
        }
}


void set_if_admin_bpduguard_default(struct cdb* sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen == 0)
        { /* not config gen */
                if (sptr_cdb->no == 1)
                {
                        /*uprintf("set_if_admin_root_guard: pid=%d enable\n", port_id);*/
                        uprintf("'no spanning-tree bpdu-guard default' is not a valid command\n");
                }
                else
                {
                        cu_set_port_bpdu_guard(port_id, PORT_BPDUGUARD_DEFAULT);
                }

        }
}

// kamat change, ??? should we use this new one?
void set_mif_admin_bpduguard_enable(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = sptr_cdb->no ? 0 : 1;

        if (sptr_cdb->no == 1)
        {
                        /*uprintf("set_if_admin_root_guard: pid=%d enable\n", port_id);*/
                        uprintf("'no spanning-tree bpdu-guard enable' is not a valid command\n");
                        return;
        }

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_mif(sptr_cdb, TRUE, (void *)set_if_admin_bpduguard_enable);
        }
}

void set_mif_admin_bpduguard_disable(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = sptr_cdb->no ? 0 : 1;
                if (sptr_cdb->no == 1)
                {
                        /*uprintf("set_if_admin_root_guard: pid=%d enable\n", port_id);*/
                        uprintf("'no spanning-tree bpdu-guard disable' is not a valid command\n");
                        return;
                }

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_mif(sptr_cdb, TRUE, (void *)set_if_admin_bpduguard_disable);
        }
}


void set_mif_admin_bpduguard_default(struct cdb* sptr_cdb)
{
        sptr_cdb->integer3 = sptr_cdb->no ? 0 : 1;

                if (sptr_cdb->no == 1)
                {
                        /*uprintf("set_if_admin_root_guard: pid=%d enable\n", port_id);*/
                        uprintf("'no spanning-tree bpdu-guard default' is not a valid command\n");
                        return;
                }
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_mif(sptr_cdb, TRUE, (void *)set_if_admin_bpduguard_default);
        }
}

/* utility */
int get_ifNumber()
{
#ifdef SM_MASTER
        return cu_get_max_port(FMP_MASTER_SLOT);
#else
        return g_hw_info.total_config_ports;
#endif
}

#ifdef SR_SWITCH_ROUTER
#ifdef NOT_USED
enum BOOLEAN cli_parser_cmd_check_filter_for_acl(UINT8 *line)
{
        char temp1[] = "ip access-policy";
        int len_temp1 = strlen(temp1);

        while (*line == ' ')
                line++;

        if (memcmp(line, temp1, len_temp1) == 0)
        {
                return(TRUE);
        }

        return(FALSE);
}

void kinit_read_use_acl()
{
        UINT8 *u8ptr;
        UINT32 i;

        #if defined (PV_CHANGES)
    return;
        #endif

        // Prasard needs to define "FLASH_CODE"
        uprintf("kinit_read_use_acl: Tao & Prasard need to define FLASH_CODE \n");
        return;

        u8ptr = (UINT8 *)(FLASH_CODE + g_hw_info.primary_config_data_offset);
        /* read till the 1st NEWLINE character */
        i=0;
        while ((i++<g_hw_info.config_data_size) && (*u8ptr++ != 0))
        {
                if (*u8ptr == '\n')
                {
                        u8ptr++;
                        break;
                }
        }

        if (!memcmp(u8ptr, "ip dont-use-acl", 15))
        {
                rtr_use_acl = 0;
                return;
        }

        /* Now search for ip access-policy-group. if we found one, then
                assume the user wants to continue use "old" style */

        u8ptr = (UINT8 *)(FLASH_CODE + g_hw_info.primary_config_data_offset);
        i = 0;
        while ((i++<g_hw_info.config_data_size) && (*u8ptr++ != 0))
        {
                if (*u8ptr == '\n')
                {
                        u8ptr++;        /* skip \n */
                        i++;

                        if (!memcmp(u8ptr, " ip access-policy-g", 19))
                        {
                                rtr_use_acl = 0;
                                return;
                        }
                }
        }
}
#endif NOT_USED
#endif SR_SWITCH_ROUTER

/* FUNCTION
 * cli_parser_cmd_sys_boot_param()
 *
 * SYNOPSIS
 * Applicable only for Katara Platform
 * Called during phase one of config parsing. This for setting
 * boot parameter to uboot from the startup-config file since
 * uboot cannot read from startup-config
 */
static void cli_parser_cmd_sys_boot_param(unsigned char *line)
{
        //These strings much match the way config is generated
        //in boot_sys_config_gen( )
        char tempf[] = "boot sys fl ";
        char tempt[] = "boot sys tf ";
                char fipstr[] = "fips ";
        char temp1[] = "pri";
        char temp2[] = "sec";
                char temp3[] = "enable";
        int len_ip = 0;

        //Note variables subnet, has_slash and sptr_cdb are dummy here.
        //I could find only "parse_ip_string()" to convert string to ip_addr format
        //which requires these arguments. We only use boot_ip.
        unsigned int boot_ip, subnet;
        int has_slash;
        struct cdb *sptr_cdb = &cdbs[0];

        if(! is_linux_based_system())
                return;
#ifndef PV_CHANGES
#ifdef FI_LINUX
        if (memcmp(line, tempf, strlen(tempf)) == 0) //boot from flash
        {
                line += strlen(tempf); //move to flash source

                if (memcmp(line, temp1, strlen(temp1)) == 0)
                {
                        //Need to boot from primary
                        if (sil_get_boot_source() != SIL_BOOT_SOURCE_PRIMARY)
                                sil_set_boot_source(SIL_BOOT_SOURCE_PRIMARY);

                }
                else if (memcmp(line, temp2, strlen(temp2)) == 0)
                {
                        //Need to boot from secondary
                        if (sil_get_boot_source() != SIL_BOOT_SOURCE_SECONDARY)
                                sil_set_boot_source(SIL_BOOT_SOURCE_SECONDARY);
                }
                else
                        uprintf("Error! Invalid flash partition\n");
        }
        else if (memcmp(line, tempt, strlen(tempt)) == 0) //boot from tftp
        {
                line += strlen(tempt); //move to tftp source
                len_ip = (int)strchr(line, ' ') - (int)line; //length of boot ip

                //extract and convert boot ip address from dot format to int into boot_ip
                parse_ip_string(&boot_ip, &subnet, line, len_ip, IP_ADDR, sptr_cdb, &has_slash, FALSE);
                next_token(&line); //move to boot file

                if((sil_get_boot_source() != SIL_BOOT_SOURCE_TFTP) ||
                                (sil_get_tftp_server_ip() != boot_ip) ||
                                (strcmp(sil_get_tftp_file_name(), line)))
                {
                        /* Set boot-source as TFTP Server & set tftp boot info */
                        sil_set_tftp_boot_info(boot_ip, line);
                        sil_set_boot_source(SIL_BOOT_SOURCE_TFTP);
                }
        }

                else if (memcmp(line, fipstr, strlen(fipstr)) == 0) //set fips_status
                {
                        line += strlen(fipstr);// move to fips_status
                        if(memcmp(line, temp3, strlen(temp3)) == 0)
                        {
                                if(!sil_get_fips_status())
                                sil_set_fips_status(1);
                        }
                }
#endif /* ifdef FI_LINUX */
#endif PV_CHANGES

        return;
}

#ifndef NO_SYS_PAR
/* FUNCTION
 *      cli_parser_cmd_sys_max_param()
 *
 * SYNOPSIS
 *      Called during phase one of config parsing. This sets up the
 *      variables in fndry_system_parameters for memory allocation
 *      purposes.
 *    This is moved to pre_parse_config_file() since some variables, such as "ip-arp"
 *    needs to be set before phase one of config parsing
 */
void cli_parser_cmd_sys_max_param(unsigned char *line)
{
        char    temp1[]         = "system-max";
        int     len_temp1       = strlen(temp1);
        int     len_temp2       = 0;
        int     i;
        int     param           = 0;
        int     size;


        if ( cli_is_skip_config() )
                return;

        while (*line == ' ')
                line++;

        if (memcmp(line, temp1, len_temp1) == 0)
        {
                next_token(&line);
                len_temp2 = (int)strchr(line, ' ') - (int)line;
                size = cu_get_sys_param_table_size();

                for (i = 1; i < size; i++)
                {
                        if (pp_check_is_ipv6_hw())
                        {
                                if ((i == MAX_HW_IP_NEXT_HOP_INDEX) ||
                                        (i == MAX_HW_LOGICAL_INT_INDEX) ||
                                        (i == MAX_HW_IP_MCAST_MLL_INDEX) //||
                                        //(i == MAX_HW_TRAFFIC_COND_INDEX) //could have been automatically adjusted earlier
                                        //(i == VLAN_ENTRIES_INDEX))//could have been automatically adjusted earlier
                                        ) //BUG: 96287
                                        continue;
                        }
#ifdef SR_SWITCH_ROUTER 
                                                /* IPV6_ROUTES_ENTRIES_INDEX is now stored in flash for BCM. Hence skip its processing here.
                                                  * ip6 cache and ip6 static routes can still be configured individually for bcm. So keep the !IS_FI_BCM() check
                                                  */
                        if(L3_UC_IS_SYSTEM_MAX_PARSED_DURING_BOOTUP && i == STATIC_ROUTE_ENTRIES_INDEX)
                                continue;  
                        if(L3_UC_IS_SYSTEM_MAX_PARSED_DURING_BOOTUP && i == IPV6_ROUTES_ENTRIES_INDEX)
                                continue;  
                        if(L3_UC_IS_SYSTEM_MAX_PARSED_DURING_BOOTUP && i == MAX_SUBNET_PER_PORT_INDEX)
                                continue;                                               
                                                if((L3_UC_IS_SYSTEM_MAX_PARSED_DURING_BOOTUP &&
                                        (i == IPV6_MAX_CACHE_ENTRIES_INDEX || 
                                         i == IPV6_STATIC_ROUTE_ENTRIES_INDEX)) && (!IS_FI_BCM()))
                                continue;    
                        if (L3_UC_IS_SYSTEM_MAX_PARSED_DURING_BOOTUP && 
                                                                                (i == ROUTES_ENTRIES_INDEX || 
                                                                    i == MAX_GRE_IP_TUNNEL_INDEX ||
                                        i == ARP_ENTRIES_INDEX || i == MAX_IPV4_ROUTES_DEFAULT_VRF ||
                                        i == MAX_IPV6_ROUTES_DEFAULT_VRF || i == MAX_ROUTER_INT_INDEX
                                                                                #ifdef FIOFL_INCLUDE
                                                                                || (i == MAX_OPENFLOW_NEXTHOP_INDEX && (!IS_FI_BCM()))
                                                                                #endif FIOFL_INCLUDE                                                                            
                                                                                ))
                                continue;
#endif SR_SWITCH_ROUTER                                         
                        if ((memcmp(line, fndry_system_parameters[i].para_name, len_temp2)==0) &&
                                                        (len_temp2 == strlen(fndry_system_parameters[i].para_name)))
                        {
                                /* bug 8931 */
                                /* due to changes in the system-max implementation, it is
                                 * not enough to just find the parameter in system parameters
                                 * array but to check if this is a valid command. it is
                                 * possible that an older config or a config that has been
                                 * tftp'd to the box would have an invalid command. This
                                 * would be set in the system parameters array. if
                                 * command does not exist in the c_system_max command
                                 * node array, do nothing (exit)
                                 */
                                if (find_node(  c_system_max,
                                                fndry_system_parameters[i].para_name,
                                                KEYWORD) == NULL)
                                {
                                        break;
                                }

                                next_token(&line);
                                param = atoi((char *)line);
                                /* Bug: TR000377625 */
                                /* spanning-tree MAX value is reduced from 256 to 254 in 7.4 release
                                 * accounting for two STG index used internally(0 and 1 STG span index).
                                 * Below change is done to provide backward compatibility for MAX spanning
                                 * tree parameter when customer upgrades from (7.3,7.2,..etc.,) to 7.4 software
                                 * version. Without this below patch system-max spanning tree which was 255 before
                                 * upgradation will fall back to 32 after moving to 7.4 firmware or later one's
                                 */
                                if((SYS_MAX_STP_INDEX == i) && (SYS_MAX_SPAN_INSTANCE_BEFORE_7_4_RELEASE == param))
                                {
                                        /* System max for span is configured to be 255, modify it to 254 */
                                        param = SYS_MAX_SPAN_INSTANCE_AFTER_7_4_RELEASE;
                                }
                                if (cu_test_param_in_range(i, param) == CU_OK)
                                {
                                        fndry_system_parameters[i].config = param;
//                                      if (g_sw_sys.init_in_progress) {
                                                fndry_system_parameters[i].current = param;

                                                if (i == IP_FILTER_SYS_ENTRIES_INDEX) {
//                                                      if (g_sw_sys.init_in_progress)
                                                                ip_filter_sys_set++;
                                                }
#ifdef SR_SWITCH_ROUTER
                                                if (i == IP_FILTER_PORT_ENTRIES_INDEX) {
//                                                      if (g_sw_sys.init_in_progress)
                                                                ip_filter_port_set++;
                                                }
#endif SR_SWITCH_ROUTER

                                                                                if (i == PIM_MAX_FWD_ENTRY_INDEX) 
                                                                                {
                                                                                         fndry_system_parameters[PIM_MAX_HW_MCACHE_ENTRIES].config = param;
                                                                                         fndry_system_parameters[PIM_MAX_HW_MCACHE_ENTRIES].current = param;
                                                                                }
                                                                                if (i == PIM_MAX_HW_MCACHE_ENTRIES) 
                                                                                {
                                                                                         fndry_system_parameters[PIM_MAX_FWD_ENTRY_INDEX].config = param;
                                                                                         fndry_system_parameters[PIM_MAX_FWD_ENTRY_INDEX].current = param;
                                                                                }
                                                                                if (i == IGMP_ENTRIES_INDEX) 
                                                                                {
                                                                                         fndry_system_parameters[IGMP_SNOOP_GROUP_INDEX].config = param;
                                                                                         fndry_system_parameters[IGMP_SNOOP_GROUP_INDEX].current = param;
                                                                                }
                                                                                if (i == IGMP_SNOOP_GROUP_INDEX) 
                                                                                {
                                                                                         fndry_system_parameters[IGMP_ENTRIES_INDEX].config = param;
                                                                                         fndry_system_parameters[IGMP_ENTRIES_INDEX].current = param;
                                                                                }
                                                                                if (i == MLD_ENTRIES_INDEX) 
                                                                                {
                                                                                         fndry_system_parameters[MLD_SNOOP_GROUP_INDEX].config = param;
                                                                                         fndry_system_parameters[MLD_SNOOP_GROUP_INDEX].current = param;
                                                                                }
                                                                                if (i == MLD_SNOOP_GROUP_INDEX) 
                                                                                {
                                                                                         fndry_system_parameters[MLD_ENTRIES_INDEX].config = param;
                                                                                         fndry_system_parameters[MLD_ENTRIES_INDEX].current = param;
                                                                                }                                                                                                                                                       
//                                      }
                                }
                                else
                                {
                                        /* Handle IP_CACHE_ENTRIES_INDEX when MAX > 32768, use 32768 as current value */
                                        if (i == IP_CACHE_ENTRIES_INDEX)
                                        {
                                                fndry_system_parameters[i].current = fndry_system_parameters[IP_CACHE_ENTRIES_INDEX].max;
                                                fndry_system_parameters[i].config = fndry_system_parameters[i].current;
                                        }
                                }
                                break;
                        }
                }
        }

        return;
}
#endif NO_SYS_PAR

void cli_set_global_mcast_snoop_flood_mode(unsigned char *line)
{
         unsigned char *token=line;
         char *temp1 = "ip multicast disable-flooding";
         char *temp2 = "ipv6 multicast disable-flooding";

         SKIP_WHITE_SPACE(token);

         if (memcmp(token, temp1, strlen(temp1)) == 0) 
         {
                ip.igmp.disable_flood = TRUE; 
         }
         if (memcmp(token, temp2, strlen(temp2)) == 0) 
         {
                ip6.mld.disable_flood = TRUE; 
         }       
}

#ifndef FIXED_RESERVE_VLAN_ID

void cli_parser_cmd_reserved_vlan_map(unsigned char *line)
{
  unsigned char *token=line;
        int reserved_vlan_id;
        int new_reserved_vlan_id;
        int config_module_type;
        int count=0;
        char *temp1 = "reserved-vlan-map";
        char *temp2 = "vlan";
        char *temp3 = "new-vlan";
/*   Maocheng++: 72032, the parse of the reserved vlan has to be moved before hw_init(), this flag is nto available yet.
        if (!g_sw_sys.init_in_progress)
          return;
          */

       //uprintf("cli_parser_cmd_reserved_vlan_map: %s\n", line);
        /* this function handles addition of user defined
         * module type at initialization time
         */
        SKIP_WHITE_SPACE(token);

        /* "module" */
        if (memcmp(token, temp1, strlen(temp1)) == 0)
        {
           //uprintf("cli_parser_cmd_reserved_vlan_map- entering\n");
           /* slot number */
           NEXT_TOKEN(token);

           if(memcmp(token, temp2, strlen(temp2)) == 0)
           {
             //uprintf("cli_parser_cmd_reserved_vlan_map- find vlan keyword\n");
             NEXT_TOKEN(token);
             reserved_vlan_id = cli_get_int(token,1,&count);

             switch(reserved_vlan_id)
             {
               case DEFAULT_CPU_VLAN_ID:
                 {
                   NEXT_TOKEN(token);

                   if(memcmp(token, temp3, strlen(temp3)) == 0)
                   {
                      //uprintf("cli_parser_cmd_reserved_vlan_map- cpu_vlan find next_vlan keyword\n");

                      NEXT_TOKEN(token);

                      new_reserved_vlan_id = cli_get_int(token,1,&count);

                      //uprintf("cli_parser_cmd_reserved_vlan_map- cpu_vlan -> next_vlan=%d\n", new_reserved_vlan_id);
                      // 72032 g_cpu_vlan_id = g_cfg_cpu_vlan_id = new_reserved_vlan_id;
                      if (!STACK_BOOTUP_AS_SLAVE) {
                         global_cpu_vlan_id = new_reserved_vlan_id;
                      }
                   }
                 }
                 break;
               case DEFAULT_ALL_PORTS_VLAN_ID:
                 {
                   NEXT_TOKEN(token);

                   if(memcmp(token, temp3, strlen(temp3)) == 0)
                   {
                      //uprintf("cli_parser_cmd_reserved_vlan_map- all ports_vlan find next_vlan keyword\n");

                      NEXT_TOKEN(token);

                      new_reserved_vlan_id = cli_get_int(token,1,&count);

                      //uprintf("cli_parser_cmd_reserved_vlan_map- all ports vlan -> next_vlan=%d\n", new_reserved_vlan_id);
                      // 72032 g_all_ports_vlan_id = g_cfg_all_ports_vlan_id = new_reserved_vlan_id;
                      global_all_ports_vlan_id = new_reserved_vlan_id;
                   }
                 }
                 break;
               default:
                 uprintf("error - Reserved vlan %d is not Configurable\n", reserved_vlan_id);
                 return;
             }
           }  // temp2
        }


}

#ifdef SIDEWINDER_BREAKOUT

PORT_ID get_sw_port_from_config(UINT16 stack, UINT16 module, UINT16 module_port)
{
        
        if(module == 0) {
                if ((module_port >= 0) && (module_port < 4)) { // 1/1/1 - 1/1/4 can't be broken
                        return ((PORT_ID) (((module << 6) | (module_port)) + ((stack-1)<<8)));
                } else if ((module_port >= 4) && (module_port < 16)) {//1/1/5 - 1/1/16 can be broken
                        return ((PORT_ID) ((((module) << 6) | ((module_port - 3) * 4) )  + ((stack-1)<<8)));
                } else { // 1/1/17 - 1/1/20 can't be broken
            return ((PORT_ID) (((module << 6) | ((module_port - 16) + 13 * 4)) + ((stack-1)<<8)));
        }
    } else if((module == 1) || (module == 2)) { //1/2/1 - 1/2/6, 1/3/1 - 1/3/6 can be broken
                return ((PORT_ID) ((((module) << 6) | (module_port * 4)) + ((stack-1)<<8))); 
        }
        return -1;      
        
}
int g_breakout_num_ports;


void update_global_breakout_interface_structure(char *str, int len,  int to)
{
    int i = 0, j = 0, k = 1;
    UINT16 unit, module = 0, port = 0;
    char unit_str[2], port_str[2];
    PORT_ID sw_port;
    if(len == 5) {
        unit = str[0] - '0';
        module = str[2] - '0';
        port = str[4] - '0';

    }
    else if (len == 6) {
        if ((isdigit(str[0]) && isdigit(str[1])) ) {
            strncpy(&unit_str[0], str, 2);
            unit = atoi(unit_str);
            module = str[3] - '0';
            port = str[5] - '0';
        }
        if ((isdigit(str[4]) && isdigit(str[5])) ) {
            strncpy(&port_str[0], &str[4], 2);
            port = atoi(port_str);
            module = str[2] - '0';
            unit = str[0] - '0';
        }
    }
    else if (len == 7) {
        if ((isdigit(str[0]) && isdigit(str[1])) ) {
            strncpy(&unit_str[0], str, 2);
            unit = atoi(unit_str);
        }
        if ((isdigit(str[5]) && isdigit(str[6])) ) {
            strncpy(&port_str[0], &str[5], 2);
            port = atoi(port_str);
        }
        module = str[3] - '0';
    }

	if((port==0) || (module == 0)) //should not happen
		return;

        port = port -1; //get_sw_port_from_4tuples(stack_id, module, port) has module and port which are 0 based. Hence we subtract 1.
        module = module -1; //get_sw_port_from_4tuples(stack_id, module, port) has module and port which are 0 based. Hence we subtract 1.
    sw_port = get_sw_port_from_config(unit, (module), (port));
    set_breakout(sw_port);
    g_breakout_num_ports++;
        /* Platform Code Start */
        //Set the Initial Enable Value to 1 for these ports so that SPTR_PORT_DB() is initialized for this broken main and sub ports
        //set_initial_enable_value_for_breakout_ports(sw_port);
        /* Platform Code End */
    if(to){
        sw_port = get_sw_port_from_config(unit, (module), (port-k));
                k++;
        while (g_ports_to_breakout[sw_port] == 0) {
            set_breakout(sw_port);
                        /* Platform Code Start */
                        //Set the Initial Enable Value to 1 for these ports so that SPTR_PORT_DB() is initialized for this broken main and sub ports
                        //set_initial_enable_value_for_breakout_ports(sw_port);
                        /* Platform Code End */
            sw_port = get_sw_port_from_config(unit, (module), (port-k));
            g_breakout_num_ports++;
           k++;
        }
    }
    return;
}


int find_next_token_len (char *line)
{
    int i = 0;
    while ((*(line+i) != ' ')  && (*(line+i) != '\0') && (*(line+i) != '\r')) {
        i++;
    }
    return i;
}

void cli_parser_breakout_config (char *line)
{
    char keyword [] = "breakout";
    unsigned int length = strlen(keyword);
    unsigned int next_token_len;
        char *interface_str = (char *)dy_malloc(6);

        if (!interface_str)//coverity defect 45001
                return;

    SKIP_WHITE_SPACE(line);

    if(memcmp(line, keyword, length) == 0) {
        while (*line != '\0' ) {
            NEXT_TOKEN(line);
            if(memcmp(line, "e", 1) == 0) {
                NEXT_TOKEN(line);
                /* Separate the interface string*/
                next_token_len = find_next_token_len(line);
                memcpy(interface_str, line , next_token_len);
                update_global_breakout_interface_structure(interface_str, next_token_len, 0);
            }
            if(memcmp(line, "to", 2) == 0) {
                NEXT_TOKEN(line);
                /* Separate the interface string*/
                next_token_len = find_next_token_len(line);
                memcpy(interface_str, line , next_token_len);
                update_global_breakout_interface_structure(interface_str,next_token_len, 1);
            }

        }
        uprintf("\n g_breakout_num_ports = %d\n", g_breakout_num_ports);
                //coverity defect 45001
                if (interface_str != NULL)
                        dy_free(interface_str);
    }


}

#endif SIDEWINDER_BREAKOUT
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                                                                                                                                                                                      
 *
 *  * Name      :   cli_pre_parse_find_macsec_config      
 *
 *  * Descrption:  To calculate hmac hash value for dot1x config during preparsing .
 *
 *  * Input     :   line
 *  
 *  * Return    :   Integer                                                                                                                                              *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


void cli_pre_parse_find_macsec_config(unsigned char *line,char *fips_bypass_test_preparse_config_hmac_hash,char *fips_bypass_test_hmac_hash)
{
  unsigned char *token = line;
  unsigned char last_token[FIPS_BYPASS_TEST_HMAC_SHA1_HASH_BUFFER_SIZE];
  char *temp1="dot1x-mka-enable";
  char *temp2="fips bypass-test macsec config-integrity ";
  static int fips_bootup_hmac_temp_variable = DISABLE;
  unsigned char iv[] = "FI08020 BRCD HMAC";
  unsigned char out[FIPS_BYPASS_TEST_HMAC_SHA1_HASH_BUFFER_SIZE] = {0};
  unsigned int outlen;
  static char fips_bypass_test_config_buffer[CU_LINE_BUF_SIZE] ; 
  int i=0;
  
  /*  To start writing macsec config from startup config  into fips_bypass_test_config_buffer */
  if(!fips_bootup_hmac_temp_variable && (memcmp(token,temp1,strlen(temp1)) == 0))
  {
        /* memset before copying the first MACSEC config */
        memset(fips_bypass_test_config_buffer,0,sizeof(fips_bypass_test_config_buffer));
    strncat(fips_bypass_test_config_buffer,line,strlen(line));
        strncat(fips_bypass_test_config_buffer,"\n",1);
    fips_bootup_hmac_temp_variable = ENABLE;
    return;
  }

  /*Once its starting writing it keeps concatenating all macsec config till "!" which indicates end or macsec config */
        
  if(fips_bootup_hmac_temp_variable && (memcmp(token,"!",strlen("!")) == 0)){
    fips_bootup_hmac_temp_variable = DISABLE;
        if(fips_bypass_test_config_buffer[0])
        {
        memset(fips_bypass_test_preparse_config_hmac_hash,0,FIPS_BYPASS_TEST_HMAC_SHA1_HASH_BUFFER_SIZE);//Coverity defect 44414 
        /* Caluclate HMAC_SHA1 for macsec config retrieved from startup config file */
        HMAC(EVP_sha1(),fips_bypass_test_config_buffer,sizeof(fips_bypass_test_config_buffer)-1,iv,sizeof(iv)-1,fips_bypass_test_preparse_config_hmac_hash,&outlen);
                
        memset(fips_bypass_test_config_buffer,0,sizeof(fips_bypass_test_config_buffer));
        return ;
        
                }
        }
  else if(fips_bootup_hmac_temp_variable)
  {
        
    strncat(fips_bypass_test_config_buffer,line,strlen(line));
        strncat(fips_bypass_test_config_buffer,"\n",1);
  }
  else if(!fips_bootup_hmac_temp_variable && (strncmp(token,temp2,strlen(temp2)) == 0)){
        /* To retrieve HMAC hash value from config file where hash value is the last token in the command */
        for(i=0;i<FIPS_BYPASS_TEST_NUM_OF_TOKENS;i++)
        {
                NEXT_TOKEN(token);
                if(end_of_token(token) == 0)
                        break;          
        }
         memcpy(last_token,token,strlen(token));
         string2hex(last_token,fips_bypass_test_hmac_hash);

}  
  return;
}



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                                                                                                                                                                                      
 *
 *  * Name      :   cu_fips_bypass_test_verify_hash_config      
 *
 *  * Descrption:  cu_fips_bypass_test_verify_hash_config to compare hmac hash value for dot1x config during preparsing 
 *
 *  * Input     :   NULL
 *  
 *  * Return    :   Integer                                                                                                                                              *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


int cu_fips_bypass_test_verify_hash_config(char *fips_bypass_test_hmac_hash,char *fips_bypass_test_preparse_config_hmac_hash)
{
        int ret = FALSE;
        if((fips_bypass_test_hmac_hash &&  fips_bypass_test_preparse_config_hmac_hash))
        {
        if(memcmp(fips_bypass_test_hmac_hash,fips_bypass_test_preparse_config_hmac_hash,FIPS_BYPASS_TEST_HMAC_SHA1_HASH_COMPARE)== 0)
                {
                
                ret = TRUE;
                }
        }
        return ret;
}


/*
 * Function:
 *  pre_parse_config_file
 * Description
 *  parse the configure file before everything starts,
 * used for cpu vlan parsing stuff.
 */
void pre_parse_config_file(void)
{
  unsigned char *pre_config_buf=NULL;
  static int output_done = 0;
  char fips_bypass_test_preparse_config_hmac_hash[FIPS_BYPASS_TEST_HMAC_SHA1_HASH_BUFFER_SIZE] = {0}; /*  to save macsec config hmac value during preparsing */
  char fips_bypass_test_hmac_hash[FIPS_BYPASS_TEST_HMAC_SHA1_HASH_BUFFER_SIZE] = {0};
//  struct cdb *sptr_cdb = &cdbs[0];

//  sptr_cdb->ui_port = 0;
//  sptr_cdb->buffer_base = get_config_buffer(sptr_cdb->ui_port);
  if (!STACK_BOOTUP_AS_SLAVE) {
  g_cfg_cpu_vlan_id = g_cpu_vlan_id = DEFAULT_CPU_VLAN_ID;
  }
  g_cfg_all_ports_vlan_id = g_all_ports_vlan_id = DEFAULT_ALL_PORTS_VLAN_ID;
  /* RAJ - Check this */
  if ( g_bootinfo_sptr->bootconfig.option.s.noconfig )
  {
    uprintf("pre_parse_config_file: NO configuration, skip CPU VLAN parse.\n");
    // maocheng++: since there is no config data, just return;
    return;
  }
  else
  {
        if((g_bootinfo_sptr->bootconfig.option.s.di)||
          (g_bootinfo_sptr->bootconfig.option.s.di_alt))
        {
                uprintf("pre_parse_config_file: NO configuration, skip CPU VLAN parse.\n");
                return;
        }
        if(( is_diag_on() || is_diag_extra_on()))
        {
                uprintf("pre_parse_config_file: NO configuration, skip CPU VLAN parse.\n");
                return;
        }
    pre_config_buf = (unsigned char*)dy_malloc_zero(MAX_CONFIG_SIZE);

    if (!pre_config_buf)
    {
      kprintf("pre_parse_config_file: Failed to get config buffer\n");
      return;
    }

        // While internally we may pre_parse config file several times,
        // we should output to the user just once to avoid confusion.
        if ( !output_done ) {
        uprintf("Pre Parsing Config Data ...\n");
                output_done = 1;
        }
   // copy_startConfig_runConfig(sptr_cdb); <------------------ Maocheng++: where is where we copy startup configuration.

    nt_read_config_file(pre_config_buf, MAX_CONFIG_SIZE); //<-- Maocheng++: startup configuration read from flash to config_buf.

    //parse_configBuf(config_buf, ui_port);
    {
        unsigned char *line;
        int i, j;

        /* allocate a line buffer */
        if ((line = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE+1)) == NULL)
        {
          uprintf("pre_parse_config_file: Error - cannot allocate line buffer\n");

          dy_free(line); /* free line buffer */
          dy_free(pre_config_buf);
          return;
        }
        line[0] = '\0';

        uprintf("\n");

        for (i = 0, j = 0; pre_config_buf[i] != 0; i++)
        {
          if (j >= CMD_LINE_SIZE)
          {
            uprintf("pre_parse_config_file: Error - the length of the command line exceeds %d characters.\n!!! Stop parsing the configuration data !!!\n",
                        CMD_LINE_SIZE);
            dy_free(line); /* free line buffer */
            dy_free(pre_config_buf);
            return;
          }

          if (pre_config_buf[i] == '\n')
          {
            strncpy(line, &pre_config_buf[i-j], j);

            line[j] = '\0';

//uprintf("\npre_parse_config_file: %s\n\n", line);

            if (j != 0 && line[j-1] == '\r')
                line[j-1] = '\0';

            cli_parser_cmd_reserved_vlan_map(line);
#ifdef FIPS_BYPASS_TEST
                        if(is_fips_bypass_test_required())   
                        {
                                cli_pre_parse_find_macsec_config(line,fips_bypass_test_preparse_config_hmac_hash,fips_bypass_test_hmac_hash);
                        }
#endif

                cli_parser_cmd_sys_max_param(line);
                                cli_set_global_mcast_snoop_flood_mode(line); 

                //Katara needs to update boot parameter
                //from startup-config. Note MAX_CONFIG_SIZE is 512k and hence
                // boot parameter has to be within this.
                if(is_linux_based_system())
                        cli_parser_cmd_sys_boot_param(line);

            j = 0;
          }
          else
            j++;
        }

        if (j != 0)
        {
           /* last line not ended with '\n' */
          strncpy(line, &pre_config_buf[i-j], j);
          line[j] = '\0';
//uprintf("\npre_parse_config_file: %s\n\n", line);
          if (line[j-1] == '\r')
            line[j-1] = '\0';

          cli_parser_cmd_reserved_vlan_map(line);
        }
#ifdef FIPS_BYPASS_TEST 
        if(is_fips_bypass_test_required())
        {
                        if(!cu_fips_bypass_test_verify_hash_config(fips_bypass_test_hmac_hash,fips_bypass_test_preparse_config_hmac_hash))
                                fips_bypass_test_error_handling();
        }
#endif
                
        dy_free(line); /* free line buffer */
    }

    dy_free(pre_config_buf);
   }

        
   /* Verify the system max for parameter and reset if nessary */
   cu_verify_and_reset_system_max_param();

   return;
}

#endif FIXED_RESERVE_VLAN_ID

void cli_find_cmd_fes_no_span_mode(unsigned char *line)
{
        UINT8 keyword[] = "fes-no-span-mode";
        int length = strlen(keyword);
        extern int gridiron_disable_per_vlan_SPT;

        SKIP_WHITE_SPACE(line);

        if (memcmp(line, keyword, length) == 0)
        {
                gi_set_per_vlan_SPT_in_all_devices(0, FALSE);
                gridiron_disable_per_vlan_SPT = 1;
        }
}

void cli_find_cmd_fes_hash_few_vlans_mode(unsigned char *line)
{
        UINT8 keyword[] = "fes-hash-few-vlans-mode";
        int length = strlen(keyword);
        extern int gridiron_vlan_hash_func_low;

        SKIP_WHITE_SPACE(line);

        if (memcmp(line, keyword, length) == 0)
        {
                gridiron_vlan_hash_func_low = 1;
                sw_gi_set_vlan_hash_func_bit(0); /* Function Optimized for less than 8 VLANs (Switch), 7 VLANs(Router)*/
        }
}

void cli_find_cmd_fes_hash_secondary_mode(unsigned char *line)
{
        UINT8 keyword[] = "fes-hash-secondary-mode";
        int length = strlen(keyword);
        extern int gridiron_mac_hash_sec_mode;

        SKIP_WHITE_SPACE(line);

        if (memcmp(line, keyword, length) == 0)
        {
                gridiron_mac_hash_sec_mode = 1;
                sw_pp_set_mac_hash_func_secondary(); /* Function Optimized for less than 8 VLANs (Switch), 7 VLANs(Router)*/
        }
}


void cli_find_cmd_use_local_management_mac(unsigned char *line)
{
    UINT8 keyword[] = "use-local-management-mac";
    int length = strlen(keyword);
    extern UINT32 use_local_management_mac;
    enum BOOLEAN ret_code;

    SKIP_WHITE_SPACE(line);

    if (memcmp(line, keyword, length) == 0)
    {
        //TR000512781 - Making the variable set to zero, to avoid any future problems.
        use_local_management_mac = 0;
        // g_hw_info.mgmt_mac_addr._ulong |= (0x02000000);

#ifdef __MPORT_SUPPORT__
        if (is_system_mport_present())   //BUG: 107298
        {
            sys_bm_ioctl(SYS_BM_IOCTL_MAC_HASH_SET, (UINT32)(&g_hw_info.mgmt_mac_addr), 1, 0, 0, 0);
        }
#endif

    }
}


int cli_find_cmd_default_vlan_id(unsigned char *line)
{
        UINT8 keyword[] = "default-vlan-id";
        int length = strlen(keyword);
        UINT16 default_vlan_id;

        SKIP_WHITE_SPACE(line);

        if (memcmp(line, keyword, length) == 0)
        {
                NEXT_TOKEN(line);
                default_vlan_id = (UINT16)atoi((char *)line);
                if (default_vlan_id >= CU_MIN_VLAN_ID_VAL
                &&  default_vlan_id <= CU_MAX_VLAN_ID_VAL)
                        return default_vlan_id;
        }
        return SW_DEFAULT_VLAN_ID_VALUE;
}

int cli_find_cmd_max_vlan(unsigned char *line)
{
        char temp1[] = "vlan";
        char temp2[] = "max-vlans";
        int len_temp1 = strlen(temp1);
        int len_temp2 = strlen(temp2);
        int number_of_vlans;

        SKIP_WHITE_SPACE(line);

        if (memcmp(line, temp1, len_temp1) == 0)
        {
                NEXT_TOKEN(line);
                if (memcmp(line, temp2, len_temp2) == 0)
                {
                        NEXT_TOKEN(line);
                        number_of_vlans = atoi((char *)line);
                        if (number_of_vlans >= 1 && number_of_vlans <= MAX_VLANS)
                                return number_of_vlans;
                }
        }

        return 0;
}

int cli_find_cmd_logging_buffer_size(unsigned char *line)
{
        char temp1[] = "logging";
        char temp2[] = "buffered";
        int len_temp1 = strlen(temp1);
        int len_temp2 = strlen(temp2);
        int buffer_size;

        SKIP_WHITE_SPACE(line);

        if (memcmp(line, temp1, len_temp1) == 0)
        {
                NEXT_TOKEN(line);
                if (memcmp(line, temp2, len_temp2) == 0)
                {
                        NEXT_TOKEN(line);
                        buffer_size = atoi((char *)line);
                        if (buffer_size >= CU_MIN_LOGGING_BUFFER_SIZE
                        &&  buffer_size <= CU_MAX_LOGGING_BUFFER_SIZE)
                                return buffer_size;
                }
        }

        return 0;
}

enum BOOLEAN check_access_list_cmd_on_run_config(UINT8 *sptr_line)
{
        if (*sptr_line == '!')
                return(TRUE);
        if (memcmp(sptr_line, "end", 3) == 0)
                return(TRUE);
        if (memcmp(sptr_line, "no", 2) == 0)
                next_token(&sptr_line);
        if (memcmp(sptr_line, "access-list", 11) == 0)
                return(TRUE);

        return(FALSE);
}

const char *parse_line_cmd[][2] =
{
        {"fes-no-span-mode"},
        {"fes-hash-secondary-mode"},
        {"fes-hash-few-vlans-mode"},
#ifdef SR_SWITCH_ONLY
        {"use-local-management-mac"},
#endif
        {"trunk"},
        {"default-vlan-id"},
        {"vlan", "max-vlans"},
        {"logging", "buffered"},
        {NULL}
};

const char *parse_line_phase1_test(char *line)
{
        int i;
        char *key[2];
        SKIP_WHITE_SPACE(line); key[0] = line;
        NEXT_TOKEN(line); key[1] = line;

        for (i = 0; parse_line_cmd[i][0]; i++)
        {
                if (!memcmp(key[0], parse_line_cmd[i][0], strlen(parse_line_cmd[i][0])))
                {
                        if (!parse_line_cmd[i][1]) break;
                        if (!memcmp(key[1], parse_line_cmd[i][1], strlen(parse_line_cmd[i][1]))) break;
                }
        }
        return parse_line_cmd[i][0];
}

void parse_line_phase1(char *line,
        UINT16 *max_vlan,
        UINT16 *default_vlan_id,
        UINT32 *logging_buffer_size)
{
        int rcode;
        cli_find_cmd_fes_no_span_mode(line);
        cli_find_cmd_fes_hash_secondary_mode(line);
        cli_find_cmd_fes_hash_few_vlans_mode(line);

/* use-local-mgmt-mac is no more supported
 * TR000512781
#ifdef SR_SWITCH_ONLY
        cli_find_cmd_use_local_management_mac(line);
#endif
 */
        /* create trunk groups before any vlan creation */
        cli_find_cmd_trunk(line);

        rcode = cli_find_cmd_default_vlan_id(line);
        if (rcode != SW_DEFAULT_VLAN_ID_VALUE)
                *default_vlan_id = rcode;
        rcode = cli_find_cmd_max_vlan(line);
        if (rcode != 0)
                *max_vlan = rcode;
        rcode = cli_find_cmd_logging_buffer_size(line);
        if (rcode != 0)
                *logging_buffer_size = rcode;
}

enum BOOLEAN parse_line(
        UINT8 *line,
        UINT32 ui_port,
        UINT32 phase,
        UINT16 *max_vlan,
        UINT16 *default_vlan_id,
        UINT32 *logging_buffer_size)
{
        extern UINT8 g_exiting_trunk;

    // Changing the KICK_WATCHDOG to sys_true_yield to work around the rtm bringup crash w/the new trunk events
    // REVISIT - KISHORE!!!!!
        //sys_true_yield();

        /* Health check on running config if in copy tftp run mode */
        if (phase == 0 && tftp_run_parser_mode)
        {
                if (check_access_list_cmd_on_run_config(line) != TRUE)
                {
                        uprintf("Error - this startup-config file contains non access-list commands\n");
                        return FALSE;   /* stop parsing next line */
                }
        }


        /* 3 passes to parse the config file:
         * First pass to pick up system parameters and config
         * module types.
         * Second pass to preprocess the config file (e.g.
         * preallocate memory for a certain commands).
         * Third pass to call each command handler.
         */
        if (phase == 0)
        {
/* 102834 Move this up to the pre_parse_config_file */
//#ifndef NO_SYS_PAR
//              cli_parser_cmd_sys_max_param(line);
//#endif NO_SYS_PAR

/* 72032 move this part to the start up
#ifndef FIXED_RESERVE_VLAN_ID
                cli_parser_cmd_reserved_vlan_map(line);
#endif  FIXED_RESERVE_VLAN_ID */
                // CHEETAH_STACKING, klin, must search for "stack id".
                cli_find_stack_id_config(line);
                cli_find_module_type(line);
//#endif HOT_SWAP


#ifdef SIDEWINDER_BREAKOUT
                if (IS_SIDEWINDER())
                {
                    startup_breakout_init_check(line, ui_port);
                }
#endif SIDEWINDER_BREAKOUT
                /******* Fan Trunk enhancement *******/
                trunk_init_check_mirror(line, ui_port);
        }
        else
        if (phase == 1)
        {
                if (parse_line_phase1_test(line))
                {
                        int k = send_remote_function_call
                        (
                                1, parse_line_phase1,
                                CMD_LINE_SIZE+1, line,
                                sizeof(*max_vlan), max_vlan,
                                sizeof(*default_vlan_id), default_vlan_id,
                                sizeof(*logging_buffer_size), logging_buffer_size, -1
                        );
                        parse_line_phase1(line, max_vlan, default_vlan_id, logging_buffer_size);
                        send_remote_function_call_completion_status(1, k, 1);
                }
        }
        else
        {
#ifdef __DEBUG__
                uprintf("%s\n", line);
#endif

                while (*line == ' ')
                        line++;

                {
                        static UINT8 trunk_mode = 0;

                        if(trunk_mode)
                        {
                                if(check_trunk_sub_cli(line)==0)
                                {
                                        trunk_mode = 0;
                                        g_sw_sys.init_in_progress = 1;
                                }
                        }

                        if (memcmp(line, "trunk", strlen("trunk")) == 0)
                        {
                                if(g_sw_sys.init_in_progress)
                                {
                                        trunk_mode = 1;
                                        g_sw_sys.init_in_progress = 0;
                                }
                        }
                }

                //g_exiting_trunk = 1;
                parser(line, ui_port, CMD_LINE_EXECUTE);
                //g_exiting_trunk = 0;
        }

        return TRUE;    /* keep on parsing next line */
}

void process_init_command(
        UINT32 ui_port,
        UINT32 phase,
        UINT16 max_vlan,
        UINT16 default_vlan_id,
        UINT32 logging_buffer_size)
{
        struct cdb*     sptr_cdb;
#ifdef SR_SWITCH_ROUTER
        UINT16 max_router_int;
#endif SR_SWITCH_ROUTER

        if (!g_sw_sys.init_in_progress)
                return;

        sptr_cdb = &cdbs[ui_port];

        if (phase == 0)
        {
                cu_trunk_pre_init();
//#if (defined(SR_SWITCH_ROUTER) || defined(MAC_FILTER))
                allocate_cli_filter_id_list();
//#endif
        }
        else
        if (phase == 1)
        {
                /* Allocate memory for vlan config structure before
                 * we start to parse the config file in the third
                 * time, which will call each command handler. Add
                 * 1 for the default vlan entry.
                 */
                 // TR282171. I don't want to block the entire process_init_command(). Just do it piece by piece
                // The standby also go through process_init_command(), but it return in port_vlan_config_init() because vlan_db is allocated.
                // However, if the default vlan id is changed now, the standby does not do anything in cu_create_default_vlan()
                /* TR000286393 - If "default-vlan-id <id>" is configured, then the existing Default vlan id is deleted and
                        the new Default vlan id is created during the pass 1 for STANDBY during the CLI sync. */
                /*  TR000287021 - bipin: added g_sptr_vlan_db check to delete the old VLAN because when standby starts
                parsing its startup config after finding no active in the stack, it had created the default VLAN */

                /* TR000283130  - re-create the Default vlan when
                        1. Standby parses the config as part of Sync from Active.
                        2. Standby take over Active role and parses the config. */
                /* TR000424205 - This piece of code should be made available to SX. Please refer TR000420107 */
#ifndef EVAL_BOARD
                if (g_sptr_vlan_db)
                {
                    cu_dispose_one_vlan_entry(SW_DEFAULT_VLAN_ID_VALUE, TRUE, 0);
                    SW_DFLT_VLAN_ID_SET = default_vlan_id;
                    cu_create_default_vlan();
                }
#endif
                sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
#ifdef SR_SWITCH_ROUTER
                if (max_vlan == 0)
                max_vlan = cu_get_curr_param(VLAN_ENTRIES_INDEX);
                max_router_int = cu_get_curr_param(MAX_ROUTER_INT_INDEX);
                router_int_config_init(max_router_int);
#else SR_SWITCH_ROUTER
                if (max_vlan == 0)
                        max_vlan = cu_get_curr_param(VLAN_ENTRIES_INDEX);
                else
                        cu_set_config_param(VLAN_ENTRIES_INDEX, max_vlan);
#endif SR_SWITCH_ROUTER
                port_vlan_config_init(max_vlan);
                init_vlan_group();
        }
        else
        if (phase == 2)
        {
#ifdef __LLDP__
                lldp_cli_post_config_file_init(sptr_cdb);
#endif __LLDP__
        }
}

void parse_configBuf(unsigned char* config_buf, unsigned int a_ui_port)
{
        unsigned char *line;
        struct cdb*     sptr_cdb;
        int i, j, k;
        int rcode;
        UINT16 max_vlan=0;
        UINT32 logging_buffer_size=0;
        UINT16 default_vlan_id=SW_DEFAULT_VLAN_ID_VALUE;
        unsigned int save_mode;
        extern UINT8 trunk_init_in_progress;
        int    config_line = 0;
        UINT32 cur_time, start_time;
        struct cdb *old_cdb=NULL;
        unsigned int ui_port=a_ui_port;
        enum BOOLEAN skip_line = FALSE;

        if(config_buf[0]) // If there is no startup config, we clear [0] to 0.
                stacking_set_parsed_config(PARSE_MODE_PARSED_STARTUP); // we do this in one shot
        /* If caller is agent, save and restore the cdb */
        if(a_ui_port == AGENT_USER)
        {
                old_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb));
                if (!old_cdb)
                        return;

                ui_port = 0;
        }

        sptr_cdb = &cdbs[ui_port];

        if(a_ui_port == AGENT_USER)
        {
                *old_cdb = *sptr_cdb;
                /*  ###!! Please make sure that current_login_password_level will not
                        be changed in set_cli_mode(..) function below! */
                sptr_cdb->current_login_password_level = CU_SECURITY_LEVEL0;
        }

        /* tell parser not to print the prompt for each line processed */
        io_cb[ui_port].no_prompt_mode = 1;
        save_mode = sptr_cdb->mode;
        set_cli_mode(sptr_cdb, CONFIG);

         if(IS_DOT1X_ENABLED())
         {
                 if(dot1x_flag_for_use_parse_configBuf==FALSE)
                 {
                        set_vlan_single_stp_node_type_flag(ENABLE);
                 }
         }
         else
         {
                  set_vlan_single_stp_node_type_flag(ENABLE);
         }
        sptr_cdb->internal_parsing_flag = 1;
        /* allocate a line buffer */
        if ((line = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE+1)) == NULL)
        {
                uprintf("Error - parse_configBuf(): can't allocate line buffer\n");
                set_cli_mode(sptr_cdb, save_mode);
                goto cleanup_parse_configBuf;
        }

        sptr_cdb->vlan_id = SW_DFLT_VLAN_ID;
        if (is_mgmt_active() && is_standby_up())
                stk_sync_one_cdb(sptr_cdb->ui_port);
        line[0] = '\0';
        parser(line, ui_port, CMD_LINE_EXECUTE);

        /* Parse the config file 3 times. */
        for (k = 0; k < 3; k++)
        {
                for (i = 0, j = 0, skip_line = FALSE; config_buf[i] != 0; i++)
                {
                        if (j >= CMD_LINE_SIZE)
                        {
                                if (k == 0)
                                        uprintf("Error - the length of the command line exceeds %d characters.\n!!!"
                                                "Stopped parsing the rest of the command line!!!\n",
                                                CMD_LINE_SIZE);
                                skip_line = TRUE;
                        }

                        if (config_buf[i] == '\n')
                        {
                                strncpy(line, &config_buf[i-j], j);
                                line[j] = '\0';
                                if (j != 0 && line[j-1] == '\r')
                                        line[j-1] = '\0';

#ifdef TIME_PARSE_LINE_TIME
                            if (k == 2)
                                {
                                   start_time = read_tb();
                }
#endif TIME_PARSE_LINE_TIME

                                if (!skip_line && !parse_line(
                                                line,
                                                ui_port,
                                                k,
                                                &max_vlan,
                                                &default_vlan_id,
                                                &logging_buffer_size))
                                {
                                        uprintf("Error - Encountered error while parsing a command line.\n");
                                }

#ifdef TIME_PARSE_LINE_TIME
                    if (k == 2)
                                {
                    config_line++;
                                        cur_time = read_tb();

                                        if (cur_time > start_time)
                                           uprintf("Parse line %d took %x ticks\n",config_line, cur_time-start_time);
                                        else
                                           uprintf("Parse line %d took %x ticks\n",config_line, cur_time+ (0xFFFFFFFF - start_time));
                }
#endif TIME_PARSE_LINE_TIME

                                j = 0;
                                skip_line = FALSE;
                        }
                        else
                                j++;
#ifdef SR_SWITCH_ROUTER
                        sys_yield_if_time_expired(1);
#else
                        sys_yield_if_time_expired(4);
#endif
                }

                if (j != 0)
                {
                        /* last line not ended with '\n' */
                        strncpy(line, &config_buf[i-j], j);
                        line[j] = '\0';
                        if (line[j-1] == '\r')
                                line[j-1] = '\0';

                        if (!skip_line && !parse_line(
                                        line,
                                        ui_port,
                                        k,
                                        &max_vlan,
                                        &default_vlan_id,
                                        &logging_buffer_size))
                        {
                                uprintf("Error - Encountered error while parsing a command line.\n");
                        }
                }
                if((g_bootinfo_sptr->bootconfig.option.s.di)||
                        (g_bootinfo_sptr->bootconfig.option.s.di_alt))
                                max_vlan = 1024; 
                process_init_command(
                        ui_port,
                        k,
                        max_vlan,
                        default_vlan_id,
                        logging_buffer_size);
        }

        /* the last line "end" will should sptr_cdb->mode = PRIV_EXEC;
        but in case config file is not correct loaded. */
        if (sptr_cdb->mode != PRIV_EXEC)
        {
                set_cli_mode(sptr_cdb, PRIV_EXEC);
                line[0] = '\0';
                sptr_cdb->vlan_group_id = 0;

#ifdef __DEBUG__
                uprintf("\n");
#endif
                parser(line, ui_port, CMD_LINE_EXECUTE);
        }

cleanup_parse_configBuf:
        set_vlan_single_stp_node_type_flag(DISABLE);
        /* tell parser not to resume printing the prompt */
        io_cb[ui_port].no_prompt_mode = 0;
        sptr_cdb->internal_parsing_flag = 0;
        trunk_init_in_progress = 0;

        /* If caller is agent, save and restore the cdb */
        if(a_ui_port == AGENT_USER)
        {
                if(old_cdb)
                {
                        *sptr_cdb = *old_cdb;
                        dy_free(old_cdb);
                }
        }

        dy_free(line); /* free line buffer */
}

/* if CU_OK is returned, caller has to free the buffer */
INT32 agt_prepare_write_mem(UINT8 **config_buf_ptr,UINT32 user)
{
        struct cdb *my_cdb;
        int status;

        my_cdb = (struct cdb *) dy_malloc(sizeof(struct cdb));
        if (!my_cdb)
                return CU_ERROR;

        memset((UINT8 *)my_cdb, 0, sizeof(struct cdb));
        my_cdb->dont_print_hostname = FALSE;

        my_cdb->buffer = my_cdb->buffer_base = get_config_buffer(user);
        if (my_cdb->buffer == 0)
        {
                dy_free(my_cdb);
                return CU_ERROR;
        }

        my_cdb->gen_to = GEN_TO_FLASH;
        //status = retrieve_running_config(my_cdb);
        status = retrieve_all_module_config_new(my_cdb);
        if (status < 0)
        {
                free_config_buffer(my_cdb->buffer_base);
                dy_free(my_cdb);
                return CU_ERROR;
        }
        else
        {
                *config_buf_ptr = my_cdb->buffer_base;
                dy_free(my_cdb);
                return CU_OK;
        }
}

#ifdef SR_SWITCH_ONLY
#ifdef SYSTEM_TEST
void l3_address_range(struct cdb* sptr_cdb)
{
        int mode;
        if (sptr_cdb->config_gen)
        {
                mode = 0;       /* place holder */
        }
        else
        {
                if (sptr_cdb->no)
                        mode = 0;       /* place holder */
                else
                {
                        l3_test_new_address_range((UINT16) sptr_cdb->integer1, (UINT16) sptr_cdb->integer2);
                }
        }
}

void l3_test_set_net(struct cdb* sptr_cdb)
{
        int mode;
        if (sptr_cdb->config_gen)
        {
                mode = 0;       /* place holder */
        }
        else
        {
                if (sptr_cdb->no)
                        mode = 0;       /* place holder */
                else
                {
                        l3_test_new_subnet(sptr_cdb->ip1,sptr_cdb->ip2,sptr_cdb->mac1);
                }
        }
}

void l3_traffic_start(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        l3_traffic_go(1);
}

void l3_traffic_stop(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        l3_traffic_go(0);
}

void l3_set_rx_arp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        l3_traffic_go(2);
}

void l3_test_mode(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        l3_traffic_mode(sptr_cdb->integer1);
}
#endif  /* SYSTEM_TEST */

#endif /* SR_SWITCH_ONLY */



/* following for dump memory */
extern void dm(UINT32, UINT32);
extern void display_mem_reg(void);
extern void rd_phy(PORT_ID port);
extern void     dset();

#ifdef MANU_DIAG
extern void diagparam(UINT32, UINT32, UINT32, UINT32);
extern void setport(UINT32, UINT32, UINT32, UINT32);
extern void startdiag3(UINT32, UINT32, UINT32);
extern void startdiag2(UINT32, UINT32);
extern void startdiag1(UINT32);
extern void startdiag();
extern void dbroadcast();
extern void print_portmask();

void d_portmask1(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        print_portmask();
}

void d_portmask2(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        dbroadcast(sptr_cdb->integer1,0,0xFF);
}

void d_portmask3(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        dbroadcast(sptr_cdb->integer1,sptr_cdb->integer2,0xFF);
}

void d_dbroadcast(struct cdb *sptr_cdb)
{
        dbroadcast(sptr_cdb->integer1,sptr_cdb->integer2,sptr_cdb->integer3);
}

void d_setport(struct cdb *sptr_cdb)
{
        setport(sptr_cdb->if1,sptr_cdb->if2,sptr_cdb->integer1,
                                sptr_cdb->integer2);
}

void d_diagparam(struct cdb *sptr_cdb)
{
        diagparam(sptr_cdb->integer1,sptr_cdb->integer2,sptr_cdb->integer3,
                                sptr_cdb->integer4);
}

void p_startdiag3(struct cdb *sptr_cdb)
{
        startdiag3(sptr_cdb->integer1,sptr_cdb->integer2,sptr_cdb->integer3);
}
void p_startdiag2(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                startdiag2(sptr_cdb->integer1,sptr_cdb->integer2);
        }
}
void p_startdiag1(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                startdiag1(sptr_cdb->integer1);
        }
}
void p_startdiag(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                startdiag();
        }
}
#endif

void p_dset(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                dset();
        }
}

void check_verify_algorithm(struct cdb *sptr_cdb)
{
        if (cu_fips_get_status() && (cu_fips_get_enable_monitor_access()== FALSE))
    {
        uprintf("verify commands are not supported in fips-mode\n");
        sptr_cdb->dont_go_next = 1;
        return ;
    }
}

void continue_dump_memory(struct cdb *sptr_cdb)
{

                if (cu_fips_get_status() && (cu_fips_get_enable_monitor_access()== FALSE))
                {
                uprintf("dm commands are not supported in fips-mode\n");
                sptr_cdb->dont_go_next = 1;
                return ;
        }

        /* Allow stacking/spx ports to be specified in dm commands */
        sptr_cdb->stacking_ports_allowed = TRUE;
#ifdef __PORT_EXTENSION__
        sptr_cdb->spx_ports_allowed = TRUE;
#endif __PORT_EXTENSION__

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (end_of_token(sptr_cdb->token) == '\0')
        {

                /* We have seen Crash at Katara and CHOW Linux image
                * Moreover this is kind of no-op for Katara
                * We return simply
                */
        /*Irrespective of platform,
        *if FI_LINUX is defined then function returns 1
        */
                if ( is_linux_based_system())
                        return;
                sptr_cdb->dont_go_next = 1;

                last_dm_addr = last_dm_addr + last_dm_len;
                dm(last_dm_addr,last_dm_len);
        }
}

void dump_memory(struct cdb *sptr_cdb)
{
        last_dm_addr = sptr_cdb->integer1;
        last_dm_len = sptr_cdb->integer2;
        dm(sptr_cdb->integer1,sptr_cdb->integer2);

}

/* default display for memory */
void dump_memory_def(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                /*Irrespective of platform,
                *if FI_LINUX is defined then function returns 1
            */
                        if ( is_linux_based_system())
                                return;

                last_dm_addr = sptr_cdb->integer1;
                last_dm_len = 0x40;
                dm(sptr_cdb->integer1,0x40);
        }
}

void mm_addr(struct cdb *sptr_cdb)
{
        int i;
        UINT32 addr;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                addr = sptr_cdb->integer1;
                if (RELATIVE_SLOT_ADDR_RANGE(addr))
                {
                        for (i=0; i<g_hw_info.max_mod; i++)
                        {
                                if (MODULE_IS_GOOD(i))
                {
                                        dm(MODULE_ADDR(i,addr), 0x40);
                                }
                        }
                } else
                {
                        dm(addr, 0x40);
                }
        }
}

void mm_addr_size(struct cdb *sptr_cdb)
{
        int i;
        UINT32 addr;
        int size;

        addr = sptr_cdb->integer1;
        size = sptr_cdb->integer2;
        if (RELATIVE_SLOT_ADDR_RANGE(addr))
        {
                if (size > 0x40)
                {
                        uprintf("display maximum 64 bytes per module\n");
                        size = 0x40;
                }
                for (i=0; i<g_hw_info.max_mod; i++)
                {
                        if (MODULE_IS_GOOD(i))
                        {
                                dm(MODULE_ADDR(i,addr), size);
                        }
                }
        } else
        {
                dm(addr, size);
        }
}

/* pvstplus protect */
void cli_set_pvst_protect(struct cdb *sptr_cdb)
{
        PORT_ID  port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
#ifdef SIDEWINDER_BREAKOUT
    if (!IS_PORT_DB_VALID(port_id))
        return;
#endif


        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                if ((SPTR_PORT_DB(port_id))->port_config.pvst_protect_en)
                {
                        ksprintf(cu_line_buf, " pvstplus-protect\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (sptr_cdb->no)
                sw_set_port_pvst_protect (port_id, FALSE);
        else
        	{
        		if (cu_get_pvst_mode(port_id))
        		{
					uprintf(" PVSTPlus-Protect is not allowed when pvst-mode is configured \n");
					return;
        		}
                sw_set_port_pvst_protect (port_id, TRUE);
        	}
}

void cli_set_pvst_protect_mif (struct cdb *sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_pvst_protect);
}

void show_pvst_protect (struct cdb *sptr_cdb)
{
	UINT16 i, port;
	PORT_ID member_port_id, j;
	UINT32  drop_cnt=0;

	if (sptr_cdb->config_gen)
		return;

	if (end_of_token(sptr_cdb->token) != '\0')
		return; /* cmd not for me */


	/* Don't process the next token. */
	sptr_cdb->dont_go_next = 1;

	/* 103204 - page mode display */
	if ((SHOW_BUF = sv_buf_alloc()) == NULL)
		return;

	ksprintf (cu_line_buf, "\tPort\tPVST Drop Count\n");
	sv_buf_write (SHOW_BUF, cu_line_buf);

	for (i = 0; i < g_hw_info.total_config_ports; i++)
	{
		port = sw_config_port_list[i];
		if (!IS_PORT_DB_VALID(port))
			continue;

		if ((SPTR_PORT_DB(port))->port_config.pvst_protect_en)
		{
			if(IS_LAG_PRIMARY_PORT(port))
			{
				UINT16  group_id = PORT_GROUP_ID(port);
				for (j = 0; j < g_sw_load_group[group_id].config_ports;j++)
				{
					member_port_id = g_sw_load_group[group_id].port_list[j];
					if((!IS_PORT_DB_VALID(member_port_id)) || IS_LAG_AP(member_port_id))
						continue;
					drop_cnt += (SPTR_PORT_DB(member_port_id))->pvst_protect_bpdu_drop_cnt;
				}
				ksprintf (cu_line_buf, "\t%p\t%d\n", port,drop_cnt);
				sv_buf_write (SHOW_BUF, cu_line_buf);
			}
			else                        
			{    
				ksprintf (cu_line_buf, "\t%p\t%d\n", port, (SPTR_PORT_DB(port))->pvst_protect_bpdu_drop_cnt);
				sv_buf_write (SHOW_BUF, cu_line_buf);
			}
		}
	}
	sv_buf_display();
}

void show_pvst_protect_per_port(struct cdb *sptr_cdb)
{
	PORT_ID port,member_port_id, j;
	UINT32  drop_cnt=0;

	if (sptr_cdb->config_gen)
		return;

	if (end_of_token(sptr_cdb->token) != '\0')
		return; /* cmd not for me */


	/* Don't process the next token. */
	sptr_cdb->dont_go_next = 1;
	port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

	if (!IS_PORT_DB_VALID(port))
	{
		sptr_cdb->dont_go_next = 1;
		uprintf("%p is not a valid port \n", port);
		return;
	}
	if ((SPTR_PORT_DB(port))->port_config.pvst_protect_en)
	{
		if(IS_LAG_PRIMARY_PORT(port))
		{
			UINT16  group_id = PORT_GROUP_ID(port);
			for (j = 0; j < g_sw_load_group[group_id].config_ports;j++)
			{
				member_port_id = g_sw_load_group[group_id].port_list[j];
				if((!IS_PORT_DB_VALID(member_port_id)) || IS_LAG_AP(member_port_id))
					continue;
				drop_cnt += (SPTR_PORT_DB(member_port_id))->pvst_protect_bpdu_drop_cnt;
			}
			uprintf("PVST-protect is enabled on port %p.  PVST drop count is %d\n",
					port, drop_cnt);
		}
		else                        
		{    
			uprintf("PVST-protect is enabled on port %p.  PVST drop count is %d\n",
					port, (SPTR_PORT_DB(port))->pvst_protect_bpdu_drop_cnt);
		}
	}
	else
	{
		uprintf("PVST-protect is not enabled on port %p\n", port);
	}
}


void cli_clear_pvst_protect_stats (struct cdb *sptr_cdb)
{
        UINT16 i, port;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        clear_pvst_protect_stats();
}
void cli_clear_pvst_protect_stats_per_port (struct cdb *sptr_cdb)
{
        PORT_ID  port_id;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */


        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;
        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        clear_pvst_protect_stats_per_port(port_id);
}

void cli_set_stp_protect(struct cdb *sptr_cdb)
{
        PORT_ID  port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    if (!IS_PORT_DB_VALID(port_id))
        return;


        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                if ((SPTR_PORT_DB(port_id))->port_config.stp_protect_en)
                {
                        ksprintf(cu_line_buf, " stp-protect\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (sptr_cdb->no)
                sw_set_port_stp_protect (port_id, FALSE);
        else
                sw_set_port_stp_protect (port_id, TRUE);
}

void cli_set_stp_protect_mif (struct cdb *sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_stp_protect);
}

void show_stp_protect (struct cdb *sptr_cdb)
{
        UINT16 i, port;
        PORT_ID member_port_id, j;
        UINT32  drop_cnt=0;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */


        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        /* 103204 - page mode display */
        if ((SHOW_BUF = sv_buf_alloc()) == NULL)
                return;

        ksprintf (cu_line_buf, "\tPort\tBPDU Drop Count\n");
        sv_buf_write (SHOW_BUF, cu_line_buf);

        for (i = 0; i < g_hw_info.total_config_ports; i++)
        {
                port = sw_config_port_list[i];
                if (!IS_PORT_DB_VALID(port))
                    continue;

                if ((SPTR_PORT_DB(port))->port_config.stp_protect_en)
                {
                   if(IS_LAG_PRIMARY_PORT(port))
		   {
		      UINT16  group_id = PORT_GROUP_ID(port);
		      for (j = 0; j < g_sw_load_group[group_id].config_ports;j++)
		      {
			 member_port_id = g_sw_load_group[group_id].port_list[j];
			 if(!IS_PORT_DB_VALID(member_port_id))
			     continue;
			 drop_cnt += SPTR_PORT_DB(member_port_id)->stp_protect_bpdu_drop_cnt;
		      }
                      ksprintf (cu_line_buf, "\t%p\t%d\n", port,drop_cnt);
                      sv_buf_write (SHOW_BUF, cu_line_buf);
                      drop_cnt = 0;
		   }
                   else                        
		   {    
                        ksprintf (cu_line_buf, "\t%p\t%d\n", port, (SPTR_PORT_DB(port))->stp_protect_bpdu_drop_cnt);
	   	        sv_buf_write (SHOW_BUF, cu_line_buf);
		   }
                }
        }
        sv_buf_display();
}

void show_stp_protect_per_port(struct cdb *sptr_cdb)
{
        PORT_ID  port_id,member_port_id,i;
        UINT32  drop_cnt=0;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */


        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;
        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        if (!IS_PORT_DB_VALID(port_id))
        {
                sptr_cdb->dont_go_next = 1;
                uprintf("%p is not a valid port \n", port_id);
                return;
        }

        if((SPTR_PORT_DB(port_id))->port_config.stp_protect_en)
        {
          if(IS_LAG_PRIMARY_PORT(port_id))
	  {
	     UINT16  group_id = PORT_GROUP_ID(port_id);
	     for (i = 0; i < g_sw_load_group[group_id].config_ports;i++)
	     {
		member_port_id = g_sw_load_group[group_id].port_list[i];
		if(!IS_PORT_DB_VALID(member_port_id))
		    continue;
		drop_cnt += SPTR_PORT_DB(member_port_id)->stp_protect_bpdu_drop_cnt;
	     }

	     uprintf("STP-protect is enabled on port %p.  BPDU drop count is %d\n",
		      port_id, drop_cnt);
	  }
          else
	  {
		  uprintf("STP-protect is enabled on port %p.  BPDU drop count is %d\n",
			  port_id, (SPTR_PORT_DB(port_id))->stp_protect_bpdu_drop_cnt);
	  }
        }
        else
        {
                uprintf("STP-protect is not enabled on port %p\n", port_id);
        }
}


void cli_clear_stp_protect_stats (struct cdb *sptr_cdb)
{
        UINT16 i, port;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        clear_stp_protect_stats();
}
void cli_clear_stp_protect_stats_per_port (struct cdb *sptr_cdb)
{
        PORT_ID  port_id;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */


        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;
        port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        clear_stp_protect_stats_per_port(port_id);
}

#ifdef FI_PROTECTED_PORTS
void set_if_protected(struct cdb* sptr_cdb)
{

    UINT16 port_id = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

    if(!IS_PORT_DB_VALID(port_id))
       return;

    if (sptr_cdb->config_gen)
    {
        if(!IS_PORT_ENET(port_id)) 
           return;

        if ((SPTR_PORT_DB(port_id))->port_config.protected)
            wr_config(sptr_cdb, " protected-port\n");
    }
    else
    {
        if (sptr_cdb->no)
        {
            cu_set_protected_port(port_id,FALSE);
        }
        else
        {

#ifdef SR_SWITCH_ROUTER
            if(cu_get_port_route_only(port_id))
	    {
		uprintf("Error:Port %p is route-only enabled, so cannot be a protected port\n",port_id);
	  	 return;
	    }

            if(IP_ADDR_COUNT(port_id))
	    {
	        uprintf("Error:Port %p has an associated ip address,hence cannot be protected port\n",port_id);
	         return;
	    }
#endif SR_SWITCH_ROUTER 

            if(SPTR_PORT_DB(port_id)->port_pvlan_type != PVLAN_TYPE_NONE)
            {
              uprintf("Error:Protected port cannot be a port in Private VLAN\n");
              return;
            }

            if (is_virtual_port (port_id))
            {
                uprintf ("Error:Protected port cannot be a VE interface\n");
                return;
            }
            
            if(sw_pp_is_port_mirror(port_id))
            {
                  uprintf ("Error: mirror-port cannot be protected port\n");
                  return;
            }
            
            if(sw_pp_is_port_monitor(port_id))
            {
                  uprintf("Error: monitor-port cannot be protected port\n");
                  return;
            }
 
            if((SPTR_PORT_DB(port_id))->port_config.erspan_monitor_profile_id!= 0)
	    {
 		  uprintf("Error: ERSPAN configuration on this port, can't be protected port.\n");
		  return;
	    }

            if((SPTR_PORT_DB(port_id))->port_config.acl_mirror)
            {
                  uprintf("Error: ACL mirroring is enabled on this port, can't be protected port.\n");
                  return;
            }
 
#ifdef FIOFL_INCLUDE
            if (IS_PORT_OPENFLOW_PORT(port_id))
            {
                uprintf("Error:Protected port cannot be enabled on a port %p with Openflow feature enabled\n", port_id);
                return;
            }
#endif FIOFL_INCLUDE

            if(IS_MGMT_PORT(port_id))
            {
               uprintf("Error:Protected port cannot be a management port\n");
               return;
            }

            if(is_loopback_port(port_id))
            {
               uprintf("Error:Protected port cannot be a loopback port\n");
               return;
            }

            if(IS_PE_PORT(port_id))
            {
                uprintf("Error: PE port cannot be protected port\n");
                return;
            }
          
            if(is_port_stack_enabled (port_id) || IS_SPX_PORT(port_id))
            {
                uprintf("Error: Stack/SPX port cannot be protected port\n");
                return;
            }

            if(IS_ZTP_PORT(port_id))
            {
               uprintf("Error: ZTP cannot be protected port\n");
               return;
            }

#ifdef INCLUDE_MCT
	    if (IS_PORT_ICL_PORT(port_id) || IS_PORT_CCEP_PORT(port_id))	
	    {
		uprintf("Error: Port is a cluster port, cannot be protected port\n", port_id);
	        return ;
	    }
#endif	

            cu_set_protected_port(port_id,TRUE);
        }
    }
}
#endif

void set_stp_port_control(struct cdb *sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 stp_enable;

#if __MPORT_SUPPORT__
        if ( IS_MPORT(port_id) )
                return;
#endif // __MPORT_SUPPORT__

        if (sptr_cdb->config_gen)
        {
#ifdef INCLUDE_802_1S
                if (g_mstp_mode)
                {
                        extern enum BOOLEAN mstplib_is_control_port(PORT_ID port_number);
                        if(!mstplib_is_control_port(port_id)!=0)
                        {
                                /* CHEETAH_STACKING : 86028 - stacking port should not be considered here. */
                                if((!is_port_stack_enabled (port_id)) && (!IS_SPX_PORT(port_id))) 
                                {
                                        wr_config(sptr_cdb," no spanning-tree\n");
                                }
                        }
                        return;
                }
#endif

                if (cu_get_stp_port_state(port_id, 1, &stp_enable) != CU_OK)
                        return;
                if (!stp_enable)
                {
            /* CHEETAH_STACKING : 86028 - stacking port should not be considered here. */
                        if((!is_port_stack_enabled (port_id)) && (!IS_SPX_PORT(port_id))) 
                        {
                                wr_config(sptr_cdb," no spanning-tree\n");
                        }
                }
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                return;

                sptr_cdb->dont_go_next = 1;

                if (sptr_cdb->no)
                {
#ifdef INCLUDE_802_1S
                        if ((g_mstp_mode) || (g_mstp_pvst_mode))
                        {
                                extern int mstpcu_update_port(PORT_ID port_number, int add);
                                if(mstpcu_update_port(port_id, 0)!=0)
                                {
                                        uprintf("error -- mstp module\n");
                                }
                          // 68081, maocheng++: return;
                        }
#endif

                        cu_set_stp_port_state(port_id, 0);

#ifdef INCLUDE_802_1W
                        /* if any of the rstp parameters are set, clear them
                         * when disabling spanning-tree on the interface
                         */
                        sptr_cdb->integer2 = sptr_cdb->integer3 = 0;
                        RSTP_SET_PORT_EDGEPORT(sptr_cdb);
                        RSTP_SET_PORT_PT2PTMAC(sptr_cdb);
                        set_rstp_port_parameters_for_all_vlans(sptr_cdb);
#endif INCLUDE_802_1W

                        //86801, 07/16/08
                        {
                                extern enum BOOLEAN macAuth_is_vlan_ingress_disabled(PORT_ID port);
                                PORT_ID primary_port;//86801
                                primary_port = trunk_primary_port(port_id);

                                if(macAuth_is_vlan_ingress_disabled(primary_port))
                                {
                                        extern enum BOOLEAN L2_IS_PORT_UP (UINT16 port);
                                        extern void sw_cu_set_port_state_in_NON_member_vlans(PORT_ID port_number, enum PORT_STATE state);

                                        if(L2_IS_PORT_UP(primary_port))
                                        {
                                                sw_cu_set_port_state_in_NON_member_vlans(primary_port, FORWARDING);
                                        }
                                        else
                                                sw_cu_set_port_state_in_NON_member_vlans(primary_port, BLOCKING);
                                }
                        }
                }
                else
                {
                                                {
                                VLAN_ENTRY *vlan_entry;
                                UINT16 stp_grp;
                                for(stp_grp= 0; stp_grp < MAX_STP_GROUP; stp_grp++)
                                {
#ifdef FIOFL_INCLUDE
                                        if (IS_PORT_OPENFLOW_NONHYBRID(port_id))
                                        {
                                            uprintf("Spanning-tree cannot be enabled on an OpenFlow enabled port\n");
                                            return;
                                        }
#endif FIOFL_INCLUDE
                                        if (g_sw_sys.topo_group_db[stp_grp].master_vlan_idx != VLAN_INDEX_INVALID)
                                        {
                                                vlan_entry = g_sptr_vlan_db + g_sw_sys.topo_group_db[stp_grp].master_vlan_idx ;
                                                if((is_member(vlan_entry->vlan_config.l2_portmask,port_id)) &&
                                                        ( vlan_entry->vlan_config_backup.stp_enabled
#ifdef INCLUDE_802_1W
                                                          || vlan_entry->vlan_config_backup.rstp_BEGIN
#endif INCLUDE_802_1W
                                                   ))
                                                {
                                                        uprintf("Error- STP cannot be enbled on this port because it is part of topology group\n");
                                                        return;
                                                }
                                        }
                                }
                        }
                        if ((cu_set_stp_port_state(port_id, 1) == CU_ERROR)&&(sptr_cdb->gen_to != GEN_TO_INTERNAL_USE))
                        {
                                uprintf("Error - STP cannot be enabled on this port\n");
                                return;
                        }
#ifdef INCLUDE_802_1S
                        if ((g_mstp_mode) || (g_mstp_pvst_mode))
                        {
                           extern int mstpcu_update_port(PORT_ID port_number, int add);
                           if(mstpcu_update_port(port_id, 1)!=0)
                           {
                             uprintf("error -- mstp module\n");
                           }
                           //68081, maocheng++ return;
                        }
#endif
                }
        }
}

void set_port_flow_control_neg_on(struct cdb *sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 flow_enable;

        if(sptr_cdb->no && IS_PORT_DB_VALID(INTERFACE_TO_PORT_ID(sptr_cdb->if_num))){
                        uprintf("Error - 'no flow-control neg-on' is not supported\n");
                        uprintf("Use 'flow-control' or 'no flow-control' instead.\n");
                        return;
        }

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                if (cu_get_port_flow_control_neg(port_id, 1, &flow_enable) != CU_OK)
                        return;
                if (!flow_enable)
                {
                        wr_config(sptr_cdb," no flow-control neg-on\n");
                }
                return;
        }
        else
        {
                if (!IS_PORT_DB_VALID(port_id))
                {
                        return;
                }

                        // Either the flow control is enabled for the first time, or the autoneg is
                        // enabled for the already enabled flow control for the first time,
                        // otherwise there is no change
                if (sptr_cdb->no) {
                                                #if defined(SIDEWINDER_LINUX) && !defined(SPATHA)
                                                if(is_gi_cut_through_mode_supported_on_this_platform() && is_gi_cut_through_enable_on_hw())
                                                        return; // FC cannot be enabled for MMU cut-through mode, return silently.
                                                #endif

                        if ((SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg)  {
                                cu_set_port_flow_control_negotiation(port_id, 0);       /* Disable negotiation of flow control */
                                cu_set_port_flow_control(port_id, 0);   /* Disable negotiation flow control */
                        }
                }
                else
                                {
                                #ifdef SIDEWINDER_LINUX
                                        #ifndef SPATHA
                                        if( is_gi_cut_through_mode_supported_on_this_platform() && is_gi_cut_through_enable_on_hw())
                                        {
                                                if(!g_sw_sys.init_in_progress)
                                                        uprintf("ERROR: This CLI operation is not supported in MMU cut-through mode\n");

                                                return;
                                        }
                                        #endif

                                        if(g_sfc_config_e == sfc_disable)
                                        {
                                                uprintf("Error: Flow-control neg-on is not allowed as Symmetric flow-control is disabled\n");
                                                return;
                                        }
                                #endif
                                        if(SPTR_PORT_DB(port_id)->port_config.disable_auto_neg_on_phy)
                                        {
                                                uprintf("\n Auto Negotiation is disabled on port = %P, Flow control Auto Negotiation cannot be enabled\n", port_id);
                                        }else
                                        {
                                        #ifdef SIDEWINDER_LINUX
                                                if (!(SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg) {
                                                        cu_set_port_flow_control_negotiation(port_id, 1);       /* Enable negotiation of flow control */
                                                        cu_set_port_flow_control_ti(port_id, 3); /* Enable flow control for both TX and RX */
                                                }
                                        #else
                                                if (!(SPTR_PORT_DB(port_id))->port_config.flow_control ||
                                                        !(SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg) {
                                                        cu_set_port_flow_control_negotiation(port_id, 1);       /* Enable negotiation of flow control */
                                                        cu_set_port_flow_control(port_id, 1);   /* Enable flow control */
                                                }
                                        #endif
                                        }
                                }
        }
}

void set_port_flow_control_tx(struct cdb *sptr_cdb)
{
        sptr_cdb->integer1 = 2;
        set_port_flow_control(sptr_cdb);
}

void set_port_flow_control_rx(struct cdb *sptr_cdb)
{
        sptr_cdb->integer1 = 1;
        set_port_flow_control(sptr_cdb);
}

void set_port_flow_control_txrx(struct cdb *sptr_cdb)
{
        sptr_cdb->integer1 = 3;
        set_port_flow_control(sptr_cdb);
}

void set_port_flow_control_ti(struct cdb *sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 flow_enable;
    UINT8 flow_enable_tx;

#if __MPORT_SUPPORT__
        if ( IS_MPORT(port_id) )
                return;
#endif // __MPORT_SUPPORT__

        if (sptr_cdb->config_gen)
        {

                sptr_cdb->dont_go_next = 1;

                if (cu_get_port_flow_control(port_id, 1, &flow_enable) != CU_OK)
                        return;

        if (cu_get_port_flow_control_tx(port_id, 1, &flow_enable_tx) != CU_OK)
                        return;


#ifdef SIDEWINDER_LINUX
                if(g_pfc_global_status == 0)
                {
            if(IS_PORT_DB_VALID(port_id) && ((SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg))
            {
                wr_config(sptr_cdb," flow-control neg-on\n");
            }
        
            else
#endif
            {
#if defined(SIDEWINDER_LINUX) && !defined(SPATHA)
                                if( is_gi_cut_through_mode_supported_on_this_platform() && is_gi_cut_through_enable_on_hw())
                                {
                    //In CT mode, FC disable is default value
                                        if(flow_enable == 1 && flow_enable_tx == 0)
                                                wr_config(sptr_cdb," flow-control honor-only \n");
                    else if (flow_enable == 0 && flow_enable_tx == 1)
                        wr_config(sptr_cdb," flow-control generate-only \n");
                    else if (flow_enable == 1 && flow_enable_tx == 1)
                        wr_config(sptr_cdb," flow-control both \n");
                                }
                                else
                                {
                    //In SF mode, FC Honor only is default mode
                                        if (flow_enable == 0 && flow_enable_tx == 0) {
                                                if (!(is_port_stack_enabled (port_id)))
                                                        wr_config(sptr_cdb," no flow-control both\n");
                                        }
                                        else if(flow_enable == 0 && flow_enable_tx == 1)
                                                wr_config(sptr_cdb," flow-control generate-only \n");
                                        else if(flow_enable == 1 && flow_enable_tx == 1)
                                                wr_config(sptr_cdb," flow-control both \n");
                                }
#else
                                /*For stacking port defult is no FC tx and RX */
                                if (flow_enable == 0 && flow_enable_tx == 0) {
                                        if (!(is_port_stack_enabled (port_id)))
                                        wr_config(sptr_cdb," no flow-control both\n");
                                        }
                                else if(flow_enable == 0 && flow_enable_tx == 1)
                                        wr_config(sptr_cdb," flow-control generate-only \n");
                                else if(flow_enable == 1 && flow_enable_tx == 1)
                                        wr_config(sptr_cdb," flow-control both \n");
#ifndef SIDEWINDER_LINUX
                                else
                                {
                                        if(IS_PORT_DB_VALID(port_id) && ((SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg))
                                        {
                                                wr_config(sptr_cdb," flow-control neg-on\n");
                                        }
                                }
#endif
#endif
            }
#ifdef SIDEWINDER_LINUX
                }
#endif
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                                        return;
                sptr_cdb->dont_go_next = 1;


                if (!IS_PORT_DB_VALID(port_id))
                {
                        return;
                }

                if (sptr_cdb->no) {

#ifdef SIDEWINDER_LINUX
                    if(g_pfc_global_status)
                    {
                        uprintf("Error: Configuration not allowed as Global PFC is enabled\n");
                        return;
                    }
#endif
                        if (cu_get_port_flow_control(port_id, 1, &flow_enable) != CU_OK)
                                return;

                if (cu_get_port_flow_control_tx(port_id, 1, &flow_enable_tx) != CU_OK)
                                return;

#ifdef SIDEWINDER_LINUX
                                        #ifndef SPATHA
                                        if(is_gi_cut_through_mode_supported_on_this_platform() && is_gi_cut_through_enable_on_hw())
                                                return; // FC cannot be enabled for MMU cut-through mode, return silently.
                                        #endif

                    if((flow_enable_tx == 1) && (sptr_cdb->integer1 == 2 || sptr_cdb->integer1 == 3))
                    {
                       if(g_sfc_config_e == sfc_disable)
                       {
                          uprintf("Error: Configuration not allowed as Symmetric flow-control is disabled\n");
                          return;
                       }
                    }
#endif

                        if ((SPTR_PORT_DB(port_id))->port_config.flow_control || (SPTR_PORT_DB(port_id))->port_config.flow_control_tx) {
                                cu_set_port_flow_control_negotiation(port_id, 0);       /* Disable negotiation of flow control */

                                if(sptr_cdb->integer1 ==1 || !sptr_cdb->integer1)
                                {
                                        if(flow_enable_tx)
                                        {
                                                cu_set_port_flow_control_ti(port_id, 2);
                                        }
                                        else
                                        {
                                                cu_set_port_flow_control_ti(port_id, 0); /*Disable flow-control*/
                                        }
                                        if((sptr_cdb->mode == CONFIG_IF && !sptr_cdb->integer1) ||
                                                (sptr_cdb->mode == CONFIG_MIF && !sptr_cdb->integer1 && flw_ctl_print))
                                        {
                                                uprintf("flow-control honor-only is removed.\n");
                                                flw_ctl_print = 0;
                                        }
                                }
                                else if(sptr_cdb->integer1==2)
                                {
                                        if(flow_enable)
                                        {
                                                cu_set_port_flow_control_ti(port_id, 1);
                                        }
                                        else
                                        {
                                                cu_set_port_flow_control_ti(port_id, 0); /*Disable flow-control*/
                                        }

                                }
                                else if(sptr_cdb->integer1==3 )
                                {

                                        cu_set_port_flow_control_ti(port_id, 0); /*Disable flow-control*/
                                }



                        }
                }
                else
                {
#ifdef SIDEWINDER_LINUX
                                        #ifndef SPATHA
                                        if( is_gi_cut_through_mode_supported_on_this_platform() && is_gi_cut_through_enable_on_hw())
                                        {
                                                if(!g_sw_sys.init_in_progress)
                                                        uprintf("ERROR: This CLI operation is not supported in MMU cut-through mode\n");

                                                return;
                                        }
                                        #endif

                                        if(g_pfc_global_status)
                                        {
                                                uprintf("Error: Flow-control configuration is not allowed as Global PFC is enabled\n");
                                                return;
                                        }
                                        if(sptr_cdb->integer1 == 2 || sptr_cdb->integer1 == 3)
                                        {
                                                if(g_sfc_config_e == sfc_disable)
                                                {
                                                        uprintf("Error: Flow-control Tx is not allowed as Symmetric flow-control is disabled\n");
                                                        return;
                                                }
                                        }
#endif
                    cu_set_port_flow_control_negotiation(port_id, 0);   /* Disable negotiation of flow control */
                        if(sptr_cdb->integer1 ==1 || !sptr_cdb->integer1 )
                        {
                                cu_set_port_flow_control_ti(port_id, 1);        /* Enable flow control rx only*/
                                if((sptr_cdb->mode == CONFIG_IF && !sptr_cdb->integer1) ||
                                        (sptr_cdb->mode == CONFIG_MIF && !sptr_cdb->integer1 && flw_ctl_print))
                                {
                                        uprintf("flow-control is set to honor-only\n");
                                        flw_ctl_print = 0;
                                }
                        }
                        else if(sptr_cdb->integer1==2)
                                cu_set_port_flow_control_ti(port_id, 2);        /* Tx Only*/
                        else if(sptr_cdb->integer1==3)
                                cu_set_port_flow_control_ti(port_id, 3);        /* Tx + Rx */
                        else
                                cu_set_port_flow_control_ti(port_id, 0);
                }

        }
}


void set_port_flow_control(struct cdb *sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT8 flow_enable;

#if __MPORT_SUPPORT__
        if ( IS_MPORT(port_id) )
                return;
#endif // __MPORT_SUPPORT__

#ifdef TURBOIRON
set_port_flow_control_ti(sptr_cdb);
#else
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;

                if (cu_get_port_flow_control(port_id, 1, &flow_enable) != CU_OK)
                        return;
                if (!flow_enable)
                {
                        if (!is_port_stack_enabled(port_id))
                        {
                                wr_config(sptr_cdb," no flow-control\n");
                        }
                }
                else
                {
                        if (IS_PORT_DB_VALID(port_id) && ((SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg))
                        {
                                wr_config(sptr_cdb," flow-control neg-on\n");
                        }
                }
        }
        else
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                sptr_cdb->dont_go_next = 1;


                if (!IS_PORT_DB_VALID(port_id))
                {
                        return;
                }

                if (sptr_cdb->no) {
                        if ((SPTR_PORT_DB(port_id))->port_config.flow_control) {
                                cu_set_port_flow_control_negotiation(port_id, 0);       /* Disable negotiation of flow control */
                                cu_set_port_flow_control(port_id, 0);   /* Disable flow control */
                        }
                }
                else
                {
                        if (is_port_stack_enabled (port_id))
                                return;
                        // Either the flow control has to be configured for the first time, or it is
                        // being modified to remove the autoneg option.
                        if (!(SPTR_PORT_DB(port_id))->port_config.flow_control ||
                            (SPTR_PORT_DB(port_id))->port_config.flow_ctrl_neg) {
                                cu_set_port_flow_control_negotiation(port_id, 0);       /* Disable negotiation of flow control */
                                cu_set_port_flow_control(port_id, 1);   /* Enable flow control */
                        }
                }
        }
#endif TURBOIRON
}


extern void portext_set_debug_level(UINT32 debug_level);


void dm_set_port_ext_debug_level(struct cdb* sptr_cdb)
{
        int rv, i=0;
        
        if (sptr_cdb->config_gen)
        return;
        if (end_of_token(sptr_cdb->token) != '\0')
        return;
        sptr_cdb->dont_go_next = 1;             

#ifdef __PORT_EXTENSION__       
        portext_set_debug_level(sptr_cdb->integer1);  
#endif

}


void set_global_flow_control_tx(struct cdb *sptr_cdb)
{
        sptr_cdb->integer1 = 2;
        set_global_flow_control(sptr_cdb);

}

void set_global_flow_control_rx(struct cdb *sptr_cdb)
{
        sptr_cdb->integer1 = 1;
        set_global_flow_control(sptr_cdb);

}

void set_global_flow_control_txrx(struct cdb *sptr_cdb)
{
        sptr_cdb->integer1 = 3;
        set_global_flow_control(sptr_cdb);

}

void set_global_flow_control_ti(struct cdb *sptr_cdb)
{

        if (!sptr_cdb->config_gen)
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;
                sptr_cdb->dont_go_next = 1;

                if (sptr_cdb->no)
                {
#ifdef SIDEWINDER_LINUX
                                                #ifndef SPATHA
                                                if(is_gi_cut_through_mode_supported_on_this_platform() && is_gi_cut_through_enable_on_hw())
                                                        return; // FC cannot be enabled for MMU cut-through mode, return silently.
                                                #endif

                        if(g_pfc_global_status)
                        {
                           uprintf("Error: Flow-control configuration is not allowed as Global PFC is enabled\n");
                           return;
                        }
/* 
                        if(sptr_cdb->integer1 == 2 || sptr_cdb->integer1 == 3)
                        {
                           if(g_sfc_config_e == sfc_disable)
                           {
                             uprintf("Error: Flow-control configuration not allowed as Symmetric flow-control is disabled\n");
                             return;
                           }
                                                }
*/
#endif
                        if(!sptr_cdb->integer1)
                        {
                                uprintf("Global flow-control honor-only is removed\n");
                        }
                        sw_set_global_flow_control_ti((sptr_cdb->integer1|0x10));
                }
                else
                {
#ifdef SIDEWINDER_LINUX
                                                #ifndef SPATHA
                                                if( is_gi_cut_through_mode_supported_on_this_platform()  && is_gi_cut_through_enable_on_hw())
                                                {
                                                        if(!g_sw_sys.init_in_progress)
                                                                uprintf("ERROR: This CLI operation is not supported in MMU cut-through mode\n");

                                                        return;
                                                }
                                                #endif

                        if(g_pfc_global_status)
                        {
                           uprintf("Error: Flow-control configuration is not allowed as Global PFC is enabled\n");
                           return;
                        }
                        if(sptr_cdb->integer1 == 2 || sptr_cdb->integer1 == 3)
                        {
                           if(g_sfc_config_e == sfc_disable)
                           {
                             uprintf("Error: Flow-control Tx configuration is not allowed as Symmetric flow-control is disabled\n");
                             return;
                           }
                                                }
#endif
                        if(sptr_cdb->integer1 ==1 || !sptr_cdb->integer1)
                        {
                                sw_set_global_flow_control_ti(1);       /* Enable flow control rx only*/
                                if(!sptr_cdb->integer1)
                                {
                                        uprintf("Global flow-control set to honor-only\n");
                                }
                        }
                        else if(sptr_cdb->integer1==2)
                                                {
                                sw_set_global_flow_control_ti(2);       /* Tx Only*/
                                                }
                        else if(sptr_cdb->integer1==3)
                                sw_set_global_flow_control_ti(3);       /* Tx + Rx */
                        else
                                sw_set_global_flow_control_ti(0);
                }

        }

#ifdef SM_MASTER
        if (!g_sw_sys.init_in_progress)
                fmp_set_switch_global_to_all_slaves(FMP_MAX_ENTRIES);
#endif SM_MASTER

}


void set_global_flow_control(struct cdb *sptr_cdb)
{
#ifdef TURBOIRON
set_global_flow_control_ti(sptr_cdb);
#else
        if (sptr_cdb->config_gen)
        {
                if (!sw_get_global_flow_control())
                        wr_config(sptr_cdb,"no flow-control\n");
        }
        else
        {
                if (sptr_cdb->no)
                        sw_set_global_flow_control(0);
                else
                        sw_set_global_flow_control(1);
        }

#ifdef SM_MASTER
        if (!g_sw_sys.init_in_progress)
                fmp_set_switch_global_to_all_slaves(FMP_MAX_ENTRIES);
#endif SM_MASTER
#endif TURBOIRON
}

void dm_func(struct cdb *sptr_cdb)
{
        UINT32 (*func)(UINT32, UINT32, UINT32, UINT32, UINT32), rcode;
        UINT32 instr;
/*
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
*/
        sptr_cdb->dont_go_next = 1;

        instr = *(UINT32 *)sptr_cdb->integer1;
        /* check if the 1st instruction is "stwu", opcode 37 */
        if (((instr >> 26) & 0x3f) != 37)
        {
                kprintf("Instruction(%x) at %x does not appear to be the beginning of a function call\n",
                                        instr, sptr_cdb->integer1);
                kprintf("It could be a leaf function if it is compiled with optimization\n");
        }
        func = (UINT32 (*)(UINT32, UINT32, UINT32, UINT32, UINT32))sptr_cdb->integer1;
        rcode = (*func)(sptr_cdb->integer2, sptr_cdb->integer3,
                                        sptr_cdb->integer4, sptr_cdb->integer5,
                                        sptr_cdb->integer6);
        kprintf("Return code %x\n",rcode);

}

void execute_confirm_callback(UINT32 yes, UINT32 ui_port, UINT32 param3)
{
        struct cdb *sptr_cdb = (struct cdb *)param3;
        sptr_cdb->dont_go_next = 1;
        if(yes)
                dm_func(sptr_cdb);
        kmfree((char *)sptr_cdb, DramHeapID);
        release_confirm_mode();
}

void dm_func1(struct cdb *sptr_cdb)
{
UINT32 sptr_cdb_addr;
struct cdb *sptr_cdb1 = NULL;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        sptr_cdb1 = (struct cdb *)kmalloc(sizeof(struct cdb), DramHeapID);

        if(NULL == sptr_cdb1)
                return;

        memcpy(sptr_cdb1, sptr_cdb, sizeof(struct cdb));
        sptr_cdb_addr = (UINT32) sptr_cdb1;
        uprintf("WARNING:  This CLI operation is for INTERNAL USE only and may cause a System Crash or High CPU usage!!!\nDo you want to continue?  (y/n)");
        set_confirm_mode(execute_confirm_callback,sptr_cdb->ui_port,sptr_cdb_addr);
	dy_free(sptr_cdb1);
}

void dm_lwr(struct cdb *sptr_cdb)
{
        UINT32 data;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        hwSwReadRegister(sptr_cdb->integer1, sptr_cdb->integer2, &data);
        uprintf("0x%x\n", data);
}
void dm_blink(struct cdb *sptr_cdb)
{
        UINT32 data;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        if(sptr_cdb->integer1 == 0)
                uprintf("Hide gig link changes\n");
        else
                uprintf("Show gig link changes\n");
}



#ifdef SR_SWITCH_ROUTER
void dm_display_host_table_chain (struct cdb *sptr_cdb)
{
        gi_display_host_table_chain (sptr_cdb->ip1);
}

void dm_del_entry_from_dev_host_table (struct cdb *sptr_cdb)
{
        UINT16 port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        fpip_delete_ip_address_from_host_table (sptr_cdb->ip1, port);
}

void dm_add_entry_to_dev_host_table (struct cdb *sptr_cdb)
{
        UINT16 port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        fpip_add_ip_address_to_host_table (sptr_cdb->ip1, port);
}

void  dm_display_router_mac_on_device (struct cdb *sptr_cdb)
{
        UINT32 device_id;
        MAC_ADDRESS mac_addr;
        UINT32 vlan_id;

        device_id = sptr_cdb->integer1;
        String2MAC((UINT8 *) (&mac_addr), sptr_cdb->string1);
        vlan_id = sptr_cdb->integer2;

}
#endif SR_SWITCH_ROUTER

void dm_arm_perf_monitor (struct cdb *sptr_cdb)
{
        UINT32 delay;

        delay = sptr_cdb->integer1;
        perfLogArm (delay);
}

void dm_trigger_perf_monitor (struct cdb *sptr_cdb)
{
        UINT32 delay;

        delay = sptr_cdb->integer1;
        perfLogTrig (delay);
}

void dm_print_perf_log_range (struct cdb *sptr_cdb)
{
        int start_index;
        int range;

        start_index = sptr_cdb->integer1;
        range = sptr_cdb->integer2;
        if ((start_index < 0) || (start_index > 4095))
        {
                uprintf ("Start Index should be between 0 and 4095\n");
                return;
        }

        if ((range <= 0) || (range > 500))
        {
                uprintf ("Range should be between 1 and 500\n");
                return;
        }
        printPerfLog (start_index, range);
}


#ifndef ANA
void dm_swana(struct cdb *sptr_cdb)
{
        PORT_ID port;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        if (SPTR_PORT_DB(port)->port_oper_info.sw_ana_forced)
                uprintf("Port %p forced SW ANA on,",port);
        else
                uprintf("Port %p forced SW ANA off,",port);
        uprintf(" try_cnt=%d, ok_cnt=%d\n",
                SPTR_PORT_DB(port)->port_oper_info.sw_ana_try_cnt,
                SPTR_PORT_DB(port)->port_oper_info.sw_ana_ok_cnt);
}
void dm_swana_clear(struct cdb *sptr_cdb)
{
        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        SPTR_PORT_DB(port)->port_oper_info.sw_ana_try_cnt = 0;
        SPTR_PORT_DB(port)->port_oper_info.sw_ana_ok_cnt = 0;
}
void dm_swana_on(struct cdb *sptr_cdb)
{
        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        SPTR_PORT_DB(port)->port_oper_info.sw_ana_forced = 1;
}
void dm_swana_off(struct cdb *sptr_cdb)
{
        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        SPTR_PORT_DB(port)->port_oper_info.sw_ana_forced = 0;
}
#endif ANA

void dm_show_uft_help(void)
{
        uprintf("\n TOR commands to debug UFT in Spatha \n");
        uprintf("1. tor getreg TABLE1_BANK_CONFIG:  To get bank configuration for L2_ENTRY table \n");
        uprintf("2. tor dump TABLE1_LOG_TO_PHY_MAPPING:  To dump logical to physical mapping for L2_ENTRY table \n");
        uprintf("3. tor getreg STAGE[0-3]_BANK_SIZE:  To get bank sizes assigned to L2_ENTRY_TABLE, select stage from 0 to 3 based on TABLE1_BANK_CONFIG output \n");
        uprintf("4. tor getreg STAGE[0-3]_HASH_OFFSET:  To get hash config for all L2_ENTRY_TABLE configured banks\n");
        return;
}

void dm_l3_vlan_members(struct cdb* sptr_cdb)
{
        UINT8   i;
        L3_VLAN_ENTRY *l3_vlan_ptr;
        VLAN_ENTRY *vlan_ptr;
        VLAN_INDEX vlan_idx;
        char intfstring[64];

    // this command is also used to display port blocking state
    if (end_of_token(sptr_cdb->token) != '\0')
                return;

        vlan_idx = VLAN_IDX_FROM_VLAN_ID(sptr_cdb->integer1);
        if (vlan_idx == VLAN_INDEX_INVALID)
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        vlan_ptr = g_sptr_vlan_db+vlan_idx;
        for (i = 0 ; i < MAX_PROTO_VLANS; i++) {

                if ( sw_is_l3_vlan_member(vlan_ptr, i)) {

                        l3_vlan_ptr = sw_l3_index_to_l3_vlan_ptr(vlan_ptr,i);
                        if (!l3_vlan_ptr)
                                continue;

                        cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.static_mask,cu_line_buf,sizeof(cu_line_buf));
                        debug_uprintf("Static members : %s\n",cu_line_buf);
                        cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.dynamic_mask,cu_line_buf,sizeof(cu_line_buf));
                        debug_uprintf("Dynamic(by config) members : %s\n",cu_line_buf);
                        cu_mask2portList(l3_vlan_ptr->auto_dynamic_ports,cu_line_buf,sizeof(cu_line_buf));
                        debug_uprintf("Dynamic(by detection) members : %s\n",cu_line_buf);
                        cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.exclude_mask,cu_line_buf,sizeof(cu_line_buf));
                        debug_uprintf("Excluded members : %s\n",cu_line_buf);
                }
        }

        l3_vlan_ptr = vlan_ptr->ip_subnet_vlan_ptr;
        while(l3_vlan_ptr) {
                debug_uprintf("IP-subnet vlan %x:\n",l3_vlan_ptr->l3_vlan_id.ip_subnet.subnet_id ,
                                l3_vlan_ptr->l3_vlan_id.ip_subnet.subnet_mask);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.static_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Static mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->active_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Active mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->auto_dynamic_ports,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Real Dynamic mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.dynamic_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Dynamic mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.exclude_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Excluded mask : %s\n",cu_line_buf);

                if (l3_vlan_ptr->next != INVALID_L3_VLAN_LIST_INDEX)
                        l3_vlan_ptr = g_sw_sys.ip_subnet_vlan_ptr+l3_vlan_ptr->next;
                else
                        l3_vlan_ptr = (L3_VLAN_ENTRY *)NULL;
        }
        l3_vlan_ptr = vlan_ptr->ipx_network_vlan_ptr;
        while(l3_vlan_ptr) {

                debug_uprintf("\nIPX-network vlan :\n");
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.static_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Static mask: %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->active_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Active mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->auto_dynamic_ports,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" real Dynamic mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.dynamic_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Candidate  mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.exclude_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Excluded mask : %s\n",cu_line_buf);

                if (l3_vlan_ptr->next != INVALID_L3_VLAN_LIST_INDEX)
                        l3_vlan_ptr = g_sw_sys.ipx_network_vlan_ptr+l3_vlan_ptr->next;
                else
                        l3_vlan_ptr = (L3_VLAN_ENTRY *)NULL;
        }
#ifdef APPLETALK_CABLE_VLAN
        l3_vlan_ptr = vlan_ptr->appletalk_subnet_vlan_ptr;
        while(l3_vlan_ptr) {

                debug_uprintf("\nAPPLETALK_subnet vlan:\n");
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.static_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Static mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->active_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Active mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->auto_dynamic_ports,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Real Dynamic mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.dynamic_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Dynamic mask : %s\n",cu_line_buf);
                cu_mask2portList(l3_vlan_ptr->l3_vlan_masks.exclude_mask,cu_line_buf,sizeof(cu_line_buf));
                debug_uprintf(" Excluded mask : %s\n",cu_line_buf);

                if (l3_vlan_ptr->next != INVALID_L3_VLAN_LIST_INDEX)
                        l3_vlan_ptr = g_sw_sys.appletalk_subnet_vlan_ptr+l3_vlan_ptr->next;
                else
                        l3_vlan_ptr = (L3_VLAN_ENTRY *)NULL;
        }
#endif

}


void dm_skip_check()
{
        if (skip_copy_check)
        {
                skip_copy_check = 0;
                uprintf("Skip_copy_check will be OFF (default) from now on\n");
        } else
        {
                skip_copy_check = 1;
                uprintf("Skip_copy_check will be ON from now on\n");
        }
}

void dm_uart()
{
        uart_eio(0,0x22,5);
}

void dm_get_hs_mask(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0') {
                sptr_cdb->dont_go_next = 1;
                uprintf("Current dm_hs_mask = %x\n", dm_hs_mask);
                uprintf("Current dm_hs_delay = %d\n", dm_hs_delay);
        }
}
void dm_set_hs_mask(struct cdb *sptr_cdb)
{
        dm_hs_mask = sptr_cdb->integer1;
        uprintf("dm_fs_mask = %x\n", dm_hs_mask);
}
void dm_set_hs_delay(struct cdb *sptr_cdb)
{
        dm_hs_delay = sptr_cdb->integer1;
        uprintf("dm_fs_delay = %d\n", dm_hs_delay);
}

void dm_get_debug(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0') {
                sptr_cdb->dont_go_next = 1;
                uprintf("Current dm_debug_mask = %x\n", dm_debug_mask);
                uprintf("0x0000 : reset the flag\n");
#ifndef NO_OPTICAL_MONITOR
                uprintf("0x0001 : optical monitor for QA\n");
#endif NO_OPTICAL_MONITOR
                uprintf("0x0002 : module hot swap\n");
		uprintf("0x0080 : SupportSave\n");
        }
}

static void
dmDumpScpCtlrMsg(char *msg)
{
  char                *funcStr = "pdsineDumpScpCtlrMsg";

  debug_uprintf("\n\nSCP Controller Message Dump:\n");
  debug_uprintf("KEY\t=\t0x%2x\n", msg[0]);
  debug_uprintf("ECHO\t=\t0x%2x\n", msg[1]);

    debug_uprintf("DATA0-3\t=\t0x%2x 0x%2x 0x%2x 0x%2x\n", msg[2], msg[3], msg[4], msg[5]);
    debug_uprintf("DATA4-7\t=\t0x%2x 0x%2x 0x%2x 0x%2x\n", msg[6],msg[7],msg[8],msg[9]);
    debug_uprintf("DATA8-10=\t0x%2x 0x%2x 0x%2x\n", msg[10],msg[11],msg[12]);
    debug_uprintf("CSUM\t=\t0x%4x\n\n", *((unsigned short *)(msg+12)));

}


void dm_set_poe_auto_recovery(struct cdb *sptr_cdb)
{

        char msg[15], recv_msg[15];
        int index;

        uprintf("Sending auto-recovery enable command to PoE\n");

                  msg[0]        = 0x00;
                  msg[1]        = 0x50;
                  msg[2]        = 0x07;
                  msg[3]        = 0x56;
                  msg[4]        = 0x1B;
                  msg[5]        = 0x01;
                  msg[6]        = 0x4E;
                  msg[7]        = 0x4E;
                  msg[8]        = 0x4E;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x02;
                          msg[14] = 0xEB;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(100);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);


        if(recv_msg[0] == 0x52 && recv_msg[1] == 0x50 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
        {
                uprintf("\n Auto-recovery Mask set successful\n");
        }
        else
        {
                uprintf("\n Auto-recovery Mask set Failed\n");
                dmDumpScpCtlrMsg(recv_msg);
        }

}


void dm_get_poe_auto_recovery(struct cdb *sptr_cdb)
{

        char msg[15], recv_msg[15];
        int index;

        uprintf("Reading auto-recovery Status\n");

                  msg[0]        = 0x02;
                  msg[1]        = 0x60;
                  msg[2]        = 0x07;
                  msg[3]        = 0x56;
                  msg[4]        = 0x1B;
                  msg[5]        = 0x4E;
                  msg[6]        = 0x4E;
                  msg[7]        = 0x4E;
                  msg[8]        = 0x4E;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x03;
                          msg[14] = 0x4A;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(100);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

        if(recv_msg[0] == 0x3 && recv_msg[1] == 0x60)
                {
                        if (recv_msg[2] == 0x1)
                                uprintf("\n Auto-recovery Mask is Set \n");
                        else uprintf("\n Auto-recovery Mask is Not Set \n");
                }
                else uprintf("\n Read failure \n");



}

void dm_get_poe_ac_mask(struct cdb *sptr_cdb)
{

        char msg[15], recv_msg[15];
        int index;

        uprintf("\nReading AC_Disconnect mask\n");

                  msg[0]        = 0x02;
                  msg[1]        = 0x70;
                  msg[2]        = 0x07;
                  msg[3]        = 0x56;
                  msg[4]        = 0x9;
                  msg[5]        = 0x4E;
                  msg[6]        = 0x4E;
                  msg[7]        = 0x4E;
                  msg[8]        = 0x4E;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x03;
                          msg[14] = 0x48;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(100);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

        if(recv_msg[0] == 0x3 && recv_msg[1] == 0x70)
        {
                if (recv_msg[2] == 0x1)
                        uprintf("\n AC-Disconnect Mask is Set \n");
                else uprintf("\n AC-Disconnect Mask is Not Set (DC-Disconnect) \n");
        }
        else uprintf("\n Read failure \n");


}

void dm_set_poe_ac_mask(struct cdb *sptr_cdb)
{

        char msg[15], recv_msg[15];
        int index;

        uprintf("Reading AC_Disconnect mask\n");

                  msg[0]        = 0x00;
                  msg[1]        = 0x80;
                  msg[2]        = 0x07;
                  msg[3]        = 0x56;
                  msg[4]        = 0x9;
                  msg[5]        = 0x1;
                  msg[6]        = 0x4E;
                  msg[7]        = 0x4E;
                  msg[8]        = 0x4E;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x03;
                          msg[14] = 0x09;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(200);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

        if(recv_msg[0] == 0x52 && recv_msg[1] == 0x80 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
        {
                uprintf("\n AC-Disconnect Mask set successful\n");
        }
        else
        {
                uprintf("\n AC-Disconnect Mask set Fail\n");
                dmDumpScpCtlrMsg(recv_msg);
        }

}


void dm_set_poe_save_config(struct cdb *sptr_cdb)
{

        char msg[15], recv_msg[15];
        int index;

        uprintf("Sending save config command to PoE\n");


  msg[0]        = 0x01;
  msg[1]        = 0x10;
  msg[2]        = 0x06;
  msg[3]        = 0x0F;
  msg[4]        = 0x4E;
  msg[5]        = 0x4E;
  msg[6]        = 0x4E;
  msg[7]        = 0x4E;
  msg[8]        = 0x4E;
  msg[9]        = 0x4E;
  msg[10]       = 0x4E;
  msg[11]       = 0x4E;
  msg[12]       = 0x4E;
  msg[13] = 0x02;
  msg[14] = 0xE4;

  sys_send_i2c_command(1,0x14,0,0,&msg[0],15,0x0); // writing
  delay_ms(200);
  sys_send_i2c_command(1,0x14,0,0,&recv_msg[0],15,0x1); // reading

  if(recv_msg[0] == 0x52 && recv_msg[1] == 0x10 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
        {
                uprintf("\n Save config successful\n");
        }
        else
        {
                uprintf("\n Save config Failed\n");
                dmDumpScpCtlrMsg(recv_msg);
        }


}

// Combinig dm commands starts here ************************************
void dm_poe_i2c_lock(struct cdb *sptr_cdb)
{
        char msg[15], recv_msg[15];
        int index;

/* Set to factory defaults */
                          msg[0]        = 0x00;
                          msg[1]        = 0x01;
                          msg[2]        = 0x2D;
                          msg[3]        = 0x4E;
                          msg[4]        = 0x4E;
                          msg[5]        = 0x4E;
                          msg[6]        = 0x4E;
                          msg[7]        = 0x4E;
                          msg[8]        = 0x4E;
                          msg[9]        = 0x4E;
                          msg[10]       = 0x4E;
                          msg[11]       = 0x4E;
                          msg[12]       = 0x4E;
                                  msg[13] = 0x03;
                                  msg[14] = 0x3A;

                                  sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                                  delay_ms(100);
                                  sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

                                  if(recv_msg[0] == 0x52 && recv_msg[1] == 0x01 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
                                  {
                                          uprintf("\n Factory Defaults set successful\n");
                                  }
                                  else
                                  {
                                        uprintf("\n Factory Defaults set Failed\n");
                                        dmDumpScpCtlrMsg(recv_msg);
                                        uprintf("\n Reading I2C bus again\n");
                                        sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);
                                        dmDumpScpCtlrMsg(recv_msg);
                                  }

        dm_set_poe_auto_recovery(sptr_cdb);


/* Brocade Defaults */
                  msg[0]        = 0x00;
                  msg[1]        = 0x05;
                  msg[2]        = 0x05;
                  msg[3]        = 0x4A;
                  msg[4]        = 0x80;
                  msg[5]        = 0x00;
                  msg[6]        = 0x3C;
                  msg[7]        = 0x30;
                  msg[8]        = 0x03;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x02;
                          msg[14] = 0x7B;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(200);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

          if(recv_msg[0] == 0x52 && recv_msg[1] == 0x05 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
          {
                  uprintf("\n Brocade Defaults set successful\n");
          }
          else
          {
                uprintf("\n Brocade Defaults set Failed\n");
                dmDumpScpCtlrMsg(recv_msg);
                uprintf("\n Reading I2C bus again\n");
                sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);
                dmDumpScpCtlrMsg(recv_msg);
          }


/* set PM Defaults */
                  msg[0]        = 0x00;
                  msg[1]        = 0x06;
                  msg[2]        = 0x07;
                  msg[3]        = 0x0B;
                  msg[4]        = 0x5F;
                  msg[5]        = 0x00;
                  msg[6]        = 0x00;
                  msg[7]        = 0x00;
                  msg[8]        = 0x4E;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x01;
                          msg[14] = 0xFD;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(100);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

          if(recv_msg[0] == 0x52 && recv_msg[1] == 0x06 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
          {
                  uprintf("\n PM Defaults set successful\n");
          }
          else
          {
                uprintf("\n Brocade Defaults set Failed\n");
                dmDumpScpCtlrMsg(recv_msg);
                uprintf("\n Reading I2C bus again\n");
                sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);
                dmDumpScpCtlrMsg(recv_msg);
          }
          /* set User Byte  */
                                msg[0]    = 0x01;
                                msg[1]    = 0x07;
                                msg[2]    = 0x41;
                                msg[3]    = 0xF0;
                                msg[4]    = 0x4E;
                                msg[5]    = 0x4E;
                                msg[6]    = 0x4E;
                                msg[7]    = 0x4E;
                                msg[8]    = 0x4E;
                                msg[9]    = 0x4E;
                                msg[10]   = 0x4E;
                                msg[11]   = 0x4E;
                                msg[12]   = 0x4E;
                                        msg[13] = 0x03;
                                        msg[14] = 0xF7;

                                        sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                                        delay_ms(100);
                                        sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

                        if(recv_msg[0] == 0x52 && recv_msg[1] == 0x07 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
                        {
                                uprintf("\n User byte set successful\n");
                        }
                        else
                        {
                                uprintf("\n User byte set Failed\n");
                                dmDumpScpCtlrMsg(recv_msg);
                                uprintf("\n Reading I2C bus again\n");
                                sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);
                                dmDumpScpCtlrMsg(recv_msg);
                        }

        uprintf("Sending save config command to PoE\n");

        msg[0]    = 0x01;
        msg[1]    = 0x10;
        msg[2]    = 0x06;
        msg[3]    = 0x0F;
        msg[4]    = 0x4E;
        msg[5]    = 0x4E;
        msg[6]    = 0x4E;
        msg[7]    = 0x4E;
        msg[8]    = 0x4E;
        msg[9]    = 0x4E;
        msg[10]   = 0x4E;
        msg[11]   = 0x4E;
        msg[12]   = 0x4E;
        msg[13] = 0x02;
        msg[14] = 0xE4;

        sys_send_i2c_command(1,0x14,0,0,&msg[0],15,0x0); // writing
        delay_ms(20);
        sys_send_i2c_command(1,0x14,0,0,&recv_msg[0],15,0x1); // reading

        if(recv_msg[0] == 0x52 && recv_msg[1] == 0x10 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
          {
                  uprintf("\n Save config successful\n");
          }
          else
          {
                uprintf("\n Save config Failed\n");
                dmDumpScpCtlrMsg(recv_msg);
          }


        dm_get_poe_sw_version(sptr_cdb);

/* Set Interrupt Mask 00 01 07 99 55 127 78 78 78 78 78 78 78 03 69 */
        msg[0]    = 0x00;
                msg[1]    = 0x11;
                msg[2]    = 0x07;
                msg[3]    = 0x63;
                msg[4]    = 0x37;
                msg[5]    = 0x7F;
                msg[6]    = 0x4E;
                msg[7]    = 0x4E;
                msg[8]    = 0x4E;
                msg[9]    = 0x4E;
                msg[10]   = 0x4E;
                msg[11]   = 0x4E;
                msg[12]   = 0x4E;
                        msg[13] = 0x03;
                        msg[14] = 0x53;

                        sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                        delay_ms(100);
                        sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);

        if(recv_msg[0] == 0x52 && recv_msg[1] == 0x07 && recv_msg[2] == 0x0 && recv_msg[3] == 0x0 )
        {
                uprintf("\n interrupt mask set successful\n");
        }
        else
        {
                uprintf("\n interrupt mask set Failed\n");
                dmDumpScpCtlrMsg(recv_msg);
                uprintf("\n Reading I2C bus again\n");
                sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);
                dmDumpScpCtlrMsg(recv_msg);
        }


}
struct poe_sw_version
{
        unsigned char telemetry;
        unsigned char echo;
        unsigned char hw_version;
        unsigned char resv1;
        unsigned char prod;
        unsigned short sw_version;
        unsigned char param;
        unsigned char build_num;
        unsigned short internal_sw;
        unsigned short resv2;
        unsigned short checksum;
};
struct poe_sw_version poe_ver;
void dm_get_poe_sw_version(struct cdb *sptr_cdb)
{

        char msg[15], recv_msg[15];

        int index;

        uprintf("Reading Software version\n");

                  msg[0]        = 0x02;
                  msg[1]        = 0xA0;
                  msg[2]        = 0x07;
                  msg[3]        = 0x1E;
                  msg[4]        = 0x21;
                  msg[5]        = 0x4E;
                  msg[6]        = 0x4E;
                  msg[7]        = 0x4E;
                  msg[8]        = 0x4E;
                  msg[9]        = 0x4E;
                  msg[10]       = 0x4E;
                  msg[11]       = 0x4E;
                  msg[12]       = 0x4E;
                          msg[13] = 0x03;
                          msg[14] = 0x58;

                          sys_send_i2c_command(1,0x14,0,0,msg,15,0x0);
                          delay_ms(100);
                          sys_send_i2c_command(1,0x14,0,0,recv_msg,15,0x1);


        if(recv_msg[0] == 0x03 && recv_msg[1] == 0xA0)
                {
                        memcpy(&poe_ver, recv_msg, 15);

                        uprintf("\n Hardware version    :%x\n", poe_ver.hw_version);
                        uprintf("\n Prod                                : %x\n", poe_ver.prod);
                        uprintf("\n Software version    : %d\n", poe_ver.sw_version);
                        uprintf("\n Param                               : %x\n", poe_ver.param);
                }
        else
        {
                uprintf("\n Read failure \n");
                dmDumpScpCtlrMsg(recv_msg);
        }
}

#ifndef NEW_INT

UINT32 g_int_auq_rx_link = FALSE;
UINT32 g_int_other_mm_enable = FALSE;
    UINT32 g_auq_interrupt_enable = FALSE;
    UINT32 g_rx_interrupt_enable = FALSE;
void dm_int_auq_rx_link_enable(struct cdb *sptr_cdb)
{

  UINT32 old_data, data;
  UINT32 slot,i;
  int ppDev;

  if(g_int_auq_rx_link == FALSE)
  {
    g_int_auq_rx_link = TRUE;
    uprintf("\n Interrupt method for AUQ, and RX is enabled \n");
  }

  else if (g_int_auq_rx_link == TRUE)
  {
        uprintf("\n Interrupt method for AUQ, and RX is already enabled\n");
  }
}
void dm_int_auq_rx_link_disable(struct cdb *sptr_cdb)
{
    UINT32 old_data, data;
    UINT32 slot,i;
    int ppDev;

  if(g_int_auq_rx_link == FALSE)
  {
        uprintf("\n Interrupt method for AUQ, and RX is already disabled \n");
  }
  else if (g_int_auq_rx_link == TRUE)
  {
    g_int_auq_rx_link = FALSE;
    uprintf("\n Interrupt method for AUQ, and RX is disabled\n");
  }
}

extern UINT32 IntmInterruptCountMajor[];
extern UINT32 IntmVecEnableMap;



void dm_int_auq_rx_link_show(struct cdb *sptr_cdb)
{
    UINT32 device = 0, intVec = 0;
 // if (g_int_auq_rx_link == TRUE)
  {
    for (intVec = 0; intVec < 32; intVec++) {
        if (IntmVecEnableMap & INTM_BITMAP(intVec)) {
        uprintf("Major interrupts[%d]: %d\n", intVec,IntmInterruptCountMajor[intVec]);
       // uprintf("AUQ   interrupts: %d\n", IntmInterruptCountAuq[intVec]);
       // uprintf("RX    interrupts: %d\n", IntmInterruptCountRx[intVec]);
       }
    }
  }
}


void dm_int_other_mm_enable (void)
{
        g_int_other_mm_enable = TRUE;
}
void dm_int_other_mm_disable (void)
{
        g_int_other_mm_enable = FALSE;
}
#endif NEW_INT


void dm_set_debug(struct cdb *sptr_cdb)
{
#ifndef NO_OPTICAL_MONITOR
        if(sptr_cdb->integer1 == DM_OPTICAL_MONITOR_QA) {
                dm_debug_mask = sptr_cdb->integer1;
                uprintf("dm_debug_mask = %x\n", dm_debug_mask);
                return;
        }
        else
#endif NO_OPTICAL_MONITOR
        dm_debug_mask = sptr_cdb->integer1;
        uprintf("dm_debug_mask = %x\n", dm_debug_mask);
}

/* "dm stack" to dump crash stack contents */
void dm_stack(struct cdb *sptr_cdb)
{
        halt_area_t     *sptr_halt;
        if (end_of_token(sptr_cdb->token) == '\0') {
                sptr_cdb->dont_go_next = 1;
#ifdef NO_FDRY_HW
#else
                sptr_halt = (halt_area_t *)(DRAM_REG +
                                                        *(UINT32 *)SYSIF_SSR2_R - TRAP_SAVE_SIZE);
#endif
        }
}

extern int dm_is_stack_size_slot_cpu;

#ifndef NO_NEW_TRAP_SAVE
/* "dm stack size" to dump crash stack contents */
void dm_stack_num(struct cdb *sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->integer1 > 4 || sptr_cdb->integer1 == 0)
        {
                uprintf("Stack save area number should be between 1 and 4\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
}
#endif NO_NEW_TRAP_SAVE

/* "dm stack size" to dump crash stack contents */
void dm_stack_size(struct cdb *sptr_cdb)
{
        halt_area_t *sptr_halt;

        if (sptr_cdb->config_gen)
                return;

}

void dump_cam_dma(struct cdb *sptr_cdb)
{
}

void dump_cam_1(struct cdb *sptr_cdb)
{

        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
}

void dump_cam(struct cdb *sptr_cdb)
{
        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

    if(port > (g_hw_info.max_port -1))
        {
                uprintf("Port number is invalid.\n");
                return;
        }

        if(!IS_PORT_DB_VALID(port))
        {
                uprintf("Port number is invalid.\n");
                return;
        }
}

void dump_cam_detail_1(struct cdb *sptr_cdb)
{

        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

    if(port > (g_hw_info.max_port -1))
        {
                uprintf("Port number is invalid.\n");
                return;
        }

        if(!IS_PORT_DB_VALID(port))
        {
                uprintf("Port number is invalid.\n");
                return;
        }
}

void dump_cam_detail(struct cdb *sptr_cdb)
{
        PORT_ID port;

        port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

    if (PORT_TO_MODULE_PORT(port) > (g_hw_info.max_installed_port -1))
        {
                uprintf("Port number is invalid.\n");

        return;
        }

        if(!IS_PORT_DB_VALID(port))
        {
                uprintf("Port number is invalid.\n");
                return;
        }
}

static char find_prt_buf[128];
static char *tbp;
void search_pattern(UINT8 *addr, int size, UINT32 pattern, int nbytes)
{
        int i;
        UINT8 *addr_end;
        int found;
        UINT8 p[4];
        int count = 0;

        *(UINT32 *)p = pattern << ((4-nbytes)*8);
        addr_end = addr + size -4;
        for (; addr < addr_end; addr++)
        {
                found = 1;
                for (i=0; i<nbytes; i++)
                {
                        if (p[i] != *(addr+i))
                        {
                                found = 0;
                                break;
                        }
                }

                if (found)
                {
                        /* cut down on uprintf usage so that telnet "dm save" will not run out of buffer */
                        if (count == 0)
                        {
                                tbp = &find_prt_buf[0];
                        }
                        ksprintf(tbp,"%x\n",addr);
                        tbp += 9;
                        count++;
                        if (count == 12)
                        {
                                count = 0;
                                *tbp = 0;
                                uprintf("%s",find_prt_buf);
                        }
                }

        }
        if (count)
        {
                *tbp = 0;
                uprintf("%s\n",find_prt_buf);
        }
}

void find_pattern(struct cdb *sptr_cdb)
{
        UINT32 i;
        int saved_wd;

        if (sptr_cdb->integer2 > 4)
        {
                uprintf("WARN: data pattern can be at most 4 bytes\n");
        }
        KICK_WATCHDOG;
        saved_wd = g_ignore_watchdog;
        g_ignore_watchdog = 1;

        if (g_hw_info.sram_size)
                search_pattern((UINT8 *)SRAM_REG, g_hw_info.sram_size, sptr_cdb->integer1,
                                                        sptr_cdb->integer2);
        search_pattern((UINT8 *)DRAM_REG, g_hw_info.dram_size, sptr_cdb->integer1,
                                                        sptr_cdb->integer2);
        g_ignore_watchdog = saved_wd;
}

int gbic_sign = 0;
void write_phy(struct cdb *sptr_cdb)
{
        if (gbic_sign == 1) { // use gbic copper phy, need to 'phy gbic port# reg' first before use write_phy for gbic
                pp_link_fiber_gbic_copper_phy_write((PORT_ID)sptr_cdb->if1-1, (UINT8)sptr_cdb->integer1, (UINT16)sptr_cdb->integer2);
                gbic_sign = 0;
        } else {
                sw_modify_phy((PORT_ID)sptr_cdb->if1, (UINT8)sptr_cdb->integer1, (UINT16)sptr_cdb->integer2);
        }
}

void phy_select_tranceiver(struct cdb *sptr_cdb)
{
}

#if 0 
void dump_phy(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0') {
                        return; /* cmd not for me */
        }
        else {
                sptr_cdb->dont_go_next = 1;
                        rd_phy((PORT_ID)INTERFACE_PORT(sptr_cdb->if1));
                        //rd_phy((PORT_ID)INTERFACE_TO_PORT_ID(sptr_cdb->if1));
        }
}
#endif 


void dump_phy_10g(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')  {
                sptr_cdb->dont_go_next = 1;
                pp_phy_clause45_display(sptr_cdb->if1-1, (UINT8)sptr_cdb->integer1 );
        }
}

#if 0 
void dump_phy_10g_reg(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) == '\0')  {
                sptr_cdb->dont_go_next = 1;
                pp_phy_clause45_reg_display(sptr_cdb->if1-1, (UINT8)sptr_cdb->integer1, (UINT16)sptr_cdb->integer2);
        }
}
#endif 

void write_phy_10g(struct cdb *sptr_cdb)
{
        pp_phy_clause45_write((PORT_ID)sptr_cdb->if1-1, (UINT8)sptr_cdb->integer1, (UINT16)sptr_cdb->integer2, (UINT16)sptr_cdb->integer3);
}

void phy_diag(struct cdb* sptr_cdb)
{
        UINT32 code, param = 0;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        code = sptr_cdb->integer1;
        param = sptr_cdb->integer2;

        pp_phy_diag_impl(code, param );

}

void phy_diag_port(struct cdb* sptr_cdb)
{
        UINT32 code, param = 0;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        code = sptr_cdb->integer1;
        param = INTERFACE_TO_PORT_ID(sptr_cdb->if1);

        pp_phy_diag_impl(code, param+1 );

}

void phy_vct_tdr(struct cdb *sptr_cdb)
{
	PORT_ID port = (PORT_ID)sptr_cdb->if1-1;
	int stackId = PORT_TO_STACK_ID(port);

        if(!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
		return;

	if (LINK_OK != validate_tdr_performable(port))
		return;

	if(stackId != MY_BOOTUP_STACK_ID)
		pp_link_stack_tdr_perform(port);
	else
		pp_link_tdr_perform(port);
}

void clear_vct_tdr(struct cdb *sptr_cdb)
{
#ifdef SIDEWINDER_LINUX
        if(!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                return;

        pp_link_tdr_clear((PORT_ID)sptr_cdb->if1-1);
#else
        pp_link_tdr_clear((PORT_ID)sptr_cdb->if1-1);
#endif
}

void show_vct_tdr(struct cdb* sptr_cdb)
{
        if (IS_FI_BCM())
        {
                if(!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                        return;

                pp_link_tdr_display_unit((PORT_ID)sptr_cdb->if1-1);
        }
        else
        {
        pp_link_tdr_display( (PORT_ID)sptr_cdb->if1-1 );
        }
}

void dump_phy_gbic(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0') {
                        return; /* cmd not for me */
        }
        else {
                sptr_cdb->dont_go_next = 1;
                pp_link_fiber_gbic_copper_phy(sptr_cdb->if1-1);
        }
}

void phy_gbic_set(struct cdb *sptr_cdb)
{
#ifdef SIDEWINDER_LINUX
        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */
        else {
                gbic_sign = 1; // to allow to write to gbic register in gig copper
                sptr_cdb->dont_go_next = 1;
                hal_fiber_gbic_copper_phy_reg_display(sptr_cdb->if1-1,sptr_cdb->integer1);
        }
#else
          sptr_cdb->flag1 = 1; // gbic set
#endif SIDEWINDER_LINUX
}




#ifdef X10G
void write_phy_x10g(struct cdb *sptr_cdb)
{
        if (sptr_cdb->integer1 > 2)
        {
                uprintf("Bad phy addr\n");
                return;
        }
        if (sptr_cdb->integer2 > 0xF)
        {
                uprintf("Bad block number\n");
                return;
        }

        /* port id, phy addr, block number, register number and value */
        sw_modify_phy_x10g((PORT_ID)sptr_cdb->if1, sptr_cdb->integer1, sptr_cdb->integer2,
                (UINT8)sptr_cdb->integer3, (UINT16)sptr_cdb->integer4);
}

void dump_phy_x10g_block(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                return;
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                if (sptr_cdb->integer1 > 2)
                {
                        uprintf("Bad phy addr\n");
                        return;
                }
                if (sptr_cdb->integer2 > 0xF)
                {
                        uprintf("Bad block number\n");
                        return;
                }

                /* port id, phy addr, block */
                rd_phy_x10g_blk(sptr_cdb->if1, sptr_cdb->integer1, sptr_cdb->integer2);
        }
}

void dump_phy_x10g(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                return;
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                if (sptr_cdb->integer1 > 2)
                {
                        uprintf("Bad phy addr\n");
                        return;
                }
                /* port id, phy addr */
                rd_phy_x10g(sptr_cdb->if1, sptr_cdb->integer1);
        }
}

#endif

extern int read_tempsensor_reg (int command, int bits);
extern void set_tempsensor_reg (int command, int new_regvalue, int bits);
extern void set_temp_threshold(int high, int value);
extern int get_temp_threshold(int high);

void tmpt_read(int regnum)
{
        int status;
        unsigned short value;
        status = read_temp_sensor_reg(regnum, &value);
        if (status >= 0)
                uprintf("0x%x\n", value);
        return;
}

void tmpt_write(int regnum, int new_regvalue)
{
        int status;
        status = write_temp_sensor_reg(regnum, (unsigned short)new_regvalue);
        if (status >= 0)
                uprintf("0x%x\n", new_regvalue);
        return;
}

void read_tmpt_reg(struct cdb *sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                        return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;
        tmpt_read(sptr_cdb->integer1);
}

void write_tmpt_reg(struct cdb *sptr_cdb)
{
        tmpt_write(sptr_cdb->integer1, sptr_cdb->integer2);
}

int tmpt_threshold_enable[MAX_STACKING_NUM+1]={FALSE,};

void cu_fan_speed_threshold_change(int stackId, int value)
{

	if (stackId != MY_BOOTUP_STACK_ID) {
		chassisFanSpeedThresholdChangeStack(stackId, value);
		return;
	}
}

void cu_fan_speed_threshold_disable (int stackId)
{
	if (tmpt_threshold_enable[stackId] == FALSE )
		return;

	tmpt_threshold_enable[stackId] = FALSE;
	cu_fan_speed_threshold_change(stackId, 0);
}
void cu_fan_speed_threshold_enable (int stackId)
{
    if (tmpt_threshold_enable[stackId] == TRUE )
        return;

	tmpt_threshold_enable[stackId] = TRUE;
	cu_fan_speed_threshold_change(stackId, 1);
}
void cli_set_fan_speed_threshold_stack(struct cdb *sptr_cdb)
{
	UINT8 stackId;
	int chassis_ptr_changed = 0;
	int curr_status_ptr_changed = 0;
	int curr_hw_data_ptr_changed = 0;

	if (!is_stacking_prom_installed())
	{
 		// this is for standalone case (no stacking EEPORM)    /*bug107322*/
 		sptr_cdb->stack_id = DEFAULT_STANDALONE_STACK_ID;
 	}

	stackId = 	sptr_cdb->stack_id;

	if (!sptr_cdb->config_gen) {	
				/* Don't process the next token. */
			sptr_cdb->dont_go_next = 1;
	
		if (!(MODULE_EXIST(STACK_TO_MODULE_ID(stackId)) || MODULE_IS_CONFIGURED(STACK_TO_MODULE_ID(stackId)))){
			uprintf("No unit %d exist and configged\n", stackId);
			return;
		}
	}

		if (sptr_cdb->config_gen) {
	
			/* Don't process the next token. */
			sptr_cdb->dont_go_next = 1;

            if (tmpt_threshold_enable[stackId] == TRUE){
			  ksprintf(cu_line_buf, "  fan-speed-threshold\n");
			  wr_config(sptr_cdb, cu_line_buf);
			}
			  
			return;
		}
	
		if (end_of_token(sptr_cdb->token) != '\0') 
			return; /* cmd not for me */

			/* Don't process the next token. */
		sptr_cdb->dont_go_next = 1;

		if (sptr_cdb->no)
			cu_fan_speed_threshold_disable(stackId);
		else
			cu_fan_speed_threshold_enable(stackId);
}
void cli_set_fan_speed_threshold (struct cdb *sptr_cdb)
{
	int stackid;
      
      for(stackid = 1; stackid <= MAX_STACKING_NUM; stackid++) {                                                                                                                                                                                                       
	      sptr_cdb->stack_id = stackid; 
		  if (MODULE_EXIST(STACK_TO_MODULE_ID(stackid)) || MODULE_IS_CONFIGURED(STACK_TO_MODULE_ID(stackid)))
            cli_set_fan_speed_threshold_stack(sptr_cdb);                                                                                                                                                                                                                
      }      
}
int g_battleshortmode = 0;
int g_battleshort_mode[MAX_STACKING_NUM+1] = {0};

int cu_ignore_temp_shdn_global_status()
{
   return g_battleshortmode;
}

void cu_set_ignore_temp_shdn_global(int value)
{

 chassisIgnoreTempShdnGlobal(value);

}

int cu_set_ignore_temp_shdn_global_disable (int value)
{
    if (g_battleshortmode == FALSE )
    {
        uprintf("Not configured the Global Ignore temperature shutdown threshold mode\n");
        return CU_ERROR;
    }

    g_battleshortmode = FALSE;
    if (!STACK_AM_I_SLAVE)
    {
      cu_logging_ignore_temp_shdn_global(FALSE);
    }
    else
    {
      cu_set_ignore_temp_shdn_global(FALSE);
    }
    return CU_OK;
}

int cu_set_ignore_temp_shdn_global_enable(int value)
{
    int stackid;

     for(stackid = 1; stackid <= MAX_STACKING_NUM; stackid++)
     {

       if (MODULE_EXIST(STACK_TO_MODULE_ID(stackid)))
       {
         if(g_battleshort_mode[stackid] == TRUE)
         {
          uprintf("Already enabled the Ignore temperature shutdown threshold mode at unit level\n");
          return CU_ERROR;
         }
       }
     }

    if (g_battleshortmode == TRUE )
    {
        uprintf("Already enabled the Ignore temperature shutdown threshold mode at global level\n");
        return CU_ERROR;
    }

    g_battleshortmode = TRUE;
    if (!STACK_AM_I_SLAVE)
    {
       cu_logging_ignore_temp_shdn_global(TRUE);

    }
    else
    {
       cu_set_ignore_temp_shdn_global(TRUE);
    }
    return CU_OK;
}

void cli_set_ignore_temp_shutdown_global(struct cdb *sptr_cdb)
{
   

        if (sptr_cdb->config_gen) {
            /* Don't process the next token. */
            sptr_cdb->dont_go_next = 1;
            if (g_battleshortmode == TRUE){
              ksprintf(cu_line_buf, "ignore-temp-shutdown\n");
              wr_config(sptr_cdb, cu_line_buf);
            }

            return;
        }

       if (STACK_AM_I_CB_ENABLE || STACK_AM_I_PE_ENABLE)
       {
         if(!g_sw_sys.init_in_progress)
         uprintf ("Error! this command is not allowed in SPX environment\n");
         return;
       }

        if (end_of_token(sptr_cdb->token) != '\0')
            return; /* cmd not for me */

            /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
            cu_set_ignore_temp_shdn_global_disable(FALSE);
        else
            cu_set_ignore_temp_shdn_global_enable(TRUE);

}


void cu_ignore_temp_shutdown(int stackId, int value)
{
    if (stackId != MY_BOOTUP_STACK_ID) {
        chassisIgnoreShutdownTemperatureThreshold(stackId, value);
        return;
    }
}

int cu_ignore_temp_shutdown_disable (int stackId)
{
    if (g_battleshort_mode[stackId] == FALSE )
    {
        uprintf("Not configured the Ignore temperature shutdown threshold mode in unit %d\n",stackId);
        return CU_ERROR;
    }

    g_battleshort_mode[stackId] = FALSE;
    if (stackId == MY_BOOTUP_STACK_ID)
    {
       cu_logging_ignore_temp_shutdown(stackId, FALSE);
    }
    else
    {
       cu_ignore_temp_shutdown(stackId, FALSE);
    }
    uprintf("Ignore temperature shutdown threshold has been disabled in Stack unit %d\n",stackId);
    return CU_OK;
}

int cu_ignore_temp_shutdown_enable (int stackId)
{
    if(g_battleshortmode == TRUE)
    {
        uprintf("Already enabled the Ignore temperature shutdown threshold mode at global level\n");
        return CU_ERROR;
    }
    if ((g_battleshort_mode[stackId] == TRUE ) )
    {
        uprintf("Already enabled the Ignore temperature shutdown threshold mode at unit level\n");
        return CU_ERROR;
    }

    g_battleshort_mode[stackId] = TRUE;

    if ((stackId == MY_BOOTUP_STACK_ID))
    {
       cu_logging_ignore_temp_shutdown(stackId, TRUE);
    }
    else
    {
       cu_ignore_temp_shutdown(stackId, TRUE);
    }

    uprintf("Ignore temperature shutdown threshold has been enabled in Stack unit %d\n",stackId);
    return CU_OK;
}

void cli_set_ignore_temp_shutdown_unit(struct cdb *sptr_cdb)
{
    UINT8 stackId;
    int chassis_ptr_changed = 0;
    int curr_status_ptr_changed = 0;
    int curr_hw_data_ptr_changed = 0;

    stackId =   sptr_cdb->stack_id;

    if (!sptr_cdb->config_gen) {
                /* Don't process the next token. */
            sptr_cdb->dont_go_next = 1;

        if (!(MODULE_EXIST(STACK_TO_MODULE_ID(stackId)) || MODULE_IS_CONFIGURED(STACK_TO_MODULE_ID(stackId)))){
            uprintf("No unit %d exist and configured\n", stackId);
            return;
        }
    }

        if (sptr_cdb->config_gen) {

            /* Don't process the next token. */
            sptr_cdb->dont_go_next = 1;
            if (g_battleshort_mode[stackId] == 1){
              ksprintf(cu_line_buf, "  ignore-temp-shutdown\n");
              wr_config(sptr_cdb, cu_line_buf);
            }

            return;
        }
       
       if (STACK_AM_I_CB_ENABLE || STACK_AM_I_PE_ENABLE)
       {
         if(!g_sw_sys.init_in_progress)
         uprintf ("Error! this command is not allowed in SPX environment\n");
         return;
       }

       
        if (end_of_token(sptr_cdb->token) != '\0')
            return; /* cmd not for me */

            /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->no)
            cu_ignore_temp_shutdown_disable(stackId);
        else
            cu_ignore_temp_shutdown_enable(stackId);

}
extern void set_stack_temp_threshold(int stackId, HW_TEMP_THRESHOLD tt_id, int value);

void set_tmpt_warning(struct cdb *sptr_cdb)
{
	int stackId;
        int warning_temp = (int) sptr_cdb->integer2;

       if (is_stacking_software_disabled() || (!is_stacking_prom_installed()))
        {
                // this is for standalone case (no stacking EEPORM)
                sptr_cdb->stack_id = DEFAULT_STANDALONE_STACK_ID;
                warning_temp = (int)sptr_cdb->integer1;
        }else
                sptr_cdb->stack_id = sptr_cdb->integer1;

        stackId =       sptr_cdb->stack_id;

		if(!IS_CHASSIS_STACK_EXIST(stackId))
		{
			uprintf("Invalid unit id %d\n", stackId); //as this unit does not exist
            return;
		}

		if(IS_SIDEWINDER() || IS_SPATHA())
		{
			
			if(!(STK_ID_RANGE_CHECK(stackId) || PE_ID_RANGE_CHECK(stackId)))   
			{
                uprintf("Invalid unit id %d\n", stackId);
                return;
        	}
		}
		else
		{
        	if(stackId <= 0 || stackId > MAX_STACKING_NUM)
			{
                uprintf("Invalid stack unit id %d\n", stackId);
                return;
       	 	}
		}
       
			
                if(!(IS_FI_BCM()))
                {

                        if (warning_temp < 0 || warning_temp > 125)
                        {
                                        uprintf("Bad value: range 0 to 125\n");
                                        return;
                        }
                }

                if (sptr_cdb->config_gen) {
                sptr_cdb->dont_go_next = 1;
                        return;
                }

                if(IS_FI_BCM())
                {
                
                        if ((warning_temp > ((tmpt_shutdown[stackId]>>1)-3)) || (warning_temp < 0) ) //maximum warning temp = shutdown temp - 5 degree
                        {
                                        uprintf("Bad value: warning level on this unit can have value from 0 to %d\n",(int)((tmpt_shutdown[stackId]>>1)-3) );
                                        return;
                        }
                }
                else
                {
                                
                        if ((warning_temp<<1) >= tmpt_shutdown[stackId] )
                        {
                                        uprintf("Bad value: warning level must be lower than shutdown level\n");
                                        return;
                        }
                }


        if(stackId == MY_BOOTUP_STACK_ID){
                set_temp_threshold(0, warning_temp<<1);
        }else{
                set_stack_temp_threshold(stackId, 0, warning_temp<<1);
                tmpt_warning[stackId] = (warning_temp<<1);
        }

}

void set_tmpt_shutdown(struct cdb *sptr_cdb)
{
        hal_set_tmpt_shutdown (sptr_cdb);
}


void get_tag_changed_portList(PP_DEVICE_MASK device_mask, PORT_MASK* temp_mask)
{
        UINT32 i, device_id;
        PORT_ID port_id;

        clear_mask(temp_mask);
        for (i = 0; i < g_hw_info.total_config_ports; i++)
        {
                port_id = sw_config_port_list[i];

                if(is_port_stack_enabled(port_id))  //BUG:97889
                        continue;

                device_id = PORT_TO_DEVICE_ID(port_id);
                if (IS_DEVICE_MASK_MEMBER(device_mask, device_id))
                {
                        set_mask_bit(temp_mask, port_id);
                }
        }
}

static PP_DEVICE_MASK gi_get_effective_tag_changed_mask(PORT_MASK *port_mask)
{
        UINT32          i, device_id;
        PP_DEVICE_MASK device_mask = {{0,0}},  old_dev_mask = {{0xFFFF,0xFFFF}};
        PORT_ID         port_id;
        PORT_MASK       actual_mask[MAX_SLOT];

        while (!IS_DEVICE_MASK_EQUAL(device_mask ,old_dev_mask))
        {
                old_dev_mask    = device_mask;
                DEVICE_MASK_ZERO(device_mask);

                cu_get_port_mask_from_trunk_group(port_mask, actual_mask);

                for (i = 0; i < g_hw_info.total_config_ports; i++)
                {
                        port_id = sw_config_port_list[i];
                        if (is_member(actual_mask, port_id))
                        {
                                device_id = PORT_TO_DEVICE_ID(port_id);
                                SET_DEVICE_MASK_BIT(device_mask, device_id);
                        }
                }
                get_tag_changed_portList(device_mask, port_mask);
        }

        return (device_mask);
}

void set_tag_type_enet(struct cdb *sptr_cdb)
{

        hal_set_tag_type_enet(sptr_cdb);
}


void set_tag_type(struct cdb *sptr_cdb)
{
        hal_set_tag_type(sptr_cdb);
}

#ifdef SR_SWITCH_ROUTER
static void set_trap_bad_checksum_enet(struct cdb *sptr_cdb)
{
        UINT32  device_id;
        PP_DEVICE_MASK device_mask = {{0,0}};
        PORT_MASK port_mask[MAX_SLOT];

        clear_mask(port_mask);
        copy_mask(port_mask, sptr_cdb->port_mask1);

        if ((sptr_cdb->no))
        {
                g_trap_bad_checksum_all_devices = 0 ;

                device_mask = gi_get_effective_tag_changed_mask(port_mask);

                for (device_id=0; device_id<g_hw_info.max_dma; device_id++)
                {
                        if (!IS_DMA_PRESENT(device_id))
                                continue;

                        if (IS_DEVICE_MASK_MEMBER(device_mask, device_id))
                        {
                                pp_trap_bad_checksum_per_device(device_id, FALSE);
                        }
                }

                cu_mask2portList(port_mask, cu_line_buf, sizeof(cu_line_buf));

                if (!g_sw_sys.init_in_progress)
                        uprintf("disable-hw-ip-checksum-check cleared for ports %s\n", cu_line_buf);

                CLEAR_DEVICE_MASK_BITS(g_trap_bad_checksum_device_mask,device_mask)
        }
        else
        {
                /* Change for requested ports */
                device_mask = gi_get_effective_tag_changed_mask(port_mask);

                for (device_id=0; device_id<g_hw_info.max_dma; device_id++)
                {
                        if (!IS_DMA_PRESENT(device_id))
                                continue;

                        if (IS_DEVICE_MASK_MEMBER(device_mask, device_id))
                        {
                                pp_trap_bad_checksum_per_device(device_id, TRUE);
                        }
                }

                cu_mask2portList(port_mask, cu_line_buf, sizeof(cu_line_buf));

                if (!g_sw_sys.init_in_progress)
                        uprintf("disable-hw-ip-checksum-check set for ports %s\n", cu_line_buf);

                SET_DEVICE_MASK_BITS( g_trap_bad_checksum_device_mask, device_mask);
        }

}


void cli_set_trap_bad_checksum(struct cdb *sptr_cdb)
{
        PORT_MASK port_mask[MAX_SLOT];
/* 541618-Since disable-hw-ip-checksum-check commond will be supported only IPV4 Hardware 
 * and since TI is not available with the current release commenting it */
#if 0 
        if(is_system_turboiron())
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
#endif

        if (sptr_cdb->config_gen)
        {
                /*if (g_sw_sys.tag_type != DMA_VLAN_ETHER_TYPE) */{

                        if (g_trap_bad_checksum_all_devices != 0)
                        {
                //              ksprintf(cu_line_buf, "tag-type %4x\n", g_sw_sys.tag_type);
                                wr_config(sptr_cdb, "disable-hw-ip-checksum-check\n");
                        }
                        else
                        {
                                get_tag_changed_portList(g_trap_bad_checksum_device_mask, port_mask);
                                if (!is_mask_clear(port_mask))
                                {
                                        ksprintf(cu_line_buf, "disable-hw-ip-checksum-check  ");
                                        wr_config(sptr_cdb, cu_line_buf);
                                        cu_mask2portList(port_mask, cu_line_buf, sizeof(cu_line_buf));
                                        wr_config(sptr_cdb, cu_line_buf);
                                        wr_config(sptr_cdb, "\n");
                                }
                        }
                }
        }
        else
        {
                if (gi_system_devFamily_type != GT_TWISTD_FAMILY)
                {
                        uprintf ("Error: command is valid only on IPv4 hardware.\n");
                        return;
                }
                if (end_of_token(sptr_cdb->token) != '\0')
                {
                        sptr_cdb->port_mask_callback = set_trap_bad_checksum_enet;
                        set_port_mask_type_enet(sptr_cdb);
                        return;
                }

                if (sptr_cdb->no)
                {
                        pp_trap_bad_checksum_all(FALSE);
                        g_trap_bad_checksum_all_devices = 0;
                        DEVICE_MASK_ZERO(g_trap_bad_checksum_device_mask);

                        if (!g_sw_sys.init_in_progress)
                                uprintf("disable-hw-ip-checksum-check cleared for all ports\n");
                }
                else
                {
                        pp_trap_bad_checksum_all(TRUE);
                        g_trap_bad_checksum_all_devices = 1;
                        g_trap_bad_checksum_device_mask = g_all_devices_mask;
                        if (!g_sw_sys.init_in_progress)
                                uprintf("disable-hw-ip-checksum-check set for all ports\n");
                }
        }

        sptr_cdb->dont_go_next = 1;

}
#endif SR_SWITCH_ROUTER

void vlancu_set_etype(UINT16 etype,     PORT_MASK * input_mask)
{
        PORT_MASK port_mask[MAX_SLOT];
        int i,j;
        int number_of_ports;
        PORT_ID port_id, *port_list;

        clear_mask(port_mask);

       if (input_mask)
        {
                if (is_mask_clear(input_mask))
                {
                        uprintf("error - input port mask is clear\n");
                        return;
                }

                cu_get_port_mask_from_trunk_group(input_mask, port_mask);

         }

        for (i=0; i < g_hw_info.total_config_ports; ++i)
        {
                port_id = sw_config_port_list[i];
                if (input_mask!=NULL)
                        if (!is_member(port_mask, port_id))
                                continue;
                /* set etype per port */
                uprintf("Tag Type changed to 0x%4x for Port: %p \n", etype,port_id);
                gi_set_port_tag_etype(port_id, etype);

        }

}


void cli_config_gen_perf_mode(struct cdb *sptr_cdb)
{
        if (g_sw_sys.perf_mode)
    {
                ksprintf(cu_line_buf, "perf-mode hi\n");
                wr_config(sptr_cdb, cu_line_buf);
    }
}

void
stk_close_telnet_sessions(void)
{
        int i;

        for (i=0; i<MAX_TELNET_SESSIONS; i++)
        {
                if (telnet.client[i].in_use)
                {
                        telnet.client[i].termination_cause = PW_ADMIN_RESET;
                        telnet_close_connection(telnet.client[i].tcb_handle);
                }
        /*      DEFECT000454135: Cleanup the CLI parser state including previledge levels, modes that previous 
                IN/OUT bound  telnet sessions created or updated */
        clean_up_parser(TELNET_TO_CDBS_INDEX(i)); 
    }
}


 CONSOLE_CLASS console;

void check_no_console_timeout(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
        {
                console_set_idle_timeout_config(0);
                sptr_cdb->dont_go_next = 1;
        }
}

#ifdef SR_SWITCH_ROUTER
#ifdef NOT_USED
void set_max_ip_static_route(struct cdb *sptr_cdb)
{
        UINT16 def, max, min;

        def = cu_get_curr_param(STATIC_ROUTE_ENTRIES_INDEX);
        max = cu_get_max_param(STATIC_ROUTE_ENTRIES_INDEX);
        min = cu_get_def_param(STATIC_ROUTE_ENTRIES_INDEX);

        if (sptr_cdb->config_gen)
        {
                if (next_maximum_number_of_ip_static_routes == def)
                        return;
                else
                {
                        wr_config(sptr_cdb, "max-ip-static-route ");
                        ksprintf(cu_line_buf, "%d\n", next_maximum_number_of_ip_static_routes);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        next_maximum_number_of_ip_static_routes = def;
                        return;
                }
                if (!valid_integer1_value_range(sptr_cdb, min, max))
                {
                        return;
                }
                if (init_in_progress)
                        next_maximum_number_of_ip_static_routes =
                        maximum_number_of_ip_static_routes = sptr_cdb->integer1;
                else
                        next_maximum_number_of_ip_static_routes = sptr_cdb->integer1;
        }
}

void set_max_ip_filter_per_sys(struct cdb *sptr_cdb)
{
        UINT16 def, max, min;

        def = IP_DEFAULT_NUMBER_OF_FILTERS;
#ifdef SR_SWITCH_ROUTER
        max = ip_maximum_number_of_filters;
#else
        max = IP_MAXIMUM_NUMBER_OF_FILTERS;
#endif SR_SWITCH_ROUTER
        min = IP_DEFAULT_NUMBER_OF_FILTERS;

        if (sptr_cdb->config_gen)
        {
                if (ip_next_maximum_number_of_filters == def)
                        return;
                else
                {
                        wr_config(sptr_cdb, "max-ip-filter-per-sys ");
                        ksprintf(cu_line_buf, "%d\n", ip_next_maximum_number_of_filters);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        ip_next_maximum_number_of_filters = def;
                        return;
                }
                if (!valid_integer1_value_range(sptr_cdb, min, max))
                {
                        return;
                }
                if (init_in_progress)
                        ip_next_maximum_number_of_filters =
                        ip_maximum_number_of_filters = sptr_cdb->integer1;
                else
                        ip_next_maximum_number_of_filters = sptr_cdb->integer1;
        }
}

void set_max_ip_filter_per_int(struct cdb *sptr_cdb)
{
        UINT16 def, max, min;

        def = IP_DEFAULT_NUMBER_OF_FILTERS_PER_LIST;
        max = IP_MAXIMUM_NUMBER_OF_FILTERS_PER_LIST;
        min = IP_DEFAULT_NUMBER_OF_FILTERS_PER_LIST;

        if (sptr_cdb->config_gen)
        {
                if (ip_next_maximum_number_of_filters_per_list == def)
                        return;
                else
                {
                        wr_config(sptr_cdb, "max-ip-filter-per-int ");
                        ksprintf(cu_line_buf, "%d\n", ip_next_maximum_number_of_filters_per_list);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        ip_next_maximum_number_of_filters_per_list = def;
                        return;
                }
                if (!valid_integer1_value_range(sptr_cdb, min, max))
                {
                        return;
                }
                if (init_in_progress)
                        ip_next_maximum_number_of_filters_per_list =
                        ip_maximum_number_of_filters_per_list = sptr_cdb->integer1;
                else
                        ip_next_maximum_number_of_filters_per_list = sptr_cdb->integer1;
        }
}

void set_max_ip_flow(struct cdb *sptr_cdb)
{
        UINT16 def, max, min;

        def = IP_DEFAULT_NUMBER_OF_FLOW_ENTRIES;
        max = IP_MAXIMUM_NUMBER_OF_FLOW_ENTRIES;
        min = IP_DEFAULT_NUMBER_OF_FLOW_ENTRIES;

        if (sptr_cdb->config_gen)
        {
                if (ip_next_maximum_number_of_flows == def)
                        return;
                else
                {
                        wr_config(sptr_cdb, "max-ip-flow ");
                        ksprintf(cu_line_buf, "%d\n", ip_next_maximum_number_of_flows);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        ip_next_maximum_number_of_flows = def;
                        return;
                }
                if (!valid_integer1_value_range(sptr_cdb, min, max))
                {
                        return;
                }
                if (init_in_progress)
                        ip_next_maximum_number_of_flows =
                        ip_maximum_number_of_flows = sptr_cdb->integer1;
                else
                        ip_next_maximum_number_of_flows = sptr_cdb->integer1;
        }
}

void set_max_ip_arp(struct cdb *sptr_cdb)
{
        UINT16 def, max, min;

        def = DEFAULT_NUMBER_OF_ARP_TABLE_ENTRIES;
        max = MAXIMUM_NUMBER_OF_ARP_TABLE_ENTRIES;
        min = DEFAULT_NUMBER_OF_ARP_TABLE_ENTRIES;

        if (sptr_cdb->config_gen)
        {
                if (ip.arp.next_maximum_number_of_entries_in_arp_table == def)
                        return;
                else
                {
                        wr_config(sptr_cdb, "max-arp ");
                        ksprintf(cu_line_buf, "%d\n", ip.arp.next_maximum_number_of_entries_in_arp_table);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        ip.arp.next_maximum_number_of_entries_in_arp_table = def;
                        return;
                }
                if (!valid_integer1_value_range(sptr_cdb, min, max))
                {
                        return;
                }
                if (init_in_progress)
                        ip.arp.next_maximum_number_of_entries_in_arp_table =
                        ip.arp.maximum_number_of_entries_in_arp_table = sptr_cdb->integer1;
                else
                        ip.arp.next_maximum_number_of_entries_in_arp_table = sptr_cdb->integer1;
        }
}

void set_max_ip_route(struct cdb *sptr_cdb)
{
        UINT32 def, max, min;

        if (g_hw_info.dram_size > 0x800000)
        {
                def = IP_DEFAULT_NUMBER_OF_ENTRIES_IN_ROUTING_TABLE_32M;
                max = IP_MAX_NUMBER_OF_ENTRIES_IN_ROUTING_TABLE_32M;
                min = IP_MIN_NUMBER_OF_ENTRIES_IN_ROUTING_TABLE_32M;
        }
        else
        {
                def = IP_DEFAULT_NUMBER_OF_ENTRIES_IN_ROUTING_TABLE_8M;
                max = IP_MAX_NUMBER_OF_ENTRIES_IN_ROUTING_TABLE_8M;
                min = IP_MIN_NUMBER_OF_ENTRIES_IN_ROUTING_TABLE_8M;
        }

        if (sptr_cdb->config_gen)
        {
                if (ip.next_maximum_number_of_entries_in_routing_table == def)
                        return;
                else
                {
                        wr_config(sptr_cdb, "max-ip-route ");
                        ksprintf(cu_line_buf, "%d\n", ip.next_maximum_number_of_entries_in_routing_table);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        ip.next_maximum_number_of_entries_in_routing_table = def;
                        return;
                }
                if (!valid_integer1_value_range(sptr_cdb, min, max))
                {
                        return;
                }
                if (init_in_progress)
                        ip.next_maximum_number_of_entries_in_routing_table =
                        ip.maximum_number_of_entries_in_routing_table = sptr_cdb->integer1;
                else
                        ip.next_maximum_number_of_entries_in_routing_table = sptr_cdb->integer1;
        }
}
#endif /* NOT_USED */
#endif /* SR_SWITCH_ROUTER */

void trace_ip(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(IP_TRACE);
}

void trace_arp(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                g_trace_arp_ipaddr = 0L;
                g_trace_arp_port = 0XFFFF;
                ip_set_trace_mask(ARP_TRACE);
        }
        return;
}


void trace_arp_ipaddr( struct cdb *sptr_cdb )
{
        g_trace_arp_ipaddr = sptr_cdb->ip1;
        ip_set_trace_mask(ARP_TRACE);
        return;
}

void trace_arp_port( struct cdb *sptr_cdb )
{
        g_trace_arp_port =( PORT_ID )( sptr_cdb->if1 - 1 );
        ip_set_trace_mask(ARP_TRACE);
        return;

}

void trace_rarp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(RARP_TRACE);
}

void trace_icmp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(ICMP_TRACE);
}

void trace_ospf(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(OSPF_TRACE);
}

void trace_igmp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(IGMP_TRACE);
}

#ifdef SR_SWITCH_ROUTER
#ifdef __IP_MULTICAST__
void trace_pim_message(struct cdb *sptr_cdb)
{
        cu_set_pim_debug_mask(PIM_DEBUG_MESSAGE);
}
#endif __IP_MULTICAST__
#endif SR_SWITCH_ROUTER

void trace_tcp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(TCP_TRACE);
}

void trace_telnet(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(TELNET_TRACE);
}

void trace_udp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(UDP_TRACE);
}

void trace_rip(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(RIP_TRACE);
}

void trace_tftp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(TFTP_TRACE);
}

void trace_snmp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(SNMP_TRACE);
}

void trace_bootp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(BOOTP_TRACE);
}

void trace_ppp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(PPP_TRACE);
}

void trace_pos(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(POS_TRACE);
}

void trace_aaa(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(AAA_TRACE);
}

void trace_nvlan(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(NVLAN_TRACE);
}

void trace_lacp(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(LACP_TRACE);
}

void trace_term(struct cdb *sptr_cdb)
{
        if (g_dprintf_dest == sptr_cdb->ui_port)
        {
                g_dprintf_dest = 0;
                g_debug_tcb = NULL;
                uprintf("debug output is now sent to console\n");
        }
        else
        {
                g_dprintf_dest = sptr_cdb->ui_port;
                if (g_dprintf_dest != 0)
                {
                        g_debug_tcb = (void *)telnet.client[(UINT8)(g_dprintf_dest-1)].tcb_handle;
                        if (!g_debug_tcb)
                                g_debug_tcb = (void *)get_ssh_debug_tcb(g_dprintf_dest);
                }
                else
                        g_debug_tcb = NULL;
                uprintf("debug output is now sent to this terminal\n");
        }
}

extern void clear_appletalk_ptrace();
void sw_set_trace_mask(UINT32 mask);

void trace_none(struct cdb *sptr_cdb)
{
        ip_set_trace_mask(CLEAR_TRACE_MASK);
        sw_set_trace_mask(CLEAR_SW_TRACE_MASK);
}

void
sw_set_trace_mask(UINT32 mask)
{
        if (mask == CLEAR_SW_TRACE_MASK)
        {
                g_sw_sys.trace_mask = CLEAR_SW_TRACE_MASK;
                return;
        }

        if (g_sw_sys.trace_mask & mask)
        {
                g_sw_sys.trace_mask &= (~mask);
                uprintf("specified trace was turned OFF\n");
        }
        else
        {
                g_sw_sys.trace_mask |= mask;
                uprintf("specified trace was turned ON\n");
        }
}

void trace_sw_stp(struct cdb *sptr_cdb)
{
        sw_set_trace_mask(STP_TRACE);
}

void trace_sw_none(struct cdb *sptr_cdb)
{
        sw_set_trace_mask(CLEAR_SW_TRACE_MASK);
}

void fastboot_on(struct cdb *sptr_cdb)
{
        if (boot_code_version_ok(2))
                fastreload(1);
}

void fastboot_off(struct cdb *sptr_cdb)
{
        if (boot_code_version_ok(2))
                fastreload(0);
}

#ifdef __PROC_CPU_UTIL__

void show_proc_cpu_hist(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->integer1 <= 0)
        {
                uprintf("1 second is the minimum interval\n");
                uprintf("Please try again.\n");
                return;
        }

        if (sptr_cdb->integer1 > MAX_TIME_PERIOD)
        {
                uprintf("%d seconds (15 minutes) is the maximum interval\n", MAX_TIME_PERIOD);
                uprintf("Please try with a smaller interval.\n");
                return;
        }

        /* can't be greater than system time */
        if ((g_time_counter/10) <= sptr_cdb->integer1)
        {
                uprintf("The system has only been up for %d seconds.\n",g_time_counter/10);
                uprintf("Please try with a smaller interval.\n");
                return;
        }
        show_proc_cpu_util_hist(sptr_cdb->integer1);
}

void show_proc_cpu(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                show_proc_cpu_util();
                sptr_cdb->dont_go_next = 1;
        }

}
#endif

void gi_collect_cpu_statistics()
{
        /* collect CPU utilization counters */
        if (++g_cpu_stat_idx >= CPU_STAT_SIZE)  g_cpu_stat_idx = 0;
        g_cpu_stat_pkt[g_cpu_stat_idx] = g_sw_sys.cpu_q_read_cnt;
        g_cpu_stat_loop[g_cpu_stat_idx] = g_sw_sys.cpu_rcv_loop_cnt;
}



void show_cpu_info(unsigned int ui_port, int detail)
{
	UINT32 saved_count;
#if defined(FI_LINUX)
	char buf[32];
	int i =1 , maxcpus =0;
#endif
#if defined(FI_LINUX)
	maxcpus = sys_get_online_cpus();
	if (maxcpus > 1)
		uprintf("\rcpu0:\n");
#endif
	saved_count = (g_time_counter - cpu_cnt[ui_port].cpuu_start_time)/10;
	if (saved_count == 0)
	{
		uprintf("Less than a second from the last call, abort\n");
	} else
	{
		uprintf("%d percent busy, from %d sec ago\n", get_cpu_utilization(detail), saved_count);
		if (saved_count > 50*60*60)
		{
			uprintf("It has  been more than 50 hours since last call, the CPU utilization\n");
			uprintf("data collected may have wrapped around and result in high\n");
			uprintf("utilization\n");
		}
	}
	uprintf("1   sec avg: %2d percent busy\n", get_cpu_hist(detail,1));
	uprintf("5   sec avg: %2d percent busy\n", get_cpu_hist(detail,5));
	uprintf("60  sec avg: %2d percent busy\n", get_cpu_hist(detail,60));
	uprintf("300 sec avg: %2d percent busy\n", get_cpu_hist(detail,300));

#if defined(FI_LINUX)
	double val;
	long secs = -1;
	for (; i < maxcpus; i++) {
		uprintf("cpu%d:\n", i);
		val = sys_smp_get_core_stats(i, -1, &secs);
		uprintf("%d percent busy, from %d sec ago\n", (int)val, (int)secs);
		val = sys_smp_get_core_stats(i, 1, &secs);
		uprintf("1   sec avg: %d percent busy\n", (int)val);
		val = sys_smp_get_core_stats(i, 5 , &secs);
		uprintf("5   sec avg: %d percent busy\n", (int)val);
		val = sys_smp_get_core_stats(i, 60, &secs);
		uprintf("60  sec avg: %d percent busy\n", (int)val);
		val = sys_smp_get_core_stats(i, 300, &secs);
		uprintf("300 sec avg: %d percent busy\n", (int)val);
}
#endif
}



void show_cpu_info_new(int detail)
{
    // Allow for passing of detail parameter, use to be decided later
    int i, k, l;
    unsigned long total_util = 0;
    unsigned long divisor = 1;                          // Needed for FCX/SX kernel differences
    SYS_TASK_INFO *cpu_task_util_array;

        cpu_task_util_array = (SYS_TASK_INFO*)dy_malloc(sizeof(SYS_TASK_INFO) * MAX_TASK_NUMBER);

    // Out of memory case
    if(!cpu_task_util_array)
    {
        uprintf("Cannot allocate memory for SYS_TASK_INFO list\n");
        return;
    }

    //Clear memory allocated for task array
    memset(cpu_task_util_array, 0, sizeof(SYS_TASK_INFO) * MAX_TASK_NUMBER);

#ifndef PV_CHANGES
    // Retrieve task utilization information from each task from the kernel
    sys_get_task_info_array(cpu_task_util_array, MAX_TASK_NUMBER, 1);
#endif PV_CHANGES

    // Add extra to idle and adjust total to 100%
    for(i = 0; cpu_task_util_array[i].handle; i++)
    {
                if(!strcmp(cpu_task_util_array[i].name, "idle")) continue;
                if(!strcmp(cpu_task_util_array[i].name, "$(idle)")) continue;
        total_util += (cpu_task_util_array[i].cpu_utilization / divisor);
    }

    // Cap summary of CPU utilization to 100%
    if(total_util > 100) total_util = 100;

    // Print sh cpu header
    //bugid 462811, show cpu task no need CPU Utilization
    // the value will be misleading 
    //uprintf("\nCurrent total CPU utilization = %d%%\n\n", total_util);
    uprintf("... Usage average for all tasks in the last %d second ...\n", 1);
    uprintf("==========================================================\n");
    uprintf("Name\t\t\t\t\t%%\n\n");

    for(i = 0; cpu_task_util_array[i].handle; i++)
    {
        for(l = 0, k = 0; cpu_task_util_array[i].name[k]; k++)
        {
            if(cpu_task_util_array[i].name[k] != '$' &&
               cpu_task_util_array[i].name[k] != '(' &&
               cpu_task_util_array[i].name[k] != ')')
            {
                cpu_task_util_array[i].name[l++] = cpu_task_util_array[i].name[k];
            }
        }
        cpu_task_util_array[i].name[l] = 0;
                if(!strcmp(cpu_task_util_array[i].name, "idle"))
                {
                    // print the idle task separately
            uprintf("%-20s\t\t\t%-16u\n", cpu_task_util_array[i].name,
                                        100 - total_util);
            continue;
                }
        uprintf("%-20s\t\t\t%-16u\n", cpu_task_util_array[i].name,
                                    (cpu_task_util_array[i].cpu_utilization / divisor));
    }
    uprintf("\n");
    dy_free(cpu_task_util_array);

    return;
}

void show_cpu(struct cdb *sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                show_cpu_info(sptr_cdb->ui_port, FALSE);
                sptr_cdb->dont_go_next = 1;
        }

}


void show_cpu_task_detail(struct cdb *sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                show_cpu_info_new(/*sptr_cdb->ui_port, */FALSE);
                sptr_cdb->dont_go_next = 1;
        }

}

void show_cpu_hist(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->integer1 <= 0)
        {
                uprintf("1 second is the minimum interval\n");
                uprintf("Please try again.\n");
                return;
        }

        if (sptr_cdb->integer1 > MAX_CPU_INTERVAL)
        {
                uprintf("%d seconds (5 minutes) is the maximum interval\n", MAX_CPU_INTERVAL);
                uprintf("Please try with a smaller interval.\n");
                return;
        }

        /* can't be greater than system time */
        if ((g_time_counter/10) <= sptr_cdb->integer1)
        {
                uprintf("The system has only been up for %d seconds.\n",g_time_counter/10);
                uprintf("Please try with a smaller interval.\n");
                return;
        }
        uprintf("%d/100 busy, for past %d sec\n",
                                get_cpu_hist(0,sptr_cdb->integer1), sptr_cdb->integer1);

}

// BUG fix for #101326  , imported from TI branch
extern int overflow_syslog_message_num;
void dm_syslog_show_overflow(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        uprintf("Number of overflow syslog messages: %d\n", overflow_syslog_message_num);

}

void dm_cpu_hist(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->integer1 <= 0)
        {
                uprintf("1 second is the minimum interval\n");
                uprintf("Please try again.\n");
                return;
        }

        if (sptr_cdb->integer1 > MAX_CPU_INTERVAL)
        {
                uprintf("%d seconds (5 minutes) is the maximum interval\n", MAX_CPU_INTERVAL);
                uprintf("Please try with a smaller interval.\n");
                return;
        }

        /* can't be greater than system time */
        if ((g_time_counter/10) <= sptr_cdb->integer1)
        {
                uprintf("The system has only been up for %d seconds.\n",g_time_counter/10);
                uprintf("Please try with a smaller interval.\n");
                return;
        }
        uprintf("CPU has been %d/100 busy for the past %d seconds\n",
                                get_cpu_hist(1,sptr_cdb->integer1), sptr_cdb->integer1);

}


void dm_cpu_utilization(struct cdb *sptr_cdb)
{
        UINT32 saved_count;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                saved_count = (g_time_counter - cpu_cnt[sptr_cdb->ui_port].cpuu_start_time)/10;
                if (saved_count == 0)
                {
                        uprintf("Less than a second from the last call, abort\n");
                } else
                {
                        uprintf("%d/100 busy, from %d sec ago\n", get_cpu_utilization(1), saved_count);
                }
                sptr_cdb->dont_go_next = 1;
        }
}

#ifdef MANU_DIAG
void ug_workgroup(struct cdb *sptr_cdb)
{
        boot_name = 'W';
        change_boot_name();
}
void ug_backbone(struct cdb *sptr_cdb)
{
        boot_name = 'B';
        change_boot_name();
}
void ug_netiron(struct cdb *sptr_cdb)
{
        boot_name = 'N';
        change_boot_name();
}
void ug_turbo_r(struct cdb *sptr_cdb)
{
        boot_name = 'R';
        change_boot_name();
}
void ug_turbo_w(struct cdb *sptr_cdb)
{
        boot_name = 'T';
        change_boot_name();
}
void ug_si(struct cdb *sptr_cdb)
{
        boot_name = 'S';
        change_boot_name();
}
#endif

#ifdef SR_SWITCH_ROUTER

void cli_ipx_debug(struct cdb* sptr_cdb)
{
        /*
         * To prevent the user accidentally reboot the system,
         * we require the user to enter the whole command.
         */
        if (memcmp(sptr_cdb->token, "debug-ipx", 9) != 0)
        {
                sptr_cdb->dont_go_next = 1;
        }
}
#endif /* SR_SWITCH_ROUTER */

/* This is obsolete */
void toggle_heap_trace(struct cdb *sptr_cdb)
{
#if 0
        if (end_of_token(sptr_cdb->token) == '\0')
        {
                sptr_cdb->dont_go_next = 1;
                if (kmallocDebugFlag)
                {
                        uprintf("Heap trace off\n");
                        kmallocDebugFlag = 0;
                }
                else
                {
                        uprintf("Heap trace on\n");
                        kmallocDebugFlag = 1;
                }
        }
#endif
}

/* This is obsolete */
void clear_heap_trace(struct cdb *sptr_cdb)
{
#if 0
        if (valid_integer1_value_range(sptr_cdb, 0, NUM_HEAP-1) == TRUE)
                kmalloc_debug_clear_trace(sptr_cdb->integer1);
#endif
}


void sw_brd_limit(struct cdb *sptr_cdb)
{
UINT32  limit = 0;
        if (sptr_cdb->config_gen)
        {
        }
        else {

                if (sptr_cdb->no) {
                        limit = 0;
                } else {
                        limit = sptr_cdb->integer1;
                        if (limit > (0xffffffff>>1))
                                limit = 0xffffffff>>1;
                }
                sw_cu_set_brd_limit(limit);
        }
}
void sw_brd_limit1(struct cdb *sptr_cdb)
{
UINT32  limit = 0;
        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.brd_limit) {
                        ksprintf(cu_line_buf,"broadcast limit %u\n",g_sw_sys.brd_limit);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else {

                if (sptr_cdb->no) {
                        limit = 0;
                } else {
                        limit = sptr_cdb->integer1;
                }
                sw_cu_set_brd_limit(limit);
        }
}

void sw_mcast_limit(struct cdb *sptr_cdb)
{
        UINT32 limit = 0;

        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.mcast_limit)
                {
                        ksprintf(cu_line_buf,"multicast limit %u\n",g_sw_sys.mcast_limit);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no) {
                        limit = 0;
                } else {
                        limit = sptr_cdb->integer1;
                }
                sw_cu_set_mcast_limit(limit);
        }
}

void sw_unknown_unicast_limit(struct cdb *sptr_cdb)
{
        UINT32 limit = 0;

        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.unknown_unicast_limit)
                {
                        ksprintf(cu_line_buf,"unknown-unicast limit %u\n",g_sw_sys.unknown_unicast_limit);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no) {
                        limit = 0;
                } else {
                        limit = sptr_cdb->integer1;
                }
                sw_cu_set_unknown_unicast_limit(limit);
        }
}

/** DEPRECATED  */
void sw_brd_limit_by_intf(struct cdb *sptr_cdb)
{
    UINT32 limit = 0;
    UINT16 port;

    port = sptr_cdb->if_num - 1;    /* 0 based */
    if (sptr_cdb->config_gen)
    {
    } 
    else
    {
        if (sptr_cdb->no)
        {
            limit = 0;
        } 
        else
        {
            limit = sptr_cdb->integer1;
        }
        sw_cu_set_brd_limit_by_intf(limit, port);
    }
}
UINT8 bum_debug_message = 0;

bum_port_conf port_conf[MAX_PORT];
bum_shutdown_port_age_list *shutdown_port_age_list;
SV_TIMER_TOKEN_T bum_shut_clk_t;


void red_packet_unit_conversion(UINT64 red_packet,UINT32 *converted_value,char **unit)
{
	if(red_packet/(1024*1024)  > 0)
	{
		*converted_value = red_packet/(1024*1024);
		*unit = "GB";
	}
	else if(red_packet/1024 > 0)
	{
		*converted_value = red_packet/1024;
		*unit = "MB";
	}
	else
	{
		*converted_value = red_packet;
		*unit = "KB";
	}
}

void stacking_hotswap_a_bum_interval(int stk_id)
{
	
	if(1 == bum_debug_message )
		uprintf("stacking_hotswap_a_bum_interval[%d] Limit_local[%d]\n",stk_id,rate_limit_log_interval);
	if( stk_id == MY_BOOTUP_STACK_ID)  // Slave stact only
		return;

	if(!IS_CHASSIS_STACK_EXIST(stk_id))
		return;

	StackBumRatelimitToStack(stk_id,rate_limit_log_interval);
}

void chassis_set_bum_interval_ipc_callback(int stk_id,chassis_bum_threshold_set_ipc_header *chassis_bum_threshold_set_info_header)
{
	if (chassis_bum_threshold_set_info_header->set_bum_threshold)
	{
	rate_limit_log_interval = chassis_bum_threshold_set_info_header->bum_threshold;
	}
	else if ( chassis_bum_threshold_set_info_header->clear_counter)
	{
		sw_BUM_clear_all_counter_by_port (chassis_bum_threshold_set_info_header->port_id);
	}
	if(1 == bum_debug_message)
		uprintf("Log Interval value stack[%d] Limt_IPC[%d] Limit_local[%d]\n",stk_id,chassis_bum_threshold_set_info_header->bum_threshold,rate_limit_log_interval);
}

void set_rate_limit_log(struct cdb *sptr_cdb)
{
	PORT_ID port_number;

	int stackid;
      
	
	if (sptr_cdb->config_gen)
	{
		sptr_cdb->dont_go_next = 1;
		if(rate_limit_log_interval_configured !=BUM_INTVERAL_DEFAULT)
		{
			ksprintf(cu_line_buf, "rate-limit-log %d\n",rate_limit_log_interval_configured);
			wr_config(sptr_cdb, cu_line_buf);
		}
		return;
    }
	
	if(end_of_token(sptr_cdb->token) != '\0')
		return;

	sptr_cdb->dont_go_next = 1;

	if(sptr_cdb->no)
	{
		
		rate_limit_log_interval = BUM_INTVERAL_DEFAULT;
		rate_limit_log_interval_configured = BUM_INTVERAL_DEFAULT;
	}
	else
	{
		if( sptr_cdb->integer1 > 10)
			uprintf("Error: Invalid input range.\n");	
		else
		{

			if(1 == bum_debug_message)
				uprintf("Time Interval [%d]\n",sptr_cdb->integer1); 
			if(sptr_cdb->integer1)
			{ 
			rate_limit_log_interval = sptr_cdb->integer1;
				rate_limit_log_interval_configured = sptr_cdb->integer1;
			}
			else
			{
				rate_limit_log_interval = BUM_INTVERAL_DEFAULT; 
				rate_limit_log_interval_configured = sptr_cdb->integer1;
			}

			for(stackid = 1; stackid <= MAX_STACKING_NUM; stackid++)
			{       
				if (MODULE_EXIST(STACK_TO_MODULE_ID(stackid)))
					StackBumRatelimitToStack(stackid,rate_limit_log_interval);
			}	    
			
			if(rate_limit_log_interval_configured == 0)
			{
				if(1 == bum_debug_message)
						kprintf("Rate Limit Interval set as Zero\n");
				for (port_number = 0; port_number < MAX_PORT; port_number++)
				{
					if((port_conf[port_number].bum_log_enable[BUM_BROADCAST]) && 
                                           !(port_conf[port_number].bum_port_dampening[BUM_BROADCAST].drop_thres))
					{
						if(1 == bum_debug_message)
							kprintf("Port [%p] brd log Disabled\n", port_number);
						port_conf[port_number].bum_log_enable[BUM_BROADCAST] =0;
						sw_brd_limit_log_disable(port_number);
					}

					if((port_conf[port_number].bum_log_enable[BUM_MULTICAST]) &&
					   !(port_conf[port_number].bum_port_dampening[BUM_MULTICAST].drop_thres))
					{
						if(1 == bum_debug_message)
							kprintf("Port [%p] multi log Disabled\n", port_number);
						port_conf[port_number].bum_log_enable[BUM_MULTICAST] =0;
						sw_mcast_limit_log_disable(port_number);
					}

					if((port_conf[port_number].bum_log_enable[BUM_UNKNOWNUNICAST]) &&
					   !(port_conf[port_number].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres))
					{
						if(1 == bum_debug_message)
							kprintf("Port [%p] Ucast log Disabled\n", port_number);
						port_conf[port_number].bum_log_enable[BUM_UNKNOWNUNICAST] =0;
						sw_unkown_ucast_limit_log_disable(port_number);
					}
				}
				
			}	
		}
	}
}


/*************************/
//Broadcast rate limit logs
/*************************/

/*****************************************************************************
 * Function: sw_brd_limit_member_log_enable 
 *
 * Params: port_id 
 * Returns: VOID
 *
 * Purpose: This function will call the main function sw_BUM_suppression_member_unit_log_enable which is common for BUM traffic
 *****************************************************************************/
void sw_brd_limit_member_log_enable(PORT_ID port_id)
{
	sw_BUM_suppression_member_unit_log_enable (port_id, BUM_BROADCAST, sw_brd_limit_member_log_enable);
}

void sw_brd_limit_member_log(PORT_ID port_id, int log_enable)
{	
	if(log_enable)
		port_conf[port_id].bum_log_enable[BUM_BROADCAST] = 1;
	else
		port_conf[port_id].bum_log_enable[BUM_BROADCAST] = 0;

	if(port_conf[port_id].bum_clbk_t[BUM_BROADCAST] != (SV_TIMER_TOKEN_T)0)
	{
		if(1 == bum_debug_message)
			uprintf("sw_brd_limit_member_log Enable Cancel Timer [%p]\n", port_id);
		sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_BROADCAST]);
		port_conf[port_id].bum_clbk_t[BUM_BROADCAST] = NULL;
	}
	if (log_enable)
	{
		/*Give a moment for ACL to get programmed*/
		port_conf[port_id].bum_clbk_t[BUM_BROADCAST] = sv_set_timer(BUM_LOG_INTERVAL, ONCE_TIMER, sw_brd_limit_member_log_enable,port_id );
	}
	else
	{
		/*This disable logging*/
		sw_brd_limit_member_log_enable(port_id);
	}
}


void sw_brd_limit_log_disable(PORT_ID port_id)
{
		if(1 == bum_debug_message)
			uprintf("+++sw_brd_limit_logs_disable [%p]+++ Log enable [%d]\n",port_id, port_conf[port_id].bum_log_enable[BUM_BROADCAST]);
		sw_pp_configure_BUM_limit(port_id,BUM_BROADCAST,0,NULL);
		if(port_conf[port_id].bum_clbk_t[BUM_BROADCAST] != (SV_TIMER_TOKEN_T)0)
		{
			if(1 == bum_debug_message)
				uprintf("sw_brd_limit_log_disable Cancel Timer [%p]\n",port_id);
			sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_BROADCAST] );
			port_conf[port_id].bum_clbk_t[BUM_BROADCAST] =NULL;
		}
		if (trunk_port_state(port_id) == TRUNK_PRIMARY)
		{
			sw_cu_disable_BUM_syslog_by_trunk(port_id, BUM_BROADCAST);
		}
}
	
/*****************************************************************************
 * Function: sw_brd_limit_log_enable 
 *
 * Params: port_id 
 * Returns: VOID
 *
 * Purpose: This function will call the main function sw_BUM_suppression_enable which is common for BUM traffic
 *****************************************************************************/
void sw_brd_limit_log_enable(PORT_ID port_id)
{
        sw_BUM_suppression_enable (port_id, BUM_BROADCAST, sw_brd_limit_log_enable);
}



void sw_brd_limit_by_intf1_bytes_logs(struct cdb *sptr_cdb)
{

	UINT32 limit;
	UINT32 port_id;
	
	if (sptr_cdb->config_gen)
	{
	  	return;
    }
	if(1 == bum_debug_message)
		uprintf("+++sw_brd_limit_by_intf1_bytes_logs config +++\n");
	
	port_id = sptr_cdb->if_num - 1;
	limit = sptr_cdb->integer1;
	if (sptr_cdb->no)
    {
		if((port_conf[port_id].bum_log_enable[BUM_BROADCAST]) && !(port_conf[port_id].bum_port_dampening[BUM_BROADCAST].drop_thres))
		{
			if(((SPTR_PORT_DB(port_id))->port_config.brd_limit & 0x7fffffff)  == sptr_cdb->integer1)
			{
				if(1 == bum_debug_message)
					uprintf("sw_brd_limit_by_intf1_bytes Log Disabled\n");
				port_conf[port_id].bum_log_enable[BUM_BROADCAST] = 0;
				sw_brd_limit_log_disable(port_id);
				limit = 0;
				sw_cu_set_brd_limit_by_intf(limit, port_id);
			}
			else
			{
				uprintf("Error - Broadcast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
			}
		}
		else
		{
			uprintf("Error - Broadcast Suppression logging notification is not enabled\n");
		}

			return;
	}
	else
	{
		if (gi_check_if_mac_filtering_configured_on_port(port_id))
		{
			uprintf ("MAC-Filter is configured on port %P. Logging option is not available \n", port_id);
			return;
		}
		if(port_conf[port_id].bum_port_dampening[BUM_BROADCAST].drop_thres)
		{
			uprintf("Error - Broadcast rate-limit syslog and port dampening cannot be configured together\n");
			return;
		}
                if(!rate_limit_log_interval_configured)
                {
			uprintf("Error - Broadcast Suppression syslog feature cannot be enabled as rate-limit-log interval was configured as 0 \n");
			return;
                }
		if (!IS_CHEETAH5())
		{
			//Byte mode
			limit |= 0x80000000;
		}
		if(sptr_cdb->integer1 !=0)
		{
                        sw_cu_set_brd_limit_by_intf(limit, port_id);
			if(1 == bum_debug_message)
				uprintf("sw_brd_limit_by_intf1_bytes_logs Enable [%d]\n",sptr_cdb->integer1);
			if(port_conf[port_id].bum_clbk_t[BUM_BROADCAST] != (SV_TIMER_TOKEN_T)0)
			{
				if(1 == bum_debug_message)
					uprintf("sw_brd_limit_by_intf1_bytes_logs Enable Cancel Timer [%p]\n",port_id);
				sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_BROADCAST] );
				port_conf[port_id].bum_log_enable[BUM_BROADCAST] = 0;
				port_conf[port_id].bum_clbk_t[BUM_BROADCAST] =NULL;
				if (trunk_port_state(port_id) == TRUNK_PRIMARY)
				{
					sw_cu_disable_BUM_syslog_by_trunk(port_id, BUM_BROADCAST);
				}
			}
			
	    	port_conf[port_id].bum_log_enable[BUM_BROADCAST] = 1;
			sw_pp_configure_BUM_limit(port_id,BUM_BROADCAST,1,limit);
			port_conf[port_id].pkt_drop_count[BUM_BROADCAST] = 0;
			sw_brd_limit_log_enable(port_id);
			if (trunk_port_state(port_id) == TRUNK_PRIMARY)
			{
				sw_cu_enable_BUM_syslog_by_trunk(port_id, BUM_BROADCAST,limit);
			}
			
		}
		else
		{
			if(1 == bum_debug_message)
				uprintf("sw_brd_limit_by_intf1_bytes_logs Disable[%d]\n",sptr_cdb->integer1);
                        sw_cu_set_brd_limit_by_intf(limit, port_id);
			port_conf[port_id].bum_log_enable[BUM_BROADCAST] = 0;
			sw_brd_limit_log_disable(port_id);
		}
	}
	if(1 == bum_debug_message)
		uprintf("--sw_brd_limit_by_intf1_bytes_logs config--\n");
}

/*****************************************************************************
 * Function: sw_brd_limit_port_dampening 
 *
 * Params: struct cdb* sptr_cdb -CLI node
 * Returns: VOID
 *
 * Purpose: This function will be used to add/delete broadcast limit port Dampening feature related variables such as threshold and shutdown period
 *****************************************************************************/
void sw_brd_limit_port_dampening(struct cdb *sptr_cdb)
{
	UINT16 port;
	UINT32 thres = 0;
	UINT32 shut_period = BUM_PORT_ERRDISABLE_PERIOD;
	UINT32 limit = 0;
	UINT8 bum_type = BUM_BROADCAST;
	limit = sptr_cdb->integer1;
	limit |= 0x80000000;
	thres = sptr_cdb->integer2;
	if(sptr_cdb->num_of_integer==3)
		shut_period = sptr_cdb->integer3;

	if (end_of_token(sptr_cdb->token) != '\0')
		return;

	if (sptr_cdb->config_gen)
	{
		return;
	}

	sptr_cdb->dont_go_next = 1;
	port = sptr_cdb->if_num - 1;
        if (!IS_PORT_DB_VALID(port))
                return;
	if(sptr_cdb->no)
	{
		if(port_conf[port].bum_port_dampening[bum_type].drop_thres)
		{
			if(port_conf[port].bum_port_dampening[bum_type].shut_period == shut_period)
			{
				if(port_conf[port].bum_port_dampening[bum_type].drop_thres == thres)
				{
					if(((SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff)  == sptr_cdb->integer1)
					{
						sw_BUM_configure_port_dampening (port, BUM_BROADCAST, 0, 0,
								BUM_PORT_ERRDISABLE_PERIOD,
								FALSE, FALSE);
						limit = 0;
						sw_cu_set_brd_limit_by_intf(limit, port);
					}
					else
					{
						uprintf("Error - Broadcast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
					}
				}   
				else
				{
					uprintf("Error- Drop Threshold %u KB is not configured\n",sptr_cdb->integer2);
				}

			}
			else
			{
				uprintf("Error- Shut period %u sec is not configured\n",shut_period);
			} 
		}
		else
		{
			uprintf("Error- Broadcast Suppression Dampening is not configured\n");
		}
			return;
	}
        else
	{
		int cli_limit;
                if (gi_check_if_mac_filtering_configured_on_port(port))
                {
                        uprintf ("MAC-Filter is configured on port %P. Broadcast Suppression port-dampening option is not available \n", port);
                        return;
                }
		if(thres == 0)
		{
			uprintf("Error - Threshold value should not be zero\n");
			return;
		}           				
		if(sw_get_BUM_limit_status (port, bum_type, &cli_limit))
		{
			if (cli_limit && 
				!port_conf[port].bum_port_dampening[bum_type].drop_thres) 
			{
				uprintf("Error - Broadcast rate-limit syslog and port dampening cannot be configured together\n");
				return;
			}
		}
                sw_cu_set_brd_limit_by_intf(limit, port);
		if ((sptr_cdb->integer1 == 0) || 
			(port_conf[port].bum_port_dampening[bum_type].drop_thres != 0))
		{
			sw_BUM_configure_port_dampening (port, bum_type, limit, 0,
											 BUM_PORT_ERRDISABLE_PERIOD,
											 FALSE,FALSE);
		}
		if (sptr_cdb->integer1)
			sw_BUM_configure_port_dampening(port,bum_type,limit,thres,shut_period,!sptr_cdb->no,FALSE);
	}
}

/****************/
//Multicast 
/****************/
/*****************************************************************************
 * Function: sw_mcast_limit_log_enable 
 *
 * Params: port_id
 * Returns: Void
 *
 * Purpose: This function is used to call the common BUM Suppression enable routine
 *****************************************************************************/
void sw_mcast_limit_log_enable(PORT_ID port_id)
{
        sw_BUM_suppression_enable (port_id, BUM_MULTICAST, sw_mcast_limit_log_enable);

}

/*****************************************************************************
 * Function: sw_mcast_limit_member_log_enable 
 *
 * Params: port_id
 * Returns: Void
 *
 * Purpose: This function is used to call the common BUM Suppression enable routine for member unit
 *****************************************************************************/
void sw_mcast_limit_member_log_enable(PORT_ID port_id)
{
	sw_BUM_suppression_member_unit_log_enable (port_id, BUM_MULTICAST, sw_mcast_limit_member_log_enable);
}
	
/*****************************************************************************
 * Function: sw_mcast_limit_member_log 
 *
 * Params: port_id,log_enable
 * Returns: Void
 *
 * Purpose: This function is used to start timer for BUM_LOG_INTERVAL
 *****************************************************************************/
void sw_mcast_limit_member_log(PORT_ID port_id, int log_enable)
{	
	if(log_enable)
		port_conf[port_id].bum_log_enable[BUM_MULTICAST] = 1;
	else
		port_conf[port_id].bum_log_enable[BUM_MULTICAST] = 0;

	if(port_conf[port_id].bum_clbk_t[BUM_MULTICAST] != (SV_TIMER_TOKEN_T)0 )
	{
		if(1 == bum_debug_message)
			uprintf("sw_mcast_limit_member_log Enable Cancel Timer [%p]\n",port_id);
		sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_MULTICAST]);
		port_conf[port_id].bum_clbk_t[BUM_MULTICAST] = NULL;
	}
	if (log_enable)
	{
		/*Give a moment for ACL to get programmed*/
		port_conf[port_id].bum_clbk_t[BUM_MULTICAST] = sv_set_timer(BUM_LOG_INTERVAL, ONCE_TIMER, sw_mcast_limit_member_log_enable,port_id );
	}
	else
	{
		/*This disable logging*/
		sw_mcast_limit_member_log_enable(port_id);
	}
}

/*****************************************************************************
 * Function: sw_mcast_limit_log_disable 
 *
 * Params: port_id
 * Returns: Void
 *
 * Purpose: This function is used to disable multicast limit syslog feature
 *****************************************************************************/
void sw_mcast_limit_log_disable(PORT_ID port_id)
{
		if(1 == bum_debug_message)
			uprintf("+++sw_mcast_limit_logs_disable [%p]+++ Log enable [%d]\n",port_id, port_conf[port_id].bum_log_enable[BUM_MULTICAST]);
		
		sw_pp_configure_BUM_limit(port_id,BUM_MULTICAST,0,NULL);
		if(port_conf[port_id].bum_clbk_t[BUM_MULTICAST] != (SV_TIMER_TOKEN_T)0 )
		{
			if(1 == bum_debug_message)
				uprintf("sw_mcast_limit_log_disable Cancel Timer [%p]\n",port_id);
			sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_MULTICAST]);
			port_conf[port_id].bum_clbk_t[BUM_MULTICAST] = NULL;
		}	
 		if (trunk_port_state(port_id) == TRUNK_PRIMARY)
		{
			sw_cu_disable_BUM_syslog_by_trunk(port_id, BUM_MULTICAST);
		}
}



void sw_mcast_limit_by_intf_bytes_logs(struct cdb *sptr_cdb)
{
	UINT32 limit;
	UINT32 port_id;

	if (sptr_cdb->config_gen)
	{
	  return;
    }

	if(1 == bum_debug_message)
		uprintf("+++sw_mcast_limit_by_intf_bytes_logs +++\n");
	
	port_id = sptr_cdb->if_num - 1;
  	
        limit = sptr_cdb->integer1;
        if (hal_brd_show_bytes_error(port_id))
        {
            uprintf("Error - Multicast Limit cannot be in bytes for PUMA machines. \n");
            return;
        }
        if (sptr_cdb->no)
        {
                if((port_conf[port_id].bum_log_enable[BUM_MULTICAST]) && !(port_conf[port_id].bum_port_dampening[BUM_MULTICAST].drop_thres))
                {
                        if(((SPTR_PORT_DB(port_id))->port_config.mcast_limit & 0x7fffffff)  == sptr_cdb->integer1)
                        {
				if(1 == bum_debug_message)
					uprintf("sw_mcast_limit_by_intf_bytes Log Disabled\n");
				port_conf[port_id].bum_log_enable[BUM_MULTICAST] = 0;
				sw_mcast_limit_log_disable(port_id);
                                limit = 0;
                                sw_cu_set_mcast_limit_by_intf(limit, port_id);
                        }
                        else
                        {
                                uprintf("Error - Multicast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
                        }
                }
                else
                {
                        uprintf("Error - Multicast Suppression logging notification is not enabled\n");
                }

                        return;
        }
	else
	{
		if (gi_check_if_mac_filtering_configured_on_port(port_id))
		{
			uprintf ("MAC-Filter is configured on port %P. Logging option is not available \n", port_id);
			return;
		}
		if(port_conf[port_id].bum_port_dampening[BUM_MULTICAST].drop_thres)
		{
			uprintf("Error - Multicast rate-limit syslog and port dampening cannot be configured together\n");
			return;
		}
                if(!rate_limit_log_interval_configured)
                {
			uprintf("Error - Multicast Suppression syslog feature cannot be enabled as rate-limit-log interval was configured as 0 \n");
			return;
                }
		if (!IS_CHEETAH5())
		{
			//Byte mode
			limit |= 0x80000000; 
		}
		if(sptr_cdb->integer1 !=0)
		{
			if(1 == bum_debug_message)
				uprintf("sw_mcast_limit_by_intf_bytes_logs Enable Limit [%d]\n",sptr_cdb->integer1 );
			sw_cu_set_mcast_limit_by_intf(limit, port_id);
			if(port_conf[port_id].bum_clbk_t[BUM_MULTICAST] != (SV_TIMER_TOKEN_T)0 )
			{
				if(1 == bum_debug_message)
					uprintf("sw_mcast_limit_by_intf_bytes_logs Enable Cancel Timer [%p]\n",port_id);
				sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_MULTICAST]);
				port_conf[port_id].bum_clbk_t[BUM_MULTICAST] = NULL;
				port_conf[port_id].bum_log_enable[BUM_MULTICAST] = 0;
				if (trunk_port_state(port_id) == TRUNK_PRIMARY)
				{
					sw_cu_disable_BUM_syslog_by_trunk(port_id, BUM_MULTICAST);
				}
			}	
	    	port_conf[port_id].bum_log_enable[BUM_MULTICAST] = 1;
			sw_pp_configure_BUM_limit(port_id,BUM_MULTICAST,1,limit);
			sw_mcast_limit_log_enable(port_id);
			port_conf[port_id].pkt_drop_count[BUM_MULTICAST] = 0;
			if (trunk_port_state(port_id) == TRUNK_PRIMARY)
			{
				sw_cu_enable_BUM_syslog_by_trunk(port_id, BUM_MULTICAST,limit);
			}

		}
		else
		{
			
			if(1 == bum_debug_message)
				uprintf("sw_mcast_limit_by_intf_bytes_logs Disable Limit [%d]\n",sptr_cdb->integer1 );
			
			sw_cu_set_mcast_limit_by_intf(limit, port_id);
			port_conf[port_id].bum_log_enable[BUM_MULTICAST] = 0;
			sw_mcast_limit_log_disable(port_id);
		}
	}

	if(1 == bum_debug_message)
		uprintf("--sw_mcast_limit_by_intf_bytes_logs--\n");
}

/*****************************************************************************
 * Function: sw_mcast_limit_port_dampening 
 *
 * Params: struct cdb* sptr_cdb -CLI node
 * Returns: VOID
 *
 * Purpose: This function will be used to add/delete multicast limit port Dampening feature related variables such as threshold and shutdown period
 *****************************************************************************/
void sw_mcast_limit_port_dampening(struct cdb *sptr_cdb)
{
	UINT16 port;
	UINT32 thres = 0;
	UINT32 shut_period = BUM_PORT_ERRDISABLE_PERIOD;
	UINT32 limit = 0;
	UINT8 bum_type = BUM_MULTICAST;
	limit = sptr_cdb->integer1;
	limit |= 0x80000000;
	thres = sptr_cdb->integer2;
	if(sptr_cdb->num_of_integer==3)
		shut_period = sptr_cdb->integer3;

	if (end_of_token(sptr_cdb->token) != '\0')
		return;

	if (sptr_cdb->config_gen)
	{
		return;
	}

	sptr_cdb->dont_go_next = 1;
	port = sptr_cdb->if_num - 1;
        if (!IS_PORT_DB_VALID(port))
                return;
	if(sptr_cdb->no)
	{
		if(port_conf[port].bum_port_dampening[bum_type].drop_thres)
		{
			if(port_conf[port].bum_port_dampening[bum_type].shut_period == shut_period)
			{
				if(port_conf[port].bum_port_dampening[bum_type].drop_thres == thres)
				{
					if(((SPTR_PORT_DB(port))->port_config.mcast_limit & 0x7fffffff)  == sptr_cdb->integer1)
					{
						sw_BUM_configure_port_dampening (port, BUM_MULTICAST, 0, 0,
								BUM_PORT_ERRDISABLE_PERIOD,
								FALSE, FALSE);
						limit = 0;
						sw_cu_set_mcast_limit_by_intf(limit, port);
					}
					else
					{
						uprintf("Error - Multicast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
						return;
					}
				}
				else
				{
					uprintf("Error- Drop Threshold %u KB is not configured\n",sptr_cdb->integer2);
					return;
				}

			}
			else
			{
				uprintf("Error- Shut period %u sec is not configured\n",shut_period);
				return;
			}
		}
		else
		{
			uprintf("Error- Multicast Suppression Dampening is not configured\n");
			return;
		}
	}
	else
	{
		int cli_limit;
                if (gi_check_if_mac_filtering_configured_on_port(port))
                {
                        uprintf ("MAC-Filter is configured on port %P. Multicast Suppression port-dampening option is not available \n", port);
                        return;
                }
		if(thres == 0)
		{
			uprintf("Error - Threshold value should not be zero\n");
			return;
		}
		if(sw_get_BUM_limit_status (port, bum_type, &cli_limit))
		{
			if (cli_limit && 
				!port_conf[port].bum_port_dampening[bum_type].drop_thres)
			{
				uprintf("Error - Multicast rate-limit syslog and port dampening cannot be configured together\n");
				return;
			}
		}
                sw_cu_set_mcast_limit_by_intf(limit, port);
		if ((sptr_cdb->integer1 == 0) || 
			(port_conf[port].bum_port_dampening[bum_type].drop_thres != 0))
		{
			sw_BUM_configure_port_dampening (port, bum_type, limit, 0,
											 BUM_PORT_ERRDISABLE_PERIOD,
											 FALSE,FALSE);
		}
		if (sptr_cdb->integer1)
			sw_BUM_configure_port_dampening(port,bum_type,limit,thres,shut_period,enable,FALSE);

	}
}

/**************/
//Unknows uni cast traffic
/**************/
/*****************************************************************************
 * Function: sw_unknown_ucast_limit_log_enable 
 *
 * Params: port_id
 * Returns: VOID
 *
 * Purpose: This function will call the common routine sw_BUM_suppression_enable
 *****************************************************************************/
void sw_unknown_ucast_limit_log_enable(PORT_ID port_id)
{
        sw_BUM_suppression_enable (port_id, BUM_UNKNOWNUNICAST, sw_unknown_ucast_limit_log_enable);
}

/*****************************************************************************
 * Function: sw_unknown_ucast_limit_member_log_enable 
 *
 * Params: port_id
 * Returns: VOID
 *
 * Purpose: This function will be used to call the common routine sw_BUM_suppression_member_unit_log_enable
 *****************************************************************************/
void sw_unknown_ucast_limit_member_log_enable(PORT_ID port_id)
{
	sw_BUM_suppression_member_unit_log_enable(port_id, BUM_UNKNOWNUNICAST,
		                                      sw_unknown_ucast_limit_member_log_enable);
}

/*****************************************************************************
 * Function: sw_unknowm_ucast_limit_member_log 
 *
 * Params: port_id,log_enable
 * Returns: VOID
 *
 * Purpose: This function will be used to start timer for BUM_LOG_INTERVAL
 *****************************************************************************/
void sw_unknowm_ucast_limit_member_log(PORT_ID port_id, int log_enable)
{	
	if(log_enable)
		port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST] = 1;
	else
		port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;

	
	if(port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] != (SV_TIMER_TOKEN_T)0 )
	{
		if(1 == bum_debug_message)
			uprintf("sw_unknowm_ucast_limit_member_log Enable Cancel Timer [%p]\n",port_id);
		sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST]);
		port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] = NULL;
	}
	if (log_enable)
	{
		/*Give a moment for ACL to get programmed*/
		port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] = sv_set_timer(BUM_LOG_INTERVAL, ONCE_TIMER, sw_unknown_ucast_limit_member_log_enable,port_id );
	}
	else
	{
		/*This disable logging*/
		sw_unknown_ucast_limit_member_log_enable(port_id);
	}
}

/*****************************************************************************
 * Function: sw_unkown_ucast_limit_log_disable 
 *
 * Params: port_id
 * Returns: VOID
 *
 * Purpose: This function will be used to disable unknown unicast limit log 
 *****************************************************************************/
void sw_unkown_ucast_limit_log_disable(PORT_ID port_id)
{
		if(1 == bum_debug_message)
			uprintf("+++sw_unkown_ucast_limit_log_disable [%p]+++ Log enable [%d]\n",port_id, port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST]);
		
		sw_pp_configure_BUM_limit(port_id,BUM_UNKNOWNUNICAST,0,NULL);
		if(port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] != (SV_TIMER_TOKEN_T)0 )
		{
			if(1 == bum_debug_message)
				uprintf("sw_unkown_ucast_limit_log_disable Cancle timer [%p]\n",port_id );
			sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST]);
			port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] = NULL;
		}
		if (trunk_port_state(port_id) == TRUNK_PRIMARY)
		{
			sw_cu_disable_BUM_syslog_by_trunk(port_id, BUM_UNKNOWNUNICAST);
		}
}



void sw_unknown_unicast_limit_by_intf_bytes_log(struct cdb *sptr_cdb)
{

	UINT32 limit;
	UINT32 port_id;
	UINT8 dev_num;
	
	if (sptr_cdb->config_gen)
	{
	  return;
	}

	if(1 == bum_debug_message)
		uprintf("+++sw_unknown_unicast_limit_by_intf_bytes_log +++\n");
	
	port_id = sptr_cdb->if_num - 1;
	
		limit = sptr_cdb->integer1;
		if (hal_brd_show_bytes_error(port_id))
		{
			uprintf("Error - Unknow unicast Limit cannot be in bytes for PUMA machines. \n");
			return;
		}
        if (sptr_cdb->no)
        {
                if((port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST]) && !(port_conf[port_id].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres))
                {
                        if(((SPTR_PORT_DB(port_id))->port_config.unknown_unicast_limit & 0x7fffffff)  == sptr_cdb->integer1)
                        {
                                if(1 == bum_debug_message)
                                        uprintf("sw_unknown_unicast_limit_by_intf_bytes Log Disabled\n");
                                port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;
                                sw_unkown_ucast_limit_log_disable(port_id);
                                limit = 0;
                                sw_cu_set_unknown_unicast_limit_by_intf(limit, port_id);
                        }
                        else
                        {
                                uprintf("Error - Unknown-unicast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
                        }
                }
                else
                {
                        uprintf("Error - Unknown-unicast Suppression logging notification is not enabled\n");
                }
                        return;

        }
	else
	{
		if (gi_check_if_mac_filtering_configured_on_port(port_id))
		{
			uprintf ("MAC-Filter is configured on port %P. Logging option is not available \n", port_id);
			return;
		}
		if(port_conf[port_id].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres)
		{
			uprintf("Error - Unknown unicast rate-limit syslog and port dampening cannot be configured together\n");
			return;
		}
                if(!rate_limit_log_interval_configured)
                {
			uprintf("Error - Unknown-unicast Suppression syslog feature cannot be enabled as rate-limit-log interval was configured as 0 \n");
			return;
                }
                if (!IS_CHEETAH5())
		{
			//Byte mode
			limit |= 0x80000000; 
		}
		if(sptr_cdb->integer1 !=0)
		{
			if(1 == bum_debug_message)
				uprintf("sw_unknown_unicast_limit_by_intf_bytes_log Enabled  Limit [%d]\n", sptr_cdb->integer1);
			sw_cu_set_unknown_unicast_limit_by_intf(limit, port_id);
			if(port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] != (SV_TIMER_TOKEN_T)0 )
			{
				if(1 == bum_debug_message)
					uprintf("sw_unknown_unicast_limit_by_intf_bytes_log Enable Cancel Timer [%d]\n",sptr_cdb->integer1);
				sv_cancel_timer(port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST]);
				port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;
				port_conf[port_id].bum_clbk_t[BUM_UNKNOWNUNICAST] = NULL;
				if (trunk_port_state(port_id) == TRUNK_PRIMARY)
				{
					 sw_cu_disable_BUM_syslog_by_trunk(port_id, BUM_UNKNOWNUNICAST);
				}
			}
				
			port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST] = 1;
			sw_pp_configure_BUM_limit(port_id,BUM_UNKNOWNUNICAST,1,limit);
			sw_unknown_ucast_limit_log_enable(port_id);
			port_conf[port_id].pkt_drop_count[BUM_UNKNOWNUNICAST] = 0;
			if (trunk_port_state(port_id) == TRUNK_PRIMARY)
			{
				sw_cu_enable_BUM_syslog_by_trunk(port_id, BUM_UNKNOWNUNICAST,limit);
			}

		}
		else
		{	
			if(1 == bum_debug_message)
				uprintf("sw_unknown_unicast_limit_by_intf_bytes_log Disabled Limit [%d]\n", sptr_cdb->integer1);
			sw_cu_set_unknown_unicast_limit_by_intf(limit, port_id);
			port_conf[port_id].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;
			sw_unkown_ucast_limit_log_disable(port_id);
		}
	}
	if(1 == bum_debug_message)
		uprintf("--sw_unknown_unicast_limit_by_intf_bytes_log--\n");
}

/*****************************************************************************
 * Function: sw_unknown_unicast_limit_port_dampening 
 *
 * Params: struct cdb* sptr_cdb -CLI node
 * Returns: VOID
 *
 * Purpose: This function will be used to add/delete unknown unicast limit port Dampening feature related variables such as threshold and shutdown period
 *****************************************************************************/

void sw_unknown_unicast_limit_port_dampening(struct cdb *sptr_cdb)
{
	UINT16 port;
	UINT32 thres = 0;
	UINT32 shut_period = BUM_PORT_ERRDISABLE_PERIOD;
	UINT32 limit = 0;
	UINT8 bum_type = BUM_UNKNOWNUNICAST;
	limit = sptr_cdb->integer1;
	limit |= 0x80000000;
	thres = sptr_cdb->integer2;
	if(sptr_cdb->num_of_integer==3)
		shut_period = sptr_cdb->integer3;

	if (end_of_token(sptr_cdb->token) != '\0')
		return;

	if (sptr_cdb->config_gen)
	{
		return;
	}
	
	sptr_cdb->dont_go_next = 1;
	port = sptr_cdb->if_num - 1;
	if (!IS_PORT_DB_VALID(port))
		return;
	if(sptr_cdb->no)
	{
		if(port_conf[port].bum_port_dampening[bum_type].drop_thres)
		{
			if(port_conf[port].bum_port_dampening[bum_type].shut_period == shut_period)
			{
				if(port_conf[port].bum_port_dampening[bum_type].drop_thres == thres)
				{
					if(((SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff)  == sptr_cdb->integer1)
					{
						sw_BUM_configure_port_dampening (port, BUM_UNKNOWNUNICAST, 0, 0,
								BUM_PORT_ERRDISABLE_PERIOD,
								FALSE, FALSE);
						limit = 0;
						sw_cu_set_unknown_unicast_limit_by_intf(limit, port);
					}
					else
					{
						uprintf("Error - Unknown-unicast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
						return;
					}
				}
				else
				{
					uprintf("Error- Drop Threshold %u KB is not configured\n",sptr_cdb->integer2);
					return;
				}

			}
			else
			{
				uprintf("Error- Shut period %u sec is not configured\n",shut_period);
				return;
			}
		}
		else
		{
			uprintf("Error- Unknown-Unicast Suppression Dampening is not configured\n");
			return;
		}
	}
	else
	{
		int cli_limit;
                if (gi_check_if_mac_filtering_configured_on_port(port))
                {
                        uprintf ("MAC-Filter is configured on port %P. Unknown-unicast Suppression port-dampening option is not available \n", port);
                        return;
                }

		if(thres == 0)
		{
			uprintf("Error - Threshold value should not be zero\n");
			return;
		}
		if(sw_get_BUM_limit_status (port, bum_type, &cli_limit))
		{
			if (cli_limit && 
				!port_conf[port].bum_port_dampening[bum_type].drop_thres) 
			{
				uprintf("Error - Unknown unicast rate-limit syslog and port dampening cannot be configured together\n");
				return;
			}
		}
		sw_cu_set_unknown_unicast_limit_by_intf(limit, port);	
		if ((sptr_cdb->integer1 == 0) || 
			(port_conf[port].bum_port_dampening[bum_type].drop_thres != 0))
		{
			sw_BUM_configure_port_dampening (port, bum_type, limit, 0,
											 BUM_PORT_ERRDISABLE_PERIOD,
											 FALSE,FALSE);
		}
		if (sptr_cdb->integer1)
			sw_BUM_configure_port_dampening(port,bum_type,limit,thres,shut_period,!sptr_cdb->no,FALSE);

	}
}


/*BUM suppression - common routines*/

/*****************************************************************************
 * Function: sw_BUM_clear_all_counter 
 *
 * Params: port_id 
 * Returns: VOID
 *
 * Purpose: This function clears counter
 *****************************************************************************/
void sw_BUM_clear_all_counter(PORT_ID port_id)
{
	
	if (PORT_TO_STACK_ID(port_id) != MY_BOOTUP_STACK_ID)
		StackBumClearStatToStack (PORT_TO_STACK_ID(port_id), port_id);
	else
		sw_BUM_clear_all_counter_by_port( port_id);

	if (trunk_port_state(port_id) == TRUNK_PRIMARY)
	{
		int number_of_ports=0;
		PORT_ID *port_list, port;
		int i;
		
		is_trunk_port(port_id, FALSE, &number_of_ports, &port_list);
		
		for (i=0; i<number_of_ports; i++)
		{
			port = port_list[i];
			if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))  //coverity 51479
				continue;
			 
			if (port == port_id)
				 continue;
			 
			if (PORT_TO_STACK_ID(port) != MY_BOOTUP_STACK_ID)
				StackBumClearStatToStack (PORT_TO_STACK_ID(port), port);
			else
				sw_BUM_clear_all_counter_by_port( port);
		
		}

	}

}


/*****************************************************************************
 * Function: sw_BUM_errdisable_port 
 *
 * Params: bum_type,port_id 
 * Returns: VOID
 *
 * Purpose: This function will err-disabe the port when the BUM limit exceeds the threshold configured
 *****************************************************************************/
void sw_BUM_errdisable_port(int bum_type, PORT_ID port_id)
{
	char *keyword[3] = {"Broadcast", "Multicast", "Unknown-unicast"};

 	if (!port_conf[port_id].is_BUM_port_shut)
 	{
 		port_conf[port_id].is_BUM_port_shut = TRUE;

/*if shut period is 0 port is not added to the list so that it wont be revisited for re-enable*/
		if(port_conf[port_id].bum_port_dampening[bum_type].shut_period != 0)
			sw_BUM_update_port_shutdown_list(bum_type,port_id);
		if (is_mgmt_active())
		{
			UINT8 *sptr_port_name;
                        sptr_port_name = cu_get_port_name(port_id, NULL);
			if(!sptr_port_name)
			{
				ksprintf(cu_line_buf, 
						"Rate-limit:Interface %P was err-disabled due to ingress %s traffic exceeded threshold value [%u] KB\n",
						port_id,
						keyword[bum_type],
						port_conf[port_id].bum_port_dampening[bum_type].drop_thres);
			}
			else
			{
				ksprintf(cu_line_buf,
						"Rate-limit:Interface %s %P was err-disabled due to ingress %s traffic exceeded threshold value [%u] KB\n",
						sptr_port_name,port_id,
						keyword[bum_type],
						port_conf[port_id].bum_port_dampening[bum_type].drop_thres);
			}
			cu_logging_generic(cu_line_buf, TRUE, CU_LOGGING_TYPE_WARNINGS);
			cu_set_port_errdisable (port_id, NULL_VLAN_ID, ERRDISABLE_BCAST_THRESHOLD_EXCEEDED+bum_type);

			sw_BUM_clear_all_counter ( port_id);
		}
	}
}

/*****************************************************************************
 * Function: sw_BUM_update_errdisable_port_list 
 *
 * Params: port_id
 * Returns: VOID
 *
 * Purpose: This function will update the err-disabled port list due to BUM traffic
 *****************************************************************************/
void sw_BUM_update_errdisable_port_list (PORT_ID port)
{
	if (!STACK_AM_I_STANDBY)
		return;

	if ( (!IS_PORT_DB_VALID(port)) || (trunk_port_state(port) == TRUNK_SECONDARY) )
		return;
	
	if ((SPTR_PORT_DB(port))->port_config.errdisable_on)
	{
		enum PORT_ERR_DISABLE_REASON errdisable_reason = (SPTR_PORT_DB(port))->port_config.errdisable_reason;
		if (errdisable_reason == ERRDISABLE_BCAST_THRESHOLD_EXCEEDED)
		{
			sw_BUM_errdisable_port (BUM_BROADCAST, port);
		}
		else if (errdisable_reason == ERRDISABLE_MCAST_THRESHOLD_EXCEEDED)
		{
			sw_BUM_errdisable_port (BUM_MULTICAST, port);
		}
		else if (errdisable_reason == ERRDISABLE_UNKNOWN_UCAST_THRESHOLD_EXCEEDED)
		{
			sw_BUM_errdisable_port (BUM_UNKNOWNUNICAST, port);
		}
	}

}

/*****************************************************************************
 * Function: sw_BUM_suppression_port_damp 
 *
 * Params: port_id,bum_type,dropped_pkt
 * Returns: VOID
 *
 * Purpose: This function will be used to compare the dropped packet count with the threshold configured
 *****************************************************************************/
void sw_BUM_suppression_port_damp(PORT_ID port,UINT8 bum_type, UINT64 dropped_pkt)
{
    char *keyword[3] = {"Broadcast" ,"Multicast", "Unknown-unicast"};
	if (trunk_port_state(port) == TRUNK_NONE)
    {
		 if(port_conf[port].bum_port_dampening[bum_type].drop_thres && 
		   (dropped_pkt >= port_conf[port].bum_port_dampening[bum_type].drop_thres))
	    {
	       sw_BUM_errdisable_port(bum_type,port);
	    }
    }
	else
	{
		sw_BUM_update_drop_count_trunk (port, bum_type, dropped_pkt);
	}

}

/*****************************************************************************
 * Function: BUM_shut_timer_call_back 
 *
 * Params: NONE
 * Returns: VOID
 *
 * Purpose: This is bum shut timer call back from where the port is re-enabled 
 *****************************************************************************/
void BUM_shut_timer_call_back()
{
	bum_shutdown_port_age_list *shut_port_list;
	bum_shutdown_port_age_list *remove_node;
	PORT_ID port;
	UINT8 bum_type;
	shut_port_list = shutdown_port_age_list;
	while (shut_port_list!=NULL)
	{
		port = shut_port_list->port_id;
		bum_type = shut_port_list->bum_type;
		shut_port_list->age += 30;
		if (shut_port_list->age >= port_conf[port].bum_port_dampening[bum_type].shut_period)
		{

			port_conf[port].is_BUM_port_shut = FALSE;
			remove_node = shut_port_list;
			if (shut_port_list->prev)
			{
				shut_port_list->prev->next = shut_port_list->next;
			}
			else
			{
				shutdown_port_age_list= shut_port_list->next;
			}

			if (shut_port_list->next)
			{
				shut_port_list->next->prev = shut_port_list->prev;
			}
			shut_port_list=shut_port_list->next;
			dy_free(remove_node);
			/*enable the port */
                        if (trunk_port_state(port) == TRUNK_NONE)
                        {
			cu_do_set_port_partition(port, PORT_DISABLE);
			cu_do_set_port_partition(port, PORT_ENABLE);
                        }
			else
			{
				sw_BUM_enable_errdisable_port_by_trunk (port);
			}
		}
		else
		{
			shut_port_list = shut_port_list->next;
		}
	}
	if((shutdown_port_age_list==NULL) && (bum_shut_clk_t != (SV_TIMER_TOKEN_T)0))
	{
		sv_cancel_timer(bum_shut_clk_t);
		bum_shut_clk_t = NULL;
	}
}


void show_BUM_shut_list(struct cdb *sptr_cdb)
{
 sptr_cdb->dont_go_next = 1;
 bum_shutdown_port_age_list *shut_port_list = shutdown_port_age_list;
 while(shut_port_list != NULL)
 {
  uprintf("\n Address %x PORT-ID  %p age %u bum_type %u next_addr %x prev_addr %x\n",
              shut_port_list,shut_port_list->port_id,shut_port_list->age,
              shut_port_list->bum_type,shut_port_list->next,shut_port_list->prev);
  shut_port_list= shut_port_list->next;
 }        
}

/*************************************************************************************/
/* sw_BUM_update_port_shutdown_list: Add the port to shutdown list, so that it will  */
/* be visited by timer.                                                              */
/*                                                                                   */
/* Return TRUE if port ID is added successfully. Otherwise FALSE.                    */
/*************************************************************************************/
static enum BOOLEAN sw_BUM_update_port_shutdown_list(int bum_type,PORT_ID port_id)
{
   bum_shutdown_port_age_list *shutdown_port;
   bum_shutdown_port_age_list *shutdown_port_add;
   shutdown_port =  shutdown_port_age_list;

   while (shutdown_port)
   {
      if (shutdown_port->port_id == port_id)
      {
          return FALSE;
      }
      shutdown_port = shutdown_port->next;
   }

   shutdown_port_add = (bum_shutdown_port_age_list *)dy_malloc_zero(sizeof(bum_shutdown_port_age_list));

   if (shutdown_port_add == NULL)
   {
       uprintf("Fatal Error: Memory allocation failed in pms_add_to_shutdown_list\n");
	   return FALSE;
   }
   shutdown_port_add->port_id = port_id;
   shutdown_port_add->bum_type = bum_type;
   shutdown_port_add->age = 0;
   shutdown_port_add->prev = NULL;
   shutdown_port_add->next = NULL;
   if(shutdown_port_age_list == NULL)
   {
       shutdown_port_age_list = shutdown_port_add;
       shutdown_port_age_list->next = NULL;
       shutdown_port_age_list->prev = NULL;
	   bum_shut_clk_t = sv_set_timer(30*SECOND, REPEAT_TIMER, BUM_shut_timer_call_back, 0);
   }
   else
   {
       shutdown_port_add->prev = NULL;
       shutdown_port_add->next = shutdown_port_age_list;
	   shutdown_port_age_list->prev = shutdown_port_add;
       shutdown_port_age_list = shutdown_port_add;
    }
    return TRUE;

}

/*****************************************************************************
 * Function: sw_BUM_remove_port_from_errdisable_list 
 *
 * Params: port_id 
 * Returns: VOID
 *
 * Purpose: This routine is used to remove the port from error-disabled state
 *****************************************************************************/
void sw_BUM_remove_port_from_errdisable_list (PORT_ID port_id)
{
	bum_shutdown_port_age_list *shutdown_port,*remove_node = NULL;
	shutdown_port =  shutdown_port_age_list;

	port_conf[port_id].is_BUM_port_shut = 0;
	while (shutdown_port)
	{
		if (shutdown_port->port_id == port_id)
		{
			remove_node = shutdown_port;
			break;
		}
		shutdown_port=shutdown_port->next;
	}
	if (remove_node)
	{
		if (remove_node->prev)
		{
			remove_node->prev->next = remove_node->next;
		}
		else
		{
			shutdown_port_age_list = remove_node->next;
		}
		
		if (remove_node->next)
		{
			remove_node->next->prev = remove_node->prev;
		}
		dy_free (remove_node);
		if (trunk_port_state(port_id) == TRUNK_NONE)
		{
			cu_do_set_port_partition(port_id, PORT_DISABLE);
			cu_do_set_port_partition(port_id, PORT_ENABLE);
		}
		else
		{
			sw_BUM_enable_errdisable_port_by_trunk (port_id);
		}
		if((shutdown_port_age_list==NULL) && (bum_shut_clk_t != (SV_TIMER_TOKEN_T)0))
		{
		   sv_cancel_timer(bum_shut_clk_t);
		   bum_shut_clk_t = NULL;
		}
	}

}

void sw_BUM_enable_errdisable_port_by_trunk ( UINT16 port_id)
{

	int number_of_ports=0;
	PORT_ID *port_list, port;
	int i;

	is_trunk_port(port_id, FALSE, &number_of_ports, &port_list);

	for (i=0; i<number_of_ports; i++)
	{
		port = port_list[i];
		if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))  //coverity 51480
			continue;
		if((SPTR_PORT_DB(port))->port_config.errdisable_on && 
                   ((SPTR_PORT_DB(port))->port_config.errdisable_reason == ERRDISABLE_BCAST_THRESHOLD_EXCEEDED || 
                   (SPTR_PORT_DB(port))->port_config.errdisable_reason == ERRDISABLE_MCAST_THRESHOLD_EXCEEDED || 
                   (SPTR_PORT_DB(port))->port_config.errdisable_reason == ERRDISABLE_UNKNOWN_UCAST_THRESHOLD_EXCEEDED))
		{
			cu_do_set_port_partition(port, PORT_DISABLE);
			cu_do_set_port_partition(port, PORT_ENABLE);
		}

	}
}
/*****************************************************************************
 * Function: sw_BUM_suppression_member_unit_log_enable 
 *
 * Params: port_id,bum_type,callback
 * Returns: VOID
 *
 * Purpose: This routine is used for BUM suppression syslog in member unit
 *****************************************************************************/
void sw_BUM_suppression_member_unit_log_enable(PORT_ID port_id, UINT8 bum_type, void* callback)
{
	UINT64 red_packet = 0;
	char *log_msg = cu_line_buf;
	char *limit[3]={"Broadcast", "Multicast", "Unknown unicast"}; 
        INT8 ret_val =0;
        UINT32 converted_value= 0;
        char *unit ="\0";
	
	if(1 == bum_debug_message)
		kprintf("+++sw_BUM_suppression_member_unit_log_enable+++");
	
	if(port_conf[port_id].bum_log_enable[bum_type]== 1)
	{
		ret_val = sw_l2_get_BUM_Rp_statistics(port_id, bum_type, 0,&red_packet);
		if((ret_val == TRUE) && red_packet > 0 )
		{
			if(1 == bum_debug_message)
			   kprintf("Interface %p reached the %s limit and [%u] kB are dropped\n", port_id, 
                                        limit[bum_type], (UINT32)(red_packet/1024));
			red_packet = red_packet/1024;
		        red_packet_unit_conversion(red_packet,&converted_value,&unit);	
			ksprintf(log_msg, "Interface %P reached the %s limit and [%u] %s are dropped\n", 
                                         port_id, limit[bum_type],converted_value,unit);
			StackBumSyslogToMaster(log_msg, bum_type+1, port_id,red_packet);
		}
		else if (ret_val == -2)
		{
			if (!sw_BUM_check_ACL_configured(port_id, bum_type))
			{
				port_conf[port_id].bum_log_enable[bum_type] = 0;
				port_conf[port_id].bum_clbk_t[bum_type] = NULL;
				return;
			}
		}
		if(1 == bum_debug_message)
			uprintf("Member %s timer started for [%p] log interval [%d] min \n",limit[bum_type], port_id,rate_limit_log_interval);

		port_conf[port_id].bum_clbk_t[bum_type] = sv_set_timer(BUM_LOG_INTERVAL * rate_limit_log_interval, ONCE_TIMER, callback,port_id );
	}
	else
	{
		port_conf[port_id].bum_log_enable[bum_type] = 0;
		BUM_reset_rate_limit_enabled_flag(port_id,bum_type);
	}
	if(1 == bum_debug_message)
		kprintf("---sw_BUM_suppression_member_unit_log_enable---");
}

/*****************************************************************************
 * Function: sw_port_dampening_disable 
 *
 * Params: port,bum_type,trunk_oper
 * Returns: VOID
 *
 * Purpose: This routine is used to disable port_dampening
 *****************************************************************************/
void sw_port_dampening_disable(UINT16 port,int bum_type,enum BOOLEAN trunk_oper)
{ 
        if (trunk_oper == FALSE)
        {
        sw_pp_configure_BUM_limit(port,bum_type,0,NULL);
        }
	if(port_conf[port].bum_clbk_t[bum_type] != (SV_TIMER_TOKEN_T)0)
	{
		sv_cancel_timer(port_conf[port].bum_clbk_t[bum_type] );
		port_conf[port].bum_clbk_t[bum_type] =NULL;
	}
	sw_port_errdisable_recover(port,bum_type);
       
}
/*****************************************************************************
 * Function: sw_port_errdisable_recover 
 *
 * Params: port,bum_type
 * Returns: VOID
 *
 * Purpose: This routine will recover the port from err-disable based on bum-type
 *****************************************************************************/
void sw_port_errdisable_recover(UINT16 port,int bum_type)
{
	if(bum_type == BUM_BROADCAST)
	{
		if((SPTR_PORT_DB(port))->port_config.errdisable_on && (SPTR_PORT_DB(port))->port_config.errdisable_reason == ERRDISABLE_BCAST_THRESHOLD_EXCEEDED)
			sw_BUM_remove_port_from_errdisable_list (port);
	}
	else if (bum_type == BUM_MULTICAST)
	{
		if((SPTR_PORT_DB(port))->port_config.errdisable_on && (SPTR_PORT_DB(port))->port_config.errdisable_reason == ERRDISABLE_MCAST_THRESHOLD_EXCEEDED)
			sw_BUM_remove_port_from_errdisable_list (port);
	}
	else
	{
		if((SPTR_PORT_DB(port))->port_config.errdisable_on && (SPTR_PORT_DB(port))->port_config.errdisable_reason == ERRDISABLE_UNKNOWN_UCAST_THRESHOLD_EXCEEDED)
			sw_BUM_remove_port_from_errdisable_list (port);
	}
}
/*****************************************************************************
 * Function: sw_BUM_configure_port_dampening 
 *
 * Params: port,type,limit,thres,shut_period,enable
 * Returns: VOID
 *
 * Purpose: This function will be used to configure BUM Suppression-port dampening feature
 *****************************************************************************/
void sw_BUM_configure_port_dampening(UINT16 port,int type,UINT32 limit,UINT32 thres,
                                               UINT32 shut_period, UINT8 enable, UINT8 trunk_oper)
{

	if (enable)
		port_conf[port].bum_log_enable[type] = 1;
	else
		port_conf[port].bum_log_enable[type] = 0;
	
	port_conf[port].bum_port_dampening[type].drop_thres= thres;
	port_conf[port].bum_port_dampening[type].shut_period= shut_period;
	if (enable)
	{
		if(port_conf[port].bum_clbk_t[type] != (SV_TIMER_TOKEN_T)0)
		{
			sv_cancel_timer(port_conf[port].bum_clbk_t[type]);
			port_conf[port].bum_clbk_t[type] = NULL;
		}
		sw_pp_configure_BUM_limit (port,type,1,limit);
		if (type == BUM_BROADCAST)
			sw_brd_limit_log_enable(port);
		else if (type == BUM_MULTICAST)
			sw_mcast_limit_log_enable(port);
		else if (type == BUM_UNKNOWNUNICAST)
			sw_unknown_ucast_limit_log_enable(port);
	}
	else
	{
		sw_port_dampening_disable(port,type,trunk_oper);
	}

	if ( (trunk_port_state(port) == TRUNK_PRIMARY) && (FALSE == trunk_oper))
	{
		if (enable)
			sw_cu_enable_BUM_port_dampening_by_trunk (port, type, limit);
		else
			sw_cu_disable_BUM_port_dampening_by_trunk (port, type);
	}

}

/*****************************************************************************
 * Function: sw_BUM_clear_all_counter_by_port 
 *
 * Params: port_id
 * Returns: VOID
 *
 * Purpose: This function will clear all the BUM counters 
 *****************************************************************************/
void sw_BUM_clear_all_counter_by_port (PORT_ID port_id)
{
	UINT8 bum_type;
        UINT64 red_bytes =0;
	for (bum_type = BUM_BROADCAST; bum_type<BUM_UNKNOWNUNICAST+1; bum_type++)
	{
		if (port_conf[port_id].bum_log_enable[bum_type])
		{
			/* This clears counter*/
			sw_l2_get_BUM_Rp_statistics(port_id, bum_type, 0,&red_bytes);
		}
	}
}

/*****************************************************************************
 * Function: sw_BUM_suppression_enable 
 *
 * Params: port_id,bum_type,callback
 * Returns: VOID
 *
 * Purpose: This function is used for both BUM Suppression- sylog and port-dampening feature.
 *****************************************************************************/
void sw_BUM_suppression_enable(PORT_ID port_id, UINT8 bum_type, void *callback)
{
	INT8 ret_val =0;
	UINT64 red_packet = 0;
	char *log_msg = cu_line_buf;
	UINT64 dropped_pkt_cnt = 0;
	char *limit[3]={"Broadcast", "Multicast", "Unknown unicast"};
	UINT32 converted_value=0;
	char *unit = "\0";

        port_conf[port_id].bum_clbk_t[bum_type] = NULL;

	if(MY_BOOTUP_STACK_ID ==  PORT_TO_STACK_ID(port_id) || STACK_AM_I_STANDALONE)
	{
		if(1 == bum_debug_message)
		{
			uprintf("\n+++ sw_brd_limit_log_enable [%p]+++ Log Enable [%d]\n",port_id, port_conf[port_id].bum_log_enable[bum_type]);
		}

		if(port_conf[port_id].bum_log_enable[bum_type] == 1)
		{
            if(trunk_port_state(port_id) == TRUNK_PRIMARY && port_id >= LAG_START_PORT && port_id < LAG_END_PORT){
                red_packet = 0;
                ret_val = TRUE;
            }
            else
                ret_val = sw_l2_get_BUM_Rp_statistics(port_id, bum_type, 0,&red_packet);
			if((ret_val == TRUE) && red_packet >= 0 )
			{
				
				if(STACK_AM_I_MASTER || STACK_AM_I_STANDALONE)
				{
					if (trunk_port_state(port_id) == TRUNK_SECONDARY)
					{
						sw_BUM_update_drop_count_trunk(port_id, bum_type,red_packet/1024);
					}
					else
					{
						if ((trunk_port_state(port_id) == TRUNK_PRIMARY) &&
							!sw_BUM_get_drop_count_trunk(port_id, bum_type, &dropped_pkt_cnt))
						{
							dropped_pkt_cnt = 0;
						}

						red_packet = red_packet/1024 + dropped_pkt_cnt;

						if (red_packet > 0)
						{
							if ((!port_conf[port_id].bum_port_dampening[bum_type].drop_thres) && 
                                                            (rate_limit_log_interval_configured !=0))
							{
								red_packet_unit_conversion(red_packet,&converted_value,&unit);	
								ksprintf(log_msg, 
							        "Interface %P reached the %s limit and [%u] %s are dropped\n", 
										port_id, limit[bum_type],converted_value,unit);
								cu_logging_generic(log_msg, TRUE, CU_LOGGING_TYPE_INFORMATIONAL);
								send_ratelimit_trap(bum_type+1, log_msg);
							}
							else if (red_packet> port_conf[port_id].bum_port_dampening[bum_type].drop_thres)
							{
                                sw_BUM_errdisable_port(bum_type,port_id);	
							}
						}
					}
				}
				else
				{
					if (red_packet > 0)
					{
						red_packet = red_packet/1024;
                                                                
						if (!port_conf[port_id].bum_port_dampening[bum_type].drop_thres)
						{
                                                           red_packet_unit_conversion(red_packet,&converted_value,&unit);
                                                           ksprintf(log_msg, 
                                                           "Interface %P reached the %s limit and [%u] %s are dropped\n", 
                                                           port_id, limit[bum_type], converted_value,unit);
	 						
                                                           StackBumSyslogToMaster(log_msg, bum_type+1, port_id,red_packet);
						}
						else 
						{
                                                           red_packet_unit_conversion(red_packet,&converted_value,&unit);
                                                           StackBumSyslogToMaster(log_msg, bum_type+1, port_id,red_packet);		
						}
					}
				}
			}
			if(1 == bum_debug_message)
				uprintf("Broadcast timer started for [%p] log interval [%d] min port_s[%d]\n", port_id,rate_limit_log_interval,IS_PORT_UP(port_id));
			port_conf[port_id].bum_clbk_t[bum_type] = sv_set_timer(BUM_LOG_INTERVAL * rate_limit_log_interval , ONCE_TIMER, callback,port_id);
		}
		
		if(1 == bum_debug_message)
			uprintf("--sw_brd_limit_log_enable--\n");
	}
	else if (trunk_port_state(port_id) == TRUNK_PRIMARY)
	{
		if(port_conf[port_id].bum_log_enable[bum_type] == 1)
		{
			if (STACK_AM_I_MASTER)
			{
				if (sw_BUM_get_drop_count_trunk (port_id, 
									   bum_type,
 									   &dropped_pkt_cnt))
				{
					if (dropped_pkt_cnt > 0)
					{
						if ((!port_conf[port_id].bum_port_dampening[bum_type].drop_thres)&&
                                                    (rate_limit_log_interval_configured!=0))
						{
        					        red_packet_unit_conversion(dropped_pkt_cnt,&converted_value,
                                                                                  &unit);
						        ksprintf(log_msg, 
                                                                 "Interface %P reached the %s limit and [%u] %s are dropped\n", 
                                                                 port_id, limit[bum_type],converted_value,unit);
							cu_logging_generic(log_msg,TRUE, CU_LOGGING_TYPE_INFORMATIONAL);
							send_ratelimit_trap(bum_type+1, log_msg);
						}
						else if (dropped_pkt_cnt > port_conf[port_id].bum_port_dampening[bum_type].drop_thres)
						{	
                            sw_BUM_errdisable_port(bum_type,port_id);
						}
					}
				}
			}
			port_conf[port_id].bum_clbk_t[bum_type] = sv_set_timer(BUM_LOG_INTERVAL * rate_limit_log_interval , ONCE_TIMER, callback,port_id);
		}

	}

}
/*****************************************************************************
 * Function: sw_get_BUM_limit_status 
 *
 * Params: struct cdb* sptr_cdb -CLI node
 * Returns: TRUE or FALSE
 *
 * Purpose: This function is used to get the BUM limit status 
 *****************************************************************************/

enum BOOLEAN sw_get_BUM_limit_status (PORT_ID port_id, UINT8 bum_type, UINT32 *cli_limit)
{
	*cli_limit = 0;
	if (!IS_PORT_DB_VALID(port_id))
		return FALSE;
	
	if (port_conf[port_id].bum_log_enable[bum_type])
	{
		if (bum_type == BUM_BROADCAST)
			*cli_limit = (SPTR_PORT_DB(port_id))->port_config.brd_limit;
		else if (bum_type == BUM_MULTICAST)
			*cli_limit = (SPTR_PORT_DB(port_id))->port_config.mcast_limit;
		else if (bum_type == BUM_UNKNOWNUNICAST)
			*cli_limit = (SPTR_PORT_DB(port_id))->port_config.unknown_unicast_limit;
		else 
			return FALSE;
	}
	return (port_conf[port_id].bum_log_enable[bum_type]);
}


/**
 * 
 * @name sw_cu_enable_BUM_syslog_by_trunk 
 * 
 * @details When BUM-syslogging is enabled on a trunk, this API
 *              configures the feature to secondary  ports
 * @param IN   Port_id - Primary port of the LAG
 *                    bum_type - indicates Broadcast/unknown-unicast/member type
 *                   
 **/


void sw_cu_enable_BUM_syslog_by_trunk ( UINT16 port_id, UINT8 bum_type, UINT32 limit)
{

    int number_of_ports=0;
    PORT_ID *port_list, port;
    int i;

    is_trunk_port(port_id, FALSE, &number_of_ports, &port_list);

    for (i=0; i<number_of_ports; i++)
    {
        port = port_list[i];
        if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port)) 
            continue;
        if (port == port_id)
            continue;
        port_conf[port].bum_log_enable[bum_type] = 1;
		port_conf[port].pkt_drop_count[bum_type] = 0;
        if (bum_type == BUM_BROADCAST)
             sw_brd_limit_log_enable (port);
        else if (bum_type == BUM_MULTICAST)
             sw_mcast_limit_log_enable(port);
        else if (bum_type == BUM_UNKNOWNUNICAST)
             sw_unknown_ucast_limit_log_enable(port);

    }
}

/**
 * 
 * @name sw_cu_disable_BUM_syslog_by_trunk 
 * 
 * @details When BUM-syslogging is disabled on a trunk, this API
 *              unconfigures the feature in secondary  ports
 * @param IN   Port_id - Primary port of the LAG
 *                    bum_type - indicates Broadcast/unknown-unicast/member type
 *                   
 **/

void sw_cu_disable_BUM_syslog_by_trunk ( UINT16 port_id, UINT8 bum_type)
{

    int number_of_ports=0;
    PORT_ID *port_list, port;
    int i;

    is_trunk_port(port_id, FALSE, &number_of_ports, &port_list);

    for (i=0; i<number_of_ports; i++)
    {
        port = port_list[i];
        if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))  /* coverity 51434 */
            continue;
	    if (port == port_id)
		    continue;

    	port_conf[port].bum_log_enable[bum_type] = 0;
	    if(port_conf[port].bum_clbk_t[bum_type])
    	{
	        sv_cancel_timer(port_conf[port].bum_clbk_t[bum_type]);
    	    port_conf[port].bum_clbk_t[bum_type] = NULL;
	    }
    }
}

/**
 * 
 * @name sw_cu_enable_BUM_port_dampening_by_trunk 
 * 
 * @details When BUM-port-dampening is enabled on a trunk, this API
 *              configures the feature to secondary  ports
 * @param IN   Port_id - Primary port of the LAG
 *                    bum_type - indicates Broadcast/unknown-unicast/member type
 *                    limit - rate-limit in kbps
 *                   
 **/


void sw_cu_enable_BUM_port_dampening_by_trunk ( UINT16 port_id, UINT8 bum_type, UINT32 limit)
{

    int number_of_ports=0;
    PORT_ID *port_list, port;
    int i;
	UINT32 thres;
	UINT32 shut_period;
	
	thres = port_conf[port_id].bum_port_dampening[bum_type].drop_thres;
	shut_period = port_conf[port_id].bum_port_dampening[bum_type].shut_period;

    is_trunk_port(port_id, FALSE, &number_of_ports, &port_list);

    for (i=0; i<number_of_ports; i++)
    {
        port = port_list[i];
        if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))
            continue;
		
        if (port == port_id)
            continue;
		
		sw_BUM_configure_port_dampening(port,bum_type,
		                                limit,thres,shut_period,
			                            1 /*ENABLE*/, TRUE);

    }
}

/**
 * 
 * @name sw_cu_disable_BUM_port_dampening_by_trunk 
 * 
 * @details When BUM-port-dampening is disabled on a trunk, this API
 *              unconfigures the feature in secondary  ports
 * @param IN   Port_id - Primary port of the LAG
 *                    bum_type - indicates Broadcast/unknown-unicast/member type
 *                   
 **/

void sw_cu_disable_BUM_port_dampening_by_trunk ( UINT16 port_id, UINT8 bum_type)
{

    int number_of_ports=0;
    PORT_ID *port_list, port;
    int i;

    is_trunk_port(port_id, FALSE, &number_of_ports, &port_list);

    for (i=0; i<number_of_ports; i++)
    {
        port = port_list[i];
        if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))
            continue;
	    if (port == port_id)
		    continue;

		sw_BUM_configure_port_dampening (port, bum_type, 0, 0,
										 BUM_PORT_ERRDISABLE_PERIOD,
										 0 /*DISABLE*/, TRUE);

    }
}


/*BUM - Trunk*/
/*****************************************************************************
 * Function: sw_BUM_get_drop_count_trunk 
 *
 * Params: port_id,bum_type,*dropped_pkt_count
 * Returns: TRUE or FALSE
 *
 * Purpose: This function is used to get the BUM dropped packet count
 *****************************************************************************/
enum BOOLEAN sw_BUM_get_drop_count_trunk (PORT_ID port_id, UINT8 bum_type, UINT64 *dropped_pkt_count)
{
	PORT_ID primary_port;

	if (trunk_port_state(port_id) == TRUNK_NONE)
	{
		if(1 == bum_debug_message)
			debug_uprintf("sw_BUM_get_drop_count_trunk called when port is not in trunk %P\n",port_id);
		return 0;
	}
	if (bum_type > BUM_UNKNOWNUNICAST)
	{
		if(1 == bum_debug_message)
			debug_uprintf("sw_BUM_get_drop_count_trunk called invalid bum_type %P %d\n",port_id, bum_type);
		return 0;
	}
	primary_port = trunk_primary_port (port_id);
	if (primary_port > MAX_PORT)
	{
		if(1 == bum_debug_message)
			debug_uprintf("sw_BUM_get_drop_count_trunk Primary port validation failed %p %P\n",port_id, primary_port);
		return 0;
	}

	*dropped_pkt_count = port_conf[primary_port].pkt_drop_count[bum_type];
	port_conf[primary_port].pkt_drop_count[bum_type] = 0;
	if(1 == bum_debug_message)
		debug_uprintf("sw_BUM_get_drop_count_trunk %p %p %X\n",port_id, primary_port,*dropped_pkt_count );
		
	return 1;
	
}
/*****************************************************************************
 * Function: sw_BUM_update_drop_count_trunk 
 *
 * Params: port_id,bum_type,dropped_pkt_count
 * Returns: TRUE or FALSE
 *
 * Purpose: This function is used to update the BUM dropped packet count for trunk
 *****************************************************************************/

void sw_BUM_update_drop_count_trunk (PORT_ID port_id, UINT8 bum_type, UINT64 dropped_pkt_count)
{
	PORT_ID primary_port;


	if (trunk_port_state(port_id) == TRUNK_NONE)
	{
		if(1 == bum_debug_message)
			debug_uprintf("sw_BUM_update_drop_count_trunk called when port is not in trunk %p\n",port_id);
		return;
	}
	if (bum_type > BUM_UNKNOWNUNICAST)
	{
		if(1 == bum_debug_message)
			debug_uprintf("sw_BUM_update_drop_count_trunk called invalid bum_type %p %d\n",port_id, bum_type);
		return;
	}

	primary_port = trunk_primary_port (port_id);
	if (primary_port > MAX_PORT)
	{
		if(1 == bum_debug_message)
			debug_uprintf("sw_BUM_update_drop_count_trunk Primary port validation failed %p %p\n",port_id, primary_port);
		return;
	}
	if(1 == bum_debug_message)
		debug_uprintf("sw_BUM_update_drop_count_trunk %p %p %X %X\n",port_id, primary_port,(UINT32)dropped_pkt_count,
		                                        (UINT32)port_conf[primary_port].pkt_drop_count[bum_type]);

	port_conf[primary_port].pkt_drop_count[bum_type] += dropped_pkt_count;
}


/**
 * 
 * @name sw_cu_handle_BUM_syslog_when_trunk_added 
 * 
 * @details When trunk is deployed / port members added to a deployed trunk, this API
 *              configures BUM-syslog feature to new secondary member ports
 * @param IN   primary_port - Primary port of the LAG
 *                    port_list_in_trunk - ports that are being added
 *                    number_of_ports - Number of ports in the port list.
 **/


void sw_cu_handle_BUM_syslog_when_trunk_added (PORT_ID primary_port, PORT_ID * port_list_in_trunk, int number_of_ports)
{
    int i, bum_type;
    PORT_ID  port;

    for (bum_type = BUM_BROADCAST; bum_type <= BUM_UNKNOWNUNICAST; bum_type++)
    {
       if (!port_conf[primary_port].bum_log_enable[bum_type])
	       continue;
	   else if (port_conf[primary_port].bum_port_dampening[bum_type].drop_thres)
	   	   continue;
	   
       for (i=0; i<number_of_ports; i++)
       {
           port = port_list_in_trunk[i];
           if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))//Coverity defect 23197 & 23198 & 51435
               continue;
		   
           if ((port == primary_port) && (MY_BOOTUP_STACK_ID ==  PORT_TO_STACK_ID(primary_port)))
               continue;
		   
           if (port_conf[primary_port].bum_log_enable[bum_type]) 
           {
               port_conf[port].bum_log_enable[bum_type] = 1;
			   port_conf[port].pkt_drop_count[bum_type] = 0;
               if (bum_type == BUM_BROADCAST)
                   sw_brd_limit_log_enable (port);
               else if (bum_type == BUM_MULTICAST)
                   sw_mcast_limit_log_enable(port);
               else if (bum_type == BUM_UNKNOWNUNICAST)
                   sw_unknown_ucast_limit_log_enable(port); 
            }
        }
    }
}

/**
 * 
 * @name sw_cu_handle_BUM_syslog_when_trunk_removed 
 * 
 * @details When trunk is undeployed / port members removed from  a trunk, this API
 *              unconfigures BUM-syslog feature from the removed secondary member ports
 * @param IN   primary_port - Primary port of the LAG
 *                    port_list_in_trunk - ports that are being removed
 *                    number_of_ports - Number of ports in the port list.
 **/


void sw_cu_handle_BUM_syslog_when_trunk_removed (PORT_ID primary_port, PORT_ID * port_list_in_trunk, int number_of_ports)
{
    int i, bum_type;
    PORT_ID  port;
    UINT8 mod_port;

    for (bum_type = BUM_BROADCAST; bum_type <= BUM_UNKNOWNUNICAST; bum_type++)
    {
       for (i=0; i<number_of_ports; i++)
       {
           port = port_list_in_trunk[i];
           if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))//Coverity defect 23197 & 23198 & 51438
               continue;
   
           if (port == primary_port)
               continue;
   
		   if (!port_conf[port].bum_log_enable[bum_type])
			   continue;
		   else if (port_conf[port].bum_port_dampening[bum_type].drop_thres)
			   continue;
		   
           if (port_conf[port].bum_log_enable[bum_type])
           {
                port_conf[port].bum_log_enable[bum_type] =0;
                if(port_conf[port].bum_clbk_t[bum_type])
                {
                    sv_cancel_timer(port_conf[port].bum_clbk_t[bum_type]);
                    port_conf[port].bum_clbk_t[bum_type] = NULL;
                }
           }
        }
    }
}

/**
 * 
 * @name sw_cu_handle_BUM_port_dampening_when_trunk_added 
 * 
 * @details When trunk is deployed / port members added to a deployed trunk, this API
 *              configures BUM-port dampening feature to new secondary member ports
 * @param IN   primary_port - Primary port of the LAG
 *                    port_list_in_trunk - ports that are being added
 *                    number_of_ports - Number of ports in the port list.
 **/


void sw_cu_handle_BUM_port_dampening_when_trunk_added (PORT_ID primary_port, PORT_ID * port_list_in_trunk, int number_of_ports)
{
    int i, bum_type;
    PORT_ID  port;
	UINT32 thres;
	UINT32 shut_period;
	UINT32 limit;
	
	if (port_conf[primary_port].is_BUM_port_shut)
	{
		sw_BUM_remove_port_from_errdisable_list (primary_port);
	}

    for (bum_type = BUM_BROADCAST; bum_type <= BUM_UNKNOWNUNICAST; bum_type++)
    {
       if (!port_conf[primary_port].bum_port_dampening[bum_type].drop_thres)
	       continue;
	   
	   thres = port_conf[primary_port].bum_port_dampening[bum_type].drop_thres;
	   shut_period = port_conf[primary_port].bum_port_dampening[bum_type].shut_period;
	   sw_get_BUM_limit_status (primary_port, bum_type, &limit);

       for (i=0; i<number_of_ports; i++)
       {
           port = port_list_in_trunk[i];
           if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))//Coverity defect 23197 & 23198
               continue;
		   
           if (port == primary_port)
           {
               if (MY_BOOTUP_STACK_ID !=  PORT_TO_STACK_ID(primary_port))
               {
				   if (bum_type == BUM_BROADCAST)
					   sw_brd_limit_log_enable(port);
				   else if (bum_type == BUM_MULTICAST)
					   sw_mcast_limit_log_enable(port);
				   else if (bum_type == BUM_UNKNOWNUNICAST)
					   sw_unknown_ucast_limit_log_enable(port);
               }
			   	
               continue;
           }
		   
		   sw_BUM_configure_port_dampening(port,bum_type,
										   limit,thres,shut_period,
										   1 /*ENABLE*/, TRUE);
	
        }
    }
}

/**
 * 
 * @name sw_cu_handle_BUM_port_dampening_when_trunk_removed 
 * 
 * @details When trunk is undeployed / port members removed from  a trunk, this API
 *              unconfigures BUM-port dampening feature from the removed secondary member ports
 * @param IN   primary_port - Primary port of the LAG
 *                    port_list_in_trunk - ports that are being removed
 *                    number_of_ports - Number of ports in the port list.
 **/


void sw_cu_handle_BUM_port_dampening_when_trunk_removed (PORT_ID primary_port, PORT_ID * port_list_in_trunk, int number_of_ports)
{
	int i, bum_type;
	PORT_ID  port;
	UINT8 mod_port;

	for (bum_type = BUM_BROADCAST; bum_type <= BUM_UNKNOWNUNICAST; bum_type++)
	{
		for (i=0; i<number_of_ports; i++)
		{
			port = port_list_in_trunk[i];
			if (!IS_PORT_DB_VALID(port) || !IS_PORT_ENET(port))//Coverity defect 23197 & 23198 &51488
				continue;

			if (port == primary_port)
				continue;

			if (!port_conf[port].bum_port_dampening[bum_type].drop_thres)
				continue;

			sw_BUM_configure_port_dampening (port, bum_type, 0, 0,
					BUM_PORT_ERRDISABLE_PERIOD,
					0 /*DISABLE*/, TRUE);
			if (port_conf[primary_port].is_BUM_port_shut)
				cu_do_set_port_partition(port,PORT_DISABLE);

		}
	}
	if (port_conf[primary_port].is_BUM_port_shut)
	{
		sw_BUM_remove_port_from_errdisable_list (primary_port);
	}

}




/**
 * 
 * @name sw_brd_limit_by_intf1_bytes 
 * 
 * @details BYTE mode for bradcast limit
 * 
 * @param sptr_cdb 
 */
void sw_brd_limit_by_intf1_bytes(struct cdb *sptr_cdb)
{
    UINT32 limit;
    UINT16 port;

    /** already done in sw_brd_limit_by_intf1 */
    if (sptr_cdb->config_gen)
    {
        return;
    }
	/* 0 based */
	port = sptr_cdb->if_num - 1;
    if (sptr_cdb->no)
    {
	    if(end_of_token(sptr_cdb->token) == '\0')
	    {
		    sptr_cdb->dont_go_next = 1;
		    if(((SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff)  == sptr_cdb->integer1)
			    limit = 0;
		    else
		    {
			    uprintf("Error - Broadcast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
			    return;
		    }
		    if(port_conf[port].bum_log_enable[BUM_BROADCAST])
		    {
			    if (port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres)
			    {
				    sw_BUM_configure_port_dampening (port, BUM_BROADCAST, 0, 0,
						    BUM_PORT_ERRDISABLE_PERIOD,
						    FALSE, FALSE);					                             
			    }
			    else
			    {
				    if(1 == bum_debug_message)
					    uprintf("sw_brd_limit_by_intf1_bytes Log Disabled\n");
				    port_conf[port].bum_log_enable[BUM_BROADCAST] = 0;
				    sw_brd_limit_log_disable(port);
			    }
		    }
	    sw_cu_set_brd_limit_by_intf(limit, port);
	    }

	} 
	else
	{
		limit = sptr_cdb->integer1;
		if (hal_brd_show_bytes_error(port))
		{
			uprintf("Error - Broadcast Limit cannot be in bytes for PUMA machines. \n");
			return;
		}
	if (!IS_CHEETAH5())
	{
		//Byte mode
		limit |= 0x80000000; 
	}
	if (end_of_token(sptr_cdb->token) == '\0')
	{
		sptr_cdb->dont_go_next = 1;
		if( port_conf[port].bum_log_enable[BUM_BROADCAST])
		{
			if(1 == bum_debug_message)
				uprintf("sw_brd_limit_by_intf1_bytes Log Disabled\n");

			if (port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres)
			{
				sw_BUM_configure_port_dampening (port, BUM_BROADCAST, 0, 0,
						BUM_PORT_ERRDISABLE_PERIOD,
						FALSE, FALSE);					                             
			}
			else
			{
				if(port_conf[port].bum_clbk_t[BUM_BROADCAST])
				{
					if(1 == bum_debug_message)
						uprintf("sw_brd_limit_by_intf1_bytes\n");
				sv_cancel_timer(port_conf[port].bum_clbk_t[BUM_BROADCAST]);
				port_conf[port].bum_clbk_t[BUM_BROADCAST] = NULL;
			}
			
			port_conf[port].bum_log_enable[BUM_BROADCAST] = 0;
			sw_brd_limit_log_disable(port);
		}
		}
		sw_cu_set_brd_limit_by_intf(limit, port);
	}
	if(1 == bum_debug_message)
		uprintf("sw_brd_limit_by_intf1_bytes config [%d] \n",port_conf[port].bum_log_enable[BUM_BROADCAST]);	
	
    }
}


/**
 * 
 * @name sw_brd_limit_by_intf1 
 * 
 * @details 
 * 
 * @param sptr_cdb 
 * @param unit_type 
 */
void sw_brd_limit_by_intf1(struct cdb *sptr_cdb,UINT8 unit_type)
{
    UINT32 limit = 0;
    UINT16 port;
    UINT16 port_id = PORT_INDEX_INVALID;
    UINT16 trunk_group_id = INVALID_LOAD_SHARE_GROUP_ID;
    int i;

    /** 0 based */
    port = sptr_cdb->if_num - 1;
    if (sptr_cdb->config_gen)
    {
        if (((SPTR_PORT_DB(port))->port_config.brd_limit) & 0x7fffffff)
        {
	        if(1 == bum_debug_message)
				uprintf("sw_brd_limit_by_intf1 config_gen Log [%d]\n",port_conf[port].bum_log_enable[BUM_BROADCAST]);	
            char *next_keywrd = "";
            if ((SPTR_PORT_DB(port))->port_config.brd_limit & 0x80000000)
            {
                if (unit_type == 0) 
                {
                    next_keywrd = " bytes";
                }
                else 
                {       
					if(port_conf[port].bum_log_enable[BUM_BROADCAST] && port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres)
					{
						if(port_conf[port].bum_port_dampening[BUM_BROADCAST].shut_period != BUM_PORT_ERRDISABLE_PERIOD)
						{
							ksprintf(cu_line_buf, " broadcast limit %u kbps threshold %u action port-shutdown %u\n",
									(SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres,port_conf[port].bum_port_dampening[BUM_BROADCAST].shut_period);
						}
						else
						{
							ksprintf(cu_line_buf, " broadcast limit %u kbps threshold %u action port-shutdown\n",
									(SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres);
						}
						wr_config(sptr_cdb, cu_line_buf);
						return;

					}
					if(port_conf[port].bum_log_enable[BUM_BROADCAST] && rate_limit_log_interval_configured !=0)
					{
						next_keywrd = " kbps log";
					}
					else
						next_keywrd = " kbps";
					if(port_conf[port].bum_log_enable[BUM_BROADCAST] && port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres)
					{
						if(port_conf[port].bum_port_dampening[BUM_BROADCAST].shut_period != BUM_PORT_ERRDISABLE_PERIOD)
						{
							ksprintf(cu_line_buf, " broadcast limit %u kbps threshold %u action port-shutdown %u\n",
									(SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres,port_conf[port].bum_port_dampening[BUM_BROADCAST].shut_period);
						}
						else
						{
							ksprintf(cu_line_buf, " broadcast limit %u kbps threshold %u action port-shutdown\n",
									(SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres);
						}
						wr_config(sptr_cdb, cu_line_buf);
						return;

					}
					if(port_conf[port].bum_log_enable[BUM_BROADCAST] && rate_limit_log_interval_configured !=0)
					{
						next_keywrd = " kbps log";
					}
					else
						next_keywrd = " kbps";
                }
            }
            ksprintf(cu_line_buf, " broadcast limit %u%s\n",
                     (SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff, next_keywrd);

            wr_config(sptr_cdb, cu_line_buf);
        }
    }
    else
    {
        if (end_of_token(sptr_cdb->token) != '\0') 
        {
            return;
        }
        else 
        {
            sptr_cdb->dont_go_next = 1;
        }

        if ((sptr_cdb->no) || (sptr_cdb->integer1 == 0))
        {
			if ((sptr_cdb->integer1 != 0) && (((SPTR_PORT_DB(port))->port_config.brd_limit & 0x7fffffff) != sptr_cdb->integer1))
			{
				sptr_cdb->dont_go_next = 1;
				uprintf("Error - broadcast limit %d doesn't match with the configured value in port %p.\n",  sptr_cdb->integer1, port);
				return;
			}
            limit = 0;
	    if(port_conf[port].bum_log_enable[BUM_BROADCAST])
	    {
		    if (port_conf[port].bum_port_dampening[BUM_BROADCAST].drop_thres)
		    {
			    sw_BUM_configure_port_dampening (port, BUM_BROADCAST, 0, 0,
					    BUM_PORT_ERRDISABLE_PERIOD,
					    FALSE, FALSE);
		    }
		    else
		    {
			    if(1 == bum_debug_message)
				    uprintf("sw_brd_limit_by_intf1_bytes Log Disabled\n");
			    port_conf[port].bum_log_enable[BUM_BROADCAST] = 0;
			    sw_brd_limit_log_disable(port);
		    }
	    }
        } 
        else
        {
            limit = sptr_cdb->integer1;
            if (limit > PP_RATE_LIMIT_VALUE_MAX) //Sanity check
            {
                uprintf("Error - Broadcast Limit value is out of range.\n");
                return;
            }
        }
		
		if(1 == bum_debug_message)
			uprintf("sw_brd_limit_by_intf1 Log [%d]\n",port_conf[port].bum_log_enable[BUM_BROADCAST]);	
        sw_cu_set_brd_limit_by_intf(limit, port);
    }
}

void sw_brd_limit_by_intf1_byte_mode(struct cdb *sptr_cdb)
{
   sw_brd_limit_by_intf1(sptr_cdb,0);
}
void sw_brd_limit_by_intf1_kbps_mode(struct cdb *sptr_cdb)
{
   sw_brd_limit_by_intf1(sptr_cdb,1);
}

void sw_mcast_limit_by_intf_bytes(struct cdb *sptr_cdb)
{
    UINT32 limit;
    UINT16 port;

    if (sptr_cdb->config_gen) //already done in sw_brd_limit_by_intf1()
    {
        return;
    }
    port = sptr_cdb->if_num - 1;    /* 0 based */
    if (sptr_cdb->no)
    {
	    if(end_of_token(sptr_cdb->token) == '\0')
	    { 
		    sptr_cdb->dont_go_next = 1;
		    if(((SPTR_PORT_DB(port))->port_config.mcast_limit & 0x7fffffff) == sptr_cdb->integer1)
			    limit = 0;
		    else
		    {
			    uprintf("Error - Multicast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
			    return;
		    }
		    if(1 == bum_debug_message)
			    uprintf("sw_mcast_limit_by_intf_bytes Log Disabled\n");

		    if(port_conf[port].bum_log_enable[BUM_MULTICAST])
		    {
			    if (port_conf[port].bum_port_dampening[BUM_MULTICAST].drop_thres)
			    {
				    sw_BUM_configure_port_dampening (port, BUM_MULTICAST, 0, 0,
						    BUM_PORT_ERRDISABLE_PERIOD,
						    FALSE, FALSE);					                             
			    }
			    else
			    {
				    port_conf[port].bum_log_enable[BUM_MULTICAST] = 0;
				    sw_mcast_limit_log_disable(port);
			    }
		    }
	    sw_cu_set_mcast_limit_by_intf(limit, port);
	    }

    } 
    else
    {
        limit = sptr_cdb->integer1;
        if (limit > PP_RATE_LIMIT_VALUE_MAX_BYTES) //Sanity check
        {
            uprintf("Error - Multicast Limit value is out of range, max %d.\n", PP_RATE_LIMIT_VALUE_MAX_BYTES);
            return;
        } 
        else
        {
		limit |= 0x80000000; //Byte mode          
		if(end_of_token(sptr_cdb->token) == '\0') 
			{
			sptr_cdb->dont_go_next = 1;
			if(port_conf[port].bum_log_enable[BUM_MULTICAST])
			{
				if(1 == bum_debug_message)
					uprintf("sw_mcast_limit_by_intf_bytes Log Disabled\n");
				if (port_conf[port].bum_port_dampening[BUM_MULTICAST].drop_thres)
				{
					sw_BUM_configure_port_dampening (port, BUM_MULTICAST, 0, 0,
							BUM_PORT_ERRDISABLE_PERIOD,
							FALSE, FALSE);												 
				}
				else
				{
				
				if(port_conf[port].bum_clbk_t[BUM_MULTICAST] != (SV_TIMER_TOKEN_T)0)
				{
						if(1 == bum_debug_message)
						uprintf("sw_mcast_limit_by_intf_bytes_timer_cancel [%p]\n",port);
					sv_cancel_timer(port_conf[port].bum_clbk_t[BUM_MULTICAST]);
					port_conf[port].bum_clbk_t[BUM_MULTICAST] = NULL;
				}
				port_conf[port].bum_log_enable[BUM_MULTICAST] = 0;
				sw_mcast_limit_log_disable(port);
			}
			}
			sw_cu_set_mcast_limit_by_intf(limit, port);
    }
        if(1 == bum_debug_message)
		uprintf("sw_mcast_limit_by_intf_bytes\n");

        }
    }
}

void sw_mcast_limit_by_intf(struct cdb *sptr_cdb, UINT8 unit_type)
{
    UINT32 limit = 0;
    UINT16 port;

    port = sptr_cdb->if_num - 1;    /* 0 based */
    if (sptr_cdb->config_gen)
    {
        if (((SPTR_PORT_DB(port))->port_config.mcast_limit) & 0x7fffffff)
        {
            char *next_keywrd = "";
            if (is_system_turboiron())
            {
                if ((unit_type != 0) && ((SPTR_PORT_DB(port))->port_config.mcast_limit & 0x80000000))
                {
                    if (unit_type == 1) 
                    {
						if(port_conf[port].bum_log_enable[BUM_MULTICAST] && port_conf[port].bum_port_dampening[BUM_MULTICAST].drop_thres)
						{
							if(port_conf[port].bum_port_dampening[BUM_MULTICAST].shut_period != BUM_PORT_ERRDISABLE_PERIOD)
							{
								ksprintf(cu_line_buf, " multicast limit %u kbps threshold %u action port-shutdown %u\n",
										(SPTR_PORT_DB(port))->port_config.mcast_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_MULTICAST].drop_thres,port_conf[port].bum_port_dampening[BUM_MULTICAST].shut_period);
							}
							else
							{
								ksprintf(cu_line_buf, " multicast limit %u kbps threshold %u action port-shutdown\n",
										(SPTR_PORT_DB(port))->port_config.mcast_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_MULTICAST].drop_thres);

							}
							wr_config(sptr_cdb, cu_line_buf);
							return;
						}
						if(port_conf[port].bum_log_enable[BUM_MULTICAST]&& rate_limit_log_interval_configured !=0)
							next_keywrd = " kbps log";
						else
							next_keywrd = " kbps";
                    }
                }

                ksprintf(cu_line_buf, " multicast limit %u%s\n",
                         (SPTR_PORT_DB(port))->port_config.mcast_limit & 0x7fffffff, next_keywrd);
            } 
            else 
            {
                ksprintf(cu_line_buf, " multicast limit\n");
            }

            wr_config(sptr_cdb, cu_line_buf);
        }
    } 
    else
    {
        if (end_of_token(sptr_cdb->token) != '\0') 
        {
            return;
        }
        else 
        {
            sptr_cdb->dont_go_next = 1;
        }

        if ((sptr_cdb->no) || (sptr_cdb->integer1 ==0))
        {
			if ((sptr_cdb->integer1 !=0) && (((SPTR_PORT_DB(port))->port_config.mcast_limit & 0x7fffffff) != sptr_cdb->integer1))
			{
				sptr_cdb->dont_go_next = 1;
				uprintf("Error - multicast limit %d doesn't match with the configured value in port %p.\n",  sptr_cdb->integer1, port);
				return;
			}
            limit = 0;
	    if(port_conf[port].bum_log_enable[BUM_MULTICAST])
	    {
		    if (port_conf[port].bum_port_dampening[BUM_MULTICAST].drop_thres)
		    {
			    sw_BUM_configure_port_dampening (port, BUM_MULTICAST, 0, 0,
					    BUM_PORT_ERRDISABLE_PERIOD,
					    FALSE, FALSE);
		    }
		    else
		    {
			    port_conf[port].bum_log_enable[BUM_MULTICAST] = 0;
			    sw_mcast_limit_log_disable(port);
		    }
	    }
        } 
        else
        {
            if (!is_system_turboiron()) // Sampath -- Please revisit
            {
                limit = 1;
            }
            else
            {
                limit = sptr_cdb->integer1;
                if (limit > PP_RATE_LIMIT_VALUE_MAX) //Sanity check
                {
                    uprintf("Error - Multicast Limit value is out of range, max %d.\n", PP_RATE_LIMIT_VALUE_MAX);
                    return;
                }
            }
        }
        sw_cu_set_mcast_limit_by_intf(limit, port);
    }
}

void sw_mcast_limit_by_intf_default_mode(struct cdb *sptr_cdb)
{
  sw_mcast_limit_by_intf(sptr_cdb,0);
}

void sw_mcast_limit_by_intf_kbps_mode(struct cdb *sptr_cdb)
{
  sw_mcast_limit_by_intf(sptr_cdb,1);
}

void sw_unknown_unicast_limit_by_intf_bytes(struct cdb *sptr_cdb)
{
    UINT32 limit;
    UINT16 port;

    if (sptr_cdb->config_gen) 
    {
        return;
    }

    port = sptr_cdb->if_num - 1;    /* 0 based */

    /** Need to explicitly check this, as we 'or' the limit with
    0x8000000 later to convert the value to byte mode. */
    if(sptr_cdb->no) 
    {
	    if(end_of_token(sptr_cdb->token) == '\0')
	    {
		    sptr_cdb->dont_go_next = 1;
		    if (((SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff) == sptr_cdb->integer1)
		    {
			    limit =0;
		    }
		    else
		    {
			    uprintf("Error - Unknown unicast Limit value %u kbps is not configured\n",sptr_cdb->integer1);
			    return;
		    }
		    if(port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST])
		    {
			    if(1 == bum_debug_message)
				    uprintf("sw_unknown_unicast_limit_by_intf_bytes Log Disabled\n");
			    if (port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres)
			    {
				    sw_BUM_configure_port_dampening (port, BUM_UNKNOWNUNICAST, 0, 0,
						    BUM_PORT_ERRDISABLE_PERIOD,
						    FALSE, FALSE);												 
			    }
			    else
			    {
				    port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;
				    sw_unkown_ucast_limit_log_disable(port);
			    }
		    }
	    sw_cu_set_unknown_unicast_limit_by_intf(limit, port);
	    }
	}
	else
	{
        limit = sptr_cdb->integer1;
        if (hal_unknown_unicast_show_bytes_error(port))
        {
            uprintf("Error - Unkown Unicast Limit cannot be in bytes for PUMA machines. \n");
            return;
        }
        if (!IS_CHEETAH5())
        {
            limit |= 0x80000000; //Byte mode
        }
	if (end_of_token(sptr_cdb->token) == '\0') 
	{
		sptr_cdb->dont_go_next = 1;
		if(port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST])
		{
			if (port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres)
			{
				sw_BUM_configure_port_dampening (port, BUM_UNKNOWNUNICAST, 0, 0,
						BUM_PORT_ERRDISABLE_PERIOD,
						FALSE, FALSE);												 
			}
			else
			{
				if(port_conf[port].bum_clbk_t[BUM_UNKNOWNUNICAST])
				{
					if(1 == bum_debug_message)
						uprintf("sw_unknown_unicast_limit_by_intf_bytes_timer_cancle\n");
				sv_cancel_timer(port_conf[port].bum_clbk_t[BUM_UNKNOWNUNICAST]);
				port_conf[port].bum_clbk_t[BUM_UNKNOWNUNICAST] = NULL;
			}
				if(1 == bum_debug_message)
				uprintf("sw_unknown_unicast_limit_by_intf_bytes Log Disabled\n");
			port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;
			sw_unkown_ucast_limit_log_disable(port);
		}
		}
		sw_cu_set_unknown_unicast_limit_by_intf(limit, port);
	}
	if(1 == bum_debug_message)
		uprintf("sw_unknown_unicast_limit_by_intf_bytes\n");
		
}
}

void sw_unknown_unicast_limit_by_intf_puma(struct cdb *sptr_cdb)
{
    UINT32 limit = 0;
    UINT16 port;

    port = sptr_cdb->if_num - 1;    /* 0 based */

    if (sptr_cdb->config_gen)
    {
        if ((SPTR_PORT_DB(port))->port_config.unknown_unicast_limit)
        {
            if (hal_unknown_unicast_show_bytes_error(port))
            {
                ksprintf(cu_line_buf, " unknown-unicast limit \n");
                sptr_cdb->dont_go_next = 1;
                wr_config(sptr_cdb, cu_line_buf);
            }
        }
    } 
    else
    {
        if (end_of_token(sptr_cdb->token) != '\0') 
        {
            return;
        }
        else 
        {
            sptr_cdb->dont_go_next = 1;
        }

        if (!hal_unknown_unicast_show_bytes_error(port))
        {
            uprintf("Error - Please specify the limit values for ports on this module.\n");
            sptr_cdb->dont_go_next = 1;
            return;
        }

        if (sptr_cdb->no)
        {
            limit = 0;
        } 
        else
        {
            limit = 1;
        }

        sw_cu_set_unknown_unicast_limit_by_intf(limit, port);
    }
}





void sw_unknown_unicast_limit_by_intf(struct cdb *sptr_cdb)
{
    UINT32 limit = 0;
    UINT16 port;

    port = sptr_cdb->if_num - 1;    /* 0 based */


    if (sptr_cdb->config_gen)
    {
        if ((SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff)
        {
            if (!hal_unknown_unicast_show_bytes_error(port))
            {
		    if(port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST] && port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres)
		    {
			    if(port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].shut_period != BUM_PORT_ERRDISABLE_PERIOD)
			    {
				    ksprintf(cu_line_buf, " unknown-unicast limit %u kbps threshold %u action port-shutdown %u\n",
						    (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres,port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].shut_period);
			    }
			    else
			    {
				    ksprintf(cu_line_buf, " unknown-unicast limit %u kbps threshold %u action port-shutdown\n",
						    (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff,port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres);

			    }
			    wr_config(sptr_cdb, cu_line_buf);
			    return;
		    }

            	if(port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST] && rate_limit_log_interval_configured !=0)
            	{
                ksprintf(cu_line_buf, " unknown-unicast limit %u%s\n",
                         (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff,
#ifdef TURBOIRON
                     (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x80000000 ? " kbps log" : "");
#else
                     (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x80000000 ? " bytes" : "");
#endif TURBOIRON
            	}
				else
				{
					ksprintf(cu_line_buf, " unknown-unicast limit %u%s\n",
						 (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff,
#ifdef TURBOIRON
						 (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x80000000 ? " kbps" : "");
#else
                         (SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x80000000 ? " bytes" : "");
#endif TURBOIRON
            	}

            }
            wr_config(sptr_cdb, cu_line_buf);
        }
        //ksprintf(cu_line_buf,"Hi. it reached here\n");
    } 
    else
    {
        if (end_of_token(sptr_cdb->token) != '\0')
        {
            return;
        }
        else 
        {
            sptr_cdb->dont_go_next = 1;
        }

        if (hal_unknown_unicast_show_bytes_error(port))
        {
            uprintf("Error - Cannot specify a value for unknown-unicast limit on this card. Please enable broadcast limit\n");
            sptr_cdb->dont_go_next = 1;
            return;
        }

        if ((sptr_cdb->no) || (sptr_cdb->integer1 == 0))
        {
			if ((sptr_cdb->integer1 != 0) &&
					((SPTR_PORT_DB(port))->port_config.unknown_unicast_limit & 0x7fffffff) != sptr_cdb->integer1)
			{
				sptr_cdb->dont_go_next = 1;
				uprintf("Error - unknown unicast limit %d doesn't match with the configured value in port %p.\n",  sptr_cdb->integer1, port);
				return;
			}
            limit = 0;
	    if(port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST])
	    {
		    if(1 == bum_debug_message)
			    uprintf("sw_unknown_unicast_limit_by_intf_bytes Log Disabled\n");
		    if (port_conf[port].bum_port_dampening[BUM_UNKNOWNUNICAST].drop_thres)
		    {
			    sw_BUM_configure_port_dampening (port, BUM_UNKNOWNUNICAST, 0, 0,
					    BUM_PORT_ERRDISABLE_PERIOD,
					    FALSE, FALSE);
		    }
		    else
		    {
			    port_conf[port].bum_log_enable[BUM_UNKNOWNUNICAST] = 0;
			    sw_unkown_ucast_limit_log_disable(port);
		    }
	    }
        } 
        else
        {
            limit = sptr_cdb->integer1;
            if (limit > PP_RATE_LIMIT_VALUE_MAX) //Sanity check
            {
                uprintf("Error - Unknown Unicast Limit value is out of range.\n");
                return;
            }
#ifdef FIOFL_INCLUDE
            if (IS_PORT_OPENFLOW_PORT (port))
            {
                uprintf("Error - OpenFlow is enabled on port %p\n", port);
                return;
            }
#endif FIOFL_INCLUDE
        }
        sw_cu_set_unknown_unicast_limit_by_intf(limit, port);
    }
}

#ifdef FI_PROTECTED_PORTS
void set_mif_protected(struct cdb* sptr_cdb)
{
   set_mif(sptr_cdb, TRUE, (void *)set_if_protected);
}
#endif

void set_mif_mcast_limit_default_mode(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)sw_mcast_limit_by_intf_default_mode);
}

void set_mif_mcast_limit_kbps_mode(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)sw_mcast_limit_by_intf_kbps_mode);
}

void set_mif_mcast_limit1_bytes(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)sw_mcast_limit_by_intf_bytes);
}


void set_mif_brd_limit1_byte_mode(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        else
                sptr_cdb->dont_go_next = 1;

        set_mif(sptr_cdb, TRUE, (void *)sw_brd_limit_by_intf1_byte_mode);
}

void set_mif_brd_limit1_kbps_mode(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        else
                sptr_cdb->dont_go_next = 1;

        set_mif(sptr_cdb, TRUE, (void *)sw_brd_limit_by_intf1_kbps_mode);
}

void set_mif_brd_limit1_bytes(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)sw_brd_limit_by_intf1_bytes);
}

void set_mif_unknown_unicast_limit(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)sw_unknown_unicast_limit_by_intf);
}

void set_mif_unknown_unicast_limit_bytes(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)sw_unknown_unicast_limit_by_intf_bytes);
}

void sw_l2_hw_age_off(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen) {
                if (l2_hw_age_off)
                        wr_config(sptr_cdb,"l2-hw-age-dis\n");
        } else {
                if (sptr_cdb->no) {
                        l2_hw_age_off =  0;
                } else {
                        l2_hw_age_off =  1;
                }
        }
}

void sw_l3_hw_age_off(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen) {
                if (l3_hw_age_off)
                        wr_config(sptr_cdb,"l3-hw-age-dis\n");
        } else {
                if (sptr_cdb->no) {
                        l3_hw_age_off =  0;
                } else {
                        l3_hw_age_off =  1;
                }
        }
}



void show_tech(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (!(end_of_token(sptr_cdb->token)) == '\0')
                        return;
         else
                 sptr_cdb->dont_go_next = 1;


        if ( sptr_cdb->mode == USER_EXEC )
                {
                        uprintf("User is not in the privileged mode.\n");
                        return;
                }
        if (g_uprintf_dest != 0)
        {
                //g_saved_show_tech_dest = g_uprintf_dest;
                io_cb[g_uprintf_dest].application_in_use = 1;
                //debug_uprintf("saved show tech dest %d", g_saved_show_tech_dest);
        }

        cu_show_tech_support(sptr_cdb);
}

#ifndef NO_SYS_PAR

/* global variable - help string for system-max
 * this is set dynamically based on the parameter
 * see cmd3.h as well.
 */
UINT8 cli_system_max_help_string[80];

/* FUNCTION
 *      cli_config_gen_system_max()
 *
 * SYNOPSIS
 *      Generates configuration of all system max
 *      commands - called by retrieve_running_config()
 */
void cli_config_gen_system_max(struct cdb* sptr_cdb)
{
        UINT32 i,size;
        enum BOOLEAN config_written = FALSE;

        if (sptr_cdb->config_gen)
        {
                if (g_stk_clean_cfg)
                        return;

                size = cu_get_sys_param_table_size();
                for (i = 1; i < size; i++)
                {
#ifdef SR_SWITCH_ONLY
                    if ( (strcmp(fndry_system_parameters[i].para_name,"max-ip-mac") == 0))
                    {
                        continue;
                    }
#endif SR_SWITCH_ONLY
#ifdef SR_SWITCH_ROUTER
                    if ( (strcmp(fndry_system_parameters[i].para_name,"max-ip-mac") == 0) && ((fndry_system_parameters[i].config - fndry_system_parameters[i].def) == IP_MAC_MY_STATION_RESERVED_ENTRIES))
                    {
                        continue;
                    }
#endif SR_SWITCH_ROUTER
                        if (fndry_system_parameters[i].config !=
                                fndry_system_parameters[i].def)
                        {
                                if (pp_check_is_ipv6_hw())
                                {
                                        if ((i == MAX_HW_IP_NEXT_HOP_INDEX) ||
                                                (i == MAX_HW_LOGICAL_INT_INDEX) ||
                                                (i == MAX_HW_IP_MCAST_MLL_INDEX))
                                                        continue;
                                }

                                if (IS_SICA() || IS_SPATHA())
                                {
                                        if ((i == IPV6_ROUTES_ENTRIES_INDEX) ||
                                                (i == IPV6_STATIC_ROUTE_ENTRIES_INDEX) ||
                                                (i == IPV6_MAX_CACHE_ENTRIES_INDEX))
                                                        continue;
                                }

                                /* Don't generate the config for vrf param if not supported */
                                /* as of now KATARA don't support multi VRF, all other platforms supports this.
                                   8050 release onwards , SICA supports VRF
                                */
                                if(IS_KATARA() || IS_MINIONS())   
                                {
                                        if ((i == MAX_IPV4_ROUTES_DEFAULT_VRF) ||
                                                (i == MAX_IPV6_ROUTES_DEFAULT_VRF) ||
                                                (i == MAX_IPV4_ROUTES_VRF) ||
                                                (i == MAX_IPV6_ROUTES_VRF) ||
                                                (i == MAX_IP_VRFS_INDEX))
                                                continue;
                                }

                                /* For Minions the virtual-interface is redifned as l3-interface */
                                if (IS_MINIONS())
                                {
                                    if (i == MAX_ROUTER_INT_INDEX) 
                                    {
                                        config_written = TRUE;
                                        ksprintf(cu_line_buf, "%s %s %d\n",
                                        "system-max",
                                        "l3-interface",
                                        fndry_system_parameters[i].config);
                                        wr_config(sptr_cdb, cu_line_buf);
                                        continue;
                                    }
                                }

                                /* Don't generate the config for openflow param if not supported */
                                #ifdef FIOFL_INCLUDE
                                if (!openflow_fi_platform_support())
                                {
                                        if ((i == MAX_OPENFLOW_NEXTHOP_INDEX) 
                                                 || (i == MAX_OPENFLOW_FLOW_ENTRIES_INDEX)
                                                 || (i == MAX_OPENFLOW_HYBRID_PROTECTED_VLAN_INDEX)
                                                 || (i == MAX_OPENFLOW_HYBRID_UNPROTECTED_VLAN_INDEX)
                                                 || (i == MAX_OPENFLOW_SELECT_GROUP_INDEX))
                                        {
                                                continue;
                                        }
                                }
                                #endif FIOFL_INCLUDE

                                /* Do not show "pim-mcache", "igmp-max-group-addr", "mld-max-group-addr" as it is 
                               replaced with "pim-hw-mcache", "igmp-snoop-group-addr", "mld-snoop-group-addr". 
                               Also "mutlicast-route" is replaced with NI command "ip max-mroute" */ 
                                if((i == PIM_MAX_FWD_ENTRY_INDEX) || (i == IGMP_ENTRIES_INDEX) || (i == MLD_ENTRIES_INDEX) || (i == MULTICAST_ROUTE_ENTRIES_INDEX))
                                        continue; 
                                        
                                config_written = TRUE;
                                ksprintf(cu_line_buf, "%s %s %d\n",
                                "system-max",
                                fndry_system_parameters[i].para_name,
                                fndry_system_parameters[i].config);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }

                if (config_written == TRUE)
                {
                        wr_config(sptr_cdb, "!\n");
                }
        }
}

/* FUNCTION
 *      cu_check_system_max_param_value()
 *
 * SYNOPSIS
 *      Checks the value of the system max parameter given the
 *      index to the parameter and the new value.
 */
enum BOOLEAN cu_validate_system_max_param_value(UINT32 index, UINT32 new_value)
{
        CU_SYSTEM_PARAMETER* param_entry = &fndry_system_parameters[index];

        /* validate the input value */
        if (new_value > param_entry->max || new_value < param_entry->min)
        {
                uprintf("Error - Parameter %s should be between %d and %d\n",
                        param_entry->para_name, param_entry->min, param_entry->max);
                return FALSE;
        }

        return TRUE;
}

extern UINT32 acldevGetValidTpdCount();
extern UINT32  gTpdMaxEntries;

/* FUNCTION
 *      check_system_max_vrf_route()
 *
 * SYNOPSIS
 *      Will check whether the ip-route, ip-route-default-vrf and ip-route-vrf or
 *      ip-route, ip-route-default-vrf and ip-route-vrf are in valid range.
 *
 * ARGUMENTS:
 *      is_ip6_route          TRUE - Validate the IPV6 routes, FALSE - - Validate the IPV6 routes
 *      from_max_route   TRUE - Called during ip-route/ipv6-route changes
 *                                 FALSE - Called during ip-route-default-vrf/ip-route-vrf
 *                                              or ip6-route-default-vrf/ip6-route-vrf/ changes
 *      max_route            Configured ip-route or ip6-route value 
 *      default_route        Configured ip-route-default-vrf or ip6-route-default-vrf value 
 *      vrf_route              Configured ip-route-vrf or ip6-route-vrf value 
 * 
 *  RETURN:
 *                                TRUE - If it in valid range
 *                                FALSE - If it in not in valid range and display error messages
 *
 */
UINT32 cu_check_system_max_route_for_gre(UINT32 max_route, UINT32 default_route, UINT32 vrf_route)
{
        /* if default_route = 0, discard the check */
        if ((default_route != 0) && (default_route > max_route))
                        return 1;

        /* if vrf_route = 0, discard the check */
        if ((vrf_route != 0) && (vrf_route > max_route))
                        return 2;

        return 0;
}

enum BOOLEAN cu_check_system_max_route(enum BOOLEAN is_ip6_route, enum BOOLEAN from_max_route,
                                                    UINT32 max_route, UINT32 default_route, UINT32 vrf_route, UINT8 print_error)
{
        char *ip_str = (is_ip6_route)?"IPv6":"IPv4";
        char *str1 = (from_max_route)?" configured":"";
        char *str2 = (from_max_route)?"being configured":"configured";
#ifdef SR_SWITCH_ROUTER
    int total_vrf_max_route = 0;
#endif SR_SWITCH_ROUTER

        /* if default_route = 0, discard the check */
        if ((default_route != 0) && (default_route > max_route))
        {
                if (print_error)
                {
                        uprintf("Error: Max default VRF %s routes %s(%d)\n", ip_str, str1, default_route);
                        uprintf("       cannot be greater than total %s routes %s (%d)\n", ip_str, str2, max_route);
                }

                return FALSE;
        }               

        /* if vrf_route = 0, discard the check */
        if ((vrf_route != 0) && (vrf_route > max_route))
        {
                if (print_error)
                {
                        uprintf("Error: Default %s routes per VRF %s(%d)\n", ip_str, str1, vrf_route);
                        uprintf("       cannot be greater than total %s routes %s (%d)\n", ip_str, str2,max_route);
                }
                
                return FALSE;
        }       

#ifdef SR_SWITCH_ROUTER
        if (!vrf_route)
        {
                if (is_ip6_route)
                        vrf_route = (UINT32)cu_get_config_param(MAX_IPV6_ROUTES_VRF);
                else
                        vrf_route = (UINT32)cu_get_config_param(MAX_IPV4_ROUTES_VRF);
        }
        
        if (!default_route)
        {
                if (is_ip6_route)
                        default_route = (UINT32)cu_get_config_param(MAX_IPV6_ROUTES_DEFAULT_VRF);
                else
                        default_route = (UINT32)cu_get_config_param(MAX_IPV4_ROUTES_DEFAULT_VRF);
        }

    if (is_ip6_route)
        total_vrf_max_route = (int)ipvrf_cu_get_max_V6_route_count_with_def_val(vrf_route);
    else
        total_vrf_max_route = (int)ipvrf_cu_get_max_V4_route_count_with_def_val(vrf_route);

    if ((total_vrf_max_route + default_route) > max_route)
    {
        if (print_error)
        {
            uprintf("Error: Total %s routes in all VRF %s(Default %d, All-VRFs present on system %d) %d\n",  ip_str, str1,             
                                                                        default_route, total_vrf_max_route, (total_vrf_max_route+default_route));
            uprintf("       cannot be greater than total %s routes %s (%d)\n", ip_str, str2,max_route);
                        uprintf("               reduce %s default vrf values or delete some %s vrfs \n", ip_str, ip_str);
        }
        return FALSE;
    }
#endif SR_SWITCH_ROUTER

        return TRUE;
}

/*API to check the number configured VRRP IPv4 instances and validated the effect of IP-MAC system-max value configuration on these numbers*/
enum BOOLEAN cu_check_configured_vrrp_instances_count(int diff_value)
{
		UINT16 count_ipv4_vrrp_configured = 0, new_entries_available_for_ip_mac = 0, current_ip_mac_max; 
		/*evaluate number of ipv4 vrrp isntances configured on the device*/
		count_ipv4_vrrp_configured = g_vrrp_class.number_of_vrtr_entries[VRRP_AFI_TO_INDEX(IP_IPV4_AFI)];

		if((VRRP4_MAX_CONFIG_ROUTERS - diff_value) < count_ipv4_vrrp_configured)
		{
			/*evaluate the maximum ip-mac entries we can configure*/
			
			new_entries_available_for_ip_mac = VRRP4_MAX_CONFIG_ROUTERS - count_ipv4_vrrp_configured;
			current_ip_mac_max = cu_get_curr_param(MAX_IP_MAC_INDEX);
			
			uprintf("Maximum configurable ip-mac is :%d, system has configured %d ipv4 vrrp instances,\n	remove some ipv4 vrrp instances configured to increase max-ip-mac beyond %d \n", 
						current_ip_mac_max + new_entries_available_for_ip_mac, count_ipv4_vrrp_configured, current_ip_mac_max + new_entries_available_for_ip_mac);
			
			return FALSE;
		}
		return TRUE;
}
/* FUNCTION
 *      cu_set_system_max_param_value()
 *
 * SYNOPSIS
 *      Sets the value of the system max parameter given the
 *      index to the parameter and the new value.
 */
void cu_set_system_max_param_value(struct cdb* sptr_cdb, UINT32 index, UINT32 new_value)
{
        CU_SYSTEM_PARAMETER* param_entry = &fndry_system_parameters[index];
        UINT8* printString = "No need to reload\n";
        UINT32 vlan_entry_cnt;
        UINT32 valid_tpd_cnt;
        UINT32 old_value = 0;
        UINT32 total_value;
        int multicast_val; 
        int ipv6_value = 0, ipv4_value = 0, arp_value = 0;
        int diff, diff_mac_entries;
        enum BOOLEAN reload_required = FALSE;
        UINT32 max_hw_entries = 0;      
        UINT8 print_error = TRUE;
        UINT32 of_nh = 0;
        UINT32 max_nh = 0;
        UINT32 max_intf = 0;
        UINT32 min_routes = 0;
        UINT32 max_routes = 0;

        /* For no case, dont print error message when execute == 1, 
         * we have already printed it when execute == 0 
         */
        if (sptr_cdb->no && sptr_cdb->execute)
                print_error = FALSE;
                
        if (new_value == param_entry->config)
        {
                /* new value is the same as the configured
                 * value - do nothing
                 */
                return;
        }

        /* validate the input value */
        if (new_value > param_entry->max || new_value < param_entry->min)
        {
                uprintf("Error - Parameter %s should be between %d and %d\n",
                                param_entry->para_name, param_entry->min, param_entry->max);
                return;
        }

        /* handle special cases */
        switch (index)
        {
#ifdef SR_SWITCH_ROUTER
                case ARP_ENTRIES_INDEX:
                        if (IS_MINIONS())    
                        {
                                /* Minions shares the nh resource with ARP and Openflow */
                                old_value = cu_get_config_param(ARP_ENTRIES_INDEX);
                                if (new_value > old_value) 
                                {
                                        /* We need to reduce from openflow if required */
                                        max_nh = cu_get_max_param (ARP_ENTRIES_INDEX); 
                                        of_nh = cu_get_config_param (MAX_OPENFLOW_NEXTHOP_INDEX);
                                        if ((of_nh + new_value) > max_nh)
                                        {
                                                /* Reduce from OF and warn user */
                                                of_nh = max_nh - new_value;
                                                cu_set_config_param (MAX_OPENFLOW_NEXTHOP_INDEX, of_nh);
                                                uprintf("Warning: openflow-nexthop-entries is reduced to %d\n", of_nh);
                                        }
                                }

                                /* For minions the arp and hw_ip_nexthop has 1:1 correlation */
                                cu_set_config_param (MAX_HW_IP_NEXT_HOP_INDEX, new_value);
                                reload_required = TRUE;
                                /* Do the checks for arp value and warn the admin */
                                ipv4_value = cu_get_config_param(IP_CACHE_ENTRIES_INDEX);
                                ipv6_value = cu_get_config_param(IPV6_MAX_CACHE_ENTRIES_INDEX);
                                arp_value = new_value;
                                if ((ipv4_value + ipv6_value) >= arp_value)
                                    uprintf("Warning: Please set ip-arp to (ip-cache + ip6-cache + delta),\nWhere delta is number of neighbors the prefix route is pointing to.\n\n");
                        }
                        break;

                case MAX_ROUTER_INT_INDEX:
                        if (IS_MINIONS())    
                        {
                                /* Minions shares the egress_l3_iif and l3_iif resource with l3 intf and Openflow */
                                old_value = cu_get_config_param(MAX_ROUTER_INT_INDEX);
                                if (new_value > old_value) 
                                {
                                        /* We need to reduce from openflow if required */
                                        max_intf = cu_get_max_param (MAX_ROUTER_INT_INDEX); 
                                        /* OF has 1:1 correlation of NH:IIF */
                                        of_nh = cu_get_config_param (MAX_OPENFLOW_NEXTHOP_INDEX);
                                        if ((of_nh + new_value) > max_intf)
                                        {
                                                /* Reduce from OF and warn user */
                                                of_nh = max_intf - new_value;
                                                cu_set_config_param (MAX_OPENFLOW_NEXTHOP_INDEX, of_nh);
                                                uprintf("Warning: openflow-nexthop-entries is reduced to %d\n", of_nh);
                                        }
                                }

                                reload_required = TRUE;
                        }
                        break;

                case IP_CACHE_ENTRIES_INDEX:
                        if (IS_MINIONS())    
                        {
                                /* Minions shares the l3-entry resource with ip-host, ipv6-host and multicast. 
                                 * There is a static partition between uc and mc so nothing to worry.
                                 * Just manipulate the ip and ipv6 range. 
                                 */
                                max_routes = cu_get_max_param (IP_CACHE_ENTRIES_INDEX); 
                                min_routes = cu_get_min_param (IP_CACHE_ENTRIES_INDEX); 
                                diff = ((min_routes + max_routes - new_value)/2); 
                                if (diff < cu_get_min_param(IPV6_MAX_CACHE_ENTRIES_INDEX))
                                        diff = cu_get_min_param(IPV6_MAX_CACHE_ENTRIES_INDEX);

                                /* For Minions v6 l3_entry takes 2 rows vs 1 row for ipv4 */
                                cu_set_config_param (IPV6_MAX_CACHE_ENTRIES_INDEX, diff);
                                uprintf("Warning: ip6-cache is updated to %d\n", diff);
                                reload_required = TRUE;
                                /* ipv4 entry is set at the end of this switch case */
                                ipv4_value = new_value;
                                ipv6_value = diff;
                                arp_value = cu_get_config_param(ARP_ENTRIES_INDEX);
                                max_intf = cu_get_config_param(MAX_ROUTER_INT_INDEX);
                                /* ip address configured for the interface == 1 host route (/32) entry in ip-cache, warn the admin */
				if (ipv4_value < max_intf)
                                    uprintf("Warning: ip-cache is < configured l3-interface, ensure enough space in ip-cache for host routes, 1 cache entry required for each configured interface ip address.\n");
                                /* Do the checks for arp value and warn the admin */
                                if ((ipv4_value + ipv6_value) >= arp_value)
                                    uprintf("Warning: Please set ip-arp to (ip-cache + ip6-cache + delta),\nWhere delta is number of neighbors the prefix route is pointing to.\n\n");
                        }
                        break;

                case STATIC_ARP_ENTRIES_INDEX:
                case STATIC_ROUTE_ENTRIES_INDEX:
                        if (IS_MINIONS())    
                        {
                                if (sptr_cdb->execute == TRUE)
                                        uprintf ("Error: This system-max parameter is not configurable.\n");
                                return;
                        }
                        break;
#endif

                case VLAN_ENTRIES_INDEX:
                        /* cannot reduce the max vlans below # of vlans created */
                        vlan_entry_cnt = (UINT32) cu_get_vlan_entry_cnt();
                        if (vlan_entry_cnt > new_value)
                        {
                                if(print_error)
                                        uprintf("Error - Max VLANs cannot be less than "
                                                        "the number of configured VLANs - %d.\n",
                                                        (vlan_entry_cnt-1));
                                return;
                        }
                        reload_required = TRUE;
                        break;
                case MAC_ENTRIES_INDEX:
#ifdef SIDEWINDER_LINUX
                        max_hw_entries = pp_get_hw_config_fdb_entries();
                        if (new_value > max_hw_entries)
                        {
                                 uprintf("Cannot set system-max mac to %d. Max FDB entries supported by h/w is %d\n", new_value, max_hw_entries);
                                 return;
                        }
#else
                        if (new_value > param_entry->def)
                        {
                                uprintf("Mac Learning must be flow based to scale beyond %d Mac Entries\n", param_entry->def);
                        }
#endif /* SIDEWINDER_LINUX */
                        reload_required = TRUE;
                        break;
#ifdef __IP_MULTICAST__
#ifdef SR_SWITCH_ROUTER
                case PIM_MAX_FWD_ENTRY_INDEX:
                /* For backward compatibility */        
                        index = PIM_MAX_HW_MCACHE_ENTRIES; 
                case PIM_MAX_HW_MCACHE_ENTRIES: 
                        fndry_system_parameters[PIM_MAX_FWD_ENTRY_INDEX].config = new_value; 
                        fndry_system_parameters[PIM_MAX_FWD_ENTRY_INDEX].current = new_value;  
                        cu_init_pim_global_class(IP_IPV4_AFI, 0, new_value); // init 0 
                        break;          
                case PIM6_MAX_HW_MCACHE_ENTRIES:
                        cu_init_pim_global_class(IP_IPV6_AFI, 0, new_value); // init 0 
                        break;          
                case MAX_MSDP_SA_CACHE_INDEX: 
                        multicast_val = msdp_get_sa_cache_total(); 
                        if ((multicast_val >= 0) && (new_value < multicast_val))  // multicast_val = -1 if pool not initialized 
                        {
                                uprintf("Current MSDP SA Cache entries %d is greater than the configured value %d.\n", multicast_val, new_value);
                                reload_required = TRUE;
                        }
                        else
                        {
                                msdp_set_sa_cache_limit(new_value);   
                        }  
                        break;                  
                case DVMRP_MAX_FWD_ENTRY_INDEX:
                        TODO_MCAST(); // Follow PIM_MAX_FWD_ENTRY_INDEX above. set_generic_pool_upper_limit(ip.dvmrp.sptr_fwd_entry_pool, new_value);
                        //set_generic_pool_upper_limit(ip.dvmrp.sptr_fwd_entry_pool, new_value);
                        break;
// Maocheng++: IGMPv3, move out side ROUTER
//              case IGMP_ENTRIES_INDEX:
//                      set_generic_pool_upper_limit(ip.igmp.sptr_igmp_group_pool, new_value);
//                      break;

#endif SR_SWITCH_ROUTER
#endif

#ifndef NO_IGMP_V3_SUPPORT
                case IGMP_ENTRIES_INDEX:
                /* For backward compatibility */ 
                        index = IGMP_SNOOP_GROUP_INDEX;
                case IGMP_SNOOP_GROUP_INDEX:  
                        multicast_val = generic_get_pool_total_number (ip.igmp.sptr_group_pool);
                        if ((multicast_val >= 0) && (new_value < multicast_val))  // multicast_val = -1 if pool not initialized 
                        {
                                uprintf("Current IGMP snoop group entries %d is greater than the configured value %d.\n", multicast_val, new_value);
                                reload_required = TRUE;
                        }
                        else
                        {
                                set_generic_pool_upper_limit(ip.igmp.sptr_group_pool, new_value);
                                fndry_system_parameters[IGMP_ENTRIES_INDEX].current = new_value;
                        }  
                        fndry_system_parameters[IGMP_ENTRIES_INDEX].config = new_value;
                        break;                          
#ifdef __MLD__
                case MLD_ENTRIES_INDEX:
                /* For backward compatibility */ 
                        index = MLD_SNOOP_GROUP_INDEX;
                case MLD_SNOOP_GROUP_INDEX:     
                        multicast_val = generic_get_pool_total_number (ip6.mld.sptr_group_pool);
                        if ((multicast_val >= 0) && (new_value < multicast_val))  // multicast_val = -1 if pool not initialized 
                        {
                                uprintf("Current MLD snoop group entries %d is greater than the configured value %d.\n", multicast_val , new_value);
                                reload_required = TRUE;
                        }
                        else
                        {
                                set_generic_pool_upper_limit(ip6.mld.sptr_group_pool, new_value);
                                fndry_system_parameters[MLD_ENTRIES_INDEX].current = new_value;
                        }        
                        fndry_system_parameters[MLD_ENTRIES_INDEX].config = new_value;
                        break;  
#endif __MLD__  
                case IGMP_SNOOP_MCACHE_INDEX:   
                        multicast_val = generic_get_pool_total_number (ip.igmp.snoop_fwd_entry_pool);                                                                                                             
                        if ((multicast_val >= 0) && (new_value < multicast_val))  // multicast_val = -1 if pool not initialized 
                        {
                                uprintf("Current IGMP snoop mcache entries %d is greater than the configured value %d.\n", multicast_val , new_value);
                                reload_required = TRUE;
                        }
                        else
                        {
                                set_generic_pool_upper_limit(ip.igmp.snoop_fwd_entry_pool, new_value);                                                                                                                                                                                          
                        }
                        break;
#ifdef __MLD__
                case MLD_SNOOP_MCACHE_INDEX:
                        multicast_val = generic_get_pool_total_number (ip6.mld.snoop_fwd_entry_pool);                                                                                                            
                        if ((multicast_val >= 0) && (new_value < multicast_val))  // multicast_val = -1 if pool not initialized 
                        {
                                uprintf("Current MLD snoop mcache entries %d is greater than the configured value %d.\n", multicast_val , new_value);
                                reload_required = TRUE;
                        }
                        else
                        {
                                set_generic_pool_upper_limit(ip6.mld.snoop_fwd_entry_pool, new_value);                                                                                                                                                                                     
                        }        
                        break;  
#endif __MLD__
#endif  NO_IGMP_V3_SUPPORT
                case MAX_HW_TRAFFIC_COND_INDEX:
                        /* cannot reduce the max vlans below # of vlans created */

                        valid_tpd_cnt = (UINT32) acldevGetValidTpdCount();
                        if (valid_tpd_cnt > new_value)
                        {
                                uprintf("Error - Maximum TPDs cannot be less than "
                                                "the number of configured TPD's - %d.\n",
                                                valid_tpd_cnt);
                                return;
                        }
                        reload_required = TRUE;
                        gTpdMaxEntries = new_value;
                        break;
                case MAX_IPV4_ROUTES_DEFAULT_VRF:
                        {
                                UINT32 ip_route_value = cu_get_config_param(ROUTES_ENTRIES_INDEX);      // configured param

                                // if configured value has changed, check for config param,
                                if (FALSE == cu_check_system_max_route(FALSE, FALSE, ip_route_value, new_value, 0, print_error))
                                {
                                        return;
                                }
                                
                                uprintf("\nTotal maximum configured ipv4 routes are %d\n", ip_route_value);
                                uprintf("  - Maximum ipv4 routes configured for default VRF are %d\n", new_value);
                                #ifdef FIOFL_INCLUDE
                                uprintf("  - Maximum ipv4 routes available for all non-default VRFs %sare %d\n", 
                                                 ((openflow_fi_platform_support())?"and openflow ":""), (ip_route_value - new_value));
                                #else FIOFL_INCLUDE
                                uprintf("  - Maximum ipv4 routes available for all non-default VRFs are %d\n", (ip_route_value - new_value));
                                #endif FIOFL_INCLUDE
                                uprintf("Warning: Please revalidate these values to be valid for your configuration.\n");
                        }
                        reload_required = TRUE;
                        break;
                case MAX_IPV6_ROUTES_DEFAULT_VRF:
                        {
                                UINT32 ip6_route_value = cu_get_config_param(IPV6_ROUTES_ENTRIES_INDEX);  // configured param
                                

                                if (FALSE == cu_check_system_max_route(TRUE, FALSE, ip6_route_value, new_value, 0, print_error))
                                {
                                        return;
                                }
                                uprintf("\nTotal maximum configured ipv6 routes are %d\n", ip6_route_value);
                                uprintf("  - Maximum ipv6 routes configured for default VRF are %d\n", new_value);
                                uprintf("  - Maximum ipv6 routes available for all non-default VRFs are %d\n", (ip6_route_value - new_value));
                                uprintf("Warning: Please revalidate these values to be valid for your configuration.\n");
                        }
                        reload_required = TRUE;
                        break;
                case MAX_IPV4_ROUTES_VRF:
                        {
                                UINT32 ip_route_value = cu_get_config_param(ROUTES_ENTRIES_INDEX);      // configured param

                                // if configured value has changed, check for config param,
                                if (FALSE == cu_check_system_max_route(FALSE, FALSE, ip_route_value, 0, new_value, print_error))
                                {
                                        return;
                                }
                        }
                        reload_required = TRUE;
                        break;
                case MAX_IPV6_ROUTES_VRF:
                        {
                                UINT32 ip6_route_value = cu_get_config_param(IPV6_ROUTES_ENTRIES_INDEX);  // configured param

                                // if configured value has changed, check for config param,
                                if (FALSE == cu_check_system_max_route(TRUE, FALSE, ip6_route_value, 0, new_value, print_error))
                                {
                                        return;
                                }
                        }
                        reload_required = TRUE;
                        break;
                                
#ifdef SR_SWITCH_ROUTER
                case ROUTES_ENTRIES_INDEX:
                        if(!PP_IS_IPV4_IPV6_SHARE_TABLE)        
                        {
                                {
                                        UINT32 ip_default_vrf = cu_get_config_param(MAX_IPV4_ROUTES_DEFAULT_VRF);
                                        UINT32 ip_vrf_route = cu_get_config_param(MAX_IPV4_ROUTES_VRF);

                                        // if configured value has changed, check for config param,
                                        if (FALSE == cu_check_system_max_route(FALSE, TRUE, new_value, ip_default_vrf, ip_vrf_route, print_error))
                                        {
                                                return;
                                        }
                                }
                                uprintf("Warning: Please reconfigure system-max for ip-route-default-vrf and ip-route-vrf (if required).\n");                   
                                reload_required = TRUE;
                                break;
                        }

                        if (IS_MINIONS())    
                        {
                                /* 
                                 * Minions shares the l3-defip resource between ipv4 and ipv6. 
                                 * Minions doesn't support VRF
                                 */
                                max_routes = cu_get_max_param (ROUTES_ENTRIES_INDEX); 
                                min_routes = cu_get_min_param (ROUTES_ENTRIES_INDEX); 
                                diff = min_routes + max_routes - new_value; 
                                if (diff < cu_get_min_param(IPV6_ROUTES_ENTRIES_INDEX))
                                    diff = cu_get_min_param(IPV6_ROUTES_ENTRIES_INDEX);
                                /* For Minions v6 l3_defip takes 1 rows vs 1 row for ipv4 */
                                cu_set_config_param (IPV6_ROUTES_ENTRIES_INDEX, diff);
                                uprintf("Warning: ip6-route is updated to %d\n", diff);
                                reload_required = TRUE;
                                break;
                                /* ipv4 entry is set at the end of this switch case */
                        }


                        old_value = cu_get_config_param(ROUTES_ENTRIES_INDEX);
                        ipv6_value = cu_get_config_param(IPV6_ROUTES_ENTRIES_INDEX);
            diff = ((int)(old_value)/PP_MAX_HW_ROUTE_TABLE_COLUMN) - ((int)(new_value)/PP_MAX_HW_ROUTE_TABLE_COLUMN);


                        //TR000430684
                        //Compare the ip-route value should be less than equal to ip-route-default-vrf value
                        // 8050 release onwards SICA supports VRF.
                        if ((!IS_KATARA() || !IS_MINIONS()))
                        {
                                //Check IPv4 ip-routes and IPv4 default vrf routes are in valid range
                                UINT32 ip_default_route = cu_get_config_param(MAX_IPV4_ROUTES_DEFAULT_VRF);
                                UINT32 ip_route_vrf = cu_get_config_param(MAX_IPV4_ROUTES_VRF);
                                if (FALSE == cu_check_system_max_route(FALSE, TRUE, new_value, ip_default_route, ip_route_vrf, print_error))
                                {
                                        return;
                                }

                                if(soft_package_supported_feature(IPV6_SOFT_PKG_INDEX))
                                {
                                        // Check IPv6 ip-routes and IPv6 default vrf routes are in valid range
                                        UINT32 ip6_default_route = cu_get_config_param(MAX_IPV6_ROUTES_DEFAULT_VRF);
                                        UINT32 ip6_route_vrf = cu_get_config_param(MAX_IPV6_ROUTES_VRF);

                                        /* Verify the valid range of ip6-route, ip6-vrf-route and ip6-default-vrf-route */
                                        if (FALSE == cu_check_system_max_route(TRUE, TRUE, (ipv6_value + diff), ip6_default_route, ip6_route_vrf, FALSE))
                                        {
												
											uprintf("Error: Max default VRF IPV6 routes being configured %d\n", ip6_default_route);
											uprintf("	cannot be greater than newly computed  IPV6 routes %d value\n",(ipv6_value + diff));
                                            return;
                                        }
                                }
                        }
                        
                        fndry_system_parameters[ROUTES_ENTRIES_INDEX].config = new_value;

                        if(soft_package_supported_feature(IPV6_SOFT_PKG_INDEX))
                        {
                                if (IS_SICA() || IS_SPATHA())
                                {
                                        fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config =
                                                get_ipv6_routes_from_ipv4_routes(fndry_system_parameters[ROUTES_ENTRIES_INDEX].config);
                                                                                   
                                }
                                else
                                {
                                        fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config = ipv6_value + diff;
                                }
                        }

                        if(!IS_SIDEWINDER() || !IS_TANTO())
                        {
                                // Set ip6-static-route and ip6-cache values whenever we change the ip6-route value for all stackables except Sidewinder.
                                set_ip6_static_route_n_cache_system_max(fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config, FALSE);
                        }

                        if(soft_package_supported_feature(IPV6_SOFT_PKG_INDEX))
                        {
                                        uprintf ("ip-route, ip6-route, ip6-cache and ip6-static-route values changed.\n"
                                                         "ip-route: %d\nip6-route: %d\nip6-cache: %d\nip6-static-route: %d\n",
                                                        fndry_system_parameters[ROUTES_ENTRIES_INDEX].config,
                                                        fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config,
                                                        fndry_system_parameters[IPV6_MAX_CACHE_ENTRIES_INDEX].config,
                                                        fndry_system_parameters[IPV6_STATIC_ROUTE_ENTRIES_INDEX].config);
                        } else {
                                        uprintf ("ip-route value changed.\nip-route: %d\n",
                                        fndry_system_parameters[ROUTES_ENTRIES_INDEX].config);

                        }
                        // 8050 release onwards SICA supports VRF                   
                        if ((!IS_KATARA() || !IS_MINIONS())) 
                        {
                                        uprintf("Warning: Please reconfigure system-max for ip-route-default-vrf and ip-route-vrf (if required).\n");
                        }

                        reload_required = TRUE;

                        break;
                case MAX_GRE_IP_TUNNEL_INDEX:
                {
                        if(!PP_IS_IPV4_TUNNEL_SHARE_TABLE)
                        {
                                reload_required = TRUE;
                                break;
                        }

                        old_value = cu_get_config_param (MAX_GRE_IP_TUNNEL_INDEX);
                        diff = (int)(old_value - new_value);

                        ipv6_value = cu_get_config_param(IPV6_ROUTES_ENTRIES_INDEX);
                        if (!ipv6_value)
                                ipv6_value = cu_get_curr_or_def_param(IPV6_ROUTES_ENTRIES_INDEX);

                        //Comare the ip6-route value should be less than equal to ip6-route-default-vrf value
                        // 8050 release onwards SICA supports VRF                   
                        if ((!IS_KATARA() || !IS_MINIONS())) // AMIT_TODO: Need to check the sidewinder case here
                        {
                                UINT32 retVal = 0;
                                if(soft_package_supported_feature(IPV6_SOFT_PKG_INDEX))
                                {
                                        // Check IPv6 routes and IPv6 default vrf routes are in valid range
                                        UINT32 ip6_default_route = cu_get_config_param(MAX_IPV6_ROUTES_DEFAULT_VRF);
                                        UINT32 ip6_route_vrf = cu_get_config_param(MAX_IPV6_ROUTES_VRF);
                                        int total_vrf_max_route = 0;

                                        /* Verify the valid range of ip6-route, ip6-vrf-route and ip6-default-vrf-route */
                                        retVal = cu_check_system_max_route_for_gre((ipv6_value + diff), ip6_default_route, ip6_route_vrf);
                                        if (retVal != 0)
                                        {
                                                uprintf( "Error:Changing gre-tunnels max value from %d to %d changes the total IPv6 routes value from %d to %d\n",
                                                                                old_value, new_value, ipv6_value, ipv6_value+diff);                                     
                                                if(retVal == 1)
                                                {
                                                        uprintf("Max default VRF IPv6 routes configured(%d)\n", ip6_default_route);
                                                        uprintf("       cannot be greater than total IPv6 routes being configured (%d)\n", ipv6_value + diff);
                                                        return;
                                                }
                                                else
                                                {
                                                        uprintf("Default IPv6 routes per VRF configured(%d)\n", ip6_route_vrf);
                                                        uprintf("       cannot be greater than total IPv6 routes being configured (%d)\n", ipv6_value + diff);
                                                        return;
                                                }
                                                return;
                                        }

                                        /* Verify the valid range of all VRF's ip6-vrf-route   */
                                        total_vrf_max_route = (int)ipvrf_cu_get_max_V6_route_count_with_def_val(ip6_route_vrf);
                                        if ((total_vrf_max_route + ip6_default_route) > (ipv6_value + diff))
                                        {
                                                uprintf("Error:Changing gre-tunnels max value from %d to %d changes the total IPv6 routes value from %d to %d\n",
                                                                                                                        old_value, new_value, ipv6_value, ipv6_value+diff);                                     
                                                uprintf("Total Max routes of all IPv6 VRF configured(%d)\n", total_vrf_max_route);
                                                uprintf("               cannot be greater than total IPv6 routes being configured (%d)\n", ipv6_value + diff);
                                                return;
                                        }
                                }
                        }

                        fndry_system_parameters[MAX_GRE_IP_TUNNEL_INDEX].config = new_value;

                        if(soft_package_supported_feature(IPV6_SOFT_PKG_INDEX))
                        {
                                fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config = ipv6_value + diff;
                                // 8050 release onwards SICA supports VRF
                                if(!IS_SIDEWINDER() && !IS_SPATHA() && !IS_SICA() && !IS_TANTO())
                                {
                                        // Set ip6-static-route and ip6-cache values whenever we change the ip6-route value for all stackables except Sidewinder and SPATHA.
                                        set_ip6_static_route_n_cache_system_max(fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config, FALSE);
                                }

                                uprintf ("gre-tunnels, ip6-route, ip6-cache and ip6-static-route values changed.\n"
                                                 "New values: gre-tunnels: %d ip6-route: %d\n"
                                                 "            ip6-cache: %d ip6-static-route: %d\n",
                                                fndry_system_parameters[MAX_GRE_IP_TUNNEL_INDEX].config,
                                                fndry_system_parameters[IPV6_ROUTES_ENTRIES_INDEX].config,
                                                fndry_system_parameters[IPV6_MAX_CACHE_ENTRIES_INDEX].config,
                                                fndry_system_parameters[IPV6_STATIC_ROUTE_ENTRIES_INDEX].config);
                        }

                        reload_required = TRUE;

                        break;
                }
                case IPV6_ROUTES_ENTRIES_INDEX:
                        if (IS_MINIONS())    
                        {
                                /* 
                                 * Minions shares the l3-defip resource between ipv4 and ipv6. 
                                 * Minions doesn't support VRF
                                 */
                                max_routes = cu_get_max_param (ROUTES_ENTRIES_INDEX); 
                                min_routes = cu_get_min_param (ROUTES_ENTRIES_INDEX); 
                                diff = min_routes + max_routes - new_value; 
                                if (diff < cu_get_min_param(ROUTES_ENTRIES_INDEX))
                                    diff = cu_get_min_param(ROUTES_ENTRIES_INDEX);
                                /* For Minions v6 l3_defip takes 1 rows vs 1 row for ipv4 */
                                cu_set_config_param (ROUTES_ENTRIES_INDEX, diff);
                                uprintf("Warning: ip-route is updated to %d\n", diff);
                                reload_required = TRUE;
                                break;
                                /* ipv4 entry is set at the end of this switch case */
                        }

                        if (PP_IS_IPV4_IPV6_SHARE_TABLE)
                        {
                                if(sptr_cdb->execute == TRUE)
                                        uprintf ("Error: Please configure system-max ip-route command to change the value of ip6-route.\n");
                                return;
                        }
                        else
                        {
                                UINT32 ip6_default_vrf = cu_get_config_param(MAX_IPV6_ROUTES_DEFAULT_VRF);
                                UINT32 ip6_vrf_route = cu_get_config_param(MAX_IPV6_ROUTES_VRF);

                                // if configured value has changed, check for config param,
                                if (FALSE == cu_check_system_max_route(TRUE, TRUE, new_value, ip6_default_vrf, ip6_vrf_route, print_error))
                                {
                                        return;
                                }
                                uprintf("Warning: Please reconfigure system-max for ip6-route-default-vrf and ip6-route-vrf (if required).\n\n");
                                reload_required = TRUE;         
                                break;                          
                        }

                case IPV6_STATIC_ROUTE_ENTRIES_INDEX:
                        if(PP_IS_IPV4_IPV6_SHARE_TABLE)
                        {
                                if (sptr_cdb->execute == TRUE)
                                        uprintf ("Error: This system-max parameter is not configurable.\n");
                                return;
                        }
                        else
                        {
                                reload_required = TRUE;
                                break;
                        }       

                case IPV6_MAX_CACHE_ENTRIES_INDEX:
#ifdef SR_SWITCH_ROUTER
                        if (IS_MINIONS())    
                        {
                                /* Minions shares the l3-entry resource with ip-host, ipv6-host and multicast. 
                                 * There is a static partition between uc and mc so nothing to worry.
                                 * Just manipulate the ip and ipv6 range. 
                                 */
                                max_routes = cu_get_max_param (IP_CACHE_ENTRIES_INDEX); 
                                min_routes = cu_get_min_param (IP_CACHE_ENTRIES_INDEX); 
                                diff = min_routes + max_routes - (new_value*2);
                                if (diff < min_routes)
                                        diff = min_routes;
                                /* For Minions v6 l3_entry takes 2 rows vs 1 row for ipv4 */
                                cu_set_config_param (IP_CACHE_ENTRIES_INDEX, diff);
                                uprintf("Warning: ip-cache is updated to %d\n", diff);
                                reload_required = TRUE;
                                /* ipv6 entry is set at the end of this switch case */
                                ipv4_value = diff;
                                ipv6_value = new_value;
                                arp_value = cu_get_config_param(ARP_ENTRIES_INDEX);
                                max_intf = cu_get_config_param(MAX_ROUTER_INT_INDEX);
                                /* ip address configured for the interface == 1 host route (/32) entry in ip-cache, warn the admin */
				if (ipv6_value < max_intf)
                                    uprintf("Warning: ip6-cache is < configured l3-interface, ensure enough space in ip6-cache for host routes, 1 cache entry required for each configured interface ipv6 address.\n");
                                /* Do the checks for arp value and warn the admin */
                                if ((ipv4_value + ipv6_value) >= arp_value)
                                    uprintf("Warning: Please set ip-arp to (ip-cache + ip6-cache + delta),\nWhere delta is number of neighbors the prefix route is pointing to.\n\n");
                                break;
                        }
#endif

                        if(PP_IS_IPV4_IPV6_SHARE_TABLE)
                        {
                                if (sptr_cdb->execute == TRUE)
                                        uprintf ("Error: This system-max parameter is not configurable.\n");
                                return;
                        }
                        else
                        {
                                reload_required = TRUE;
                                break;
                        }       
#ifdef SIDEWINDER_LINUX
                case MAX_ECMP_INDEX:
                        if (gRtm.ipv4_max_equal_cost_paths > new_value || gRtm6.ipv6_max_equal_cost_paths > new_value)
                        {
                                
                                uprintf ("Error: Please reduce ip load-sharing or ipv6 load-sharing values below %d to be able to set this value\n",
                                        new_value);
                                return;
                        }
                        
                        reload_required = TRUE;
                        break;
                case MAX_IP_MAC_INDEX:

                        if(IS_MINIONS())
                        {
                                if (sptr_cdb->execute == TRUE)
                                        uprintf ("Error: This system-max parameter is not configurable.\n");
                                return;
                        }

			diff_mac_entries = new_value - cu_get_curr_param(MAX_IP_MAC_INDEX);
                        if(diff_mac_entries != 0)
                        {
							if(cu_check_configured_vrrp_instances_count(diff_mac_entries) == FALSE)
							{	/*check for vrrp instance is failed, i.e this ip-mac value can't be configured*/
								return;
							}	
                        	uprintf ("Total IP-MAC entries supported is changed to %d \n Total VRRP instances supported changed to %d, IPv4 VRRP instances: %d, IPv6 VRRP instances %d \n", 
                                                    new_value, VRRP_MAX_VIRTUAL_ROUTERS - diff_mac_entries, VRRP4_MAX_CONFIG_ROUTERS - diff_mac_entries, VRRP6_MAX_CONFIG_ROUTERS);
                        	reload_required = TRUE;
						}
                        break;
#endif SIDEWINDER_LINUX
#endif SR_SWITCH_ROUTER
                #ifdef FIOFL_INCLUDE
                case MAX_OPENFLOW_FLOW_ENTRIES_INDEX:
                case MAX_OPENFLOW_HYBRID_PROTECTED_VLAN_INDEX:
                case MAX_OPENFLOW_HYBRID_UNPROTECTED_VLAN_INDEX:
                case MAX_OPENFLOW_NEXTHOP_INDEX:
                case MAX_OPENFLOW_SELECT_GROUP_INDEX:
                {
                        if (!openflow_fi_configure_system_max(index, new_value, &reload_required))
                                return;                 
                        break;
                }
                #endif FIOFL_INCLUDE
                default:
                        reload_required = TRUE;
                        break;
        } /* switch index */

        /* If reload is not required, then change the current value also. */            
        if (TRUE == reload_required)
        {
                cu_set_is_reload_required(TRUE);
                printString = SaveAndReloadString;
        }
        else
        {
                /* set the value in the data structure */
                fndry_system_parameters[index].current = new_value;             
        }
        
        /* print appropriate message */
        if(!STACK_AM_I_SLAVE)
                uprintf("%s", printString);

        /* set the value in the data structure */
        fndry_system_parameters[index].config = new_value;
}

enum BOOLEAN cu_is_reload_required()
{
        return is_reload_required;
}

void cu_set_is_reload_required(enum BOOLEAN val)
{
        is_reload_required = val;
}

/* FUNCTION
 *      cli_set_system_max_type()
 *
 * SYNOPSIS
 *      Called by various parameters of system-max command. This
 *      function searches for the command in the fndry_system_parameters
 *      data structure and stores the index in integer9 of the
 *      struct cdb structure. This will be accessed by
 *      cli_set_system_max_value() in order to validate and set
 *      the system max value.
 */
void cli_set_system_max_type(struct cdb* sptr_cdb)
{
        UINT32 index, new_value;

        /* don't execute this during initialization */
        if (g_sw_sys.init_in_progress
                        && !(STACK_AM_I_STANDBY) // Standby don't pre-parsing. So, allow. I don't use #ifdef CHEETAH... because superX failover might need it.
                        )
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        index = cu_get_sys_param_index((sptr_cdb->current_node)->keyword);

        /* For Minions the virtual-interface is redifned as l3-interface */
        if (IS_MINIONS())
        {
                if(strcmp((sptr_cdb->current_node)->keyword, "l3-interface") == 0)
                        index = MAX_ROUTER_INT_INDEX;
        }

        if ((index == 0) || (index >= cu_get_sys_param_table_size()))
        {
                uprintf("Error - unable to find appropriate keyword in system "
                                        "parameters table.\n");
                sptr_cdb->dont_go_next = 1;
        }
        else
        {
                /* valid node found */

                if (sptr_cdb->help)
                {
                        /* dynamically change the help string to reflect the valid range
                         * for the expected decimal input.
                         */
                        ksnprintf(cli_system_max_help_string,
                                sizeof(cli_system_max_help_string),
                                "Valid range %d to %d (default: %d)",
                                fndry_system_parameters[index].min,
                                fndry_system_parameters[index].max,
                                fndry_system_parameters[index].def);
                        return;
                }

                /* check for no flag here - it is not necessary
                 * to enter an argument if no flag is entered since
                 * this will anyway reset the parameter to the
                 * default value.
                 */
                if (sptr_cdb->no)
                {
                        sptr_cdb->dont_go_next = 1;
                        new_value = fndry_system_parameters[index].def;
                        cu_set_system_max_param_value(sptr_cdb, index, new_value);
                        return;
                }

                /* set integer9 with the valid index */
                sptr_cdb->integer9 = index;
        }
}

/* FUNCTION
 *      cli_set_system_max_value()
 *
 * SYNOPSIS
 *      Final target function of the system-max command.
 *      This function validates the input (stored in integer1) using
 *      the data values stored in fndry_system_parameters data structure
 *      To index into the data structure, the function uses the index
 *      stored in integer9 by cli_set_system_max_type().
 */
void cli_set_system_max_value(struct cdb* sptr_cdb)
{
        UINT32 index = sptr_cdb->integer9;
        UINT32 new_value, max_next_hop, max_mll, max_inlif, max_pcl_action, max_tc;
        enum BOOLEAN skip_check;

        sptr_cdb->dont_go_next = 1;

        /* Sanity checks - should not ever happen */
        if (index == 0 || index >= cu_get_sys_param_table_size())
        {
                uprintf("Error - system-max - invalid index %d\n", index);
                return;
        }

        /* get the appropriate parameter entry */
        new_value = ((sptr_cdb->no) ?
                fndry_system_parameters[index].def : sptr_cdb->integer1);

#ifndef TURBOIRON
        switch(index) 
        {
                case MAC_ENTRIES_INDEX:         /* 64K FDB entries */
                        if ((new_value != fndry_system_parameters[index].max)  && 
                                (new_value != fndry_system_parameters[index].min))
                        {
                                uprintf("Error - Parameter %s should be ether %d or %d\n",
                                        fndry_system_parameters[index].para_name, fndry_system_parameters[index].min, fndry_system_parameters[index].max);
                                return;
                        }
                        break;
                default:
                        break;
        }

#ifdef SR_SWITCH_ROUTER
        max_next_hop    = cu_get_config_param(MAX_HW_IP_NEXT_HOP_INDEX);
        max_mll                 = cu_get_config_param(MAX_HW_IP_MCAST_MLL_INDEX);
        if (isSysDevFamilyTiger() || isSysDevFamilyPumaTigerHybrid())
                max_inlif = cu_get_config_param (VLAN_ENTRIES_INDEX) + 1;
        else
                max_inlif               = cu_get_config_param(MAX_HW_LOGICAL_INT_INDEX);
        max_tc                  = cu_get_config_param(MAX_HW_TRAFFIC_COND_INDEX);
        max_pcl_action  = PP_MAX_PCL_ACTION;

        skip_check = FALSE;
        switch(index) {
                case MAX_HW_IP_NEXT_HOP_INDEX:
                        if (isSysDevFamilyTiger() || isSysDevFamilyPumaTigerHybrid()) {
                                max_inlif          = cu_get_config_param(VLAN_ENTRIES_INDEX) + 1;
                        }
                        max_next_hop = new_value;
                                break;
                case MAX_HW_IP_MCAST_MLL_INDEX:
                        if (!isSysDevFamilyPumaTigerHybrid() && !isSysDevFamilyTiger()) {
                                max_mll = new_value;
                        } else {
                                uprintf("Max Hardware IP Multicast MLL entries can not be changed for this platform.\n");
                                return;
                        }
                        break;
                case MAX_HW_LOGICAL_INT_INDEX:
                        if (!isSysDevFamilyPumaTigerHybrid() && !isSysDevFamilyTiger()) {
                                max_inlif        = new_value;
                        } else {
                                uprintf("Max Hardware Logical Interface can not be changed for this platform.\n");
                                return;
                        }
                        break;
                case MAX_HW_TRAFFIC_COND_INDEX:
                        max_tc           = new_value;
                        break;
                case VLAN_ENTRIES_INDEX:
                        if (isSysDevFamilyTiger() || isSysDevFamilyPumaTigerHybrid()) {
                                        max_inlif = new_value + 1;
                        }
                        break;
                case MAX_MULTICAST_TCAM_ENTRIES:
                        if(isSysDevFamilyTiger())
                        {
                                uprintf("MAX multicast TCAM entries is not applicable to this platform.\n");
                                return;
                        }
                default:
                        skip_check = TRUE;
                        break;
}

        if (!skip_check)
        {
                /*
                if (isSysDevFamilyTiger())
                {
                        //Tiger mll has its own memory
                        max_mll = 0;
                }
                */
                if (!isSysDevFamilyPumaTigerHybrid() && !isSysDevFamilyTiger() && !isSysDevFamilyPumaOnly())
                {
                        if (pp_check_max_wsram_usage(
                                                                        max_next_hop,
                                                                        max_mll,
                                                                        max_inlif,
                                                                        max_pcl_action,
                                                                        max_tc) != RETURN_OK)
                        {
                                uprintf("Error: Parameter setting failed. Please reduce other parameters before increasing this one\n");
                                return;
                        }
                }
        }
#endif SR_SWITCH_ROUTER

#ifdef SR_SWITCH_ROUTER
        if (isSysDevFamilyTiger() || isSysDevFamilyPumaTigerHybrid())
        {
                if ((index == MAX_HW_TRAFFIC_COND_INDEX) ||
                        (index == VLAN_ENTRIES_INDEX))
                {
                        int nexthop;
                        nexthop = pp_ip6_calculate_num_hw_nexthop(max_tc, max_inlif);
                        if( nexthop < 0x400 )//reserve a minimum of 1024 nexthop entries
                        {
                                uprintf("Error : Insufficient resources to set this value. Please set a lower limit\n");
                                return;
                        }
                        if (nexthop !=  fndry_system_parameters[MAX_HW_IP_NEXT_HOP_INDEX].current)
                                uprintf ("Warning: hw-ip-next-hop will be changed to %d after reboot\n",
                                                nexthop);
                }
        }
#endif SR_SWITCH_ROUTER
#endif TURBOIRON

        if(index == MAC_NOTIFICATION_BUFFER_SIZE)
        {
                if ((new_value > fndry_system_parameters[index].max) ||   
                        (new_value < fndry_system_parameters[index].min))
                {
                        uprintf("Error - Parameter %s should be within the range %d to %d\n",
                                        fndry_system_parameters[index].para_name, fndry_system_parameters[index].min, fndry_system_parameters[index].max);
                        return;
                }
        }

#ifdef SR_SWITCH_ROUTER // this check is to not allow the IPv6 route related system max configuration in case of shared TCAM between IPv4 and IPv6. 
        if(PP_IS_IPV4_IPV6_SHARE_TABLE && !IS_MINIONS())
        {
                if (index == IPV6_STATIC_ROUTE_ENTRIES_INDEX || index == IPV6_MAX_CACHE_ENTRIES_INDEX)
                {
                        if (sptr_cdb->execute == TRUE)
                                uprintf ("Error: This system-max parameter is not configurable.\n");

                        return;
                }

                if (index == IPV6_ROUTES_ENTRIES_INDEX)
                {
                        if (sptr_cdb->execute == TRUE)
                                uprintf ("Error: Please configure system-max ip-route command to change the value of ip6-route.\n");

                        return;
                }
        }
#endif // SR_SWITCH_ROUTER

        /* set the value */
        cu_set_system_max_param_value(sptr_cdb, index, new_value);
}
#endif NO_SYS_PAR

//#ifdef HOT_SWAP
static void cli_find_module_type(unsigned char *line)
{
        unsigned char *token=line;
        int slot;
        int config_module_type;
        int count=0;
        char *temp = "module";
        UINT32 moduleId;

        if (is_stack())
                return;

        /* this function handles addition of user defined
         * module type at initialization time
         */
        SKIP_WHITE_SPACE(token);

        /* "module" */
        if (memcmp(token, temp, strlen(temp)) == 0)
        {
                /* slot number */
                NEXT_TOKEN(token);
                slot = cli_get_int(token,1,&count);
                if (slot<1 || slot>g_hw_info.max_mod)
                        return;
                slot--;
                /* module type */
                NEXT_TOKEN(token);
                config_module_type = mod_keyword_to_type(token);
                if (config_module_type == INVALID_MODULE_TYPE)
                        return;

                /* Raj - 10/13/2006
                  * In case there is a conflict between the module configured as per the startup
                  * configuration and the actual module present in the slot (only for slot == 1,
                  * since on 24 port cheetah slot 2 is fixed when shipped), the following logic is applied
                  * Case 1
                  *  In case there is no physical card in the slot then the module config from the
                  *  startup config is applied
                  * Case 2
                  *  In case there is a physical card present in the slot and the there is a mismatch
                  *  between configured and the phy card then the config from the startup config is
                  *  skipped
                  * Case3
                  *  In case there is a physical card in the slot and it matches with the startup
                  *  configuration , then the module addition is skipped
                  */
                // CHEETAH_STACKING klin, we must do conversion between 4.0 and 5.0 format
                // klin, If there is 4.0 config, but it does not match the real module, we must block. This can be duplicated
                // by copy t startup. This is a negative case test. I know the code is messy, but I don't want to streamline it.
                // verify the following to skip pp_update_module_id() and return otherwise it create module without default port
                if(g_stacking.has_stack_most_recent== 0) // There is no "stack unit ?" at all.
                {
                        if(IS_BASE_STACK_MODULE(slot))
                        {
                                int mybaseslot = STACK_TO_MODULE_ID(MY_BOOTUP_STACK_ID);
                                if(g_module[mybaseslot].module_type != INVALID_MODULE_TYPE && g_module[mybaseslot].module_type != config_module_type)
                                {       //This can only happen in negative case that "copy tftp startup" a wrong config without stack-id
                                        uprintf("Warning! base config module %u %s does not match hardware %s. Ignore\n",
                                                MODULE_TO_STACK_MODULE(slot) + 1,
                                                modtype_to_keyword(config_module_type),
                                                modtype_to_keyword(g_module[mybaseslot].module_type));
                                        g_base_module_no_match = 1;
                                        return;
                                }
                                else
                                        g_base_module_no_match = 0;
                        }
                        else if(g_base_module_no_match)
                                return;
                }
#if 0 // master_id_change is never implemented. But we keep code in case
                if(g_stacking.eeprom_data_bootup.master_id_change &&
                        g_stacking.eeprom_data_bootup.old_stack_id_ary_not_used[MY_BOOTUP_STACK_ID] == g_stacking.has_stack_most_recent)
                {
                        slot += STACK_TO_MODULE_ID(MY_BOOTUP_STACK_ID);
                        cu_add_module_type(slot, config_module_type);
                        return; // This is my old config. I should ignore this.
                }
#endif 0 // master_id_change is never implemented. But we keep code in case
                // CHEETAH_STACKING klin, we must do conversion between 4.0 and 5.0 format
                // Suppose I bootup as 3, and there is no stack unit 3, then I must use the stack unit 1 module.
                // If the standby parsing config, the g_stacking.has_stack[MY_BOOTUP_STACK_ID] could be 0
                // because hal_gi_get_variables_from_startup_config_before_parsing() is not executed.
                // We don't want to go through the pre-parsing trouble for synced run-time config, so just modify here.

                // TR290356 The master boot up as unit 8. There is no unit 8 in startup config. The unit 1 config base module
                // does not match startup config. But it take unit 1 config but later reject it. This cause unit 1 port db not allocated
                // and later crash in acl trunk. In such case, we should not change unit 1 config to unit 8.
                if(g_stacking.has_stack_most_recent == 1 &&
                        MY_BOOTUP_STACK_ID != 1 && !g_stacking.has_stack[MY_BOOTUP_STACK_ID]
                        &&  (g_mod2cpu[STACK_TO_MODULE_ID(MY_BOOTUP_STACK_ID)].config_module_type == config_module_type)
                        && (!STACK_AM_I_SLAVE)) // standby does not have has_stack[] done properly in run-time config
                        slot += STACK_TO_MODULE_ID(MY_BOOTUP_STACK_ID);
                else if(g_stacking.has_stack_most_recent)
                {
                        slot += STACK_TO_MODULE_ID(g_stacking.has_stack_most_recent);
                }
                // klin, All my module is read in module_probe(), cold_start_modules(), hw_init(), kinit().
                // This is in reading config. If the master ID change and this is the new master config, we should not read it.
                // It belongs to someone else in the old startup_config.
                // TR280925. Somehow the slave bootup as master with id=3, but its run-time config
                // has a wrong unit 1 config. So, it fall into the case most_recent=1 && ID != 1 && !has_stack[ID],
                // Then slot becomes 8. If it is not reject, it will call cli_stacking_add_module_type() and then
                // crash due to overwritting itself with wrong type.
                if(g_stacking.has_stack_most_recent == MY_BOOTUP_STACK_ID // is this necessary ?? due to the next line
                        || (MODULE_TO_STACK_ID(slot)) == MY_BOOTUP_STACK_ID) // TR280925
                {
#if 0 // master_id_change is never implemented. But we keep code in case
                        if(g_stacking.eeprom_data_bootup.master_id_change)
                        {
                                return;
                        }
#endif 0 // master_id_change is never implemented. But we keep code in case
                        // If the base module does not match myself, it is due to some residue config. We should reject all modules in such case.
                        if(IS_BASE_STACK_MODULE(slot))
                        {
                                if(g_module[slot].module_type != INVALID_MODULE_TYPE && g_module[slot].module_type != config_module_type)
                                {
                                        uprintf("Warning! stack %u base config module %u %s does not match hardware %s. Ignore stack %u module config\n",
                                                MY_BOOTUP_STACK_ID, MODULE_TO_STACK_MODULE(slot) + 1,
                                                modtype_to_keyword(config_module_type),
                                                modtype_to_keyword(g_module[slot].module_type), MY_BOOTUP_STACK_ID);
                                        g_base_module_no_match = 1;
                                        return;
                                }
                                else
                                        g_base_module_no_match = 0;
                        }
                        else if(g_base_module_no_match)
                                return;
                }
                else
                        g_base_module_no_match = 0; // clear it so it can handle next stack id config
                if (g_stacking.has_stack_most_recent ==0 || g_stacking.has_stack_most_recent == MY_BOOTUP_STACK_ID)
                {
                        cu_add_module_type(slot, config_module_type);
                }
                else
                {
                        int res;
                        res = cli_stacking_add_module_type(slot, config_module_type);

                }
        }
}

static void cli_add_module_type(struct cdb *sptr_cdb)
{
UINT32 module;
        /* this function handles addition of user defined
         * module type at runtime
         */
         /* TBD Rolled back for now: TR000318794: When active executes cu_add_module_type() command
                internal_parsing_flag was 0, which happened in the first phase or
                pre-parsing time. But during this time dynamic sync the commands to
                standby was not supported, but when this command was called during
                parsing internal_parsing_flag was set to 1 in some cases such as
                parsing config file from buffer, so cu_add_module_type() was never be
                called on the standby because of this flag is set to 1. To execute
                cu_add_module_type() function on the standby, we are skipping the
                returning from here. */
        if (sptr_cdb->internal_parsing_flag) // && is_mgmt_active())
                return;
                if(sptr_cdb->config_gen) // kklin, add this to avoid lots of comaplain
                        return; 
        // CHEETAH_STACKING: klin, should we add this to prevent from
        if(sptr_cdb->mode != CONFIG_STACK && sptr_cdb->mode != CONFIG_SPX_PE)
        {
                if (!is_stacking_prom_installed())
                {
                        // this is for standalone case (no stacking EEPORM)    /*bug107322*/
                        sptr_cdb->stack_id = DEFAULT_STANDALONE_STACK_ID;
                }
                else
                {
                        uprintf("Error! you must enter stack config mode by \"stack unit ID\"\n");
                        return;
                }
        }

        module = MAKE_MODULE_ID(sptr_cdb->stack_id, sptr_cdb->integer1)-1; // CHEETAH_STACKING

        if (sptr_cdb->stack_id == MY_BOOTUP_STACK_ID)
        {

                if (MODULE_TO_STACK_MODULE(module))
                {
   
                        cu_add_module_type((MODULE_ID)module, (UINT8)sptr_cdb->integer2);
                }
                else
                {
                        uprintf("ERROR - Cannot add or delete base module %d.\n", sptr_cdb->integer1);
                }
        }
        else
        {
                cli_stacking_add_module_type((MODULE_ID)module, sptr_cdb->integer2);
        }
}

static void cli_delete_module_type(struct cdb *sptr_cdb)
{
        int i;
        UINT32 module;
        //convet local module id to stacking module id
        int base_mod;
        module = MAKE_MODULE_ID(sptr_cdb->stack_id, sptr_cdb->integer1-1); // CHEETAH_STACKING
        base_mod = MODULE_TO_BASE_MODULE(module);
        // before deleting the module we need to make sure no session is inside the interface
        // config mode for that module. Otherwise that session will crash trying to access
        // ports on just deleted module. This can also happen through concurrent sessions.
        for( i=0; i<MAX_IO_CB; i++)
        {       // CHEETAH_STACKING BUG: 88916. Also update update_sptr_cdb_config_mode_due_to_stack_removal
                if(cdbs[i].mode == CONFIG_IF || cdbs[i].mode == CONFIG_PORT_SECURITY_IF)
                {
                        if (PORT_TO_MODULE_ID(INTERFACE_TO_PORT_ID(cdbs[i].if_num)) == module) // CHEETAH_STACKING, 84979, use module, not sptr_cdb->integer1-1
                                set_cli_mode(&cdbs[i], CONFIG);
                }
                else if ( cdbs[i].mode == CONFIG_MIF)
                {       // check if MIF contains any ports belonging to this module being deleted.
                        if (PORT_MASK_ISSET_ANY (cdbs[i].mif_port_mask[module]))
                                set_cli_mode(&cdbs[i], CONFIG);
                }

        }
       	cli_stacking_delete_module(module, FALSE);
}

void cli_config_gen_module_type(struct cdb *sptr_cdb)
{
        int i;
        char *module_name;

        if (is_stack())
                return;

        if (sptr_cdb->config_gen)
        {
                for (i=0; i < g_hw_info.max_mod; i++)
                {
                        if (CONFIG_MODULE_EXIST(i))
                        {
                                module_name = modtype_to_keyword(g_mod2cpu[i].config_module_type);
                                if (module_name)
                                {
                                        if (!is_stacking_prom_installed())         /*bug107322*/
                                                ksprintf(cu_line_buf, "module %d %s\n", i+1, module_name);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }
                        }
                }
        }
}

static void disable_sidewinder_module_types()
{
        if (IS_SIDEWINDER())
                return;
        
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_20QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_FRONT_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_REAR_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
static void disable_spatha_module_types()
{
        if(IS_SPATHA())
                return;

    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_32P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_48GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_IPSEC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );	
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
static void disable_sica_module_types()
{
        if(IS_SICA())
                return;

    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}

static void disable_minions_module_types()
{
        if(IS_MINIONS())
                return;

    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_C12P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48PF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48ZP_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_2GC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_2XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}

static void disable_tanto_module_types()
{
        if(IS_TANTO())
                return;

    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_BASE_48ZP_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_BASE_48GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );	
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_1HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_4QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_2HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
    update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_48P_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}

static void disable_all_module_types()
{
    disable_sidewinder_module_types();
        disable_spatha_module_types();
        disable_sica_module_types();
		disable_minions_module_types();
		disable_tanto_module_types();
    return;
}
void allow_sidewiner_base_module_config() // KKLIN_8021BR
{
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SIDEWINDER_STACK_BASE_20QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SIDEWINDER_STACK_BASE_48XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SIDEWINDER_STACK_BASE_48XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_FRONT_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_REAR_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void disallow_sidewiner_base_module_config() // KKLIN_8021BR
{
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_20QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void allow_spatha_base_module_config() // KKLIN_8021BR
{
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_BASE_32P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_BASE_48GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_IPSEC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void allow_sica_l_base_module_config() // KKLIN_8021BR
{
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_L_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void allow_sica_base_module_config() // KKLIN_8021BR
{
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void allow_minions_base_module_config() 
{
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_C12P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_48PF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_BASE_48ZP_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_2GC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_2XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void allow_tanto_base_module_config() 
{
        update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_BASE_48ZP_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_BASE_48GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_1HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_4QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_2HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
        update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_48P_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
}
void cli_preset_module_type(struct cdb *sptr_cdb)
{
MODULE_ID base_mod;
UINT8 module_type;
int max_mod = -1;
    if (sptr_cdb->execute)
    {
                if (sptr_cdb->config_gen) // kklin, add this, otherwise it complains for module 0 durining show run
    {
        sptr_cdb->dont_go_next = 1;
        return;
    }
            if (!hal_check_for_valid_module(sptr_cdb, 1, MAX_LOCAL_SLOT)) //stacking local module 1-4
            {
                    sptr_cdb->dont_go_next = 1;
                    return;
            }

    }
    disable_all_module_types();
    if (sptr_cdb->integer1 == 1) // base module
    {
            if (IS_SIDEWINDER())
            {
                if(sptr_cdb->stack_id <= MAX_STACKING_NUM) // KKLIN_8021BR
                {
                     //Sidewinder
                     
                                         allow_sidewiner_base_module_config();
                }
#ifdef __PORT_EXTENSION__ // KKLIN_8021BR
                                else // PE config, allow Spatha, Sica will be done later
                                {
#ifndef OFFICIAL_RELEASE // official release do not allow Sidewinder as a PE unit
                                        allow_sidewiner_base_module_config();
                                        //allow_sica_l_base_module_config(); //BA: aggreed with PM that SICA-L will not be a PE
#endif OFFICIAL_RELEASE
                                        allow_spatha_base_module_config();
                                        allow_sica_base_module_config();
										allow_minions_base_module_config();
										allow_tanto_base_module_config();
                                }
#endif __PORT_EXTENSION__ // KKLIN_8021BR
            }
                        else if (IS_SPATHA())
                        {
                                //Spatha
                                allow_spatha_base_module_config();
                        }
                        else if(IS_SICA())
                        {
                                //Sica
                                if(IS_SICA_L_24GC())
                                {
                                        allow_sica_l_base_module_config();
                                }
                                else
                                {
                                        allow_sica_base_module_config();
                                }
                        }
            			else if (IS_MINIONS())
            			{
							allow_minions_base_module_config();
            			}
            			else if (IS_TANTO())
            			{
							allow_tanto_base_module_config();
            			}

    }
    else // non-base module
    {
            //this is the case for standalone (no stacking EEPROM)   /*bug107322*/
            if (!is_stacking_prom_installed())
                    sptr_cdb->stack_id = DEFAULT_STANDALONE_STACK_ID;

            if (sptr_cdb->stack_id)
            {
                    base_mod = MAKE_MODULE_ID(sptr_cdb->stack_id, 0);

                    if (MODULE_IS_SIDEWINDER(base_mod))
                    {
                             //Sidewinder
                             if(sptr_cdb->integer1 == 2) // This is front 6 QXG module
                             {
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_REAR_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_20QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 0, GS_SIDEWINDER_STACK_FRONT_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                             }
                             else if(sptr_cdb->integer1 == 3)// This is back 6 QXG module
                             {
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_FRONT_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_REAR_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_20QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 1, GS_SIDEWINDER_STACK_BASE_48XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                 update_tree_node_flag(c_module_num, TRUE, 0, GS_SIDEWINDER_STACK_REAR_6QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                             }
                    }
                    else if (MODULE_IS_SPATHA(base_mod))
                    {
                    
#ifdef __PORT_EXTENSION__ // KKLIN_8021BR, we do not turn off sidewinder yet, so do it here for PE
                                                if (IS_SIDEWINDER())
                                                        disallow_sidewiner_base_module_config();
#endif __PORT_EXTENSION__ // KKLIN_8021BR
                                                update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_32P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_BASE_48GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        if((sptr_cdb->integer1 == 3) || (sptr_cdb->integer1 == 4)) //4x1F is not supported on slot 2 & 3
                            update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        else
                            update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );

                        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_MOD_IPSEC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );						
                        update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_MOD_4XGC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );

                        if((sptr_cdb->integer1 == 2) && !MODULE_IS_SPATHA24(base_mod)) // if base module is not 24/24p slot 1 doesnt support 1x40Q
                            update_tree_node_flag(c_module_num, TRUE, 1, GS_SPATHA_STACK_MOD_QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                        else
                            update_tree_node_flag(c_module_num, TRUE, 0, GS_SPATHA_STACK_MOD_QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                    }
                                        else if (MODULE_IS_SICA(base_mod))
                                        {
#ifdef __PORT_EXTENSION__ // KKLIN_8021BR, we do not turn off sidewinder yet, so do it here for PE
                                                if (IS_SIDEWINDER())
                                                        disallow_sidewiner_base_module_config();
#endif __PORT_EXTENSION__ // KKLIN_8021BR
                                                update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );

                                                if(MODULE_IS_SICA_L(base_mod))
                                                {
                                                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_L_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                }
                                                else
                                                {
                                                        update_tree_node_flag(c_module_num, TRUE, 0, GS_SICA_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                        update_tree_node_flag(c_module_num, TRUE, 1, GS_SICA_L_STACK_MOD_4GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
                                                }
                                        }
                                        else if (MODULE_IS_MINIONS(base_mod))
                                        {
#ifdef __PORT_EXTENSION__ // KKLIN_8021BR, we do not turn off sidewinder yet, so do it here for PE
                                                if (IS_SIDEWINDER())
                                                        disallow_sidewiner_base_module_config();
#endif __PORT_EXTENSION__ // KKLIN_8021BR
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_C12P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_24G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_24P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48G_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48PF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 1, GS_MINIONS_STACK_BASE_48ZP_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_MOD_2GC_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_MOD_2XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
												update_tree_node_flag(c_module_num, TRUE, 0, GS_MINIONS_STACK_MOD_8XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );

                                        }
                                        else if (MODULE_IS_TANTO(base_mod))
                                        {
#ifdef __PORT_EXTENSION__ // KKLIN_8021BR, we do not turn off sidewinder yet, so do it here for PE
                                                if (IS_SIDEWINDER())
                                                        disallow_sidewiner_base_module_config();
#endif __PORT_EXTENSION__ // KKLIN_8021BR
						update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_BASE_48P_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
						update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_BASE_48ZP_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
						update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_BASE_48GF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
						if (sptr_cdb->integer1 == 3) {
							update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_1HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_MOD_4QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_MOD_2HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							if(IS_TANTO_48GP())
								update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_MOD_48P_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							else
								update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_48P_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
						} else if (sptr_cdb->integer1 == 2) {
							update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_MOD_4XGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_MOD_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );

							if(IS_TANTO_48GP()) /* Tanto-48P does not support 1X100G in slot1(front side slot)*/
								update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_1HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							else
								update_tree_node_flag(c_module_num, TRUE, 0, GS_TANTO_STACK_MOD_1HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );

							update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_4QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_2HGF_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
							update_tree_node_flag(c_module_num, TRUE, 1, GS_TANTO_STACK_MOD_48P_2QXG_KEYWORD, KEYWORD, DONT_PARSE | DONT_SHOW );
						}
                                        }
            }
    }


    if (!sptr_cdb->execute)
                    return;

    base_mod = MAKE_MODULE_ID(sptr_cdb->stack_id, 0);
    if(base_mod != sptr_cdb->integer1)
    {
            module_type = g_module[(base_mod)].module_type;
            if (MODULE_TYPE_IS_SICA(module_type))
            {
                                max_mod = 2;
            }
            else if (MODULE_TYPE_IS_SIDEWINDER(module_type) || MODULE_TYPE_IS_SPATHA(module_type) 
							|| MODULE_TYPE_IS_MINIONS(module_type) || MODULE_TYPE_IS_TANTO(module_type))
            {
                                max_mod = 3;
            }

                        if (MODULE_TO_STACK_MODULE(sptr_cdb->integer1-1) > max_mod)
            {
                char *stack_spx;
#ifdef __PORT_EXTENSION__ // KKLIN_8021BR, This function is shared between stack and PE
                                if(sptr_cdb->stack_id > MAX_STACKING_NUM)
                                        stack_spx = stack_spx_cscd_str[1];
                                else
#endif __PORT_EXTENSION__ // KKLIN_8021BR, This function is shared between stack and PE
                                        stack_spx = stack_spx_cscd_str[0];
                                uprintf("Error - %s unit %d module %d is invalid for this system\n", 
                                        stack_spx,
                                        sptr_cdb->stack_id, sptr_cdb->integer1);
                    sptr_cdb->dont_go_next = 1;
                    return;
            }
    }
        if (sptr_cdb->no)
        {
                if (sptr_cdb->help)
                        return;
                cli_delete_module_type(sptr_cdb);
                sptr_cdb->dont_go_next = 1;
        }
                return;
}

extern void icx7650_rear_module_mode_set(int mod);

#ifdef SIDEWINDER_LINUX
void cli_set_module_pp_sidewinder_20qxg_base_mgmt( struct cdb *sptr_cdb )
{
    sptr_cdb->integer2 = GS_SIDEWINDER_STACK_BASE_20QXG;
    cli_add_module_type( sptr_cdb );
}

void cli_set_module_pp_sidewinder_48xgf_base_mgmt( struct cdb *sptr_cdb )
{
    sptr_cdb->integer2 = GS_SIDEWINDER_STACK_BASE_48XGF;
    cli_add_module_type( sptr_cdb );
}

void cli_set_module_pp_sidewinder_48xgc_base_mgmt( struct cdb *sptr_cdb )
{
    sptr_cdb->integer2 = GS_SIDEWINDER_STACK_BASE_48XGC;
    cli_add_module_type( sptr_cdb );
}

void cli_set_module_pp_sidewinder_6qxg_front_mgmt( struct cdb *sptr_cdb )
{
    sptr_cdb->integer2 = GS_SIDEWINDER_STACK_FRONT_6QXG;
    cli_add_module_type( sptr_cdb );
}

void cli_set_module_pp_sidewinder_6qxg_bear_mgmt( struct cdb *sptr_cdb )
{
    sptr_cdb->integer2 = GS_SIDEWINDER_STACK_REAR_6QXG;
    cli_add_module_type( sptr_cdb );
}

#endif

void cli_set_module_pp_spatha_24_base_mgmt (struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SPATHA_STACK_BASE_24G;
        cli_add_module_type( sptr_cdb );

}
void cli_set_module_pp_spatha_24p_base_mgmt (struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SPATHA_STACK_BASE_24P;
        cli_add_module_type( sptr_cdb );

}
void cli_set_module_pp_spatha_48_base_mgmt (struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SPATHA_STACK_BASE_48G;
        cli_add_module_type( sptr_cdb );

}
void cli_set_module_pp_spatha_48p_base_mgmt (struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SPATHA_STACK_BASE_48P;
        cli_add_module_type( sptr_cdb );

}
void cli_set_module_pp_spatha_32p_base_mgmt (struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SPATHA_STACK_BASE_32P;
        cli_add_module_type( sptr_cdb );

}
void cli_set_module_pp_spatha_48f_base_mgmt (struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SPATHA_STACK_BASE_48GF;
        cli_add_module_type( sptr_cdb );

}

void cli_set_module_pp_spatha_4xgf_mod(struct cdb *sptr_cdb)

{
        sptr_cdb->integer2 = GS_SPATHA_STACK_MOD_4XGF;
        cli_add_module_type( sptr_cdb );


}

void cli_set_module_pp_spatha_ipsec_mod(struct cdb *sptr_cdb)

{
        sptr_cdb->integer2 = GS_SPATHA_STACK_MOD_IPSEC;
        cli_add_module_type( sptr_cdb );


}

void cli_set_module_pp_spatha_4xgc_mod(struct cdb *sptr_cdb)

{
        sptr_cdb->integer2 = GS_SPATHA_STACK_MOD_4XGC;
        cli_add_module_type( sptr_cdb );


}
void cli_set_module_pp_spatha_4f_mod(struct cdb *sptr_cdb)

{
        sptr_cdb->integer2 = GS_SPATHA_STACK_MOD_4GF;
        cli_add_module_type( sptr_cdb );


}
void cli_set_module_pp_spatha_1qxg_mod(struct cdb *sptr_cdb)

{
        sptr_cdb->integer2 = GS_SPATHA_STACK_MOD_QXG;
        cli_add_module_type( sptr_cdb );


}

//Sica
void cli_set_module_pp_sica_l_base_24(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_L_STACK_BASE_24G;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_sica_base_24(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_STACK_BASE_24G;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_sica_base_48(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_STACK_BASE_48G;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_sica_base_24_poe(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_STACK_BASE_24P;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_sica_base_48_poe(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_STACK_BASE_48P;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_sica_4gf(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_L_STACK_MOD_4GF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_sica_8xgf(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_SICA_STACK_MOD_8XGF;
        cli_add_module_type(sptr_cdb);
}

/* minions */
void cli_set_module_pp_minions_base_c12_poe(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_C12P;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_base_24(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_24G;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_base_24_poe(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_24P;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_base_48(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_48G;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_base_48_poe(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_48P;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_base_48_poef(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_48PF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_base_48z_poeh(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_BASE_48ZP;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_2gc(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_MOD_2GC;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_4xgf(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_MOD_4XGF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_2xgf(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_MOD_2XGF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_minions_8xgf(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_MINIONS_STACK_MOD_8XGF;
        cli_add_module_type(sptr_cdb);
}
/* Tanto */
void cli_set_module_pp_tanto_48p_base_mgmt(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_BASE_48P;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_48zp_base_mgmt(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_BASE_48ZP;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_48f_base_mgmt(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_BASE_48GF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_4xgf_mod(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_MOD_4XGF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_2qxg_mod(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_MOD_2QXG;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_1hgf_mod(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_MOD_1HGF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_4qxg_mod(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_MOD_4QXG;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_2hgf_mod(struct cdb *sptr_cdb)
{
        sptr_cdb->integer2 = GS_TANTO_STACK_MOD_2HGF;
        cli_add_module_type(sptr_cdb);
}

void cli_set_module_pp_tanto_48p_2qxg_mod(struct cdb *sptr_cdb)
{
	if(!IS_TANTO_48GP())
		return;

        sptr_cdb->integer2 = GS_TANTO_STACK_MOD_48P_2QXG;
        cli_add_module_type(sptr_cdb);
}

void cli_show_module(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        cu_show_module();
}
//#endif HOT_SWAP

enum BOOLEAN validate_time_after_arguments(
        UINT32 day,
        UINT32 hour,
        UINT32 min)
{
        if (day > 99)
        {
                uprintf("error - invalid days %u\n", day);
                return FALSE;
        }
        if (hour > 23)
        {
                uprintf("error - invalid hours %u\n", hour);
                return FALSE;
        }
        if (min > 59)
        {
                uprintf("error - invalid minutes %u\n", min);
                return FALSE;
        }
        return TRUE;
}

UINT32 convert_to_full_year(UINT32 year)
{
        /* Also accept format like 98 vs. 1998 */
        /* Note: 35 --> 2035, while 36 --> 1936 */
        if (year <= 35)
                year += 2000;
        else
        if (year <= 99)
                year += 1900;
        return year;
}

enum BOOLEAN validate_time_at_arguments(
        UINT32 year,
        UINT32 month,
        UINT32 day,
        UINT32 hour,
        UINT32 min,
        UINT32 sec)
{
        if (hour > 23)
        {
                uprintf("error - invalid hours %u\n", hour);
                goto return_false;
        }
        if (min > 59)
        {
                uprintf("error - invalid minutes %u\n", min);
                goto return_false;
        }
        if (sec > 59)
        {
                uprintf("error - invalid seconds %u\n", sec);
                goto return_false;
        }
	/*
        if (month == 0 || month > 12)
        {
                uprintf("error - invalid month %u\n", month);
                goto return_false;
        }
	*/
        if (day == 0 || day > 31)
        {
                uprintf("error - invalid day %u\n", day);
                goto return_false;
        }
        if (year < 1936 || year > 2035)
        {
                uprintf("error - invalid year %u\n", year);
                goto return_false;
        }
                /*Have to validate the day for the corresponding month and year */
                switch(month)
                {
                case JANUARY:
                case MARCH:
                case MAY:
                case JULY:
                case AUGUST:
                case OCTOBER:
                case DECEMBER:
		/*
                        if( day > THIRTYONE_DAY)
                {
                uprintf("error - invalid day %u\n", day);
                goto return_false;
                }
		*/
                        break;
        case APRIL:
                case JUNE:
                case SEPTEMBER:
                case NOVEMBER:
                        if( day > THIRTY_DAY )
                        {
                uprintf("error - invalid day %u\n", day);
                goto return_false;
                }
                        break;
                case FEBRUARY:
                        if(year % 4 == 0){
                                if(day > FEB_LEAPYEAR_DAY)
                                {
                uprintf("error - invalid day %u\n", day);
                goto return_false;
                }
                                }
                        else
                                if(day > FEB_NONLEAPYEAR_DAY)
                                {
                uprintf("error - invalid day %u\n", day);
                goto return_false;
                }
                                break;
                default:
                                goto return_false;
                                uprintf("error - invalid month %u\n", month);
                                break;
                        
                }
        return TRUE;
return_false:
        // 290554, kklin, display the stack trace otherwise we don't know whose fault during booting up
        return FALSE;
}

/* The following is for scheduled system reload */
//extern UINT32 zone_offset;
#define RELOAD_WARN_INTERVAL 180

void scheduled_reset(UINT32 typeNSession)
{
        UINT32 * cli_boot;
        UINT32 type;
        //Under AAA, parameter "typeNSession" is a combo of boot from type (MS 16 bits) and issuing ui_port (LS 16 bits)
        UINT16  ui_port = typeNSession&0x0000ffff;
        type = (UINT32)(typeNSession>>16 & 0x0000ffff);

        g_reboot_timer = NULL;
        if ( (sptr_flash_cb)
                )
        {
                g_reboot_timer = sv_set_timer((3 * SECOND), ONCE_TIMER, scheduled_reset, typeNSession);
                return;
        }
                if (!STACK_AM_I_SLAVE)
                {
                        UINT32 next_session_id;
                        //If system accounting is configured, do it now. After AAA is done, call the function special_reload() again
                        //Assume sessionid as 0 as we don't know the origination of this command.
                        cdbs[ui_port].cli_callback = (void (*)())scheduled_reset;
                        cdbs[ui_port].cli_callback_param = typeNSession;
                        aaa.shutdown_in_progress = TRUE;
                        if (cli_request_system_accounting(ui_port, FALSE))
                                return;
                        else
                        {
                                //Start EXEC Accnt STOP from the first active console/telnet/ssh session.
                                next_session_id = aaa_get_next_active_session(0xffffffff);
                                cdbs[next_session_id].cli_callback = (void (*)())scheduled_reset;
                                cdbs[next_session_id].cli_callback_param = typeNSession;
                                if (cli_request_exec_accounting_stop_all(next_session_id))
                                        return;
                        }
                }

    if (STACK_AM_I_MASTER || STACK_AM_I_CB_AND_PE_NUM)
    {
                if(dnld_send_boot_req_all(STK_DNLD_BOOT_TYPE_SCHED_RESET, type)) // 573019 If return 1, it setup a timer to reload
                return;
    }


        if (type == 0)
        {
			print_reboot_and_cold_reset_now();
               /* Never returned */
        }
		else
		{
			print_hold_and_reboot();
			sys_sleep(2); // 1 tick is 25ms
			flush_output();
		}

        cu_shutdown_software_subsystems();

        write_log_crc ();
        sys_reset(type, NULL);
}

void warn_scheduled_reset(UINT32 type)
{
        uprintf("\n!!!!!!! System is going to reload in %d seconds !!!!!!!\n", RELOAD_WARN_INTERVAL);
        g_reboot_timer = sv_set_timer((RELOAD_WARN_INTERVAL * SECOND), ONCE_TIMER, scheduled_reset, type);
        /* Remaining time for scheduled reload */
        reload_secs = 0;
}

void do_reload_schedule(UINT32 type)
{
        if (g_reboot_timer != (SV_TIMER_TOKEN_T)0)
        {
                sv_cancel_timer(g_reboot_timer);
                g_reboot_timer = (SV_TIMER_TOKEN_T)0;
                reload_location = 0;
        }

        /* Bug 6385: Siddhartha Aggarwal
         * Code Review: Sunil Chitnis
         */
        //Under AAA, parameter "typeNSession" is a combo of boot from type (MS 16 bits) and issuing ui_port (LS 16 bits)
        reload_location = (UINT32)(type>>16 & 0x0000ffff);

        /* sv_set_timer can handle maximum 2 months. So, restarting it every month */
        if (reload_secs > (SECSPERDAY * 30))
        {
                uprintf("\n!!!!!!! System is going to reload in %s  !!!!!!!\n", cu_time_string2((reload_secs * SECOND), 0));
                reload_secs -= (SECSPERDAY * 30);
                g_reboot_timer = sv_set_timer(((SECSPERDAY * 30) * SECOND), ONCE_TIMER, do_reload_schedule, type);
        }
        else if (reload_secs > RELOAD_WARN_INTERVAL)
        {
                reload_secs -= RELOAD_WARN_INTERVAL;
                g_reboot_timer = sv_set_timer((reload_secs * SECOND), ONCE_TIMER, warn_scheduled_reset, type);
        }
        else
        {
                if (reload_secs > 10)
                {
                        uprintf("\n!!!!!!! System will reload in %d seconds !!!!!!!\n", reload_secs );
                        g_reboot_timer = sv_set_timer((reload_secs * SECOND), ONCE_TIMER, scheduled_reset, type);
                }
                else
                {
                        uprintf("\n!!!!!!! System will reload in 10 seconds !!!!!!!\n");
                        g_reboot_timer = sv_set_timer((10 * SECOND), ONCE_TIMER, scheduled_reset, type);
                }
                /* Remaining time for scheduled reload */
                reload_secs = 0;
        }
}

void reload_cancel(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (g_reboot_timer != (SV_TIMER_TOKEN_T)0)
        {
                sv_cancel_timer(g_reboot_timer);
                g_reboot_timer = (SV_TIMER_TOKEN_T)0;
                reload_secs = 0;
                reload_location = 0;
                uprintf("Scheduled reload cancelled\n");
        }
        else
                uprintf("No scheduled reload\n");
}

UINT32 get_duration_by_calendar(
        UINT32 year,
        UINT32 month,
        UINT32 day,
        UINT32 hour,
        UINT32 min,
        UINT32 sec)
{
        UINT32 i, days_year, days;
        UINT32 start_secs, end_secs;
        UINT32 current_time, reload_time;
		UINT32 offset_flag = 0, offset_val = 0;
        struct tm ntp_tmst;
        UINT8 mon_lengths[2][MONSPERYEAR] =
                {
                        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
                        31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
                };

        /* If clock is not set by NTP or locally then return */
                if (!(ntp_clock_set() || ntp_clock_calibrated() || sys_rtc_synced_up))
        {
            uprintf("clock is not set, request aborted!\n");
            return 0;
        }

        days_year = DAYSPERNYEAR * (year-TM_YEAR_BASE);
        for (i=TM_YEAR_BASE; i<year; i++)
        {
                if (isleap(i))
                        days_year++;
        }

        /* make days to be 1st of the month */
        days = days_year;
        if (isleap(year))
        {
                for (i=0; i<month-1; i++)
                        days += mon_lengths[1][i];
        }
        else
        {
                for (i=0; i<month-1; i++)
                        days += mon_lengths[0][i];
        }
        days += day-1;
        reload_time = SECSPERDAY*days + SECSPERHOUR*hour +
                SECSPERMIN*min + sec;

        /* call dummy localsub to get gmt offset */
        localsub(&reload_time, &ntp_tmst);

        if (cu_ntp_get_summer_time())
        {
                calc_summer_time(ntp_tmst.tm_year, &start_secs, &end_secs, &offset_flag, &offset_val);
                if (reload_time >= start_secs && reload_time < end_secs)
                {
                        /* adjust to raw time */

                        if(offset_flag == TRUE)
                        {
                        reload_time -= SECSPERHOUR;
                }
                        /* For configurable offset value*/
                        else
                        {
                            reload_time -= SECSPERMIN*offset_val;
                        }
                }
        }
        reload_time -= cu_ntp_get_zone_offset();
        current_time =  ntp_get_time_in_sec();

        return ((reload_time <= current_time) ? 0 : (reload_time - current_time));
}

void reload_date(struct cdb* sptr_cdb)
{
        UINT32 typeNsessionid;
        UINT32 boot_source;

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        l_hr = sptr_cdb->integer1;
        l_min = sptr_cdb->integer2;
        l_sec = sptr_cdb->integer3;
        l_mon = sptr_cdb->integer4;
        l_day = sptr_cdb->integer5;
        l_yr = convert_to_full_year(sptr_cdb->integer6);

        if (!validate_time_at_arguments(l_yr, l_mon, l_day, l_hr, l_min, l_sec))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        reload_secs = get_duration_by_calendar(l_yr, l_mon, l_day, l_hr, l_min, l_sec);

        if (reload_secs == 0)
        {
                uprintf("error - failed to convert time duration from calendar time\n");
                sptr_cdb->dont_go_next = 1;
                /* Bug 6441: Siddhartha Aggarwal
                 * Code review: Sunil Chitnis
                 */
                if (g_reboot_timer != (SV_TIMER_TOKEN_T)0)
                {
                        sv_cancel_timer(g_reboot_timer);
                        g_reboot_timer = (SV_TIMER_TOKEN_T)0;
                }
                reload_location = 0;
                return;
        }
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                return;
        }

        sptr_cdb->dont_go_next = 1;
        boot_source = get_boot_source_from_boot_param();
        typeNsessionid = (boot_source<<16 | sptr_cdb->ui_port);
        do_reload_schedule(typeNsessionid);
 }

void
fast_reload_slaves(struct cdb* sptr_cdb)
{
#ifdef FI_LINUX
        if(sil_is_hv_enable()) {
                /* Todo: Actually here we should check if the member
                 * unit is running on HV. For now let's assume that
                 * Master and member run either bare metal or on HV
                 */
                /* HV is enabled so can go for a quick reset */
                sil_set_fast_reload(1);
                /* Commenting out this as it needs Stacking infra to be pulled in */
                //reload_slaves(sptr_cdb);
                sil_set_fast_reload(0);
        } else
#endif
                uprintf("Fast reload is not supported \n");
        return;
}

void reload_time(struct cdb* sptr_cdb)
{
        char *sptr_ch1, *sptr_ch2;

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
                return;

        if (sptr_cdb->help)
        {
                return;
        }

        strcpy(cu_line_buf, sptr_cdb->token);
        sptr_ch1 = cu_line_buf;
        if ((sptr_ch2=cli_find_char(sptr_ch1, ':')) != NULL)
        {
                *sptr_ch2 = 0;
                l_hr = atoi(sptr_ch1);
                *sptr_ch2 = ':';
                sptr_ch1 = sptr_ch2 + 1;
                if ((sptr_ch2=cli_find_char(sptr_ch1, ':')) != NULL)
                {
                        *sptr_ch2 = 0;
                        l_min = atoi(sptr_ch1);
                        *sptr_ch2 = ':';
                        sptr_ch1 = sptr_ch2 + 1;
                        l_sec = atoi(sptr_ch1);
                }
                else
                {
                        l_min = atoi(sptr_ch1);
                        l_sec = 0;
                }
        }
        else
        {
                l_hr = atoi(sptr_ch1);
                l_min = l_sec = 0;
        }

        if (l_hr > 23 || l_min > 59 || l_sec > 59)
        {
                uprintf("%s -- invalid input\n", sptr_cdb->token);
                sptr_cdb->dont_go_next = 1;
                return;
        }
}

void
erase_startup_slaves(struct cdb* sptr_cdb)
{
        UINT32 slave_ary[MAX_SYS_UNIT_NUM] = {0};
        int ind;

    if(sptr_cdb->config_gen)
        return;

    if(!set_flash_use_in_progress())
    {
        return;
    }

        ind = parse_range(sptr_cdb->string1, slave_ary, MAX_SYS_UNIT_NUM);
    if (ind)
    {   // 556626 don't use dnld_valid_list and dnld_valid_count that have fixed size
                if(dnld_valid_list_range(slave_ary, ind, 1, MAX_SYS_UNIT_NUM) &&
                        dnld_valid_count_range(slave_ary, ind))
                {
                        dnld_send_erase_startup_req(slave_ary, ind);

                        /* In case of Katara we need to sync uboot env variable (boot-src & fips_status )
                         * to all stack members.
                         */
                        if (is_linux_based_system() || is_a_fs() )
                                                {
#ifndef PV_CHANGES
                                                        if( katara_boot_env_updated || linux_boot_env_updated) {
                                /* Cleanup boot-source-params on required members */
                                dnld_send_boot_env_update_req_members(slave_ary, BOOT_FROM_NONE, 0, " ");
                                katara_boot_env_updated = 0;
                                                                linux_boot_env_updated = 0;
                                                        }
#ifdef FI_LINUX
                                                        if(katara_fips_boot_env_updated)
                                                        {
                                                                /* Cleanup fips_status on required members */
                                                                dnld_send_fips_status_update_req_members(slave_ary, sil_get_fips_status());
                                                                katara_fips_boot_env_updated = 0;
                                                        }
#endif/*FI_LINUX*/
#endif/*PV_CHANGES*/
                        }
                }
                else
                {
                        uprintf("No eligible stack members found. Use \"erase startup-config\" for the entire stack\n");
                        reset_flash_use_in_progress();
                        return;
                }
    }
        else
        {
                uprintf("Enter: stk-mem list:  2,3,5-7,8 (no space)\n");
        }
        reset_flash_use_in_progress();
}

void
reload_slaves(struct cdb* sptr_cdb)
{
    UINT32 slave_ary[MAX_SYS_UNIT_NUM] = {0};

    if (sptr_cdb->config_gen)
                return;
    if (parse_range(sptr_cdb->string1, slave_ary, MAX_SYS_UNIT_NUM) && dnld_valid_list(slave_ary))
    {
                if (dnld_valid_count(slave_ary));
                //dnld_init_info(slave_ary);
                else
                {
                        uprintf("No eligible stack members found. Use \"reload\" to reload the entire stack\n");
                        return;
                }
                dnld_send_boot_req(slave_ary, NULL); // 450529
    }
        else
        {
                uprintf("Enter: stk-mem list:  2,3,5-7,8,23-56 (no space)\n");
        }
}

void reload_after_time(struct cdb* sptr_cdb)
{
        UINT32 typeNsessionid;
        UINT32 boot_source;

        if (sptr_cdb->no)
        {
                if (sptr_cdb->mode == CONFIG)
                        reload_config_secs = 0;
                return;
        }

        if (sptr_cdb->help)
                return;

        l_day = sptr_cdb->integer1;
        l_hr = sptr_cdb->integer2;
        l_min = sptr_cdb->integer3;

        if (!validate_time_after_arguments(l_day, l_hr, l_min))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
        reload_secs = (l_min + (l_hr + l_day * 24) * 60) * 60;

        if (sptr_cdb->mode == CONFIG || g_sw_sys.init_in_progress)
        {
                if (end_of_token(sptr_cdb->token) == '\0')
                        reload_config_secs = reload_secs;
                ksprintf(reload_config_string, "killme after %s\n", sptr_cdb->token);
        }

        if (end_of_token(sptr_cdb->token) != '\0')
        {
                return;
        }

        sptr_cdb->dont_go_next = 1;
        boot_source = get_boot_source_from_boot_param();
        typeNsessionid = (boot_source<<16 | sptr_cdb->ui_port);
        do_reload_schedule(typeNsessionid);
 }
// 371142 kklin, new timer return a unique ID. I don't move this to service.c because it must include some header file.
UINT32 sntp_get_set_clock()
{
        return sntp.set_clock;
}

void reload_show(struct cdb* sptr_cdb)
{
        if (g_reboot_timer == (SV_TIMER_TOKEN_T) 0)
        {
                uprintf("No scheduled reload\n");
                return;
        }
        reload_show_timer(g_reboot_timer);
}

void reload_sched_pri(struct cdb* sptr_cdb)
{
        UINT32 typeNsessionid;

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
                return;

        if (!boot_code_version_ok(1))
        {
                return;
        }

        if (sptr_cdb->mode == CONFIG || g_sw_sys.init_in_progress)
        {
                reload_config_secs = reload_secs;
        }
        typeNsessionid = 0x00010000;  //type is 1.
        typeNsessionid |= (UINT32)sptr_cdb->ui_port;
        do_reload_schedule(typeNsessionid);
 }

void reload_sched_sec(struct cdb* sptr_cdb)
{
        UINT32 typeNsessionid;
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
                return;

        if (!boot_code_version_ok(1))
        {
                return;
        }

        if (sptr_cdb->mode == CONFIG || g_sw_sys.init_in_progress)
        {
                reload_config_secs = reload_secs;
        }

        typeNsessionid = 0x00020000;  //type is 2.
        typeNsessionid |= (UINT32)sptr_cdb->ui_port;
        do_reload_schedule(typeNsessionid);
 }

// IGMPV3_SNOOP, keep this as marker for easy porting
// porting guide: remove cu_set_ip_mcast_if_filter_value and cu_get_ip_mcast_if_filter_value



#define PS1_MASK        CH_PS1_MASK
#define PS2_MASK        CH_PS2_MASK
#define PS3_MASK        CH_PS3_MASK
#define PS4_MASK        CH_PS4_MASK
#define FAN1_MASK       CH_FAN1_MASK
#define FAN2_MASK       CH_FAN2_MASK
#define FAN3_MASK       CH_FAN3_MASK
#define FAN4_MASK       CH_FAN4_MASK
#define FAN5_MASK       CH_FAN5_MASK
#define FAN6_MASK       CH_FAN6_MASK

void cli_preset_chassis_poll_time(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no)
                {
                        sw_set_chassis_poll_time(CU_DFT_CHASSIS_POLL_TIME);
                        sptr_cdb->dont_go_next = 1;
                }
        }
}

void cli_set_chassis_poll_time(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen == 0)
        {
                if (valid_integer1_value_range(sptr_cdb, CU_MIN_CHASSIS_POLL_TIME, CU_MAX_CHASSIS_POLL_TIME))
                        sw_set_chassis_poll_time((UINT16)sptr_cdb->integer1);
        }
}

void cli_preset_chassis_name(struct cdb* sptr_cdb)
{
        config_gen_chassis(sptr_cdb);

        if (sptr_cdb->config_gen == 0)
        {
                if (sptr_cdb->no)
                {
                        g_sw_sys.chassis_id_number[0] = 0;
                        sptr_cdb->dont_go_next = 1;
                }
        }
}

void cli_set_chassis_name(struct cdb* sptr_cdb)
{
        int len;

        if (sptr_cdb->config_gen == 0)
        {
                len = cu_min(strlen(sptr_cdb->string1), CU_MAX_CHASSIS_ID_NUMBER_LEN);
                memcpy(g_sw_sys.chassis_id_number, sptr_cdb->string1, len);
                g_sw_sys.chassis_id_number[len] = 0;
        }
}

void cu_config_gen_default_vlan_id(struct cdb* sptr_cdb)
{
    if (SW_DFLT_VLAN_ID != SW_DEFAULT_VLAN_ID_VALUE)
    {
            if ((sptr_cdb->gen_to != GEN_TO_INTERNAL_USE) || g_stk_clean_cfg)
            {
                    ksprintf(cu_line_buf, "default-vlan-id %d\n", SW_DFLT_VLAN_ID);
                    wr_config(sptr_cdb, cu_line_buf);
                    wr_config(sptr_cdb, "!\n");
            }
    }
}

void cli_set_default_vlan_id(struct cdb* sptr_cdb)
{
	MAC_ADDRESS ip_mac_address;
	enum BOOLEAN is_ip_mac_valid = FALSE;
	UINT16 router_vid;
        if (sptr_cdb->config_gen)
        {
#if 0
                if (SW_DFLT_VLAN_ID != SW_DEFAULT_VLAN_ID_VALUE)
                {
                        if ((sptr_cdb->gen_to != GEN_TO_INTERNAL_USE) || g_stk_clean_cfg)
                        {
                                ksprintf(cu_line_buf, "default-vlan-id %d\n", SW_DFLT_VLAN_ID);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
#endif
        }
        else
        {
                // TR282171, standby crash if default vlan is set.
                // stack trace: Standalone or master: parse_configBug, then in parse_line(), it also search for "default-vlan-id",
                // use it to call process_init_command, port_vlan_config_init, cu_create_default_vlan.
                // slave skip parsing config: system_app_init, port_vlan_config_init, cu_create_default_vlan.
                // The standby also go through process_init_command(), but it return in port_vlan_config_init() because vlan_db is allocated.
                // Here, if it is standby, let it go through to remove the old vlan.
                /* TR000286393 - remove the fix TR282171 */
//              if (g_sw_sys.init_in_progress && !(STACK_AM_I_STANDBY))
                if (g_sw_sys.init_in_progress)
                        return;

#ifdef __GVRP_SUPPORT__

                if (IS_GVRP_ENABLED())
                {
                        uprintf("Default VLAN ID cannot be changed with GVRP enabled\n");
                        uprintf("Error - Default VLAN ID not changed\n");
                        return;
                }

#endif __GVRP_SUPPORT__

                                if(sptr_cdb->integer1 == g_flexauth->auth_default_vlanid)
                                {
                                        uprintf("Error - Default VLAN ID cannot be Auth Default VLAN ID.\n");
                                        return;
                                }
                                        
                if (sptr_cdb->no && (sptr_cdb->integer1 != SW_DFLT_VLAN_ID))
                {
                        uprintf("Invalid default Vlan id %d, Configured Default VLAN ID is %d \n", sptr_cdb->integer1, SW_DFLT_VLAN_ID);
                        uprintf("Error - Default VLAN ID not changed\n");
                        return;
                }


#ifdef SR_SWITCH_ROUTER
		router_vid = sw_find_configured_router_interface_from_l2_vlan(SW_DFLT_VLAN_ID);
		if (ip_is_urpf_global_current_enabled() && 
				ip_is_port_urpf_enabled((VID_TO_ROUTER_INT(router_vid)-1)))
		{
			UINT8 port_buf[MAX_PORT_ID_STRING_LEN]={0};
			interface_print_name((VID_TO_ROUTER_INT(router_vid)-1), port_buf);
			uprintf("\nError: rpf-mode configured on router ve %son default vlan.\nUnconfigure uRPF before changing default-vlan\n", port_buf);
			return;
		}
#endif SR_SWITCH_ROUTER
                g_default_vlan_id_in_transition = TRUE;
                if (sptr_cdb->no)
                {
#ifdef SR_SWITCH_ROUTER
			if (is_mgmt_active() && router_vid && 
			IS_IP_PORT_MAC_CONFIG_VALID((VID_TO_ROUTER_INT(router_vid)-1)))
			{
				is_ip_mac_valid = TRUE;
				ip_mac_default_vlan_id_change(&ip_mac_address, TRUE);
			}
#endif SR_SWITCH_ROUTER
                        cu_set_default_vlan_id((UINT16) SW_DEFAULT_VLAN_ID_VALUE, sptr_cdb->ui_port);
#ifdef SR_SWITCH_ROUTER
			if (is_mgmt_active() && (is_ip_mac_valid == TRUE))
			{
				ip_mac_default_vlan_id_change(&ip_mac_address, FALSE);
			}
#endif SR_SWITCH_ROUTER
                }
                else
                {
                        UINT16 old_vlan_id = SW_DFLT_VLAN_ID;
                        if (!valid_integer1_value_range(sptr_cdb, CU_MIN_VLAN_ID_VAL, CU_MAX_VLAN_ID_VAL))
                                return;
#ifdef SINGLE_SPAN
                        if (sptr_cdb->integer1 == SW_SINGLE_STP_VLAN_ID)
                        {
                                uprintf("Error - L2 vlan id %d is reserved for single stp vlan\n",SW_SINGLE_STP_VLAN_ID);
                                return;
                        }
#endif /* SINGLE_SPAN */
#ifdef SR_SWITCH_ROUTER
			if (is_mgmt_active() && router_vid && 
			IS_IP_PORT_MAC_CONFIG_VALID((VID_TO_ROUTER_INT(router_vid)-1)))
			{
				is_ip_mac_valid = TRUE;
				ip_mac_default_vlan_id_change(&ip_mac_address, TRUE);
			}
#endif SR_SWITCH_ROUTER
                        cu_set_default_vlan_id((UINT16) sptr_cdb->integer1, sptr_cdb->ui_port);
#ifdef SR_SWITCH_ROUTER
			if (is_mgmt_active() && (is_ip_mac_valid == TRUE))
			{
				ip_mac_default_vlan_id_change(&ip_mac_address, FALSE);
			}
#endif SR_SWITCH_ROUTER

                        // We should probably do it for acl also but in case of acl the we don't see the problem
                        //as seen in Bug: 80011   "M:0 L:0 - Sanity check failed: expected l4_on_ve count of 1 on port id 513" error when applying IPv6 ACL.
                        // Did the study for acl case, the ve goes away, so the selective on the ve also goes away, as a result of this we never check for PPPve
                        // config, even though the config is there, we don't take any action on it when the default vlan is reverted.

                }

                g_default_vlan_id_in_transition = FALSE;

                #ifdef SR_SWITCH_ROUTER
                ip_refresh_virtual_ports();
                #else
                pp_refresh_interface_settings();
                #endif

                {
                        extern void udld_update_cam_for_default_vlan(void);
                        sv_set_timer(HUNDRED_MILLISEC, ONCE_TIMER, udld_update_cam_for_default_vlan, 0);
                }

        }
}



void place_cb_pe_units_in_mismatch()
{
        
        int stack_id;
        UINT8 pe_version[32];
        UINT32 pe_image = 0;
        UINT32 mask = 0x3f;
		PE_MAILBOX	*pe_mail;
        for(stack_id = 1; stack_id <= MAX_SYS_UNIT_NUM; stack_id++)
        {
                if(G_STACK_STATE(stack_id) == STACK_STATE_REMOTE) {
                        if (is_unit_valid_pe(stack_id)) {
							pe_mail = find_pe_mail_from_id(stack_id);
							strncpy(pe_version,& pe_mail->build_ver,sizeof(pe_mail->build_ver));
                                
                               

                                        if (cb_check_pe_image_version(stack_id, &pe_version, &pe_mail->image_version) == 0) {

                                                update_image_mismatch_bitmask(stack_id);
                }

        } else {
                                if(stack_id <PE_START_NUM) {

                                if(stacking_check_image_version(stack_id) == FALSE) {

                                        g_AutoCopy_BitMask_homogenous|= (1 << (stack_id - 1));
                                        
        }
                                }
                        }
                }




        }
                                                return;
                                        }
void place_units_in_mismatch()
                                        {
        int stack_id;




        for(stack_id = 1; stack_id <= MAX_SYS_UNIT_NUM; stack_id++)
        {
                    if(G_STACK_STATE(stack_id) == STACK_STATE_REMOTE)
                    {
                if(stacking_check_image_version(stack_id) == FALSE)
                {
                    if(STACK_AM_I_MASTER ) // Following code can only take place on master.
                    {
                        if ((is_a_fs())) {
                                                        g_AutoCopy_BitMask_katara |= (1 << (stack_id - 1));
                                                } else {
                                                        g_AutoCopy_BitMask_homogenous|= (1 << (stack_id - 1));
                                                }
                    }
                }
            }
    }
}
void cli_set_tftp_server(struct cdb* sptr_cdb)
{
        int stack_id;
                char * pathname;
        if (sptr_cdb->config_gen) {
                if (tftp_server_ip_auto_copy) {
                ksprintf(cu_line_buf, "tftp-server %I image-location %s \n",tftp_server_ip_auto_copy, g_image_pathname);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        } else {
                if(!is_a_fs() && !(IS_SIDEWINDER()) )
        {
                uprintf("This CLI operation is applicable only in mixed stacking\n");
                return;
        }
                if (sptr_cdb->no) {
                        tftp_server_ip_auto_copy = 0;
                                                memset(g_image_pathname,0,MAX_PATHNAME_SIZE);
                }else {
                        tftp_server_ip_auto_copy = sptr_cdb->ip1;
                                        pathname = sptr_cdb->string1;
                                        if(strlen(pathname) > MAX_PATHNAME_SIZE -1)
                                        {
                                                sptr_cdb->dont_go_next = 1;
                                                uprintf("Image pathname cannot be longer than maximum %d chars\n",MAX_PATHNAME_SIZE);
                                                return;
                                        }
                                        if(pathname[strlen(pathname)-1] != '/')
                                        {
                                                strcat(pathname,"/");
                                        }
                                        strcpy(g_image_pathname, pathname);
#ifdef __PORT_EXTENSION__
place_cb_pe_units_in_mismatch();
#else
place_units_in_mismatch();
#endif
        }

                sptr_cdb->dont_go_next = 1;

        }

}


void e_freeze_at_crash(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (is_crash_freeze)
                {
                        ksprintf(cu_line_buf, "freeze-at-crash\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
        } else
        {
                if (!sptr_cdb->no)
                {
                        if (!is_crash_freeze)
                        {
                                is_crash_freeze = 1;
                        }
                } else
                {
                        if (is_crash_freeze)
                        {
                                is_crash_freeze = 0;
                        }
                }
        }
}

void set_mem_low_mark(struct cdb* sptr_cdb)
{
        char temp3[] = "mem-low-mark ";

        if (sptr_cdb->config_gen)
        {
                if (g_mem_low_mark == default_mem_low_mark)
                        return;
                wr_config(sptr_cdb, temp3);
                ksprintf(cu_line_buf, "%x\n", g_mem_low_mark);
                wr_config(sptr_cdb, cu_line_buf);
        } else
        {
                g_mem_low_mark = sptr_cdb->integer1;
                if (g_sw_sys.init_in_progress == 0)
                        uprintf("Set memory low water mark to %x\n", g_mem_low_mark);
        }
}
void show_mem_low_mark(struct cdb* sptr_cdb)
{
#if 0
        int size;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        uprintf("Current memory low water mark is %x\n", g_mem_low_mark);
        size = get_free_mem_size(DramHeapID);
        uprintf("Current free memory is %x (= %d)\n", size, size);
#endif
}

void dm_mod_glitch()
{
}



void e_dm_save_area(struct cdb* sptr_cdb)
{
        int slot;

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        sptr_cdb->integer1 = 1;

        dm_select_save_area(sptr_cdb);

}

void config_gen_bcast_filter(struct cdb* sptr_cdb)
{
        UINT32 i;
        PORT_MASK swmask[MAX_SLOT], hwmask[MAX_SLOT];

        if (sptr_cdb->config_gen)
        {
                for (i=0; i < MAX_BROADCAST_FILTER_IDS/2; i++)
                {
                        if (g_sw_sys.bcast_filter_ids[i].broadcast_filter)
                        {
                                ksprintf(cu_line_buf, "broadcast filter %u", i+1);
                                wr_config(sptr_cdb, cu_line_buf);

                                switch(g_sw_sys.bcast_filter_ids[i].packet_proto_id)
                                {
                                        case 0:
                                                wr_config(sptr_cdb, " any");
                                                break;

                                        case DMA_PKT_TYPE_IP_ETHERNET:
                                                wr_config(sptr_cdb, " ip");
                                                break;

                                        default:
                                                break;
                                }

                                switch(g_sw_sys.bcast_filter_ids[i].l3_proto_id)
                                {
                                        case UDP_PROTOCOL:
                                                wr_config(sptr_cdb, " udp");
                                                break;

                                        default:
                                                break;
                                }

                                if (g_sw_sys.bcast_filter_ids[i].vlan_id)
                                {
                                        ksprintf(cu_line_buf, " vlan %u", g_sw_sys.bcast_filter_ids[i].vlan_id);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }

                                wr_config(sptr_cdb, "\n");

                                if (!is_all_one_mask(g_sw_sys.bcast_filter_ids[i].broadcast_portmask))
                                {
                                        not_mask(
                                                hwmask,
                                                g_sw_sys.bcast_filter_ids[i].broadcast_portmask);
                                        sw_hwmask_to_swmask(hwmask, swmask);

                                        wr_config(sptr_cdb, " exclude-ports ");
                                        cu_makePortMask2CfgStrShort_cfgGen(swmask, cu_line_buf, sizeof(cu_line_buf));
                                        wr_config(sptr_cdb, cu_line_buf);
                                        wr_config(sptr_cdb, "\n");
                                }
                        }
                }
        }
}

void config_gen_mcast_filter(struct cdb* sptr_cdb)
{
        UINT32 i;
        PORT_MASK swmask[MAX_SLOT], hwmask[MAX_SLOT];

        if (sptr_cdb->config_gen)
        {
                for (i=MAX_BROADCAST_FILTER_IDS/2; i < MAX_BROADCAST_FILTER_IDS; i++)
                {
                        if (g_sw_sys.bcast_filter_ids[i].broadcast_filter)
                        {
                                ksprintf(cu_line_buf, "multicast filter %u", i-MAX_BROADCAST_FILTER_IDS/2+1);
                                wr_config(sptr_cdb, cu_line_buf);

                                switch(g_sw_sys.bcast_filter_ids[i].packet_proto_id)
                                {
                                        case 0:
                                                wr_config(sptr_cdb, " any");
                                                break;

                                        case DMA_PKT_TYPE_IP_ETHERNET:
                                                wr_config(sptr_cdb, " ip");
                                                break;

                                        default:
                                                break;
                                }

                                switch(g_sw_sys.bcast_filter_ids[i].l3_proto_id)
                                {
                                        case UDP_PROTOCOL:
                                                wr_config(sptr_cdb, " udp");
                                                break;

                                        default:
                                                break;
                                }

                                if (g_sw_sys.bcast_filter_ids[i].anycast_flag)
                                {
                                        wr_config(sptr_cdb, " mac any");
                                }
                                else
                                if (g_sw_sys.bcast_filter_ids[i].mcast_flag)
                                {
                                        ksprintf(cu_line_buf, " mac %m", &g_sw_sys.bcast_filter_ids[i].da);
                                        wr_config(sptr_cdb, cu_line_buf);
                                        if (g_sw_sys.bcast_filter_ids[i].da_mask._ulong ||
                                                        g_sw_sys.bcast_filter_ids[i].da_mask._ushort)
                                        {
                                                ksprintf(cu_line_buf, " mask %m", &g_sw_sys.bcast_filter_ids[i].da_mask);
                                                wr_config(sptr_cdb, cu_line_buf);
                                        }
                                }

                                if (g_sw_sys.bcast_filter_ids[i].vlan_id)
                                {
                                        ksprintf(cu_line_buf, " vlan %u", g_sw_sys.bcast_filter_ids[i].vlan_id);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }

                                wr_config(sptr_cdb, "\n");

                                if (!is_all_one_mask(g_sw_sys.bcast_filter_ids[i].broadcast_portmask))
                                {
                                        not_mask(
                                                hwmask,
                                                g_sw_sys.bcast_filter_ids[i].broadcast_portmask);
                                        sw_hwmask_to_swmask(hwmask, swmask);

                                        wr_config(sptr_cdb, " exclude-ports ");
                                        cu_makePortMask2CfgStrShort_cfgGen(swmask, cu_line_buf, sizeof(cu_line_buf));
                                        wr_config(sptr_cdb, cu_line_buf);
                                        wr_config(sptr_cdb, "\n");
                                }

                        }
                }
        }
}


void set_bcast_id_mode(struct cdb* sptr_cdb, UINT8 filter_id)
{
        if (sptr_cdb->no)
        {
                g_sw_sys.bcast_filter_ids[filter_id].broadcast_filter = 0;
                g_sw_sys.bcast_filter_ids[filter_id].packet_proto_id = 0;
                g_sw_sys.bcast_filter_ids[filter_id].l3_proto_id = 0;
                g_sw_sys.bcast_filter_ids[filter_id].vlan_id = 0;
                all_one_mask(g_sw_sys.bcast_filter_ids[filter_id].broadcast_portmask);
                if (sptr_cdb->mode == CONFIG_BCAST_FILTER_ID)
                {
                        set_cli_mode(sptr_cdb, CONFIG);
                }
        }
        else
        {
                set_cli_mode(sptr_cdb, CONFIG_BCAST_FILTER_ID);
                g_sw_sys.bcast_filter_ids[filter_id].broadcast_filter = 1;
                if (filter_id >= MAX_BROADCAST_FILTER_IDS/2)
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].mcast_flag = 1;

        }

        sptr_cdb->dont_go_next = 1;
}

void set_bcast_id_vlan(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].vlan_id = sptr_cdb->integer2;

        set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
}

void set_bcast_id_da_any(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].anycast_flag = 1;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
        }
}

void set_bcast_id_da_mac(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        if ((sptr_cdb->mac1[0] & 0x3) != 0x01)
        {
                uprintf("You must enter a 6 byte multicast MAC address\n");
                 sptr_cdb->dont_go_next = 1;
                return;
        }
        if (IS_BROADCAST_MAC((sptr_cdb->mac1)))
        {
                uprintf("Broadcast address is not a valid multicast MAC address\n");
                sptr_cdb->dont_go_next = 1;
                return;
        }

        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].anycast_flag = 0;
        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].mcast_flag = 1;
        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].mcast_mask_flag = 0;

        memcpy((char*)&g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].da,
                (char*)sptr_cdb->mac1, 6);

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
        }
}

void set_bcast_id_da_mac_mask(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        memcpy((char*)&g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].da_mask,
                (char*)sptr_cdb->mac2, 6);

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].mcast_mask_flag = 1;
                set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
        }
}

void set_bcast_id_ip_type_udp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].l3_proto_id = UDP_PROTOCOL;

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                /* Default to any multicast */
                g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].anycast_flag = 1;
                set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
        }
}

void set_bcast_id_pkt_type_ip(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_BROADCAST_FILTER_IDS/2))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

//      bcast_curr_filter_id = sptr_cdb->integer1 - 1;  /* 0 based */

        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].packet_proto_id = DMA_PKT_TYPE_IP_ETHERNET;
}

void set_bcast_id_pkt_type_any(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_BROADCAST_FILTER_IDS/2))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

//      bcast_curr_filter_id = sptr_cdb->integer1 - 1;  /* 0 based */

        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].packet_proto_id = 0; /* any */

        if (end_of_token(sptr_cdb->token) == '\0')
        {
                g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].anycast_flag = 1;
                set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
        }
}

void del_bcast_id(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_BROADCAST_FILTER_IDS/2))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        bcast_curr_filter_id = sptr_cdb->integer1 - 1;  /* 0 based */

        if (!sptr_cdb->no)
        {
                g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_cmd = 1;
        }

//      if (end_of_token(sptr_cdb->token) == '\0')
//      {
//              set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
//      }
}

void del_mcast_id(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->help)
                return;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_BROADCAST_FILTER_IDS/2))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }

        bcast_curr_filter_id = sptr_cdb->integer1 - 1 + MAX_BROADCAST_FILTER_IDS/2;     /* 0 based */

        if (!sptr_cdb->no)
        {
                g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_cmd = 0;
        }

//      if (end_of_token(sptr_cdb->token) == '\0')
//      {
//              set_bcast_id_mode(sptr_cdb, bcast_curr_filter_id);
//      }
}

void bcast_update_portlist(struct cdb* sptr_cdb, PORT_MASK *target_mask)
{
        PORT_MASK hwmask[MAX_SLOT];

        sw_swmask_to_hwmask(target_mask, hwmask);

        if (sptr_cdb->no)
        {
                or_masks(
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_portmask,
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_portmask,
                        hwmask);
                if (g_sw_sys.init_in_progress == 0)
                {
                        cu_mask2portList(target_mask, cu_line_buf, sizeof(cu_line_buf));
                        if (g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].mcast_flag == 1)
                                uprintf("included port %sfrom multicast forwarding.\n", cu_line_buf);
                        else
                                uprintf("included port %sfrom broadcast forwarding.\n", cu_line_buf);
                }
        }
        else
        {
                or_masks(
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_portmask,
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_portmask,
                        hwmask);
                and_not_masks(
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_portmask,
                        g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].broadcast_portmask,
                        hwmask);
                if (g_sw_sys.init_in_progress == 0)
                {
                        cu_mask2portList(target_mask, cu_line_buf, sizeof(cu_line_buf));
                        if (g_sw_sys.bcast_filter_ids[bcast_curr_filter_id].mcast_flag == 1)
                                uprintf("excluded port %sfrom multicast forwarding.\n", cu_line_buf);
                        else
                                uprintf("excluded port %sfrom broadcast forwarding.\n", cu_line_buf);
                }
        }
}



void set_bcast_id_exclude_ports_enet_num(struct cdb* sptr_cdb)
{
        int slot;
        PORT_ID port;
        PORT_MASK target_mask[MAX_SLOT];

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1; /* don't loop back */
        }
        else {
                /* if next is "to" or "?", the cmd is not for us */
                if (tolower(end_of_token(sptr_cdb->token)) == 't' ||
                        tolower(end_of_token(sptr_cdb->token)) == 'T' ||
                        sptr_cdb->help)
                        return;

                if (!validate_interface_value(sptr_cdb, 1, ENET_INTERFACE))
                {
                        sptr_cdb->num_of_if = 0;
                        if (end_of_token(sptr_cdb->token) == '\0')
                                sptr_cdb->dont_go_next = 1;
                        return;
                }

                slot = INTERFACE_SLOT(sptr_cdb->if1);
                port = INTERFACE_PORT(sptr_cdb->if1);
#ifdef SIDEWINDER_BREAKOUT
                        if(cu_range2maskLong(slot, port, slot, port, target_mask) == CU_ERROR)
                        {
                        cu_range2maskLongError(sptr_cdb);
                                        return;
                        }       
#else
                cu_range2maskLong(slot, port, slot, port, target_mask);
#endif
                bcast_update_portlist(sptr_cdb, target_mask);

                sptr_cdb->num_of_if = 0;
                if (end_of_token(sptr_cdb->token) == '\0')
                        sptr_cdb->dont_go_next = 1;
        }
}

void set_bcast_id_exclude_ports_enet_num_num(struct cdb* sptr_cdb)
{
        int fslot, fport, tslot, tport;
        PORT_MASK target_mask[MAX_SLOT];

        if (sptr_cdb->config_gen) {
                /*
                 * We should never get here. If so, don't walk
                 * to the next node. - rlau
                 */
                sptr_cdb->dont_go_next = 1; /* don't loop back */
        }
        else { /* not config gen */

                if (sptr_cdb->help)
                        return;

                fslot = INTERFACE_SLOT(sptr_cdb->if1);
                fport = INTERFACE_PORT(sptr_cdb->if1);
                tslot = INTERFACE_SLOT(sptr_cdb->if2);
                tport = INTERFACE_PORT(sptr_cdb->if2);

                if ((fport < 1) || (fport > cu_get_max_port(fslot)) ||
                        (tport < 1) || (tport > cu_get_max_port(tslot)))
                {
                        uprintf("Error - invalid port-range.\n");
                        sptr_cdb->num_of_if = 0;
                        if (end_of_token(sptr_cdb->token) == '\0')
                                sptr_cdb->dont_go_next = 1;
                        return;
                }
#ifdef SIDEWINDER_BREAKOUT
                                if(cu_range2maskLong(fslot, fport, tslot, tport, target_mask) == CU_ERROR)
                        {
                            cu_range2maskLongError(sptr_cdb);
                                        return;
                        }
#else
                cu_range2maskLong(fslot, fport, tslot, tport, target_mask);
#endif
                                bcast_update_portlist(sptr_cdb, target_mask);
                sptr_cdb->num_of_if = 0;
                if (end_of_token(sptr_cdb->token) == '\0')
                        sptr_cdb->dont_go_next = 1;
        }
}

#ifndef NO_GIG_ANA_SWITCH
void e_gig_default_neg_full_auto(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                /*
                if (g_gig_auto == NEG_FULL_AUTO)
                {
                        ksprintf(cu_line_buf, "gig-default neg-full-auto\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
                */
        }
        else
        {
                if (sptr_cdb->no)
                {
                }
                else
                {
                        cu_set_gig_default(NEG_FULL_AUTO);
                        //g_gig_auto = NEG_FULL_AUTO;
                }
        }
}
void e_gig_default_neg_off(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_gig_auto == NEG_OFF)
                {
                        ksprintf(cu_line_buf, "gig-default neg-off\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if (g_gig_auto == NEG_OFF)
                                cu_set_gig_default(NEG_FULL_AUTO);
                                //g_gig_auto = NEG_FULL_AUTO;
                }
                else
                {
                        cu_set_gig_default(NEG_OFF);
                        //g_gig_auto = NEG_OFF;
                }
        }
}
void e_gig_default_auto_gig(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_gig_auto == AUTO_GIG)
                {
                        ksprintf(cu_line_buf, "gig-default auto-gig\n");
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                        if (g_gig_auto == AUTO_GIG)
                                cu_set_gig_default(NEG_FULL_AUTO);
                                //g_gig_auto = NEG_FULL_AUTO;
                }
                else
                {
                        cu_set_gig_default(AUTO_GIG);
                        //g_gig_auto = AUTO_GIG;
                }
        }
}
#endif NO_GIG_ANA_SWITCH

int do_parse_version_string(char *ver_string, int *major, int *minor, int *maintenance )
{
char c, *sptr_start, *sptr_end;

        /* the version string format is XX.Y.ZZ;
          * XX is major, Y is minor, ZZ is bug-fixed
          */
        /* Parsing of version string based on below nomenclature:-
            Prior to 8.0, version string is XX.YY.ZZ
                        XX -- Major Version
                        YY -- Minor Version
                        ZZ -- Maintenance Version 
           From 8.0, version string is XX.YY.Zz (08.0.20b1T203)
                        XX -- Major Version
                        Y  -- Not used
                        Z  -- Minor Version
                        z  -- Maintenance Version       
        */
        if (ver_string == NULL)
        {
                uprintf("ERROR: NULL version string pointer\n");
        }
        if ((major == NULL) || (minor == NULL) || (maintenance == NULL))
        {
                uprintf("ERROR: NULL destination string pointer\n");
                return(NULL);
        }
        *major = *minor = *maintenance = 0;
        sptr_start = ver_string;
        sptr_end = cli_find_char(sptr_start, '.');
        if (sptr_end != NULL)
        {
                c = *sptr_end;
                *sptr_end = 0;
                *major = atoi(sptr_start);
                *sptr_end = c;
                sptr_start = sptr_end+1;
                sptr_end = cli_find_char(sptr_start, '.');
                if (*major < 8) 
                {
                        if (sptr_end != NULL)
                        {
                                c = *sptr_end;
                                *sptr_end = 0;
                                *minor = atoi(sptr_start);
                                *sptr_end = c;
                                sptr_start = sptr_end + 1;
                                sptr_end = sptr_start + 2;
                                c = *sptr_end;
                                *sptr_end = 0;
                                *maintenance = atoi(sptr_start);
                                *sptr_end = c;
                        }
                }
                else
                {
                        if (NULL != sptr_end)
                        {
                                sptr_start = sptr_end + 1;
                                sptr_end = sptr_start + 1;
                                c = *sptr_end;
                                *sptr_end = 0;
                                *minor = atoi(sptr_start);
                                *sptr_end = c;
                                sptr_start = sptr_end;
                                sptr_end = sptr_start + 1;
                                c = *sptr_end;
                                *sptr_end = 0;
                                *maintenance = atoi(sptr_start);
                                *sptr_end = c;
                        }
                }
                
        }
        else
        {
                uprintf("ERROR: Bad version string %s\n", ver_string);
                return(NULL);
        }
        if ((*major == 0) && (*minor == 0) && (*maintenance == 0))
        {
                uprintf("ERROR: Invalid version, major %d, minor %d maintenance %d\n", *major, *minor, *maintenance);
                return(NULL);
        }
        return(1);
}


void e_ver(struct cdb* sptr_cdb)
{
        if (sptr_cdb->internal_parsing_flag == 0)
                return;

        if (sptr_cdb->no)
        {
                g_version[0]='\0';
                g_ptr_version = (char *)NULL;
        } else
        {
                char c, *sptr_start, *sptr_end;

                strncpy(g_version,sptr_cdb->string1,32);
                g_version[31]='\0'; /* safty net */
                g_ptr_version = &g_version[0];
                        /* Extract the version in which the startup file was saved */
                        /* the version string format is XX.Y.ZZ;
                         * XX is major, Y is minor, ZZ is bug-fixed
                         */
                        /* Parsing of version string based on below nomenclature:-
                           Prior to 8.0, version string is XX.YY.ZZ
                                        XX -- Major Version
                                        YY -- Minor Version
                                        ZZ -- Maintenance Version 
                           From 8.0, version string is XX.YY.Zz
                                        XX -- Major Version
                                        YY -- Not used
                                        Z  -- Minor Version
                                        z  -- Maintenance Version       */
                sptr_start = g_ptr_version;
                sptr_end = cli_find_char(sptr_start, '.');
#if 0
                if (sptr_end != NULL)
                {
                        c = *sptr_end;
                        *sptr_end = 0;
                        g_major_version = atoi(sptr_start);
                        *sptr_end = c;
                        sptr_start = sptr_end+1;
                        sptr_end = cli_find_char(sptr_start, '.');
                        if (sptr_end != NULL)
                        {
                                c = *sptr_end;
                                *sptr_end = 0;
                                g_minor_version = atoi(sptr_start);
                                *sptr_end = c;
                        }
                }
#endif

                if (sptr_end != NULL)
                {
                        c = *sptr_end;
                        *sptr_end = 0;
                        g_major_version = atoi(sptr_start);
                        *sptr_end = c;
                        sptr_start = sptr_end+1;
                        sptr_end = cli_find_char(sptr_start, '.');
                        if (g_major_version < 8) 
                        {
                                if (sptr_end != NULL)
                                {
                                        c = *sptr_end;
                                        *sptr_end = 0;
                                        g_minor_version = atoi(sptr_start);
                                        *sptr_end = c;
                                        sptr_start = sptr_end + 1;
                                        sptr_end = sptr_start + 2;
                                        c = *sptr_end;
                                        *sptr_end = 0;
                                        g_maintenance_version = atoi(sptr_start);
                                        *sptr_end = c;
                                }
                        }
                        else
                        {
                                if (NULL != sptr_end)
                                {
                                        sptr_start = sptr_end + 1;
                                        sptr_end = sptr_start + 1;
                                        c = *sptr_end;
                                        *sptr_end = 0;
                                        g_minor_version = atoi(sptr_start);
                                        *sptr_end = c;
                                        sptr_start = sptr_end;
                                        sptr_end = sptr_start + 1;
                                        c = *sptr_end;
                                        *sptr_end = 0;
                                        g_maintenance_version = atoi(sptr_start);
                                        *sptr_end = c;
                                }
                        }
                }


#ifdef SR_SWITCH_ROUTER
                renew_system_default_configuration();
#endif /* SR_SWITCH_ROUTER */
        }
}

void debug_malloc(struct cdb* sptr_cdb)
{
#if 0
        UINT32 size = sptr_cdb->integer1;

        if (!kmallocDebugCheck)
        {
                uprintf("debug heap is not enabled\n");
                return;
        }

        uprintf("addr %x\n", kmalloc(size, DramHeapID));
#endif
        uprintf("memory trace is available from kernel\n");
}

void debug_mfree(struct cdb* sptr_cdb)
{
#if 0
        UINT32 addr = sptr_cdb->integer1;

        if (!kmallocDebugCheck)
        {
                uprintf("debug heap is not enabled\n");
                return;
        }

        kmfree((char *)addr, DramHeapID);
#endif
        uprintf("debug heap is not enabled\n");
}


void do_debug_malloc_en(int mask)
{
#if 0
        if (kmallocDebugCheck_logbuf == 0)
        {
                kmallocDebugCheck_logbuf = (char *)frozen_dram_alloc(FROZEN_DRAM_USER_DRAMHEAP, FROZEN_DRAM_USER_DRAMHEAP_SIZE);
                if ((int)kmallocDebugCheck_logbuf == 0)
                {
                        uprintf("fail to allocate debug heap log buffer\n");
                        heapIDDebugCheckMask = 0;
                        return;
                }
                kmallocDebugCheck_logbuf_head = kmallocDebugCheck_logbuf;
        }
        uprintf("debug heap log buffer: %x\n", kmallocDebugCheck_logbuf);
        heapIDDebugCheckMask |= mask;
        kmallocDebugCheck = 1;
#endif
        uprintf("memory trace is available from kernel\n");
}

void debug_malloc_off(struct cdb* sptr_cdb)
{
#if 0
        heapIDDebugCheckMask = 0;
        kmallocDebugCheck = 0;
#endif
}

void debug_malloc_en_snmp(struct cdb* sptr_cdb)
{
#if 0
        do_debug_malloc_en(1);
#endif
}

void debug_malloc_en_rmon(struct cdb* sptr_cdb)
{
#if 0
        do_debug_malloc_en(1<<RMON_ENGINE);
#endif
}

void debug_malloc_en_ipx(struct cdb* sptr_cdb)
{
#if 0
        do_debug_malloc_en(1<<IPXHeapID);
#endif
}

void debug_malloc_en_mbox(struct cdb* sptr_cdb)
{
}

void debug_malloc_en_dramheap(struct cdb* sptr_cdb)
{
#if 0
        do_debug_malloc_en(1<<DramHeapID);
#endif
}

void debug_malloc_log_head(struct cdb* sptr_cdb)
{
#if 0
        if (kmallocDebugCheck_logbuf_head)
                uprintf("debug heap log buffer head: %x\n", kmallocDebugCheck_logbuf_head);
        else
#endif
                uprintf("debug heap is not enabled\n");
}

void debug_malloc_log_clear(struct cdb* sptr_cdb)
{
#if 0
        if (kmallocDebugCheck_logbuf)
                memset (kmallocDebugCheck_logbuf, 0, FROZEN_DRAM_USER_DRAMHEAP_SIZE);
        else
#endif
                uprintf("debug heap is not enabled\n");
}

#if 0
void dns_whois_callback(
        DNS_SESSION_CLASS *dns_ptr,
        UINT8 *sptr_answer,
        UINT8 answer_type,
        UINT8 status,
        UINT32 param)
{
        int old_ui_port;
        UINT32 resolved_address;
        UINT8 *resolved_name;
#ifdef __IPV6__
        IPV6_ADDRESS resolved6_address;
#endif __IPV6__

        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = param;

        switch (status)
        {
        case DNS_CALLBACK_NOERROR:
                /* DNS operation succeed */
                if (answer_type == T_A)
                {
                        /* ip to name */
                        resolved_address = *((UINT32 *)sptr_answer);
                        uprintf("Host address %I resolved\n", resolved_address);
                }
#ifdef __IPV6__
                else if (answer_type == T_AAAA)
                {
                        /* ip to name */
                        resolved6_address = *((IPV6_ADDRESS *)sptr_answer);
                        uprintf("Host address %I resolved\n", resolved6_address);
                }
#endif __IPV6__
                else
                {
                        resolved_name = sptr_answer;
                        uprintf("Host name %s resolved\n", resolved_name);
                }
                release_page_mode();
                break;
        case DNS_CALLBACK_TIMEOUT:
                /* DNS operation failed */
                uprintf("Address translation timeout due to DNS query failure\n");
                break;
        case DNS_CALLBACK_ABORT:
                /* DNS operation aborted */
                uprintf("Address translation aborted!\n");
                break;
        case DNS_CALLBACK_NAME_TOO_LONG:
                uprintf("Address translation failed due to DNS name too long\n");
                break;
        default:
                break;
        }

        g_uprintf_dest = old_ui_port;
}

void cli_set_whois_name(struct cdb* sptr_cdb)
{
        uprintf("Translating host %s ....\n", sptr_cdb->string1);
        if (dns_resolve_name_to_ip(
                sptr_cdb,
                sptr_cdb->string1,
                sptr_cdb->ui_port,
                sptr_cdb->ui_port,
                dns_whois_callback,
                sptr_cdb->ui_port) == FALSE)
        {
                uprintf("Failed to initialize DNS request\n");
        }
}

void cli_set_whois_ip(struct cdb* sptr_cdb)
{
        uprintf("Translating address %I ....\n", sptr_cdb->ip1);
        if (dns_resolve_ip_to_name(
                sptr_cdb,
                sptr_cdb->ip1,
                sptr_cdb->ui_port,
                sptr_cdb->ui_port,
                dns_whois_callback,
                sptr_cdb->ui_port) == FALSE)
        {
                uprintf("Failed to initialize DNS request\n");
        }
}
#endif 0

#if 0 //BUG: 96701 - new os supports dm cmac command
UINT8 defalut_mac_base[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
void set_mac_def(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                if (defalut_mac_base[0] != 0xff)
                {
                        ksprintf(cu_line_buf, "mac_default_base %m\n",
                                defalut_mac_base);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
}

void set_mac_def_base(struct cdb* sptr_cdb)
{
        if (sptr_cdb->no)
                defalut_mac_base[0] = 0xff;
        else
                memcpy(defalut_mac_base, sptr_cdb->mac1, 6);
}
#endif

void dm_resource_checkfreepattern(struct cdb* sptr_cdb)
{
#if 0
        extern int km_free_set_0xff;
        extern int check_main_heap();

        if (sptr_cdb->config_gen)
                return;

        if (km_free_set_0xff)
        {
                check_main_heap(2);
        }
#endif
        uprintf("Feature not available\n");
}

void dm_resource_freepattern(struct cdb* sptr_cdb)
{
#if 0
        extern int km_free_set_0xff;
        extern int check_main_heap();

        if (sptr_cdb->config_gen)
                return;

        if (km_free_set_0xff)
        {
                km_free_set_0xff = 0;
                check_main_heap(2);
                uprintf("No memory free pattern from now on\n");
        }
        else
        {
                km_free_set_0xff = 1;
                check_main_heap(1);
                uprintf("Memory free pattern from now on\n");
        }
#endif
        uprintf("Feature not available\n");

}

void dm_resource_trace(struct cdb* sptr_cdb)
{
        extern void dm_resource_trace();

        if (sptr_cdb->config_gen)
                return;

        dm_res_trace(sptr_cdb->integer1);
}

void dm_resource(struct cdb* sptr_cdb)
{
        extern void dm_res();

        if (sptr_cdb->config_gen)
                return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        dm_res();
}

#ifdef SR_SWITCH_ROUTER
void set_vif_up(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT16 vid=ROUTER_INT_TO_VID(port_id);

        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.router_intf[vid].router_intf_configured == 0)
                        return;

                if (g_sw_sys.router_intf[vid].router_intf_enabled == 0)
                        wr_config(sptr_cdb, " disable\n");
                return;
        }
        if (sptr_cdb->no)
                cu_set_vport_state(port_id, PORT_DISABLE);
        else
                cu_set_vport_state(port_id, PORT_ENABLE);
}

void set_vif_down(struct cdb* sptr_cdb)
{
        UINT16 port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

        if (sptr_cdb->config_gen)
                return;

        if (sptr_cdb->no)
                cu_set_vport_state(port_id, PORT_ENABLE);
        else
                cu_set_vport_state(port_id, PORT_DISABLE);
}
#endif /* SR_SWITCH_ROUTER */

static BOOLEAN32 cli_kill_console_session_has_permission(struct cdb* sptr_cdb)
{
        if (sptr_cdb->current_login_password_level != CU_SECURITY_LEVEL0)
        {
                uprintf("Error - you must be a super user to perform this CLI operation\n");
                return FALSE;
        }

        return TRUE;
}

static void cli_kill_console_session_internal(UINT32 session)
{
        if (session == g_uprintf_dest)
        {
                uprintf(
                        "Note: Use the \"logout\" command to kill the current session\n");
        }
        else
        {
                if (cu_aaa_is_login_authen_enabled_for_console())
                {
//TBD: Should the reason be changed to PW_ADMIN_RESET?
                        cu_aaa_set_account_termination_reason(session, PW_USER_REQUEST);
                        if (!aaa_close_exec_session(session, cli_aaa_accounting_callback, 0))
                                print_prelogin_message_on_console(session);
                }
                else
                {
                        clean_up_parser(session);
                        print_prompt(&cdbs[session]);
                }
        }
}

void cli_kill_console_session(struct cdb* sptr_cdb)
{
        if (cli_kill_console_session_has_permission(sptr_cdb))
                cli_kill_console_session_internal(CONSOLE_SESSION);
}

static void cli_kill_console_session_unit_internal(UINT32 unit)
{
        if (unit == MY_BOOTUP_STACK_ID)
                cli_kill_console_session_internal(CONSOLE_SESSION);
        else
        {
                int rconsole_session = rconsole_server_find_unit_session(unit);

                if (rconsole_session >= 0)
                {
                        cli_kill_console_session_internal(
                                RCONSOLE_TO_CDBS_INDEX(rconsole_session));
                }
        }
}

void cli_kill_console_session_unit(struct cdb* sptr_cdb)
{
        UINT32 unit = sptr_cdb->integer1;

        if (cli_kill_console_session_has_permission(sptr_cdb))
        {
                if ((unit < 1) || (unit > MAX_SYS_UNIT_NUM))
                {
                        uprintf("Error: unit number must be between 1 and %u\n",
                                        MAX_SYS_UNIT_NUM);
                }
                else
                        cli_kill_console_session_unit_internal(unit);
        }
}

void cli_kill_console_session_all(struct cdb* sptr_cdb)
{
        UINT32 unit;

        if (cli_kill_console_session_has_permission(sptr_cdb))
        {
                for (unit = 1; unit <= MAX_SYS_UNIT_NUM; unit++)
                {
                        cli_kill_console_session_unit_internal(unit);
                }
        }
}

void cli_kill_telnet_session(struct cdb* sptr_cdb)
{
        int session_id;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_TELNET_SESSIONS))
                return;
        if (sptr_cdb->current_login_password_level != CU_SECURITY_LEVEL0)
        {
                uprintf("Error - you must be a super user to perform this operation\n");
                return;
        }
        session_id = sptr_cdb->integer1 - 1;
        if (telnet.client[session_id].connection_established || telnet.client[session_id].itc_ctx)
        {
                telnet.client[session_id].termination_cause = PW_USER_ERROR;
                telnet_close_connection(telnet.client[session_id].tcb_handle);
        }
}

void cli_kill_ssh_session(struct cdb* sptr_cdb)
{
        int session_id;

        if (!valid_integer1_value_range(sptr_cdb, 1, MAX_SSH_SESSIONS))
                return;
        if (sptr_cdb->current_login_password_level != CU_SECURITY_LEVEL0)
        {
                uprintf("Error - you must be a super user to perform this operation\n");
                return;
        }
        session_id = sptr_cdb->integer1 - 1;
                cdbs[SSH_TO_CDBS_INDEX(session_id)].exit_reason = 1;
        cdbs[SSH_TO_CDBS_INDEX(session_id)].ui_port = sptr_cdb->ui_port;
        cu_ssh_close_session(session_id);
}


void cli_kill_all_ssh_sessions(struct cdb* sptr_cdb)
  {
      int session_id;
      if(sptr_cdb->current_login_password_level != CU_SECURITY_LEVEL0)
      {
          uprintf("Error - you must be a super user to perform this operation\n");
          return;
      }
      for(session_id=0;session_id<MAX_SSH_SESSIONS;session_id++)
      {
          cdbs[SSH_TO_CDBS_INDEX(session_id)].exit_reason = 1;
          cdbs[SSH_TO_CDBS_INDEX(session_id)].ui_port = sptr_cdb->ui_port;
          cu_ssh_close_session(session_id);
      }
  }


void dm_cmac(struct cdb *sptr_cdb)
{
        void change_hw_mac_addr(UINT8 *mac_addr);
        change_hw_mac_addr(sptr_cdb->mac1);
}

void parse_boot_config_command(char *config_buf)
{
        int  i, j, idx = 0, has_slash;
        char ip_string[20];
        struct cdb *my_cdb;
        unsigned int subnet=0;

        my_cdb = (struct cdb *) dy_malloc_zero(sizeof(struct cdb));
        if (my_cdb == NULL)
                return;
        for (i = 0; config_buf[i] != 0; i++)
        {
                if(!memcmp(&config_buf[i], "config-file", strlen("config-file")))
                {
                        i += strlen("config-file") + 1;
                        if(!memcmp(&config_buf[i], "slot1", strlen("slot1")))
                        {
                                g_config_file.config_file = 1;
                                i += strlen("slot1") + 1;
                                if(config_get_file_name(&config_buf[i]))
                                {
                                        uprintf("Bad configuration\n");
                                }
                                dy_free(my_cdb);
                                return;
                        }
                        if(!memcmp(&config_buf[i], "slot2", strlen("slot2")))
                        {
                                g_config_file.config_file = 2;
                                i += strlen("slot2") + 1;
                                config_get_file_name(&config_buf[i]);
                                if(config_get_file_name(&config_buf[i]))
                                {
                                        uprintf("Bad configuration\n");
                                }
                                dy_free(my_cdb);
                                return;
                        }
                        if(!memcmp(&config_buf[i], "tftp", strlen("tftp")))
                        {
                                g_config_file.config_file = 3;
                                i += strlen("tftp") + 1;

                                while(config_buf[i] == ' ')
                                {
                                        i++;
                                }

                                j = 0;
                                while(config_buf[i] != ' ')
                                {
                                        ip_string[j++] = config_buf[i++];
                                }
                                ip_string[j] = 0;

                                parse_ip_string((unsigned int*)&g_config_file.ip_address,
                                                    (unsigned int*)&subnet,
                                                                (unsigned char*)ip_string,
                                                                j,
                                                                1,
                                                                my_cdb,
                                                                &has_slash,
                                                                FALSE);

                                config_get_file_name(&config_buf[i]);
                                if(config_get_file_name(&config_buf[i]))
                                {
                                        uprintf("Bad configuration\n");
                                }
                                dy_free(my_cdb);
                                return;
                        }
                }
        }
        dy_free(my_cdb);
}

int config_get_file_name(char *buf)
{
        int i=0, j=0;

        while(buf[i] == ' ')
        {
                i++;
        }

        while( (buf[i] != ' ') && (buf[i] != '\n') )
        {
                g_config_file.filename[j++] = buf[i++];
                if(buf[i] == 0)
                {
                        return 1;
                }
        }

        return 0;
}

void e_extern_config_refresh(struct cdb* sptr_cdb)
{
#ifndef NO_FDRY_HW
        load_extern_config(sptr_cdb->ui_port);
#endif
}

#if defined(FOUNDRY_NAT)
void show_packet_memory_pools(struct cdb* sptr_cdb)
{
    return;
}
#endif

#if (defined(SR_SWITCH_ROUTER) && defined(LINK_INTERFACE_HOLD_DOWN))
void set_link_hold_down(struct cdb *sptr_cdb)
{
UINT8   yes_no = 1;
        if (sptr_cdb->no)
                yes_no = 0;
        if (!sptr_cdb->config_gen)
                link_interface_hold_down_init(sptr_cdb->integer1, yes_no);
}

void cli_write_link_interface_hold_down(struct cdb *sptr_cdb)
{
        if (link_interface_hold_down_time)
        {
                ksprintf(cu_line_buf, "interface hold-down %d\n", link_interface_hold_down_time);
                wr_config(sptr_cdb, cu_line_buf);
        }
}
#endif

#define CONSOLE_SESSIONS_MASK (BIT(MAX_CONSOLE_SESSIONS) \
        | (((1 << MAX_RCONSOLE_SESSIONS) - 1) << RCONSOLE_SESSION_BASE_NUM))

/*-------------------------------------------------------------------------------------------------**
** This function is called to enable the logging console for syslog display                                               **
**                                                                                                 **
** INPUT:               struct cdb* sptr_cdb  **
**-------------------------------------------------------------------------------------------------*/
void logging_console(struct cdb* sptr_cdb)
{
        /* if not configuration mode */
        if(!sptr_cdb->config_gen)
        {
                if(sptr_cdb->no)
                {
                        /* no logging console */
                        fi_syslog.logging_console_flag  = FALSE;
                        fi_syslog.terminal_monitor_flag = FALSE; /*"no logging console" turns off all "terminal monitor" o/ps */
                        fi_syslog.session_id_mask = 0;
                }
                else
                        fi_syslog.logging_console_flag  = TRUE;

                // CHEETAH_STACKING
                /* Leave console sessions enabled, even for "no" command */
                fi_syslog.session_id_mask |= CONSOLE_SESSIONS_MASK;
        }
        else
        {
                /* writing to memory, 'write mem' writes to conf file later on */
                if(fi_syslog.logging_console_flag)
                        wr_config(sptr_cdb, "logging console\n");
        }

}

/*-------------------------------------------------------------------------------------------------**
** This function is called to enable the logging persistence                                               **
**                                                                                                 **
** INPUT:               struct cdb* sptr_cdb  **
**-------------------------------------------------------------------------------------------------*/
void logging_persistence(struct cdb* sptr_cdb)
{
        /* if not configuration mode */
        if (!sptr_cdb->config_gen)
        {
                if (sptr_cdb->no)
                        fi_syslog.persistence  = FALSE;
                else fi_syslog.persistence = TRUE;
        }
        else
        {
                /* writing to memory, 'write mem' writes to conf file later on */
                if (fi_syslog.persistence)
                        wr_config(sptr_cdb, "logging persistence\n");
        }
}

void cli_set_ip_show_acl_service_number(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.show_acl_service_number)
                        wr_config(sptr_cdb, "ip show-acl-service-number\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip.show_acl_service_number = 0;
                else
                {
                         if(ip.preserve_acl_user_input_format)
                         {
                                  uprintf("Error - Conflicts with preserve-acl-user-input-format feature\n");
                                  sptr_cdb->dont_go_next = 1;
                                  return;

                         }//if
                         ip.show_acl_service_number = 1;
                }//else
        }
}
void cli_set_ip_preserve_acl_user_input_format(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.preserve_acl_user_input_format)
                        wr_config(sptr_cdb, "ip preserve-acl-user-input-format\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip.preserve_acl_user_input_format = 0;
                else
                {
                         if(ip.show_acl_service_number)
                         {
                                  uprintf("Error - Conflicts with show-acl-service-number feature\n");
                                  sptr_cdb->dont_go_next = 1;
                                  return;

                         }//if
                         ip.preserve_acl_user_input_format = 1;
                }//else
        }
}

void cli_set_ip_show_service_number_in_log(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (ip.show_service_number_in_log)
                        wr_config(sptr_cdb, "ip show-service-number-in-log\n");
        }
        else
        {
                if (sptr_cdb->no)
                        ip.show_service_number_in_log = 0;
                else
                        ip.show_service_number_in_log = 1;
        }
}

extern UINT8 send_dropped_vlan_tag_pckt_to_cpu;
extern int g_current_module_is_ipc_class;


extern void show_tcp_states(UINT32 rc, UINT32 detail, UINT32 dummy);
extern void show_tcp_one_connection(UINT32 remote_ip_address, UINT32 remote_port, UINT32 local_ip_address, UINT32 local_port, VRF_INDEX vrf_index);
#ifdef __IPV6__
extern void show_tcp6_one_connection(IPV6_ADDRESS *remote_ip_address, UINT32 remote_port, IPV6_ADDRESS *local_ip_address, UINT32 local_port, VRF_INDEX vrf_index);
#endif __IPV6__

#if 0
void show_ip6_tcp_connections(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        show_tcp6_states(TRUE, 0, 0);
}
#endif

void show_ip_tcp_traffic(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;
        show_tcp_traffic();
}

void show_ip_tcp_vrf_name(struct cdb* sptr_cdb)
{
        if (!sptr_cdb->config_gen)
        {
                if (cli_set_vrf(sptr_cdb->string1, sptr_cdb, TRUE) == 0)
                        sptr_cdb->dont_go_next = 1;
        }
}

void show_ip_tcp_connections(struct cdb* sptr_cdb)
{

        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */

        if (sptr_cdb->config_gen)
                return;

        sptr_cdb->dont_go_next = 1;

        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = sptr_cdb->vrf_idx;
        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= ip6_unspecified_address;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = FALSE;

        show_tcp_states(1, 0, 0);
}

void show_ip_tcp_connections_all_vrf(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        sptr_cdb->vrf_idx = IPVRF_INVALID_VRF_IDX;
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;
        
        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = IPVRF_INVALID_VRF_IDX;
        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= ip6_unspecified_address;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = FALSE;
        show_tcp_states(1, 0, 0);
}

void show_ip_tcp_connections_port(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;
        
        if (sptr_cdb->config_gen)
          return;
        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = sptr_cdb->vrf_idx;
        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = sptr_cdb->integer1;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= ip6_unspecified_address;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = FALSE;
        show_tcp_states(1, 0, 0);
}

void show_ip_tcp_connections_remote_ip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;
        
        if (sptr_cdb->config_gen)
          return;
        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = sptr_cdb->vrf_idx;
        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = sptr_cdb->ip1;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= ip6_unspecified_address;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = FALSE;
        show_tcp_states(1, 0, 0);
}

void show_ip_tcp_status(struct cdb* sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        
        show_tcp_one_connection(sptr_cdb->ip1, sptr_cdb->integer1, sptr_cdb->ip2,
                                                        sptr_cdb->integer2, sptr_cdb->vrf_idx);
}


#ifdef __IPV6__

void show_ipv6_tcp_connections(struct cdb* sptr_cdb)
{

        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->config_gen)
                return;

        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = sptr_cdb->vrf_idx;

        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= ip6_unspecified_address;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = TRUE;
        show_tcp_states(1, 0, 0);
}

void show_ipv6_tcp_connections_port(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;
        
        if (sptr_cdb->config_gen)
          return;
        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = sptr_cdb->vrf_idx;
        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = sptr_cdb->integer1;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= ip6_unspecified_address;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = TRUE;
        show_tcp_states(1, 0, 1);
}

void show_ipv6_tcp_connections_remote_ip(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */
        sptr_cdb->dont_go_next = 1;
        
        if (sptr_cdb->config_gen)
          return;
        tcp.tcp_paging_info[g_uprintf_dest].total_connections = 0;
        tcp.tcp_paging_info[g_uprintf_dest].tcb_handle = NULL;
        tcp.tcp_paging_info[g_uprintf_dest].vrf_index = sptr_cdb->vrf_idx;
        tcp.tcp_paging_info[g_uprintf_dest].tcp_port = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip = 0;
        tcp.tcp_paging_info[g_uprintf_dest].remote_ip6= sptr_cdb->ipv6_1;
        tcp.tcp_paging_info[g_uprintf_dest].ipv6 = TRUE;
        show_tcp_states(1, 0, 0);
}

void show_ipv6_tcp_status(struct cdb* sptr_cdb)
{

        if (sptr_cdb->config_gen)
                return;
        if (end_of_token(sptr_cdb->token) != '\0') 
                return; /* cmd not for me */

        show_tcp6_one_connection(&sptr_cdb->ipv6_1, sptr_cdb->integer1, &sptr_cdb->ipv6_2,
                                                        sptr_cdb->integer2, sptr_cdb->vrf_idx);
}
#endif __IPV6__

int  show_cam_module_checking(PORT_ID port_idx)
{
        UINT8 module;
         UINT16 dma_idx, i;
        module=PORT_TO_MODULE_ID(port_idx);
     if (!MODULE_IS_GOOD(module))
                {
                        uprintf("Module %d is Not Operational or does Not Exist!\n", module+1);
                        return  0;
                }

        //
        //  TBD: This needs to be taken care of for Cheetah.
        //
        if (port_idx>=g_module[module].start_sw_port + MODULE_NUMBER_OF_PORTS(module))
                                {
                      uprintf("Port Not Exist.\n");
                        return 0;
                        }

                return 1;

}
SHOW_CAM_LIST* show_cam_alloc_mem(PORT_ID port_idx)
{
        SHOW_CAM_LIST* show_list=(SHOW_CAM_LIST *)dy_malloc_zero(sizeof(SHOW_CAM_LIST));
        if (show_list==NULL)
        {
                uprintf("Error in Allocating Memory!");
                return NULL;
        }
        show_list->module=PORT_TO_MODULE_ID(port_idx);
        show_list->dma_idx= SWPORT_TO_DMAID(port_idx);
        show_list->index_cam=1;
        show_list->dma_master = DMA_MASTER(show_list->dma_idx);
        return show_list;
}

void show_dump_cam_ip(struct cdb* sptr_cdb)
{
        SHOW_CAM_LIST *show_list;
        PORT_ID port_idx;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;
}

/*
 * This function checks whether the user input port is a valid port
 */
int check_if_port (PORT_ID port)
{
        int slot;

        slot = PORT_TO_MODULE_ID (port);
        port = PORT_TO_MODULE_PORT (port);

        /* Slot range is checked before */
        if (g_module[slot].module_status == MODULE_EMPTY ||
                g_module[slot].number_of_ports <= port)
        {
                if (is_stack())
                        uprintf("%d does not exist\n", port+1);
                else if (is_chassis_gs())
                        uprintf("%d/%d/%d does not exist\n", MY_BOOTUP_STACK_ID, slot + 1, port+1);
                else
                        uprintf("%d/%d does not exist\n", slot+1, port+1);
        return 1;
        }
        return 0;
}

extern void show_appletalk_ptrace();

// klin, 05/06/03 centralize all cut-and-paste here to save memory.
void print_ptrace_is_turned_on(char *msg)
{
        uprintf("%s: ptrace was truned ON\n",msg);
}
void cli_ptrace_show_global(struct cdb *sptr_cdb)
{
        BYTE print_buffer_arg1[IP_ADDRESS_PRINT_SIZE];

        if (sptr_cdb->config_gen)
                return;

        if (ip.trace_mask & AAA_TRACE)
                print_ptrace_is_turned_on("AAA");


        if (ip.trace_mask & ARP_TRACE)
        {
                print_ptrace_is_turned_on("ARP");
#ifdef DEBUG_ENABLE
                if (g_trace_arp_ipaddr)
                        uprintf("  ptrace IP %s\n", debug_convert_ip_address_to_dot_format ((char *) print_buffer_arg1, g_trace_arp_ipaddr));
#endif DEBUG_ENABLE
                if (g_trace_arp_port != 0xFFFF)
                        uprintf("  ptrace port %P\n", g_trace_arp_port);
        }
        if (ip.trace_mask & BOOTP_TRACE)
                print_ptrace_is_turned_on("BOOTP");
#ifdef __IP_MULTICAST__
#ifdef SR_SWITCH_ROUTER
        if (gDvmrp.debug_mask)
        {
                uprintf("DVMRP\n");

                if (gDvmrp.debug_mask & DVMRP_DEBUG_GRAFT)
                        print_ptrace_is_turned_on("  GRAFT");
                if (gDvmrp.debug_mask & DVMRP_DEBUG_GRAFT_ACK)
                        print_ptrace_is_turned_on("  GRAFT-ACK");
                if (gDvmrp.debug_mask & DVMRP_DEBUG_MCACHE)
                        print_ptrace_is_turned_on("  MCACHE");
                if (gDvmrp.debug_mask & DVMRP_DEBUG_MESSAGE)
                        print_ptrace_is_turned_on("  MESSAGE");
                if (gDvmrp.debug_mask & DVMRP_DEBUG_PROBE)
                        print_ptrace_is_turned_on("  PROBE");
                if (gDvmrp.debug_mask & DVMRP_DEBUG_PRUNE)
                        print_ptrace_is_turned_on("  PRUNE");
                if (gDvmrp.debug_mask & DVMRP_DEBUG_ROUTE)
                        print_ptrace_is_turned_on("  ROUTE-TABLE");
        }
#endif /* SR_SWITCH_ROUTER */
#endif
        if (ip.trace_mask & ICMP_TRACE)
                print_ptrace_is_turned_on("ICMP");
        if (ip.trace_mask & IGMP_TRACE)
                print_ptrace_is_turned_on("IGMP");
        if (ip.trace_mask & IP_TRACE)
                print_ptrace_is_turned_on("IP");
        if (ip.trace_mask & LACP_TRACE)
                print_ptrace_is_turned_on("LACP");
        if (ip.trace_mask & NVLAN_TRACE)
                print_ptrace_is_turned_on("NVLAN");
#ifdef SR_SWITCH_ROUTER
#ifndef __BASE_L3__
        if (ip.trace_mask & OSPF_TRACE)
                print_ptrace_is_turned_on("OSPF");
#endif __BASE_L3__
#endif SR_SWITCH_ROUTER
#ifdef __PIM__
        if (gPim.debug_mask)
        {
                uprintf("PIM:\n");

                if (gPim.debug_mask & PIM_DEBUG_FCACHE)
                        print_ptrace_is_turned_on("  FCACHE");
                if (gPim.debug_mask & PIM_DEBUG_MCACHE)
                        print_ptrace_is_turned_on("  MCACHE");
                if (gPim.debug_mask & PIM_DEBUG_MESSAGE)
                        print_ptrace_is_turned_on("  MESSAGE");
                if (gPim.debug_mask & PIM_DEBUG_VERIFY_MCACHE)
                        print_ptrace_is_turned_on("  VERIFY");

        }
#endif __PIM__
        if (ip.trace_mask & POS_TRACE)
                print_ptrace_is_turned_on("POS");
        if (ip.trace_mask & PPP_TRACE)
                print_ptrace_is_turned_on("PPP");
        if (ip.trace_mask & RARP_TRACE)
                print_ptrace_is_turned_on("RARP");
        if (ip.trace_mask & RIP_TRACE)
                print_ptrace_is_turned_on("RIP");
        if (ip.trace_mask & SNMP_TRACE)
                print_ptrace_is_turned_on("SNMP");
        if (g_sw_sys.trace_mask)
        {
                uprintf("SWITCH:\n");
                if (g_sw_sys.trace_mask & STP_TRACE)
                        print_ptrace_is_turned_on("  STP");
        }
        if (ip.trace_mask & TCP_TRACE)
                print_ptrace_is_turned_on("TCP");
        if (ip.trace_mask & TELNET_TRACE)
                print_ptrace_is_turned_on("TELNET");
        if (ip.trace_mask & TFTP_TRACE)
                print_ptrace_is_turned_on("TFTP");
        if (ip.trace_mask & UDP_TRACE)
                print_ptrace_is_turned_on("UDP");
}

#ifdef SR_SWITCH_ROUTER
UINT8 dhcp_valid_check=0;

/* config cmds */
void check_dhcp_valid_offer(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (dhcp_valid_check)
                        wr_config(sptr_cdb, "ip dhcp-valid-check\n");

        }
        else
        if (sptr_cdb->no)
        {
                dhcp_valid_check = 0;
        }
        else
        {
                dhcp_valid_check = 1;
        }
}
#endif SR_SWITCH_ROUTER

#ifdef SR_SWITCH_ROUTER
#ifndef _BOOTP_CLIENT_
extern void bootp_delete_udp_port();
extern void bootp_enable_udp_port();
extern void bootp_initiate_relay_agent();
extern UINT8 bootp_udp_port_enabled();

void set_udp_port_bootp(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
				/*T000569164 check if the bootp port disabled due to dhcp server */
                if (!bootp_udp_port_enabled() && (!is_dhcps_disabled_bootp_port()))
                {
                    wr_config(sptr_cdb, "no port bootp\n");
                }
        }
        else
        {
                if (sptr_cdb->no)
                {
                    if (bootp_udp_port_enabled())
                    {                    
                                                bootp_delete_udp_port();
                                                
                                                #ifdef __DHCP_SERVER__
                                                /* Reset the port diabled flag on DHCP server,
                                                    Otherwise, it will restart the bootp when dhcp server halt */
                                                dhcps_reset_bootp_port_disabled_flag(FALSE);
                                                #endif __DHCP_SERVER__
                    }
                }
                else
                {
                        if (!bootp_udp_port_enabled())
                        {
                                bootp_enable_udp_port();
                                                                #ifdef __DHCP_SERVER__
                                                                /* Set the port diabled flag on DHCP server, don't start the
                                                                    BOOTP, DHCP server will start when it is disabled */
                                                                if (is_dhcps_running())
                                                                {
                                                                        dhcps_reset_bootp_port_disabled_flag(TRUE);
                                                                }
                                                                else
                                                                #endif __DHCP_SERVER__
                                                                {                                                               
                                        bootp_initiate_relay_agent();
                                                                }
                        }
                }
        }
}
#endif _BOOTP_CLIENT_
#endif SR_SWITCH_ROUTER


void set_global_scale_timer(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_timer_scale != 1) {
                        ksprintf(cu_line_buf, "scale-timer %d\n!\n", g_timer_scale);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
                if (sptr_cdb->no) {
                        g_timer_scale = 1;
                        uprintf("Timer scaling factor is reset to 1.\n");
                } else {
                        if (!valid_integer1_value_range(sptr_cdb, 1, 10))
                                return;
                        g_timer_scale = sptr_cdb->integer1;
                }
        }
}

#define DFLT_MAX_TRACE_MESSAGES 50

UINT32  g_trace_max_msgs        = DFLT_MAX_TRACE_MESSAGES;
UINT32  g_trace_msg_count       = DFLT_MAX_TRACE_MESSAGES;
UINT8   g_trace_with_stack      = 0;
UINT8   g_trace_specific_level  = 0;
PORT_ID g_trace_specific_interface = BAD_PORT_ID;

//UINT8   g_trace_mask_level = 0;

extern UINT32 g_trace_counts[NUM_TRACE_MODULES][NUM_TRACE_LEVELS];

void set_trace_specific_level(struct cdb* sptr_cdb)
{

        /*if (g_trace_mask_level)
        {
                uprintf(" FAIL : Tracing based on specific mask level is ON \n");
                return ;
        }*/

        g_trace_specific_level = (g_trace_specific_level ? 0 : 1);
        uprintf("Tracing a specific debug level is now %s\n",
                        (g_trace_specific_level ? "ON" : "OFF"));
}

void set_trace_specific_interface(struct cdb* sptr_cdb)
{

        if (sptr_cdb->no)
        {
                g_trace_specific_interface = BAD_PORT_ID;
        }
        else
        {
                g_trace_specific_interface = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
        }
        uprintf("Tracing a specific interface %p is now %s\n", g_trace_specific_interface,
                        ((g_trace_specific_interface != BAD_PORT_ID) ? "ON" : "OFF"));
}

/*void set_trace_mask_level(struct cdb* sptr_cdb)
{

        if (g_trace_specific_level)
        {
                uprintf("FAIL:  Tracing based on specific debug level is ON \n");
                return ;
        }

        g_trace_mask_level = (g_trace_mask_level ? 0: 1);
        uprintf("Tracing base on set mask is now %s\n",
                        (g_trace_mask_level ? "ON" : "OFF"));
}*/


void show_trace_with_stack (struct cdb* sptr_cdb)
{

        fitrace_toggle_all_stacktrace(sptr_cdb);
        /*
        g_trace_with_stack = (g_trace_with_stack ? 0 : 1);

        uprintf("Printing of stack along with trace message is now %s\n",
                        (g_trace_with_stack ? "ON" : "OFF"));
        */
}

void set_trace_max (struct cdb* sptr_cdb)
{
        g_trace_max_msgs = sptr_cdb->integer1;

        //If "no" or zero, set to dflt max possible value
        if ((sptr_cdb->no) || (!g_trace_max_msgs))
                g_trace_max_msgs = DFLT_MAX_TRACE_MESSAGES;

        g_trace_msg_count = g_trace_max_msgs;

        fitrace_set_max_print(sptr_cdb);
}

void set_trace_level (struct cdb* sptr_cdb)
{
        int trace_module = sptr_cdb->integer1;
        int level = sptr_cdb->integer2;

        if ((trace_module < 0) || (trace_module >= NUM_TRACE_MODULES))
        {
                uprintf ("Error: Invalid Trace Module Id, see output of \"xtrace module_ids\"\n");
                                return;// coverity 23067
        }

        if ((level < 0) || (level >= NUM_TRACE_LEVELS))
        {
                uprintf ("Error: Invalid Trace Level, see output of \"xtrace levels\"\n");
                                return;// coverity 23067
        }

        fitrace_set_level_old(trace_module, level);

        g_trace_level[trace_module] = level;
        g_trace_msg_count = g_trace_max_msgs;

        sxr_sync_xtrace_level(trace_module,level,g_trace_max_msgs);

}

char *get_trace_module_string (UINT32 i)
{
        switch (i)
        {
                case INPUT_ACL_TRACE_UTILITY:
                        return ("Input Acl");
                case IP_FORWARDING_TRACE_UTILITY:
                        return ("Ip Forwarding");
                case FDB:
                        return ("Mac FDB");
                case CPU_PKT_TX:
                        return ("CPU Pkt Transmit");
                case CPU_PKT_RX:
                        return ("CPU Pkt Receive");
                case SFLOW_TRACE:
                        return ("SFlow");
                case CHASSIS_TRACE:
                        return ("Chassis");
                case SYS_SW_TRACE:
                        return ("System SW");
                case POE_TRACE:
                        return ("PoE");
				case LINK_TRACE:
                        return ("LINK");		
                case SXR_RED:
                        return ("SXR Redundancy");
                case SOURCE_GUARD:
                        return ("IP Source-guard");
                case IP_POLICY_TRACE:
                        return ("IP Policy");
                case MULTICAST_TRACE:
                        return ("Multicast");
                case SYNC_FW_TRACE:
                        return ("Sync Framework Trace");
                case LINK_INTR_TRACE:
                        return ("Link Interrupts");
                case L3_HITLESS_TRACE:
                        return ("L3 Hitless Trace");
                case INTERRUPT_TRACE:
                        return ("Interrupts");

                case BOOTUP_DEBUG_TRACE:
                        return ("Bootup Debug Messages");

                case MULTICAST_SNOOP_TRACE:
                        return("Multicast snoop Trace");
                                                
                case L2MCAST_HITLESS_TRACE:
                        return("L2 Multicast Hitless Trace");

                /*7.2 MCT MCAST related*/
#ifdef INCLUDE_MCT
                case L2MCAST_MCT_TRACE:
                        return("L2 Multicast MCT Trace");

                case L3MCAST_MCT_TRACE:
                        return("L3 Multicast MCT Trace");
#endif INCLUDE_MCT

                case MC_REP_MGR_TRACE:
                        return("MC REP Manager Trace");

                case TRUNK_TRACE:
                        return ("Trunk");
                case QOS_TRACE:
                        return ("QoS");

                case REL_IPC_TRACE:
                        return ("Reliable IPC");
                case ACL_HITLESS_TRACE:
                        return("ACL Hitless Trace");
                case INFRA_TRACE:
                    return("Infrastructure Trace");
                case CPUBM_TRACE:
                    return("CPU Buffer Management Trace");
                case VLAN_TRACE:
                        return("VLAN Trace");
                case MCPROXY_TRACE:
                        return("Multicast Proxy Trace");
                        case FDB_HOUSE_KEEPING:
                                return("FDB House Keeping");
                case SYSMON_TRACE:
                        return("Sysmon Trace");
                                case UDLD:
                                                return("udld");
#ifdef FI_URPF
                                case URPF:
                                                return("urpf");

#endif
#ifdef __FI_IPSEC_IKE__
		case IPSEC_TRACE:
			return("IPSEC");

#endif
                case PLM_TRACE:
                        return("PLM Trace");
                default:
                        return ("Undefined");
        }
}

char *get_trace_level_string (UINT32 i)
{
        switch (i)
        {
                case TRACE_CRITICAL:
                        return ("Critical");
                case TRACE_BOOTUP_DEBUG:
                        return ("Bootup");
                case TRACE_ERROR:
                        return ("Error");
                case TRACE_INFO:
                        return ("Info");
                case TRACE_CONTROL_FLOW:
                        return ("Control Flow");
                case TRACE_DEBUG:
                        return ("Debug");
                default:
                        return ("Undefined");
        }
}

void show_trace_module_ids (struct cdb* sptr_cdb)
{
        UINT32 i;

        uprintf (" Id        Module Name\n");

        for (i = 0; i < NUM_TRACE_MODULES; i++){
                uprintf ("%3d        %s\n", i, get_trace_module_string(i));
        }
}

void show_trace_levels (struct cdb* sptr_cdb)
{
        UINT32 i;

        uprintf ("Level      Level Name\n");

        for (i = 0; i < NUM_TRACE_LEVELS; i++)
                uprintf ("%3d        %s\n", i, get_trace_level_string(i));
}

void reset_trace_levels (struct cdb* sptr_cdb)
{
        trace_init ();
        g_trace_max_msgs = g_trace_msg_count = DFLT_MAX_TRACE_MESSAGES;
        fitrace_reset_all(sptr_cdb);
}

void show_trace_counts (struct cdb* sptr_cdb)
{
        UINT32 i, j;

        //uprintf ("ModuleId              Critical     Error      Info   Control Flow   Debug\n");
        uprintf ("ModuleId          TraceLevel  Critical     Error      Info   Control Flow   Debug\n");

        for (i = 0; i < NUM_TRACE_MODULES; i++)
        {
            uprintf ("%16s", get_trace_module_string(i));
                uprintf ("%8d", g_trace_level[i]);

                for (j= 0 ; j < NUM_TRACE_LEVELS ; j++)
                        uprintf ("%11d", g_trace_counts[i][j]);
                uprintf ("\n");
        }
        uprintf ("\n");
}

void clear_trace_counts (struct cdb* sptr_cdb)
{
        trace_counts_init ();
        fitrace_clear_counts(sptr_cdb);
}


void tftp_disable_set(struct cdb *sptr_cdb)
{
        if ( end_of_token(sptr_cdb->token) != '\0' ) {
                return;
        }


        sptr_cdb->dont_go_next = 1;

        if(sptr_cdb->config_gen) {
                return;
        }
#ifdef __DHCP_SERVER__

        if(sptr_cdb->mode == CONFIG_DHCPS)
        {
                uprintf("\"tftp\" applies globally. Use \"tftp-server\" to configure tftp related options \n" );
                return;
        }
#endif

        if ( !(sptr_cdb->no) ) {
                int i;
                for (i = 0; i < MAX_BOOT_SEQ; i++) {
                        if (boot_seq[i] == BOOT_FROM_TFTP) {
                                uprintf("Please remove your boot sys tftp configuration before disabling tftp.\n");
                                return;
                        }
                }
        }
        if ( sptr_cdb->no) {
                if (cu_fips_get_ops_state() && !(cu_fips_get_allow_tftp_access()))
                { // FIPS mode policy enforced
                        uprintf("Tftp enable is not allowed in fips mode. Enable policy first.\n");
                        return ;
                }
        }
                if( cu_fips_get_status())
        {
                uprintf("FIPS: This command cannot be executed in FIPS mode of operation\n");
                return;
        }


        sys_tftp_disable_set(!(sptr_cdb->no));
	/*000563883 aborting TFTP operation when in progress*/
        if(sys_tftp_disable_get()&& (tftp.current_operation != TFTP_IDLE))
        {
                tftp_error(TFTP_REMOTE_OTHER);
                reset_flash_use_in_progress();
        }

}

void tftp_disable_cfg_gen(struct cdb* sptr_cdb)
{
        if (sptr_cdb->gen_to == GEN_TO_INTERNAL_USE )
                return;

        if ( sys_tftp_disable_get() ) {
                wr_config(sptr_cdb, "tftp disable\n");
        }
}


/* ####PV_CHANGE remove -->#if 0*/ /* RAJ --- Need to fix */
UINT32 cpu_limit_addr_msgs = CPU_DEFAULT_LIMIT_ADDR_MSGS;

void set_cpu_limit_addr_msgs(struct cdb* sptr_cdb)
{
        UINT32 device_id;

        if (sptr_cdb->config_gen)
        {
                sptr_cdb->dont_go_next = 1;
                if (cpu_limit_addr_msgs != CPU_DEFAULT_LIMIT_ADDR_MSGS)
                {
                        ksnprintf(cu_line_buf, sizeof(cu_line_buf),"cpu-limit addr-msgs %d\n", cpu_limit_addr_msgs);
                        wr_config(sptr_cdb, cu_line_buf);
                }
                return;
        }

        if (sptr_cdb->no)
        {
                if (sptr_cdb->integer1 != cpu_limit_addr_msgs)
                {
                        uprintf("Error - Address Msg Limit of %d is not configured\n", sptr_cdb->integer1);
                        return;
                }
                cpu_limit_addr_msgs = CPU_DEFAULT_LIMIT_ADDR_MSGS;
        }
        else
        {
                /* valid input value between 200 and 50000 */
                if (!valid_integer1_value_range(sptr_cdb, CPU_MIN_LIMIT_ADDR_MSGS, CPU_MAX_LIMIT_ADDR_MSGS))
                {
                        return;
                }
                cpu_limit_addr_msgs = sptr_cdb->integer1;
        }

        for (device_id = 0; device_id < g_hw_info.max_dma; device_id++)
        {
                if (!IS_DMA_PRESENT(device_id))
                        continue;

                hal_bridge_FdbAuMsgRateLimitSet(device_id,
                                cpu_limit_addr_msgs,
                                (sptr_cdb->no ? FALSE : TRUE));

        }
}

void show_boot(struct cdb* sptr_cdb)
{
        int i;
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        uprintf("Boot system preference(Configured):\n");

        if (boot_seq[0] == BOOT_FROM_NONE)
                uprintf("\tUse Default\n");
        else {
                for (i = 0; i < MAX_BOOT_SEQ; i++)
                {
                        if (boot_seq[i] != BOOT_FROM_NONE)
                        {
                                switch(boot_seq[i])
                                {
                                case BOOT_FROM_FLASH_PRI:
                                        uprintf("\tBoot system flash primary\n");
                                        break;
                                case BOOT_FROM_FLASH_SEC:
                                        uprintf("\tBoot system flash secondary\n");
                                        break;
                                case BOOT_FROM_TFTP:
                                        uprintf("\tBoot system tftp %I %s\n", boot_ip, boot_file);
                                        break;
                                }
                        }
                }
        }
        uprintf("\nBoot system preference(Default):\n");
        uprintf("\tBoot system flash primary\n");
        uprintf("\tBoot system flash secondary\n");
}


typedef struct RunCmdFromTftp
{
        int     file_handle;
        UINT32 total_input_length;
        UINT32 current_cmd_number;
        FLASH_FILE_INFO flash_info;
        SV_TIMER_TOKEN_T        run_tftp_timer_id;
        char file_name[MAXIMUM_SIZE_OF_FILE_NAME+1];
        char line_buf[CMD_LINE_SIZE+1] ;
} RUN_CMD_FROM_TFTP;
RUN_CMD_FROM_TFTP g_tftp_run = {0};

int run_cmd_skip_control_char(char * buffer)
{
        int i;
        for (i = 0; i < CMD_LINE_SIZE; i++)
        {
                if (isprint (*(buffer+i)))
                        return(i);
        }
        return(-1);
}

SV_TIMER_TOKEN_T g_parser_wait_timer = (SV_TIMER_TOKEN_T)0;

void clear_parser_wait_until_callback(void)
{
        if (g_parser_wait_timer)
        {
                sv_cancel_timer(g_parser_wait_timer);
                g_parser_wait_timer = (SV_TIMER_TOKEN_T)0;
        }
        g_sw_sys.parser_wait_in_progress = 0;

}

void set_parser_wait_until_callback(void)
{
        g_sw_sys.parser_wait_in_progress = 1;
        g_parser_wait_timer = sv_set_timer_event(5*SECOND,
                                                        ONCE_TIMER,
                                                        (void (*)(void))clear_parser_wait_until_callback,
                                                        0,
                                                        "clear-parser-wait");
        if (g_parser_wait_timer == NULL)
        {
                uprintf("set_parser_wait_until_callback - sv_set_timer_event failed\n");
        }
}

BOOLEAN is_parser_wait_until_callback(void)
{
        return(g_sw_sys.parser_wait_in_progress);

}

void wait_for_a_while_cli_process(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen || g_sw_sys.init_in_progress)
        {
                return;
        }

//      debug_uprintf("Delay - wait_for_a_while_cli_process cdb 0x%X\n", sptr_cdb);
        
        if (g_sw_sys.parser_wait_in_progress)
        {
                g_sw_sys.parser_wait_in_progress = 0;
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                if (!valid_integer1_value_range(sptr_cdb, 1, 120))
                {
                        return;
                }
                g_sw_sys.parser_wait_in_progress = 1;
                sv_set_timer_event(sptr_cdb->integer1*SECOND,
                                                        ONCE_TIMER,
                                                        wait_for_a_while_cli_process,
                                                        (UINT32)sptr_cdb,
                                                        "wt-a_while");
        }
}

void wait_for_a_while_packet_process(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen || g_sw_sys.init_in_progress)
        {
                return;
        }

        if (g_sw_sys.packet_wait_in_progress)
        {
                g_sw_sys.packet_wait_in_progress = 0;
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                if (!valid_integer1_value_range(sptr_cdb, 1, 60))
                {
                        return;
                }
                g_sw_sys.packet_wait_in_progress = 1;
                sv_set_timer_event(sptr_cdb->integer1*SECOND,
                                                        ONCE_TIMER,
                                                        wait_for_a_while_packet_process,
                                                        (UINT32)sptr_cdb,
                                                        "wt-a_while");
        }
}


#ifndef NO_OPTICAL_MONITOR
enum BOOLEAN om_multi_interface = FALSE;
UINT16 optical_monitor_interval = 0;
extern int dom_down_port_on_off_set;
extern int dom_non_brocade_on_off_set;
extern void set_port_stack_optical_monitor_interval(UINT32 optical_monitor_intervalm, PORT_ID port);            /* in minutes */

void cli_set_port_optical_monitor_interval(struct cdb *sptr_cdb)
{
  PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
  UINT16  interval;
  STACK_ID stackId = PORT_TO_STACK_ID(port_id);
  UINT16 min_dom_interval = MIN_DOM_INTERVAL;

        if (sptr_cdb->config_gen == 0)
        {
                if(!IS_PORT_DB_VALID(port_id))
                        return;

                if (!IS_FI_BCM())
                {
                        if(is_port_stacking_port_and_stack_enable(port_id)) // STACK_TRUNK, is_port_config_stacking_port() does not check stack enable
                                return;
                }
                else
                {

                        if(is_port_stacking_port_and_stack_enable(port_id)) //OM Config is not allowed on stack trunk port
                        {
                                uprintf("Optical Monitoring is not allowed on stack trunk port\n");
                                return;
                        }
                }

                if (sptr_cdb->no)
                {

                        if (end_of_token(sptr_cdb->token) != '\0')
                                return;
                        sptr_cdb->dont_go_next = 1;

#ifdef SIDEWINDER_BREAKOUT
                        if(IS_SIDEWINDER()) {
                                if ((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)
                                                || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4)){ 
                                        if ((get_subport_fourth_tuple(port_id) != 1) && (get_subport_fourth_tuple(port_id) != 0))
                                        { 
                                                uprintf("Optical Monitor is only allowed on 1st breakout port \n"); 
                                                return;   
                                        }  
                                }
                                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = 0; 
                                        cu_optic_mon_per_port_zap_data(port_id);                                  
                        }
#else                    
                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = 0;
                        cu_optic_mon_per_port_zap_data(port_id);
#endif SIDEWINDER_BREAKOUT 

                        if(stackId != MY_BOOTUP_STACK_ID)
                                set_port_stack_optical_monitor_interval(0, port_id);
                        if(om_multi_interface == FALSE)
                                uprintf("Disable optical monitoring(default)\n");

                }
                else
                {
                                                if(!is_port_om_capable(port_id))
                                                        return;
                  if(chassisStackIsSIDEWINDER(MY_BOOTUP_STACK_ID) || chassisStackIsSpatha(MY_BOOTUP_STACK_ID) ||
					  	chassisStackIsTanto(MY_BOOTUP_STACK_ID))
                     min_dom_interval = 8;
                  else if(chassisStackIsSica(MY_BOOTUP_STACK_ID) || chassisStackIsMinions(MY_BOOTUP_STACK_ID))
                     min_dom_interval = 3;
                  if ((sptr_cdb->integer1 != 0) && (
                      (sptr_cdb->integer1 < min_dom_interval) || (sptr_cdb->integer1 > MAX_DOM_INTERVAL)))
                  {
                     uprintf("Set optical monitoring interval: bad value\n");
                     return;
                  }
#ifdef SIDEWINDER_BREAKOUT                                                                                                                       
                        if(IS_SIDEWINDER()) {                                                                                     
                                if ((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                  
                                                || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4)){ 
                                        if ((get_subport_fourth_tuple(port_id) != 1) && (get_subport_fourth_tuple(port_id) != 0)) 
                                        {                                                                                         
                                                uprintf("Optical Monitor is only allowed on 1st breakout port \n");               
                                                return;                                                                           
                                        }                                                                                         
                                }
                                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = sptr_cdb->integer1;          
                                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_trap_count = 0;                         
                                        if(is_config_trunk_port(port_id))                                                         
                                                set_trunk_optical_monitor_interval(port_id);                                      
                                        cu_optic_mon_per_port_zap_data(port_id);                                                  
                        }                                                                                                         
#else                                                                                                                                             
                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = sptr_cdb->integer1;                                          
                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_trap_count = 0;                                                         
                        if(is_config_trunk_port(port_id))                                                                                         
                                set_trunk_optical_monitor_interval(port_id);                                                                      
                        cu_optic_mon_per_port_zap_data(port_id);                                                                                  
                                                                                
#endif SIDEWINDER_BREAKOUT
                        //                      uprintf("StackId=%d port_id=%d interval=%d \n", stackId, port_id, sptr_cdb->integer1);
                        if(stackId != MY_BOOTUP_STACK_ID)
                                set_port_stack_optical_monitor_interval(sptr_cdb->integer1, port_id);
                        if(g_sw_sys.init_in_progress == 0) {
                                // bug 75713 - it's possible do "op mon 0" per port interface
                                if (sptr_cdb->integer1 == 0)
                                        uprintf("Disable optical monitoring\n");
                                else
                                        if(om_multi_interface == FALSE)
                                                uprintf("Enable optical monitoring and set alarm/warn interval to %d minute(s)\n",  sptr_cdb->integer1);
                        }
                }
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                if((stackId != MY_BOOTUP_STACK_ID) && MODULE_IS_EMPTY(PORT_TO_MODULE_ID(port_id)))
                        return;
                if(is_port_default_stacking_port(port_id)) // default ports superset of stk port, but not peri-port
                        return;
#ifdef SIDEWINDER_BREAKOUT                                                                                                                
                if(IS_SIDEWINDER()) {                                                                                     
                        if ((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                  
                                        || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4)){ 
                                if ((get_subport_fourth_tuple(port_id) != 1) && (get_subport_fourth_tuple(port_id) != 0)) 
                                {                                                                                         
                                        uprintf("Optical Monitor is only allowed on 1st breakout port \n");               
                                        return;                                                                           
                                }                                                                                         
                        }                                                                                                 
                }                                                                                                         
#endif SIDEWINDER_BREAKOUT 


                if (cu_get_port_optical_monitor_interval(port_id, &interval) != CU_OK) {
                        uprintf("Error:cli_set_port_optical_monitor_interval: cu_get_port_optical_monitor_interval() failed\n");
                        return;
                }

                if(optical_monitor_interval != 0)
                {       //  Global setting enabled
                        if ((optical_monitor_interval != interval) &&
                                        (interval != 0))
                        {
                                if(((stackId != MY_BOOTUP_STACK_ID)&& g_sw_sys.init_in_progress) || (GIG_FIBER_PORT == SPTR_PORT_DB(port_id)->port_mtype) || (X10GIG_FIBER_PORT == SPTR_PORT_DB(port_id)->port_mtype))
                                {

                                        if (interval == DEFAULT_DOM_INTERVAL)
                                            ksprintf(cu_line_buf, " optical-monitor\n");
                                        else
                                            ksprintf(cu_line_buf, " optical-monitor %d\n", interval);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }
                        }
                        else if(interval == 0 && (!is_port_stack_enabled(port_id))) {
                                if(((stackId != MY_BOOTUP_STACK_ID)&& g_sw_sys.init_in_progress) || SPTR_PORT_DB(port_id)->port_mtype == GIG_FIBER_PORT ||
                                                SPTR_PORT_DB(port_id)->port_mtype == X10GIG_FIBER_PORT ||
                                                SPTR_PORT_DB(port_id)->port_mtype == X40G_FIBER_PORT
                                                )
                                {
                                        ksprintf(cu_line_buf, " no optical-monitor\n");
                                        wr_config(sptr_cdb, cu_line_buf);
                                }
                        }
                }
                else
                {
                        if (interval)
                        {
                                if (interval == DEFAULT_DOM_INTERVAL)
                                        ksprintf(cu_line_buf, " optical-monitor\n");
                                else
                                        ksprintf(cu_line_buf, " optical-monitor %d\n", interval);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
        }
		if (IS_TANTO() && stackId == MY_BOOTUP_STACK_ID && 
			(SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval != 0){
			
			PORT_ID local_port = PORT_TO_LOCAL_PORT(port_id);
			/*This is required at the time of no optical monitoring update*/
			extern int om_enabled_port_list[];
			om_enabled_port_list[local_port] = (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval;
			extern void tanto_dom_init(PORT_ID);
			
	//		if(g_sw_sys.init_in_progress == 0)
				tanto_dom_init(port_id);
			//tanto_sfp_optical_monitoring_service(port_id);
		}
}

extern int is_sfp_sfpp_optictype_on_x40g(PORT_ID port);

void cli_set_port_optical_monitor_interval_default(struct cdb *sptr_cdb)
{
        PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
        UINT16 interval;
        STACK_ID stackId = PORT_TO_STACK_ID(port_id);

        if(!IS_PORT_DB_VALID(port_id))
                return;

        if (sptr_cdb->config_gen == 0)
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;
                sptr_cdb->dont_go_next = 1;

                if(!IS_PORT_DB_VALID(port_id))
                        return;

                if (sptr_cdb->no)
                {
#ifdef SIDEWINDER_BREAKOUT                                                                                                         
                        if(IS_SIDEWINDER()) {                                                                                      

                                if ((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                   
                                                || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4)){  

                                        if ((get_subport_fourth_tuple(port_id) != 1) && (get_subport_fourth_tuple(port_id) != 0))  
                                        {                                                                                          
                                                uprintf("Optical Monitor is only allowed on 1st breakout port \n");                
                                                return;                                                                            
                                        }                                                                                          
                                }
                                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = 0;                            
                                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_trap_count = 0;                          
                                        if(is_config_trunk_port(port_id))                                                          
                                                set_trunk_optical_monitor_interval(port_id);                                       

                                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = 0;                            
                                        cu_optic_mon_per_port_zap_data(port_id);                                                   
                                        if((om_multi_interface == FALSE) && (g_sw_sys.init_in_progress == 0))                      
                                                uprintf("Disable optical monitoring(default)\n");                                  
                        }                                                                                                          
#else                                                                                                                              
                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = 0;                                            
                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_trap_count = 0;                                          
                        if(is_config_trunk_port(port_id))                                                                          
                                set_trunk_optical_monitor_interval(port_id);                                                       

                        (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = 0;                                            
                        cu_optic_mon_per_port_zap_data(port_id);                                                                   
                        if((om_multi_interface == FALSE) && (g_sw_sys.init_in_progress == 0))                                      
                                uprintf("Disable optical monitoring(default)\n");                                                  
#endif SIDEWINDER_BREAKOUT 

                        if(stackId != MY_BOOTUP_STACK_ID)
                                set_port_stack_optical_monitor_interval(0,  port_id);
                }
                else
                {
                                        if(!is_port_om_capable(port_id)) {
                                                return;
					}

  #ifdef SIDEWINDER_BREAKOUT                                                                                                                    
                          if(IS_SIDEWINDER()) {                                                                                                     
                                  if ((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                                  
                                                  || (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4)){                 
                                                                                                                                                    
                                          if ((get_subport_fourth_tuple(port_id) != 1) && (get_subport_fourth_tuple(port_id) != 0))                 
                                          {                                                                                                         
                                                  uprintf("Optical Monitor is only allowed on 1st breakout port \n");                               
                                                  return;                                                                                           
                                          }                                                                                                         
                                                                        }
                                          (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = DEFAULT_DOM_INTERVAL;                        
                                          (SPTR_PORT_DB(port_id))->port_config.optical_monitor_trap_count = 0;                                         
                                          if(is_config_trunk_port(port_id))                                                                         
                                                  set_trunk_optical_monitor_interval(port_id);                                                      
                                          cu_optic_mon_per_port_zap_data(port_id);                                                                  
                                          if(g_sw_sys.init_in_progress == 0)                                                                        
                                                  if(om_multi_interface == FALSE)                                                                   
                                                          uprintf("Enable optical monitoring and set alarm/warn interval to default(%d minutes)\n", 
                                                                          (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval);              
                          }                                                                                                                         
  #else
                          (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval = DEFAULT_DOM_INTERVAL;                                        

                          (SPTR_PORT_DB(port_id))->port_config.optical_monitor_trap_count = 0;                                                         
                          if(is_config_trunk_port(port_id))                                                                                         
                                  set_trunk_optical_monitor_interval(port_id);                                                                      
                          cu_optic_mon_per_port_zap_data(port_id);                                                                                  
                          if(g_sw_sys.init_in_progress == 0)                                                                                        
                                  if(om_multi_interface == FALSE)                                                                                   
                                          uprintf("Enable optical monitoring and set alarm/warn interval to default(%d minutes)\n",                 
                                                          (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval);                              
  #endif SIDEWINDER_BREAKOUT      
                        if(stackId != MY_BOOTUP_STACK_ID)
                                set_port_stack_optical_monitor_interval((SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval,  port_id);

                }
        }
        else
        {
                sptr_cdb->dont_go_next = 1;
                if((stackId != MY_BOOTUP_STACK_ID) && MODULE_IS_EMPTY(PORT_TO_MODULE_ID(port_id)))
                        return;
#if 0
Cause all ACT/STBY/Member interface DOM level disappear - TR 638387
			if ((stackId == MY_BOOTUP_STACK_ID) || (G_STK_REMOTE_STATE(stackId) == 
								REG_STATE_MSR_FULLY_OPERATIONAL))
												return;
#endif

                // SideWinder stacking is not valid in the below code
                if(!IS_FI_BCM() && is_port_default_stacking_port(port_id)) // default ports superset of stk port, but not peri-port
                        return;
                if (cu_get_port_optical_monitor_interval(port_id, &interval) != CU_OK) {
                        uprintf("Error:cli_set_port_optical_monitor_interval: cu_get_port_optical_monitor_interval() failed\n");
                        return;
                }

                if(optical_monitor_interval != 0)
                {       //  Global setting enabled
                        if ((optical_monitor_interval != interval) &&
                                        (interval != 0))
                        {
                                if(((stackId != MY_BOOTUP_STACK_ID)&& g_sw_sys.init_in_progress) ||(GIG_FIBER_PORT == SPTR_PORT_DB(port_id)->port_mtype) || 
#ifdef SIDEWINDER_LINUX
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LM4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_ER4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_ESR4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4) ||
												(SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_4X10G_SR4) || 
												(is_sfp_sfpp_optictype_on_x40g(port_id)) ||
#endif SIDEWINDER_LINUX
                                                (X10GIG_FIBER_PORT == SPTR_PORT_DB(port_id)->port_mtype))
                                {

                                        if (interval == DEFAULT_DOM_INTERVAL)
                                            ksprintf(cu_line_buf, " optical-monitor\n");
                                        else
                                            ksprintf(cu_line_buf, " optical-monitor %d\n", interval);
                                        wr_config(sptr_cdb, cu_line_buf);
                                }
                        }
                        else if(interval == 0) {
                                if((!is_port_stack_enabled(port_id))) {
										if (IS_PP_40G_PORT(port_id)) { // only 4X10 has this type
                                        	if((SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LM4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_ESR4) || 
                                                (SPTR_PORT_DB(port_id)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)){
                                                	ksprintf(cu_line_buf, " no optical-monitor\n");
                                        			wr_config(sptr_cdb, cu_line_buf);
                                        	}
                                		} else
                                        if(((stackId != MY_BOOTUP_STACK_ID)&& g_sw_sys.init_in_progress) || SPTR_PORT_DB(port_id)->port_mtype == GIG_FIBER_PORT ||
                                                        SPTR_PORT_DB(port_id)->port_mtype == X10GIG_FIBER_PORT)
                                        {
                                                ksprintf(cu_line_buf, " no optical-monitor\n");
                                                wr_config(sptr_cdb, cu_line_buf);
                                        }
                                }
                        }
                }
                else
                {
                        if (interval)
                        {
                                if (interval == DEFAULT_DOM_INTERVAL)
                                        ksprintf(cu_line_buf, " optical-monitor\n");
                                else
                                        ksprintf(cu_line_buf, " optical-monitor %d\n", interval);
                                wr_config(sptr_cdb, cu_line_buf);
                        }
                }
        }

		
		if (IS_TANTO() && stackId == (UINT16)MY_BOOTUP_STACK_ID && 
			(SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval != 0){
			
			PORT_ID local_port = PORT_TO_LOCAL_PORT(port_id);
			/*This is required at the time of no optical monitoring update*/
			extern int om_enabled_port_list[];
			om_enabled_port_list[local_port] = (SPTR_PORT_DB(port_id))->port_config.optical_monitor_interval;
			extern void tanto_dom_init(PORT_ID);
	//		if(g_sw_sys.init_in_progress == 0)
				tanto_dom_init(port_id);
			//tanto_sfp_optical_monitoring_service(port_id);
		}

}
void mif_set_port_optical_monitor_interval_default(struct cdb* sptr_cdb)
{
        om_multi_interface = TRUE;
        set_mif(sptr_cdb, TRUE, (void *)cli_set_port_optical_monitor_interval_default);
        om_multi_interface = FALSE;
}

void cli_set_optical_monitor_interval(struct cdb *sptr_cdb)
{
#ifdef SIDEWINDER_BREAKOUT
        int slot, i;
        PORT_ID port=0;
        STACK_ID stackId;     
#endif
		UINT16 min_dom_interval = MIN_DOM_INTERVAL;

        if (end_of_token(sptr_cdb->token) != '\0') {
                return;
        }

        if (sptr_cdb->config_gen == 0) {
                if (sptr_cdb->no || sptr_cdb->integer1 == 0)
                {
                        sptr_cdb->dont_go_next = 1;
                        optical_monitor_interval = 0;

#ifdef SIDEWINDER_BREAKOUT
                        for(slot = 0; slot < g_hw_info.max_mod; slot++)
                        {
                                if (is_module_exist(slot) && (g_module[slot].module_status != MODULE_DISABLED) &&
                                                (g_module[slot].module_status != MODULE_EMPTY))
                                {
                                        port = MAKE_PORTID(slot, 0);
                                        stackId = PORT_TO_STACK_ID(port);
                                        if(chassisStackIsSIDEWINDER(stackId))  {  
                                                if(IS_PP_40G_PORT(port)){                                                                                  
                                                        if ((SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                      
                                                                        || (SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4))    
                                                        {                                                                                                  
                                                                if ((get_subport_fourth_tuple(port) != 1) && (get_subport_fourth_tuple(port) != 0))        
                                                                        continue;                                                                          
                                                                else                                                                                       
                                                                        optical_monitor_interval = 0;                                                      
                                                        }  
							else                                                                                       
								optical_monitor_interval = 0;
                                                } 
						else                                                                                       
							optical_monitor_interval = 0;                                                      
                                        }
                                } 
                        } 
#else
                        optical_monitor_interval = 0;                                                                                
#endif SIDEWINDER_BREAKOUT 
			if(optical_monitor_interval == 0)
				uprintf("Disable optical monitoring(default)\n");                                                            

		}
		else
		{
			if(chassisStackIsSIDEWINDER(MY_BOOTUP_STACK_ID) || chassisStackIsSpatha(MY_BOOTUP_STACK_ID) ||
					chassisStackIsTanto(MY_BOOTUP_STACK_ID))
				min_dom_interval = 8;
			else if(chassisStackIsSica(MY_BOOTUP_STACK_ID) || chassisStackIsMinions(MY_BOOTUP_STACK_ID))
				min_dom_interval = 3;
		
			if ((sptr_cdb->integer1 != 0) && (                                                                       
						(sptr_cdb->integer1 < min_dom_interval) ||                                                       
						(sptr_cdb->integer1 > MAX_DOM_INTERVAL)))                                                        
			{                                                                                                        
				uprintf("Set optical monitoring interval: bad value\n");                                         
				return;                                                                                          
			}                                                                                                        
#ifdef SIDEWINDER_BREAKOUT                                                                                                     
                        for(slot = 0; slot < g_hw_info.max_mod; slot++)
                        {
                                if (is_module_exist(slot) && (g_module[slot].module_status != MODULE_DISABLED) &&
                                                (g_module[slot].module_status != MODULE_EMPTY))                                                         
                                {
                                        port = MAKE_PORTID(slot, 0);
                                        stackId = PORT_TO_STACK_ID(port);

                                        if(chassisStackIsSIDEWINDER(stackId))  {
                                                if ((SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                   
                                                                || (SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4))  
                                                {                                                                                               
                                                        if ((get_subport_fourth_tuple(port) != 1) && (get_subport_fourth_tuple(port) != 0))     
                                                                continue;                                                                       
                                                        else                                                                                    
                                                        {                                                                                       
                                                                optical_monitor_interval = sptr_cdb->integer1;                                  
                                                        }                                                                                       
                                                }                                                                                                       
						else                                                                                    
						{                                                                                       
							optical_monitor_interval = sptr_cdb->integer1;                                  
                                        }                                                                                                               
                                }                                                                                                                       
                        }                                                                                                                               
                        }                                                                                                        
#else
                        optical_monitor_interval = sptr_cdb->integer1;                                                           
#endif SIDEWINDER_BREAKOUT 

                        // bug 75713 - it's possible do "op mon 0" per port interface
                        if (sptr_cdb->integer1 == 0)
                                uprintf("Disable optical monitoring\n");
						else if (optical_monitor_interval == sptr_cdb->integer1)
                                uprintf("Enable optical monitoring and set alarm/warn interval to %d minute(s)\n",  optical_monitor_interval);
        }
        cu_set_all_port_optical_monitor_interval(optical_monitor_interval);
    }
}

void cli_set_optical_monitor_interval_default(struct cdb *sptr_cdb)
{
#ifdef SIDEWINDER_BREAKOUT
        int slot, i;
        PORT_ID port=0;
        STACK_ID stackId;     
#endif

        if (sptr_cdb->config_gen == 0)
        {
                if (end_of_token(sptr_cdb->token) != '\0')
                        return;

                sptr_cdb->dont_go_next = 1;
                if (sptr_cdb->no)
                {
#ifdef SIDEWINDER_BREAKOUT                                                                                                      
                        for(slot = 0; slot < g_hw_info.max_mod; slot++)                                                                               
                        {                                                                                                                             
                                if (is_module_exist(slot) && (g_module[slot].module_status != MODULE_DISABLED) &&                                     
                                                (g_module[slot].module_status != MODULE_EMPTY))                                                       
                                {                                                                                                                     
                                        port = MAKE_PORTID(slot, 0);                                                                                  
                                        stackId = PORT_TO_STACK_ID(port);

                                        if(chassisStackIsSIDEWINDER(stackId))  {
                                                if ((SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)                 
                                                                || (SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4))
                                                {                                                                                             

                                                        if ((get_subport_fourth_tuple(port) != 1) && (get_subport_fourth_tuple(port) != 0))   
                                                                continue;                                                                     
                                                        else                                                                                  
                                                                optical_monitor_interval = 0;                                                 
                                                }                                                                                             
												else                                                                                  
													optical_monitor_interval = 0;                                                 
                                        }else
                                        	optical_monitor_interval = 0;      
                                }                                                                                                                     
                        }                                                                                                                             
#else
                        optical_monitor_interval = 0;                                                                            
#endif SIDEWINDER_BREAKOUT      
						if(optical_monitor_interval == 0)
							uprintf("Disable optical monitoring(default)\n");                                                        

                }
                else
                {
#ifdef SIDEWINDER_BREAKOUT 
                        for(slot = 0; slot < g_hw_info.max_mod; slot++)
                        {
                                if (is_module_exist(slot) && (g_module[slot].module_status != MODULE_DISABLED) &&
                                                (g_module[slot].module_status != MODULE_EMPTY))
                                {
                                        port = MAKE_PORTID(slot, 0);
                                        stackId = PORT_TO_STACK_ID(port);

                                        if(chassisStackIsSIDEWINDER(stackId))  {
                                                if ((SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_SR4)
                                                                || (SPTR_PORT_DB(port)->port_oper_info.media_type == LINK_MEDIA_40GBASE_LR4))
                                                {  
                                                        if ((get_subport_fourth_tuple(port) != 1) && (get_subport_fourth_tuple(port) != 0))
                                                                continue; 
                                                        else
                                                                optical_monitor_interval = DEFAULT_DOM_INTERVAL;
                                                }
						else                                                                                                           
							optical_monitor_interval = DEFAULT_DOM_INTERVAL;                                                       
                                        }  
                                }  
 
			}                                                                                                                                                                                                        
#else
			optical_monitor_interval = DEFAULT_DOM_INTERVAL; 
#endif SIDEWINDER_BREAKOUT
      if(optical_monitor_interval == DEFAULT_DOM_INTERVAL)
        uprintf("Enable optical monitoring and set alarm/warn interval to default(%d minutes)\n", optical_monitor_interval);
      if((strncmp(sptr_cdb->token, "down-port", 9) == 0))
        dom_down_port_on_off_set = TRUE;
      if((strncmp(sptr_cdb->token, "non-brocade", 11) == 0))
        dom_non_brocade_on_off_set = TRUE;
      }
      if (cu_set_all_port_optical_monitor_interval(optical_monitor_interval) != CU_OK)
        uprintf("Error:cu_set_all_port_optical_monitor_interval()  failed \n");
    }
    else
    {
      sptr_cdb->dont_go_next = 1;
      if (optical_monitor_interval != 0)
      {
        if (optical_monitor_interval == DEFAULT_DOM_INTERVAL)  /* default */
          ksprintf(cu_line_buf, "optical-monitor \n");
        else
          ksprintf(cu_line_buf, "optical-monitor %d \n", optical_monitor_interval);
        wr_config(sptr_cdb, cu_line_buf);
        if(dom_down_port_on_off_set) {
          ksprintf(cu_line_buf, "optical-monitor down-port-enable\n");
          wr_config(sptr_cdb, cu_line_buf);
        }
        if(dom_non_brocade_on_off_set) {
          ksprintf(cu_line_buf, "optical-monitor non-brocade-optic-enable\n");
          wr_config(sptr_cdb, cu_line_buf);
        }
      }
    }
}

void set_mif_optical_monitor_interval(struct cdb* sptr_cdb)
{
        om_multi_interface = TRUE;
        set_mif(sptr_cdb, TRUE, (void *)cli_set_port_optical_monitor_interval);
        om_multi_interface = FALSE;
}
#endif NO_OPTICAL_MONITOR


#define FLASH_RW_BUFFER_SIZE                    8192            /* # of bytes to copy per subtask */
typedef struct dm_run_cli_file_struct
{
        SV_TIMER_TOKEN_T script_timer_id;
        UINT32 io_session;
        int error;
        int script_handle;
        int f_d_handle;
        UINT8 delete_file_at_the_end;
        UINT8 run_cli_kill;
        char file_name[FLASH_FILE_NAME_LENGTH];
        char f_d_file_name[FLASH_FILE_NAME_LENGTH];
        FLASH_FILE_INFO f_s_info;
        FLASH_FILE_INFO f_d_info;
        char *line_buffer;
        UINT32 line_buffer_size;
        int current_cmd_number;
        int total_input_length;
        int loop_count;
        int original_loop_count;
        int old_page_mode;
} DM_RUN_CLI_FILE_STRUCT, *pDM_RUN_CLI_FILE_STRUCT;

DM_RUN_CLI_FILE_STRUCT dm_run_cli_file_data;

typedef struct copy_file2file_struct
{
        SV_TIMER_TOKEN_T f2f_timer_id;
        UINT32 io_session;
        int copy_error;
        int f_s_handle;
        int f_d_handle;
        int fclose_wait;
        char f_s_file_name[FLASH_FILE_NAME_LENGTH];
        char f_d_file_name[FLASH_FILE_NAME_LENGTH];
        FLASH_FILE_INFO f_s_info;
        FLASH_FILE_INFO f_d_info;
        char *rw_buffer;
        UINT32 rw_buffer_size;
        int current_index;
        int current_byte_count;
} COPY_FILE2FILE_STRUCT, *pCOPY_FILE2FILE_STRUCT;

COPY_FILE2FILE_STRUCT copy_file2file_data;

void redirect_uprintf(char *msg, UINT32 ui_port)
{
int save_ui_port;

        save_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        uprintf("%s", msg);

        g_uprintf_dest = save_ui_port;

}

void redirect_prompt(UINT32 ui_port)
{
int save_ui_port;
struct cdb *sptr_cdb;

        sptr_cdb = &cdbs[ui_port];
        save_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        print_prompt(sptr_cdb);

        g_uprintf_dest = save_ui_port;

}

void dm_run_script_file_callback(pDM_RUN_CLI_FILE_STRUCT run_cdb)
{
        long length = 0;
        char *end_of_line;
        int line_length;
        char buf[80];
        struct io_port_cb *sptr_cb = &io_cb[run_cdb->io_session];

        if (g_sw_sys.parser_wait_in_progress)
        {
                return;
        }

        if (length = flash_fread(run_cdb->script_handle,
                                                                run_cdb->line_buffer,
                                                                CMD_LINE_SIZE))
        {
//              uprintf("script read %d\n", length);
                run_cdb->line_buffer[length] = 0;

                end_of_line = strchr(run_cdb->line_buffer, '\r');
                if (end_of_line == NULL)
                {
                        if (flash_feof(run_cdb->script_handle))
                        {
                                end_of_line = &run_cdb->line_buffer[length+1];
                        }
                }
                if (end_of_line)
                {
                        line_length = (int)end_of_line - (int)run_cdb->line_buffer;
                        memcpy(&sptr_cb->cmd_line[0][0], run_cdb->line_buffer, line_length);
                        sptr_cb->cmd_line[0][line_length] = '\0';
                        ksprintf(&run_cdb->line_buffer[CMD_LINE_SIZE] ,"** %d cmd - %s\n",
                                                        ++run_cdb->current_cmd_number,
                                                        &sptr_cb->cmd_line[0][0]);
                        redirect_uprintf(&run_cdb->line_buffer[CMD_LINE_SIZE], run_cdb->io_session);

                        parse_input(run_cdb->io_session, CMD_LINE_EXECUTE, FALSE);
                        run_cdb->total_input_length += line_length+run_cmd_skip_control_char(&run_cdb->line_buffer[line_length]);
                        flash_fseek(run_cdb->script_handle,
                                                                        run_cdb->total_input_length,
                                                                        FLASH_FILE_SEEK_SET);
                        return;
                }
        }

        /* EOF */
        
        if (!run_cdb->run_cli_kill)
        {
        if (run_cdb->loop_count--)
        {
                run_cdb->total_input_length = 0;
                run_cdb->current_cmd_number = 0;
                flash_fseek(run_cdb->script_handle,
                                                                0,
                                                                FLASH_FILE_SEEK_SET);
                        if (run_cdb->loop_count )
                        {
                                sprintf(buf, "\nRepeated %d times.\n",  run_cdb->original_loop_count - run_cdb->loop_count);
                                redirect_uprintf(buf, run_cdb->io_session);
                        }
                        return;
                }
        }
        if (run_cdb->script_timer_id)
        {
                sv_cancel_timer(run_cdb->script_timer_id);
                run_cdb->script_timer_id = NULL;
        }
        if (run_cdb->line_buffer)
        {
                dy_free(run_cdb->line_buffer);
                run_cdb->line_buffer = NULL;
                run_cdb->line_buffer_size = 0;
        }
        if (run_cdb->script_handle)
        {
                flash_fclose(run_cdb->script_handle);
                if (run_cdb->delete_file_at_the_end)
                {
                        sys_flash_fremove(run_cdb->file_name);
                }
                run_cdb->script_handle = NULL;
        }
        if (run_cdb->original_loop_count )
        {
                sprintf(buf, "\nRepeated %d times.\n", run_cdb->original_loop_count);
                redirect_uprintf(buf, run_cdb->io_session);
        }
        if (run_cdb->run_cli_kill)
        {
                redirect_uprintf("\n******** STOPPED ******** \n", run_cdb->io_session);
        }
        else
        {
        redirect_uprintf("\n******** END ********\n", run_cdb->io_session);
        }
        redirect_prompt(run_cdb->io_session);
        g_skip_page_mode = run_cdb->old_page_mode;
        memset((void *)run_cdb, 0, sizeof(DM_RUN_CLI_FILE_STRUCT));
}
void dm_run_cli_file_kill(struct cdb* sptr_cdb)
{
        pDM_RUN_CLI_FILE_STRUCT run_cdb = &dm_run_cli_file_data;

        if (end_of_token(sptr_cdb->token) != '\0')
                        return;
        
        sptr_cdb->dont_go_next = 1;
        run_cdb->run_cli_kill = 1;
        run_cdb->original_loop_count = run_cdb->loop_count = 0;
        uprintf("Run cli will be stopped\n");
}
void dm_run_cli_file(struct cdb* sptr_cdb)
{
        int delay = SECOND*5;
        pDM_RUN_CLI_FILE_STRUCT run_cdb = &dm_run_cli_file_data;

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;
        if (sptr_cdb->no)
        {
                run_cdb->loop_count = 0;
                if(run_cdb->script_handle)
                        flash_fseek(run_cdb->script_handle,
                                                                run_cdb->f_s_info.length,
                                                                FLASH_FILE_SEEK_SET);
                return;
        }


        if (strlen((char *)sptr_cdb->string1) > FLASH_FILE_NAME_LENGTH)
        {
                return;
        }
        strcpy(run_cdb->file_name, (char *)sptr_cdb->string1);
        run_cdb->script_handle = flash_fopen((char *)sptr_cdb->string1, "r");
        if (run_cdb->script_handle == NULL)
        {
                uprintf("Can find the file %s\n", (char *)sptr_cdb->string1);
                return;
        }
        run_cdb->total_input_length = 0;
        run_cdb->current_cmd_number = 0;
        run_cdb->io_session = sptr_cdb->ui_port;
        run_cdb->error = 0;
        if ((run_cdb->line_buffer = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE*2+1)) == NULL)
        {
                flash_fclose(run_cdb->script_handle);
                run_cdb->script_handle = NULL;
                return;
        }
        run_cdb->line_buffer_size = CMD_LINE_SIZE*2;
        if (sptr_cdb->integer1 && sptr_cdb->num_of_integer)
        {
                if (sptr_cdb->integer1 < 300)   /* 5 minutes max */
                        delay = sptr_cdb->integer1 * SECOND;
                if (sptr_cdb->num_of_integer == 2)
                {
                       run_cdb->original_loop_count = run_cdb->loop_count = sptr_cdb->integer2;
                }
        }

        flash_get_file_info(run_cdb->script_handle, &run_cdb->f_s_info);
        run_cdb->old_page_mode = g_skip_page_mode;
        g_skip_page_mode = 1;
        dm_run_script_file_callback(run_cdb);

        run_cdb->script_timer_id = sv_set_timer_event(delay,
                                                                                                REPEAT_TIMER,
                                                                                                dm_run_script_file_callback,
                                                                                                (UINT32)run_cdb,
                                                                                                "tm-cli");


}

void cu_rename_cli_file(char *string1, char *string2)
{
        int f_handle;

        if ((f_handle = flash_fopen(string1, "r")) == NULL)
        {
                uprintf("Rename failed, cannot find file %s\n", string1);
                return;
        }
        flash_fclose(f_handle);

        if (f_handle = flash_fopen(string2, "r"))
        {
                uprintf("Rename failed, destination file %s exists.\n", string2);
                flash_fclose(f_handle);
                return;
        }

        flash_rename(string1, string2);

}

void dm_rename_cli_file(struct cdb* sptr_cdb)
{


        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        if (cu_is_illegal_flash_file_name(sptr_cdb->string1))
        {
                return;
        }

        if (cu_is_illegal_flash_file_name(sptr_cdb->string2))
        {
                return;
        }
        cu_rename_cli_file((char *)sptr_cdb->string1, (char *)sptr_cdb->string2);

}

#ifndef OFFICIAL_RELEASE
int fips_algtest_copy_done = 0;
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *  *  * * Name               :   fipsalgtest_flashcopy
 *   *   *
 *    *    * * Purpose            :   Callback function which completes copy of "script file fipsAlgTest" from TFTP server to flash
 *     *     *
 *      *      * * Return             :   void
 *       *       * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

void fipsalgtest_flashcopy(UINT32 error,UINT32 ui_port)
{
	int save_ui_port;
	int file, is_fs = 0;
	char *file_name;
	struct cdb* 	sptr_cdb;
	sptr_cdb = &cdbs[ui_port];
	save_ui_port = g_uprintf_dest;
	g_uprintf_dest = ui_port;
	uprintf("\nTFTP to Flash");

	if (error == TFTP_NO_ERROR)
	{
		uprintf(" Done.\n");
		uprintf("\nFIPS algorithm testing is in progress.\n");
		fips_algtest_copy_done = 1;
	}
	else
	{
		uprintf(" Error - code %d\n", error);
	}

	print_prompt(sptr_cdb);
	g_uprintf_dest = save_ui_port;
	reset_flash_use_in_progress();
	cli_fips_algtest_processscript_file();
}
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *  *  * * Name               :   request_flashcopy
 *   *   *
 *    *    * * Purpose            :   Callback function which completes copy of "request files" from TFTP server to flash
 *     *     *
 *      *      * * Return             :   void
 *       *       * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
void request_flashcopy(UINT32 error,UINT32 ui_port)
{
	int save_ui_port;
	int file, is_fs = 0;
	char *file_name;
	struct cdb* 	sptr_cdb;

	sptr_cdb = &cdbs[ui_port];

	save_ui_port = g_uprintf_dest;
	g_uprintf_dest = ui_port;
	uprintf("\nTFTP to Flash");

	if (error == TFTP_NO_ERROR)
	{
		uprintf(" Done.\n");

	}
	else
	{
		uprintf(" Error - code %d\n", error);
	}

	/*	print_prompt(sptr_cdb); */
	g_uprintf_dest = save_ui_port;
	execute_alg_test(ui_port);
}
extern void rename_flash_response_file(UINT32 ui_port);

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *  *  * * Name               :   rename_flash_response_file
 *   *   *
 *    *    * * Purpose            :   Callback function which completes copy of "response files" from  flash to TFTP eerver
 *     *     *
 *      *      * * Return             :   void
 *       *       * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
void response_flash2tftpCopy(UINT32 error,UINT32 ui_port)
{
	int save_ui_port;int i;
	struct cdb*     sptr_cdb;

	sptr_cdb = &cdbs[ui_port];

	save_ui_port = g_uprintf_dest;
	g_uprintf_dest = ui_port;

	uprintf("\nFlash to TFTP");

	if (error == TFTP_NO_ERROR)
	{
		uprintf(" Done.\n");
	}
	else
	{
		uprintf(" Error - code %d\n", error);
	}
	g_uprintf_dest = save_ui_port;

	/* Fixed bug#4204, delete tftp.vptr_udp_control_block */
	/* Fixed defect#378562, do not delete tftp.vptr_udp_control_block if tftp is busy */
	if (tftp.vptr_udp_control_block != NULL && error != TFTP_BUSY)
	{
		delete_udp_control_block( tftp.vptr_udp_control_block );
		tftp.vptr_udp_control_block = NULL;
	}
	sv_set_timer(10*SECOND,ONCE_TIMER,rename_flash_response_file,(UINT32)ui_port);
}
#endif

void tftp2flashCopy(UINT32 error,UINT32 ui_port)
{
        int save_ui_port;
        int file, is_fs = 0;
        char *file_name;
        struct cdb*     sptr_cdb;

        sptr_cdb = &cdbs[ui_port];

        save_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;
                uprintf("\nTFTP to Flash");

        if (error == TFTP_NO_ERROR)
        {
                uprintf(" Done.\n");
        }
        else
        {
                uprintf(" Error - code %d\n", error);
        }

        print_prompt(sptr_cdb);
        g_uprintf_dest = save_ui_port;

        /* Fixed bug#4204, delete tftp.vptr_udp_control_block */
        /* Fixed defect#378562, do not delete tftp.vptr_udp_control_block if tftp is busy */
        if (tftp.vptr_udp_control_block != NULL && error != TFTP_BUSY)
        {
                delete_udp_control_block( tftp.vptr_udp_control_block );
                tftp.vptr_udp_control_block = NULL;
        }
        reset_flash_use_in_progress();
          if(g_file_type == TRUST_CERT)
          {
           cli_generate_ssl_trusted_certificate_from_tftp(SSL_TRUSTED_CERT_TEMP_FNAME);
                   g_file_type = GENERAL_DATA; /* Just to clear the TRUST_CERT to avoid calling the trust creation for other flash file download */
          }
}

void
copy_tftp_flash_sig_to_all_units(struct cdb* sptr_cdb)
{
        int      is_fs = 0;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;
        sptr_cdb->dont_go_next = 1;

        if(is_fs = is_a_fs()){
                if(!strncmp(sptr_cdb->token,"icx6610",strlen("icx6610"))){
                        g_fs_sig_chow = TRUE;
                }
                else if (!strncmp(sptr_cdb->token,"icx6450",strlen("icx6450"))){
                        g_fs_sig_katara_h = TRUE;
                        g_fs_k_image = TRUE;
                }
                if (g_file_type == PRIMARY_SIG_FILE)
                        copy_tftp_flash_pri_sig(sptr_cdb);
                else if (g_file_type == SECONDARY_SIG_FILE)
                        copy_tftp_flash_sec_sig(sptr_cdb);
                                else if (g_file_type == BOOTROM_SIG_FILE)
                                                copy_tftp_flash_boot_sig(sptr_cdb);
        }
        else
        {
                uprintf("This CLI operation is applicable only in mixed stacking\n");
        }
}

void copy_tftp_flash_pri_sig(struct cdb* sptr_cdb)
{
        int      idx;
        int      is_fs = 0;

        if (end_of_token(sptr_cdb->token) != '\0'){
                return;
        }

        sptr_cdb->dont_go_next = 1;
        if ( sys_tftp_disable_get() ) {
                uprintf("tftp is disabled.\n");
                return;
        }

        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                tftp2flashCopy(TFTP_LONG_FILE_NAME, sptr_cdb->ui_port);
                return;
        }

        if (strstr ( (char*)sptr_cdb->string1, ".sig") == NULL)
        {
                uprintf("Not a .sig file.\n");
                return;
        }

        if(!set_flash_use_in_progress())
            return;

        if (IS_IPV4_AFI(sptr_cdb->afi))
        {
                if (tftp.current_operation != TFTP_IDLE) { 
                        /* prevent multiple tftp session */
                        tftp2flashCopy(TFTP_BUSY, sptr_cdb->ui_port);
                        return;
                }

                tftp_perform_download(tftp2flashCopy,
                                                                sptr_cdb->ui_port,
                                                                sptr_cdb->ip1,
                                                                (char *)sptr_cdb->string1,
                                                                GENERAL_FLASH_FILE,
                                                                PRIMARY_SIG_FILE);
        }
#ifdef __IPV6__
        else
        {
                tftp6_perform_gen_download(
                                tftp2flashCopy,
                                sptr_cdb->ui_port,
                                &sptr_cdb->ipv6_1,
                                (char*)sptr_cdb->string1,
                                GENERAL_FLASH_FILE,
                                PRIMARY_SIG_FILE,
                                TFTP_CONFIG_FILE_DOWNLOAD
                                );
        }
#endif __IPV6__
}

void copy_tftp_flash_sec_sig(struct cdb* sptr_cdb)
{
        int      idx;
        int      is_fs = 0;

        if (end_of_token(sptr_cdb->token) != '\0'){
                return;
        }

        sptr_cdb->dont_go_next = 1;

        if ( sys_tftp_disable_get() ) {
                uprintf("tftp is disabled.\n");
                return;
        }

        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                tftp2flashCopy(TFTP_LONG_FILE_NAME, sptr_cdb->ui_port);
                return;
        }

        if (strstr ( (char*)sptr_cdb->string1, ".sig") == NULL)
        {
                uprintf("Not a .sig file.\n");
                return;
        }

        if(!set_flash_use_in_progress())
            return;

        if (IS_IPV4_AFI(sptr_cdb->afi))
        {
                if (tftp.current_operation != TFTP_IDLE) {                         /* prevent multiple tftp session */
                        tftp2flashCopy(TFTP_BUSY, sptr_cdb->ui_port);
                        return;
                }

                tftp_perform_download(tftp2flashCopy,
                                                                sptr_cdb->ui_port,
                                                                sptr_cdb->ip1,
                                                                (char *)sptr_cdb->string1,
                                                                GENERAL_FLASH_FILE,
                                                                SECONDARY_SIG_FILE);
        }
#ifdef __IPV6__
        else
        {
                tftp6_perform_gen_download(
                                tftp2flashCopy,
                                sptr_cdb->ui_port,
                                &sptr_cdb->ipv6_1,
                                (char*)sptr_cdb->string1,
                                GENERAL_FLASH_FILE,
                                SECONDARY_SIG_FILE,
                                TFTP_CONFIG_FILE_DOWNLOAD
                                );
        }
#endif __IPV6__
}

void
copy_tftp_flash_boot_sig(struct cdb* sptr_cdb)
{
        int      idx;
        int      is_fs = 0;

        if (end_of_token(sptr_cdb->token) != '\0'){
                g_file_type = BOOTROM_SIG_FILE;
                return;
        }

        sptr_cdb->dont_go_next = 1;

        if ( sys_tftp_disable_get() ) {
                uprintf("tftp is disabled.\n");
                return;
        }

        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                tftp2flashCopy(TFTP_LONG_FILE_NAME, sptr_cdb->ui_port);
                return;
        }

        if (strstr ( (char*)sptr_cdb->string1, ".sig") == NULL)
        {
                uprintf("Not a .sig file.\n");
                return;
        }

        if(!set_flash_use_in_progress())
            return;

        if (IS_IPV4_AFI(sptr_cdb->afi))
        {
                if (tftp.current_operation != TFTP_IDLE) {                         /* prevent multiple tftp session */
                        tftp2flashCopy(TFTP_BUSY, sptr_cdb->ui_port);
                        return;
                }

                tftp_perform_download(tftp2flashCopy,
                                                                                                sptr_cdb->ui_port,
                                                                                                sptr_cdb->ip1,
                                                                                                (char *)sptr_cdb->string1,
                                                                                                GENERAL_FLASH_FILE,
                                                                                                BOOTROM_SIG_FILE
                                                                                                );
        }
#ifdef __IPV6__
        else
        {
                tftp6_perform_gen_download(
                                tftp2flashCopy,
                                sptr_cdb->ui_port,
                                &sptr_cdb->ipv6_1,
                                (char*)sptr_cdb->string1,
                                GENERAL_FLASH_FILE,
                                BOOTROM_SIG_FILE,
                                TFTP_CONFIG_FILE_DOWNLOAD
                                );
        }
#endif __IPV6__
}

#ifdef SIDEWINDER_LINUX
#define DEFAULT_DIRECTORY       "/fast_iron"
#define MAXIMUM_SIZE_OF_FULL_PATH (MAXIMUM_SIZE_OF_FILE_NAME + 32) // add for /fast_iron/disk0
void copy_disk0_flash_pri_sig(struct cdb* sptr_cdb)
{
        int      idx;
        int      is_fs = 0;
        char    disk0_filename[MAXIMUM_SIZE_OF_FULL_PATH];
        char syscmd[256]; // if file name is 128 byte long

                if(check_disk0())
                        return;

        if (end_of_token(sptr_cdb->token) != '\0'){
                return;
        }

        sptr_cdb->dont_go_next = 1;

        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                uprintf("File name too long\n");
                return;
        }

        if (strstr ( (char*)sptr_cdb->string1, ".sig") == NULL)
        {
                uprintf("Not a .sig file.\n");
                return;
        }

        // Can't use flash_fopen and flash copy commands here for the external usb 
        snprintf(disk0_filename, MAXIMUM_SIZE_OF_FULL_PATH, "%s/%s",EXTERNAL_USB_PATH, sptr_cdb->string1);
        snprintf(syscmd, 256, "cp -rvf %s %s/primary.sig &> /dev/null ",disk0_filename,DEFAULT_DIRECTORY) ;
                if ( sil_handle_syscmd(syscmd) != 0) 
                {
                        uprintf("File %s does not exist in external usb \n",disk0_filename);
                        return ;
                }
                else
                        uprintf (" primary.sig copied \n");
}

void copy_disk0_flash_sec_sig(struct cdb* sptr_cdb)
{
        int      idx;
        int      is_fs = 0;
        char    disk0_filename[MAXIMUM_SIZE_OF_FULL_PATH];
        char syscmd[256];

                if(check_disk0())
                        return;

        if (end_of_token(sptr_cdb->token) != '\0'){
                return;
        }

        sptr_cdb->dont_go_next = 1;

        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                uprintf("File name too long\n");
                return;
        }

        if (strstr ( (char*)sptr_cdb->string1, ".sig") == NULL)
        {
                uprintf("Not a .sig file.\n");
                return;
        }

                
        snprintf(disk0_filename, MAXIMUM_SIZE_OF_FULL_PATH, "%s/%s",EXTERNAL_USB_PATH, sptr_cdb->string1);
        snprintf(syscmd,256, "cp -rvf %s %s/secondary.sig &> /dev/null",disk0_filename,DEFAULT_DIRECTORY) ;
                if ( sil_handle_syscmd(syscmd) != 0) 
                {
                        uprintf("File %s does not exist in external usb \n",disk0_filename);
                        return ;
                }
                else
                        uprintf (" secondary.sig copied \n");
}

void
copy_disk0_flash_boot_sig(struct cdb* sptr_cdb)
{
        int      idx;
        int      is_fs = 0;
        char    disk0_filename[MAXIMUM_SIZE_OF_FULL_PATH];
        char syscmd[256];
                if(check_disk0())
                        return;

        if (end_of_token(sptr_cdb->token) != '\0'){
                g_file_type = BOOTROM_SIG_FILE;
                return;
        }

        sptr_cdb->dont_go_next = 1;

        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                uprintf("File name too long\n");
                return;
        }

        if (strstr ( (char*)sptr_cdb->string1, ".sig") == NULL)
        {
                uprintf("Not a .sig file.\n");
                return;
        }

                
        snprintf(disk0_filename, MAXIMUM_SIZE_OF_FULL_PATH, "%s/%s",EXTERNAL_USB_PATH, sptr_cdb->string1);
        snprintf(syscmd,256,"cp -rvf %s %s/bootrom.sig &> /dev/null",disk0_filename,DEFAULT_DIRECTORY) ;
                if ( sil_handle_syscmd(syscmd) != 0) 
                {
                        uprintf("File %s does not exist in external usb \n",disk0_filename);
                        return ;
                }
                else
                        uprintf (" bootrom.sig  copied \n");
}
#endif

void copy_file_to_flash(struct cdb* sptr_cdb)
{
    if(end_of_token(sptr_cdb->token) != '\0')
        return;

    if(strncmp(sptr_cdb->token,"file",4))
    {
        return;
    }

    if(sys_tftp_disable_get() ) {
        uprintf("tftp is disabled.\n");
        return;
    }
    if(strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
    {
        tftp2flashCopy(TFTP_LONG_FILE_NAME, sptr_cdb->ui_port);
        return;
    }


    if (IS_IPV4_AFI(sptr_cdb->afi))
    {
        if (tftp.current_operation != TFTP_IDLE) {                         /* prevent multiple tftp session */
            tftp2flashCopy(TFTP_BUSY, sptr_cdb->ui_port);
            return;
        }

        if(!set_flash_use_in_progress())
            return;

        tftp_perform_download(tftp2flashCopy,sptr_cdb->ui_port, sptr_cdb->ip1,
                                                        (char *)sptr_cdb->string1, GENERAL_FLASH_FILE, GENERAL_DATA);
    }
}

void flash2tftpCopy(UINT32 error,UINT32 ui_port)
{
        int save_ui_port;
        struct cdb*     sptr_cdb;

        sptr_cdb = &cdbs[ui_port];

        save_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        uprintf("\nFlash to TFTP");

        if (error == TFTP_NO_ERROR)
        {
            uprintf(" Done.\n");
        }
        else
        {
            uprintf(" Error - code %d\n", error);
        }

        //print_prompt(sptr_cdb);
        g_uprintf_dest = save_ui_port;

        /* Fixed bug#4204, delete tftp.vptr_udp_control_block */
        /* Fixed defect#378562, do not delete tftp.vptr_udp_control_block if tftp is busy */
        if (tftp.vptr_udp_control_block != NULL && error != TFTP_BUSY)
        {
            delete_udp_control_block( tftp.vptr_udp_control_block );
            tftp.vptr_udp_control_block = NULL;
        }
}

void copy_file_to_tftp(struct cdb* sptr_cdb)
{
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        if (strncmp(sptr_cdb->token,"file",4))
        {
                return;
        }

        if ( sys_tftp_disable_get() ) {
                uprintf("tftp is disabled.\n");
                return;
        }
        if (strlen((char *)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                flash2tftpCopy(TFTP_LONG_FILE_NAME, sptr_cdb->ui_port);
                return;
        }

        if (IS_IPV4_AFI(sptr_cdb->afi))
        {
                uprintf("copy2tftp %s to %I\n", (char *)sptr_cdb->string1, sptr_cdb->ip1);
                if (tftp.current_operation != TFTP_IDLE) {                         /* prevent multiple tftp session */
                        flash2tftpCopy(TFTP_BUSY, sptr_cdb->ui_port);
                        return;
                }

                tftp_perform_upload(flash2tftpCopy,
                                sptr_cdb->ui_port,
                                sptr_cdb->ip1,
                                (char *)sptr_cdb->string1,
                                GENERAL_FLASH_FILE,
                                GENERAL_DATA);
        }
        else
        {
                uprintf("copy2tftp %s to %s\n",  (char *)sptr_cdb->string1, ipv6_address_to_string (&sptr_cdb->ipv6_1, NULL));
                if (tftp.current_operation != TFTP_IDLE)
                {
                        flash2tftpCopy(TFTP_BUSY, sptr_cdb->ui_port);
                        return;
                }

                tftp6_perform_key_file_upload(
                                flash2tftpCopy,
                                sptr_cdb->ui_port,
                                &sptr_cdb->ipv6_1,
                                (char *)&sptr_cdb->string1,
                                GENERAL_FLASH_FILE
                                );
        }
}

void flash2flashCopy(COPY_FILE2FILE_STRUCT *f2f_cdb)
{
        struct cdb *sptr_cdb;
        int save_ui_port;

        sptr_cdb = &cdbs[f2f_cdb->io_session];

        save_ui_port = g_uprintf_dest;
        g_uprintf_dest = f2f_cdb->io_session;

        if (f2f_cdb->f2f_timer_id == NULL)      /* background copy completed */
        {
                uprintf("\nCopy");

                if (f2f_cdb->copy_error == 0)
                {
                        uprintf(" Done.\n");
                }
                else
                {
                        uprintf(" Error - ");
                        if (f2f_cdb->copy_error == 1)
                        {
                                uprintf("length mismatch s =%d d=%d.\n", f2f_cdb->f_s_info.length, f2f_cdb->f_d_info.length);
                        }
                        else if (f2f_cdb->copy_error == 2)
                        {
                                uprintf("checksum mismatch s=%x d=%x.\n", f2f_cdb->f_s_info.checksum, f2f_cdb->f_d_info.checksum);
                        }
                        else
                                uprintf("unknown error %d.\n", f2f_cdb->copy_error);
                }
                f2f_cdb->copy_error = 0;

                print_prompt(sptr_cdb);
        }
        else
                uprintf(".");


        g_uprintf_dest = save_ui_port;
}

void copy_flash_flash_file_callback(COPY_FILE2FILE_STRUCT * f2f_cdb)
{
        int status = 0, i;
        long length = 0;
		if (!f2f_cdb->f_d_handle)
                return;
        // return if the timer has been cancelled
        if ( NULL == f2f_cdb->f2f_timer_id )
                return;

        for (i=0; i<10; i++)
        {
                status = flash_fstat(f2f_cdb->f_d_handle);
                if (status)
                {
                        sys_sleep(2); // 1 tick is 25ms
                }
        }

        if (length = flash_fread(f2f_cdb->f_s_handle,
                                                                f2f_cdb->rw_buffer,
                                                                f2f_cdb->rw_buffer_size))
        {
                status = flash_fwrite(f2f_cdb->f_d_handle, f2f_cdb->rw_buffer, length);
                f2f_cdb->current_byte_count += length;
                flash2flashCopy(f2f_cdb);
        }
        else
        {
                if (f2f_cdb->rw_buffer)
                {
                        dy_free(f2f_cdb->rw_buffer);
                        f2f_cdb->rw_buffer = NULL;
                }
                if (f2f_cdb->f_d_handle)
                {
                        if (!f2f_cdb->fclose_wait) {
                           f2f_cdb->fclose_wait = 1;
                           flash_fclose_no_block(f2f_cdb->f_d_handle);
                           return;
                        } else {
                           status = flash_fstat(f2f_cdb->f_d_handle);
                           if (status > 0)  // fclose in progress
                              return;

                           f2f_cdb->fclose_wait = 0;
                        }
                        f2f_cdb->f_d_handle = flash_fopen(f2f_cdb->f_d_file_name, "r");

                        flash_get_file_info(f2f_cdb->f_d_handle, &(f2f_cdb->f_d_info));
                        // f2f_cdb->f_s_info.length is getting corrupted over recursive function calls . 
                        // Making sure  after calling again for source_file_info.
                        flash_get_file_info(f2f_cdb->f_s_handle, &(f2f_cdb->f_s_info));
                        //uprintf("src_file_info.lengh=%d dest_file_info.length=%d \n",f2f_cdb->f_s_info.length,f2f_cdb->f_d_info.length);
                        if (f2f_cdb->f_d_info.length != f2f_cdb->f_s_info.length)
                        {
                                f2f_cdb->copy_error = 1;
                        }
/*                      else if (f2f_cdb->f_d_info.checksum != f2f_cdb->f_s_info.checksum)
                        {
                                f2f_cdb->copy_error = 2;
                        }
*/
                        flash_fclose(f2f_cdb->f_d_handle);      /* close destination file */
                        f2f_cdb->f_d_handle = NULL;
                }
                if (f2f_cdb->f_s_handle)
                {
                        flash_fclose(f2f_cdb->f_s_handle);      /* close source file */
                        f2f_cdb->f_s_handle = NULL;
                }
                if (f2f_cdb->f2f_timer_id)
                {
                        sv_cancel_timer(f2f_cdb->f2f_timer_id);
                        f2f_cdb->f2f_timer_id = NULL;
                }
                flash2flashCopy(f2f_cdb);
                memset((void *)f2f_cdb, 0, sizeof(COPY_FILE2FILE_STRUCT));
        }
		/* We have done with copy so need to know status , just set status to TRUE */
		copy_flash_flash_file_callback_status = TRUE;
}
void cu_copy_flash_flash_file(char *string1, char* string2, UINT16 ui_port)
{
    int f_s_handle;
    int f_d_handle;
unsigned long flash_space;
pCOPY_FILE2FILE_STRUCT f2f_cdb = &copy_file2file_data;
        FS_STATFS vbuf;

        if (f2f_cdb->rw_buffer)
        {
                uprintf("Copy file to file in progress.\n");
                return;
        }

        if ((f_s_handle = flash_fopen(string1, "r")) == NULL)
        {
                uprintf("Copy failed, cannot find source file %s.\n", string1);
                return;
        }
// If file already exists .we need to overwrite it. so let's remove it first
// No need to check return status TR000537736
        flash_remove(string2) ;
        if (f_d_handle = flash_fopen(string2, "r"))
        {
                flash_fclose(f_s_handle);
                flash_fclose(f_d_handle);
                uprintf("Copy failed, destination file %s exists.\n", string2);
                return;
        }

        f_d_handle = flash_fcreat(string2);
        if (f_d_handle == NULL)
        {
                flash_fclose(f_s_handle); /* close source file */
                uprintf("Copy failed, cannot create desstination file %s.\n", string2);
                return;
        }
        flash_get_file_info(f_s_handle, &(f2f_cdb->f_s_info));

        flash_get_free_block_space(&vbuf);

        flash_space = vbuf.f_bavail * vbuf.f_bsize;
//      uprintf("Available flash space %d source file size=%d.\n", flash_space, f2f_cdb->f_s_info.length);

        f2f_cdb->rw_buffer = dy_malloc_zero(FLASH_RW_BUFFER_SIZE+1);
        if (f2f_cdb->rw_buffer == NULL)
        {
                flash_fclose(f_s_handle);       /* close source file */
                flash_fclose(f_d_handle);       /* close destination file */
                flash_remove(string2); /* delete destination file */
                uprintf("Copy failed, unable to allocate memory.\n");
                return;
        }

        f2f_cdb->rw_buffer_size = FLASH_RW_BUFFER_SIZE;
        strcpy(f2f_cdb->f_s_file_name, string1);
        strcpy(f2f_cdb->f_d_file_name, string2);
        f2f_cdb->io_session = ui_port;
        f2f_cdb->f_s_handle = f_s_handle;
        f2f_cdb->f_d_handle = f_d_handle;
        f2f_cdb->copy_error = 0;
        f2f_cdb->current_byte_count = 0;
        f2f_cdb->fclose_wait = 0;
		/* Before schedule callback, set status to FALSE */
		// uprintf("Copy %s to %s\n", string1, string2);
		copy_flash_flash_file_callback_status = FALSE;
        f2f_cdb->f2f_timer_id =  sv_set_timer_event(10,
                                                                                                REPEAT_TIMER,
                                                                                                copy_flash_flash_file_callback,
                                                                                                (UINT32)f2f_cdb,
                                                                                                "tm-f2f");
}

#ifdef SIDEWINDER_LINUX
HAL_NT_COPY_CMD_INFO _cmd_info;

void exUSB2file(UINT32 error,UINT32 ui_port)
{

int old_ui_port,ret=-1;
char cmds[64];
old_ui_port = g_uprintf_dest;
g_uprintf_dest = ui_port;

#ifdef FI_LINUX
        sil_fl_cleanup();
#endif


if (error == 0)
{
        uprintf("\n  Copy Done .. \n");
}
else
{
        uprintf("\n Copy Error.\n");

}
         print_prompt(&cdbs[ui_port]);
        g_uprintf_dest = old_ui_port;

        nt_code_reset_copy_info();

}
void file2exUSB(UINT32 error,UINT32 ui_port)
{
        int old_ui_port,ret=-1;
        char cmds[64];
        old_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

#ifdef FI_LINUX
        sil_fl_cleanup();
#endif
if (error == 0)
{
        uprintf("\n  Copy Done .. \n");
}
else
{
        uprintf("\n Copy Error.\n");

}

         print_prompt(&cdbs[ui_port]);
        g_uprintf_dest = old_ui_port;

        nt_code_reset_copy_info();

     //   reset_flash_use_in_progress();
}



void cli_copy_flash_disk0_file(struct cdb* sptr_cdb)
{

        char disk0_filename[FILE_NAME_LENGTH + 16];
        char tmp_filename[FILE_NAME_LENGTH + 16];
        void (*callback)(UINT32 error,UINT32 ui_port) ;

                int image_size=0;
            memset(&_cmd_info,0,sizeof(_cmd_info));
                int src_fd=-1;
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

#ifdef SIDEWINDER_LINUX
                if (strstr(sptr_cdb->cli_expanded_cmd, "disk0 flash"))
                {
                        if(check_disk0())
                                return;
	/*Check length of image name, it should be less than 32 char */
		if (strlen((char*)sptr_cdb->string2) > MAXIMUM_SIZE_OF_FILE_NAME)
        	{
                	uprintf("File name %s is longer than allowed %d chars.\n", sptr_cdb->string2, MAXIMUM_SIZE_OF_FILE_NAME);
                	return;
        	}
		if (strlen((char*)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        	{
                	uprintf("File name %s is longer than allowed %d chars.\n", sptr_cdb->string2, MAXIMUM_SIZE_OF_FILE_NAME);
                	return;
        	}

                        snprintf(disk0_filename, FILE_NAME_LENGTH + 16, "disk0_%s", sptr_cdb->string1);
                        //                      strcpy((char*)sptr_cdb->string1, disk0_filename);
                        _cmd_info.is_exusb_involved=1;
                        _cmd_info.dest=GENERIC_FILE;
                        sprintf(_cmd_info.destfile,"%s",sptr_cdb->string2);
                        sprintf(_cmd_info.srcfile,"%s",disk0_filename);
                        _cmd_info.src=EXTERNAL_USB;
                }
                else if (strstr(sptr_cdb->cli_expanded_cmd, "flash disk0"))
                {
                        if(check_disk0())
                                return;

		if (strlen((char*)sptr_cdb->string2) > MAXIMUM_SIZE_OF_FILE_NAME)
        	{
                	uprintf("File name %s is longer than allowed %d chars.\n", sptr_cdb->string2, MAXIMUM_SIZE_OF_FILE_NAME);
                	return;
        	}
		if (strlen((char*)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        	{
                	uprintf("File name %s is longer than allowed %d chars.\n", sptr_cdb->string2, MAXIMUM_SIZE_OF_FILE_NAME);
                	return;
        	}
                        snprintf(disk0_filename, FILE_NAME_LENGTH + 16, "disk0_%s", sptr_cdb->string2);
                        //strcpy((char*)sptr_cdb->string2, disk0_filename);
                        _cmd_info.is_exusb_involved=1;
                        _cmd_info.dest=EXTERNAL_USB;
                        sprintf(_cmd_info.destfile,"%s",disk0_filename);
                        sprintf(_cmd_info.srcfile,"%s",sptr_cdb->string1);
                        _cmd_info.src=GENERIC_FILE;
                }

                snprintf(tmp_filename, FILE_NAME_LENGTH + 16, "%s", _cmd_info.srcfile);
                if (!sil_is_regular_file(tmp_filename))
                {
                    uprintf("Please check source file. It is not present or is not a regular file\n");
                        return;
                }
                
                {
                    unsigned long long src_file_length, dst_filesys_free_space;
                        char srcfile[FILE_NAME_LENGTH + 16], destfile[FILE_NAME_LENGTH + 16];

                        snprintf(srcfile, FILE_NAME_LENGTH + 16, "%s", _cmd_info.srcfile);
                        snprintf(destfile, FILE_NAME_LENGTH + 16, "%s", _cmd_info.destfile);
                        src_file_length = get_file_size(srcfile);
                        dst_filesys_free_space = flash_get_free_block_space_of_filesystem(destfile);
                        
            if (dst_filesys_free_space < src_file_length)
                {
                    uprintf("Not enough space on the filesystem to copy the source file\n");
                                return;                                 
                }
                        
                        
                }
#endif
        
        if (cu_is_illegal_flash_file_name(_cmd_info.srcfile))
        {
                return;
        }

        if (cu_is_illegal_flash_file_name(_cmd_info.destfile))
        {
                return;
        }
                
        nt_code_set_copy_info(&_cmd_info);
// set_flash_use_in_progress();
        if (_cmd_info.src == GENERIC_FILE )
                callback=file2exUSB ;
        else

                callback =  exUSB2file ;
        if (code_flash_copy_new(_cmd_info.src, _cmd_info.dest, image_size, callback, sptr_cdb->ui_port) == -1)
        {
                uprintf("ERROR ....\n");
        }

cleanup:
                
         memset(&_cmd_info,0,sizeof(_cmd_info));
}
#endif
void cli_copy_flash_flash_file(struct cdb* sptr_cdb)
{
                char disk0_filename[MAXIMUM_SIZE_OF_FILE_NAME + 32];
        if (end_of_token(sptr_cdb->token) != '\0')
                return;

#ifdef SIDEWINDER_LINUX
	/*Check length of image name, it should be less than 32 char */
	if (strlen((char*)sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                uprintf("File name is longer than allowed %d chars.\n", MAXIMUM_SIZE_OF_FILE_NAME);
                return;
        }


                if (strstr(sptr_cdb->cli_expanded_cmd, "disk0 flash"))
                {
                        if(check_disk0())
                                return;

                        snprintf(disk0_filename, MAXIMUM_SIZE_OF_FILE_NAME + 32, "disk0_%s", sptr_cdb->string1);
                        strcpy((char*)sptr_cdb->string1, disk0_filename);
                }
                else if (strstr(sptr_cdb->cli_expanded_cmd, "flash disk0"))
                {
                        if(check_disk0())
                                return;

                        snprintf(disk0_filename, MAXIMUM_SIZE_OF_FILE_NAME + 32, "disk0_%s", sptr_cdb->string2);
                        strcpy((char*)sptr_cdb->string2, disk0_filename);
                }
#endif
                
        if (cu_is_illegal_flash_file_name(sptr_cdb->string1))
        {
                return;
        }

        if (cu_is_illegal_flash_file_name(sptr_cdb->string2))
        {
                return;
        }
        cu_copy_flash_flash_file(sptr_cdb->string1, sptr_cdb->string2, sptr_cdb->ui_port);
}
void copy_flash_flash_file_check(struct cdb* sptr_cdb)
{
        if (strncmp(sptr_cdb->token,"file",4))
        {
                sptr_cdb->dont_go_next = 1;
                return;
        }
}
void set_copy_to_cli_flag(struct cdb* sptr_cdb)
{
        if (!sptr_cdb->config_gen)
        {
                sptr_cdb->flag1 = -1;
                sptr_cdb->flag2 = -1;
        }
}

void tftp_2_cli_run(UINT32 error_code, UINT32 ui_port)
{
        struct io_port_cb *sptr_io_cb;
        int save_ui_port, save_skip_mode;
        int length, line_length;
        char *end_of_line;
        pDM_RUN_CLI_FILE_STRUCT run_cdb = &dm_run_cli_file_data;
        
        save_ui_port = g_uprintf_dest;
        g_uprintf_dest = ui_port;

        /* Fixed bug#4204, delete tftp.vptr_udp_control_block */
        /* Fixed defect#378562, do not delete tftp.vptr_udp_control_block if tftp is busy */
        if ((tftp.vptr_udp_control_block != NULL) && (error_code != TFTP_BUSY))
        {
                delete_udp_control_block( tftp.vptr_udp_control_block );
                tftp.vptr_udp_control_block = NULL;
        }
        reset_flash_use_in_progress();

        if(error_code)
        {
                uprintf("copy tftp to cli failed rc = %d\n", error_code);
        }
        else
        {
                debug_uprintf("tftp to cli transfer file %s done\n", g_tftp_run.file_name);
                run_cdb->script_handle = flash_fopen(g_tftp_run.file_name, "r");
                if (run_cdb->script_handle == NULL)
                {
                        uprintf("Cannot find the file %s\n", g_tftp_run.file_name);
                        return;
                }
                run_cdb->total_input_length = 0;
                run_cdb->current_cmd_number = 0;
                run_cdb->io_session = ui_port;
                run_cdb->error = 0;
                run_cdb->original_loop_count = run_cdb->loop_count = 0;
                if ((run_cdb->line_buffer = (unsigned char*)dy_malloc_zero(CMD_LINE_SIZE*2+1)) == NULL)
                {
                        flash_fclose(run_cdb->script_handle);
                        run_cdb->script_handle = NULL;
                        return;
                }
                run_cdb->line_buffer_size = CMD_LINE_SIZE*2;

                flash_get_file_info(run_cdb->script_handle, &run_cdb->f_s_info);
                run_cdb->old_page_mode = g_skip_page_mode;
                g_skip_page_mode = 1;
                dm_run_script_file_callback(run_cdb);

                run_cdb->script_timer_id = sv_set_timer_event(SECOND,
                                                                                                        REPEAT_TIMER,
                                                                                                        dm_run_script_file_callback,
                                                                                                        (UINT32)run_cdb,
                                                                                                        "tm-cli");

        }
        g_uprintf_dest = save_ui_port;
        return;
}

void copy_tftp_to_cli_and_run(struct cdb* sptr_cdb)
{
        UINT8 temp[32];
        pDM_RUN_CLI_FILE_STRUCT run_cdb = &dm_run_cli_file_data;
        
        if (end_of_token(sptr_cdb->token) != '\0')
        {
                return;
        }

        if (sptr_cdb->config_gen)
        {
                return;
        }

        if ((sptr_cdb->flag1 != -1) || (sptr_cdb->flag2 != -1))
        {
                return;
        }
        
        sptr_cdb->dont_go_next = 1;
        if ( sys_tftp_disable_get() )
        {
                uprintf("tftp is disabled\n");
                return;
        }

        if (g_tftp_run.file_handle)
        {
                uprintf("BUSY: file %s processing in progress.\n", g_tftp_run.file_name);
                return;
        }
        
        if (strlen(sptr_cdb->string1) > MAXIMUM_SIZE_OF_FILE_NAME)
        {
                tftp_2_cli_run(TFTP_LONG_FILE_NAME, sptr_cdb->ui_port);
                return;
        }
        
        memset((void *)run_cdb, 0, sizeof(DM_RUN_CLI_FILE_STRUCT));
        memset((void *)&g_tftp_run, 0, sizeof(RUN_CMD_FROM_TFTP));
        if (sptr_cdb->token[0] == 'd')
        {
                run_cdb->delete_file_at_the_end = 1;
        }
        
        strcpy(g_tftp_run.file_name, sptr_cdb->string1);
        strcpy(run_cdb->file_name, sptr_cdb->string1);
    sys_flash_fremove(g_tftp_run.file_name);

        if (IS_IPV4_AFI(sptr_cdb->afi))
        {
                
                debug_uprintf("tftp %s from %I\n", sptr_cdb->string1, sptr_cdb->ip1);
                tftp_perform_download(tftp_2_cli_run,
                                                sptr_cdb->ui_port,
                                                sptr_cdb->ip1,
                                                sptr_cdb->string1,
                                                LOCAL_FLASH_FS,
                                                CLI_FILE);
        }
#ifdef __IPV6__
#ifdef SR_SWITCH_ONLY
        else
        {
                debug_uprintf("tftp %s from %J\n", sptr_cdb->string1, &sptr_cdb->ipv6_1);
                tftp6_perform_download(
                                                tftp_2_cli_run,
                                                sptr_cdb->ui_port,
                                                &sptr_cdb->ipv6_1,
                                                (char*)sptr_cdb->string1,
                                                LOCAL_FLASH_FS,
                                                CLI_FILE,
                                                TFTP_CONFIG_FILE_UPLOAD);
        }
#endif
#endif __IPV6__

        return; 
}

// CHEETAH_STACKING, BUGID:81495
// This function sets the global tag profile
void set_tag_profile(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (g_sw_sys.tag_profile != DMA_VLAN_ETHER_TYPE)
                {
                        ksprintf(cu_line_buf, "tag-profile %4x\n", g_sw_sys.tag_profile);
                        wr_config(sptr_cdb, cu_line_buf);
                }
        }
        else
        {
            // CHEETAH_STACKING, BUG: 82944
            if(g_sw_sys.tag_type != DMA_VLAN_ETHER_TYPE)
            {
                uprintf("un-configure the tag-type to add the tag-profile\n");
                        return;
            }
                if (sptr_cdb->integer1 > 0xFFFF)
                {
                        uprintf("Error - Tag profile must be between 0 and 0xFFFF\n");
                        return;
                }

                if( (sptr_cdb->no) && (sptr_cdb->integer1 != g_sw_sys.tag_profile))
                {
                        uprintf("Error - Tag profile was set to 0x%4x\n", g_sw_sys.tag_profile);
                        return;
                }

                if ((sptr_cdb->no) || ((!sptr_cdb->no) && (sptr_cdb->integer1 == DMA_VLAN_ETHER_TYPE)))
                {
                        set_dma_tag_profile((UINT16) DMA_VLAN_ETHER_TYPE);
                        uprintf("Tag profile set to Default(0x%4x) \n", DMA_VLAN_ETHER_TYPE);
                        return;
                }
                set_dma_tag_profile((UINT16)sptr_cdb->integer1);
        }
        sptr_cdb->dont_go_next = 1;
}

#ifdef __DHCP_CLIENT__

void no_dhcp_client_lease_time(struct cdb* sptr_cdb)
{
        if (sptr_cdb == NULL)
                {
                return;
                }
}
void set_dhcp_client_lease_time(struct cdb* sptr_cdb)
{
    #ifdef SR_SWITCH_ROUTER
        size_t port_number;
        //int vlan_id = 0;
        //int vlan_index  =0;
    #endif

        if (sptr_cdb == NULL)
                {
                return;
                }
    #ifdef SR_SWITCH_ROUTER
    /* 95014: DHCPC doesn't support Virtual Interfaces. */
    port_number = (size_t)INTERFACE_TO_PORT_ID(sptr_cdb->if_num);

#if 0 // DHCP over VE is supported now, this dead code can be removed
    /* 95014: DHCPC doesn't support Virtual Interfaces. */
    if (is_virtual_port (port_number))
    {
         //uprintf ("DHCPC cannot be applied to a VE interface\n");
        return;
    }
#endif 0

    if(is_loopback_port(port_number))
    {
        //uprintf(" LoopBack interface \n");
        return;
    }
#if 0 // DHCP over VE is supported now, this dead code can be removed
        /*99285: DHCPC -- configuration is not allowed on VE*/
        if (is_member(g_vport_member_mask, port_number))
        {
                return;
        }
#endif 0
        if (is_port_stack_enabled (port_number))
        {
                if (!sptr_cdb->config_gen)
                        uprintf("Error - This CLI operation is not allowed on stacking port: %P\n", port_number);
                return;
        }

#if 0
        /* 99283: DHCPC -- disallow configuration if port does not belong to the default VLAN-ID*/
        vlan_index = (SPTR_PORT_DB(port_number))->port_config.port_vlan_idx;

        if (vlan_index == VLAN_INDEX_INVALID)
        {
                return;
        }

        vlan_id = VLAN_ID_FROM_IDX(vlan_index);

        if (vlan_id != SW_DFLT_VLAN_ID)
        {
                return;
        }
#endif
     #endif/*SR_SWITCH_ROUTER*/


        if (sptr_cdb->config_gen)
                {
        #ifdef SR_SWITCH_ROUTER
                if (is_dhcpc_enabled_on_port(port_number) == TRUE)
                        {
                        if (dhcpc_have_port_lease_time (port_number) == TRUE)
        #else
                if (is_dhcpc_enabled() == TRUE)
                        {
                        if (dhcpc_have_lease_time () == TRUE)
                #endif
                                {
                                BYTE cli_command_buffer[DHCP_CLIENT_CONFIG_GEN_BUFFER];

                                size_t lease_time = 0;
                #ifdef SR_SWITCH_ROUTER
                if (dhcpc_get_port_lease_time (port_number, &lease_time) == PASS)
                #else
                                if (dhcpc_get_lease_time (&lease_time) == PASS)
                #endif
                                        {
#if 0// lease time on SX will not be displayed as a part of the running config
                                        #ifdef SR_SWITCH_ROUTER
                                        ksnprintf ((char*)cli_command_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER - 1), " ip dhcp-client lease %d\n", lease_time);
                        #else
                                        ksnprintf ((char*)cli_command_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER - 1), "ip dhcp-client lease %d\n", lease_time);
                        #endif
                                        wr_config(sptr_cdb, (char*)cli_command_buffer);
#endif
                                        }
                                }
                        }
                }
        else
                {

                #ifdef SR_SWITCH_ROUTER
#if 0
                if (vlan_id != SW_DFLT_VLAN_ID)
        {
                        debug_uprintf("Port %p does not belong to default VLAN, unable to configure DHCP client\n", port_number);
                return;
        }
#endif
            #endif/*SR_SWITCH_ROUTER*/

                if (sptr_cdb->no)
                        {
                        /*negate the following statement*/
                        }
                else
				{
					size_t lease_time = 0;

					lease_time = (size_t)sptr_cdb->integer1;

					if (lease_time > 0)
					{
#ifdef SR_SWITCH_ROUTER
						if (dhcpc_set_port_lease_time (port_number, lease_time) == FAIL)
#else
							if (dhcpc_set_lease_time (lease_time) == FAIL)
#endif
							{

							}
					}
				}
				}

				}

		void dhcp_client_disable(struct cdb* sptr_cdb)
		{
			 enum BOOLEAN flag = FALSE;


			if (sptr_cdb == NULL)
			{
				uprintf("Error: Invalid CLI parameter\n");
				return;
			}

			if (end_of_token(sptr_cdb->token) != '\0')
			{
				return;
			}

			sptr_cdb->dont_go_next = 1;
			if (sptr_cdb->config_gen)

			{
				if(dhcpc_get_user_disable_flag())
					wr_config(sptr_cdb, "ip dhcp-client disable\n");
            }
            else
			{
				/* All global level commands are allowed in sub-levels as per design. 
				 * disabling dhcp-client at interface level by mistake would remove all the 
				 * dhcp configuration , hence adding the mode check*/
				if(sptr_cdb->mode != CONFIG)
				{
					uprintf("Error: This CLI operation is applicable only at global configuration level\n");
					return;
				}
				if (sptr_cdb->no)
				{
#ifdef __DHCP_SERVER__
					if (is_dhcps_running () == TRUE)
					{
						uprintf("Error: cannot enable this feature while the DHCP-Server is enabled\n");
						return;
					}
#endif /*__DHCP_SERVER__*/

					/*	The below functions will restart the dhcp client, and updatedhcp client states, */
					/*	Restart the dhcp client process */
					dhcpc_set_user_disable_flag(flag);
					if(dhcpc_check_for_ip_address_configuration_l3() != TRUE)
						restart_dhcpc_for_new_active(TRUE);
				}				  
				else
				{
					flag = TRUE;
					dhcpc_set_user_disable_flag(flag);
					dhcpc_force_shutdown();
				} 
			}
		}

		void set_dhcp_client(struct cdb* sptr_cdb)
{
	PORT_ID port_number;
#ifdef SR_SWITCH_ROUTER
	//int vlan_id = 0;
	//int vlan_index  =0;
#endif
	enum BOOLEAN disable_dhcp_client = FALSE;

	if (sptr_cdb == NULL)
	{
		return;
	}
#if __MPORT_SUPPORT__
	if (is_system_mport_present() == TRUE)
	{
		PORT_ID mport = mport_id_get();

		//if (mport == sptr_cdb->if_num || mport == INTERFACE_TO_PORT_ID(sptr_cdb->if_num))
		if (mport == INTERFACE_TO_PORT_ID(sptr_cdb->if_num))
		{
			port_number = mport;
		}
		else
		{
			port_number = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
		}
		if(!is_mgmt_active() && (port_number == master_mport_id_get()))
		{
			port_number = mport_id_get();
		}
	}
	else
#endif /*__MPORT_SUPPORT__*/
	{
		port_number = INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
	}

	if((!sptr_cdb->config_gen) && (!sptr_cdb->no) )
	{

		if(IS_MAC_BASED_VLAN_ENABLED_ON_PORT(port_number)) {
			uprintf("Error: DHCP Snooping conflicts with Mac Based VLan on this port\n");
			return;
		}

	}
#ifdef SR_SWITCH_ROUTER

	/*Bug 103197 and 102679*/
	if(!IS_IP_PORT_DB_VALID(port_number/*sptr_cdb->if_num*/))
	{
		return;
	}

	/*	DHCP discovery is supported only on the default VE , reason that not supported DHCP discovery on the non default VE is, genarally DHCP client feature  should complement zero touch configuration.
		In case of user defined VEs, it is already needs the admin help to configure them, as well they configure IP address  too if required. */
	if(is_virtual_port(port_number) && ((check_default_router_interface() == PORT_INDEX_INVALID) || (check_default_router_interface() != port_number)))
	{
		if (!sptr_cdb->config_gen)  // Defect 635431.
			uprintf("Error: DHCP Client is not supported on 'non default virtual interfaces'\n");
		return;
	}

	/* 95014: DHCPC doesn't support Virtual Interfaces. */
	if(is_loopback_port(port_number))
	{
		//uprintf(" LoopBack interface \n");
		return;
	}

#if 0 // DHCP over VE is supported now, this dead code can be removed
	if (is_virtual_port (port_number))
	{
		return;
	}


	/*99285: DHCPC -- configuration is not allowed on VE*/
	if (is_member(g_vport_member_mask, port_number))
	{
		return;
	}
#endif 0 

	if (is_port_stack_enabled (port_number))
	{
		if (!sptr_cdb->config_gen)
			uprintf("Error - This CLI operation is not allowed on stacking port: %P\n", port_number);
		return;
	}

#if 0
	/* 99283: DHCPC -- disallow configuration if port does not belong to the default VLAN-ID*/
	vlan_index = (SPTR_PORT_DB(port_number))->port_config.port_vlan_idx;
	if (vlan_index == VLAN_INDEX_INVALID)
	{
		return;
	}

	vlan_id = VLAN_ID_FROM_IDX(vlan_index);

	if (vlan_id != SW_DFLT_VLAN_ID)
	{
		return;
	}
#endif

#endif/*SR_SWITCH_ROUTER*/
	if (sptr_cdb->config_gen)
	{
		/*
		 ** system requesting
		 */
#ifdef SR_SWITCH_ROUTER
		if (is_dhcpc_enabled_on_port((size_t)port_number) == FALSE)
#else
			if (is_dhcpc_enabled() == FALSE)
#endif
			{
				/*
				 ** client was disabled
				 */
#ifdef SR_SWITCH_ROUTER
				if (is_dhcpc_port_disabled_by_user((size_t)port_number) == TRUE)
#else
					if (dhcp_client_disabled_by_user == TRUE)
#endif
					{
#ifdef SR_SWITCH_ROUTER
						wr_config(sptr_cdb, " no ip dhcp-client enable\n");
#else
						wr_config(sptr_cdb, "no ip dhcp-client enable\n");
#endif
					}
			}
	}
	else
	{
#if 0

#ifdef SR_SWITCH_ROUTER
		if (vlan_id != SW_DFLT_VLAN_ID)
		{
			debug_uprintf("Port %p does not belong to default VLAN, unable to configure DHCP client\n", port_number);
			return;
		}
#endif/*SR_SWITCH_ROUTER*/
#endif
		if (sptr_cdb->no)
		{
			/*
			 ** user requested to disable dhcp-client
			 */
			disable_dhcp_client = TRUE;
#ifdef SR_SWITCH_ROUTER
			dhcpc_set_port_protocol_state((size_t)port_number, disable_dhcp_client, TRUE);
#else
			dhcpc_set_protocol_state (disable_dhcp_client);
#endif
			dhcp_client_disabled_by_user = TRUE;
		}
		else
		{
#ifdef __DHCP_SERVER__
			if (is_dhcps_running () == TRUE)
			{
				uprintf("Error: cannot enable this feature while the DHCP-Server is enabled\n");
				return;
			}
#endif /*__DHCP_SERVER__*/
			dhcp_client_disabled_by_user = FALSE;

			/*
			 ** user requested to enabled dhcp-client
			 */
#ifdef SR_SWITCH_ROUTER
            /*  The below functions will restart the dhcp client, and updatedhcp client states, */
			/*	start the DHCP client only when no IP address exists in the system. */
			if(!dhcpc_is_ip_address_exists())
			{
                restart_dhcpc_for_new_active(TRUE);
            }
            
			dhcpc_update_states_for_client_enable(port_number, disable_dhcp_client, FALSE);
#else
			if (is_dhcpc_enabled() == FALSE)
			{
				/*
				 ** client was disabled
				 */
				dhcpc_set_protocol_state (disable_dhcp_client);
			}
			/*
			 ** start the client
			 */
			initialize_dhcpc ();
#endif
		}
	}
}

void cli_ip_mgmt_interface(char* ip_mgmt)
{

	BYTE cli_show_buffer[DHCP_CLIENT_CONFIG_GEN_BUFFER];
	size_t  port_number = 0;

	size_t  addr_index = 0;




	for (port_number = 0; port_number < ip.number_of_ports; port_number++)
	{
#ifdef SR_SWITCH_ROUTER

		if (!IS_IP_PORT_DB_VALID(port_number))
		{
			continue;
		}


		if(IP_ADDR_COUNT(port_number))
		{

			ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%18I",  IP_ADDR_TBL(port_number)[addr_index].ip_address);
			strncpy(ip_mgmt , cli_show_buffer, DHCP_CLIENT_CONFIG_GEN_BUFFER);
			return ;
		}
#endif
	}


	return ;

}


void  cli_ip_address_information(struct cdb* sptr_cdb)
{

	if (sptr_cdb->config_gen == 0)
	{

		BYTE cli_show_buffer[DHCP_CLIENT_CONFIG_GEN_BUFFER];
		size_t  lease_time = 0;
		size_t  port_number = 0;
#ifdef SR_SWITCH_ROUTER
		size_t  addr_index = 0;
		enum BOOLEAN have_address = FALSE;
#endif

#ifdef SR_SWITCH_ROUTER

		for (port_number = 0; port_number < ip.number_of_ports; port_number++)
		{
			if (!IS_IP_PORT_DB_VALID(port_number))
			{
				continue;
			}
#if 0 // compiler warning fix. As 'break;' is unconditional, 'addr_index++' is not needed
			// better way is to use IP_ADDR_COUNT() to set the have_address flag, as shown below
			for (addr_index = 0; addr_index< IP_ADDR_COUNT(port_number); addr_index++)
			{
				have_address = TRUE;
				break;
			}
#endif
			if(IP_ADDR_COUNT(port_number))
			{
				have_address = TRUE;
				break; // break from the outer loop, as no need to scan further
			}
		}

		if (have_address == FALSE)
		{
			ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%s", "no ports configured");
			uprintf("%s\n",cli_show_buffer);
			return ;
		}

		ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%18s %10s %15s %15s", "IP Address","Type","Lease Time","Interface");
		uprintf("%s\n",cli_show_buffer);
#endif

#ifndef SR_SWITCH_ROUTER
		ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%18s %10s %15s ", "IP Address","Type","Lease Time");
		uprintf("%s\n",cli_show_buffer);
		ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%18I", ip.ip_address);
		uprintf("%s", cli_show_buffer);
#endif

#ifdef SR_SWITCH_ROUTER
		for (port_number = 0; port_number < ip.number_of_ports; port_number++)
		{

			if (!IS_IP_PORT_DB_VALID(port_number))
			{
				continue;
			}

			for (addr_index = 0; addr_index< IP_ADDR_COUNT(port_number); addr_index++)
			{

				ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%18I", IP_ADDR_TBL(port_number)[addr_index].ip_address);
				uprintf("%s", cli_show_buffer);


				if (IP_ADDR_TBL(port_number)[addr_index].ip_address_dynamic  == TRUE)
				{
					if (IP_ADDR_TBL(port_number)[addr_index].ip_address == INTERNET_ADDRESS_ANY)
#else
						if (ip.ip_address_dynamic == TRUE)
						{
							if (ip.ip_address == INTERNET_ADDRESS_ANY)
#endif
							{
								ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%13s", "Dynamic");
							}
							else
							{
								ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%14s", "Dynamic");
							}
							uprintf("%s", cli_show_buffer);
						}
						else
						{
#ifdef SR_SWITCH_ROUTER
							if (IP_ADDR_TBL(port_number)[addr_index].ip_address == INTERNET_ADDRESS_ANY)
#else
								if (ip.ip_address == INTERNET_ADDRESS_ANY)
#endif
								{
									ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%13s", "Static");
								}
								else

								{
									ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%13s", "Static");
								}
							uprintf("%s", cli_show_buffer);
						}

					
#ifdef SR_SWITCH_ROUTER
				if(  IP_ADDR_TBL(port_number)[addr_index].ip_address_dynamic == TRUE)
					dhcpc_get_port_lease_time  (port_number, &lease_time);
#else
                   if (ip.ip_address_dynamic == TRUE)
					dhcpc_get_lease_time (&lease_time);
#endif
					

					if (lease_time > 0)
					{
						if (lease_time > 9999 && lease_time < 999999)
						{
							ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%8d", lease_time);
						}
						else if (lease_time > 999999)
						{
							ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%10d", lease_time);
						}
						else
						{
							ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%7d", lease_time);
						}
						uprintf("%s", cli_show_buffer);
					}
					else
					{
						ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%7s", "N/A");
						uprintf("%s", cli_show_buffer);
					}

#ifdef SR_SWITCH_ROUTER
					if (IP_ADDR_TBL(port_number)[addr_index].ip_address == INTERNET_ADDRESS_ANY)
						//#else
						//if (ip.ip_address == INTERNET_ADDRESS_ANY)
						//#endif
					{
						ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%14s%p", "",port_number);
					}
					else
					{
						if (lease_time > 9999 && lease_time < 999999)
						{
							ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%12s%p", "",port_number);
						}
						else if (lease_time > 999999)
						{
							ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%10s%p", "",port_number);
						}
						else
						{
							ksnprintf ((char*)cli_show_buffer, (int)(DHCP_CLIENT_CONFIG_GEN_BUFFER- 1), "%13s%p", "",port_number);
						}
					}
					uprintf("%s", cli_show_buffer);
#endif

					uprintf("\n");
#ifdef SR_SWITCH_ROUTER
					lease_time = 0;
				}
			}
#endif
		}
	}

void set_mif_dhcp_client(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void*)set_dhcp_client);
        return;

}

void set_dhcp_client_auto_update(struct cdb* sptr_cdb)
{

        if (sptr_cdb == NULL)
                {
                uprintf("Error: Invalid CLI parameter\n");
                return;
                }

        if (end_of_token(sptr_cdb->token) != '\0')
                {
                return;
                }

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->config_gen)
                {
                /*
                ** system requesting
                */
#if 0
                if (is_dhcpc_enabled() == TRUE)
#endif
                        {
                        if (dhcpc_get_system_requesting_image_update_state () == TRUE)
                                {
                                /*
                                **No config-gen for default values
                                */
                                }
                        else
                                {
                        #ifdef SR_SWITCH_ROUTER
                                wr_config(sptr_cdb, "no ip dhcp-client auto-update enable\n");
                                #else
                                wr_config(sptr_cdb, "no ip dhcp-client auto-update enable\n");
                                #endif
                                }
                        }

                }
        else
                {
                /*
                ** auto update
                */
                if (dhcpc_is_auto_update_in_progress () == TRUE)
                        {
                        uprintf("Error: Auto update in progress, cannot change DHCP client auto-update\n");
                        return;
                        }

                if (sptr_cdb->no)
                        {
                        dhcpc_set_system_requesting_image_update_state(FALSE);
                        }
                else
                        {
                        dhcpc_set_system_requesting_image_update_state(TRUE);
                        }


                }

}
#endif __DHCP_CLIENT__


void show_mgmt_interface_config(struct cdb* sptr_cdb)
{
        //show_running_config_interface(sptr_cdb);

        sptr_cdb->dont_go_next = 1;

        if(sptr_cdb->integer1 != 1)
        {
                uprintf("Error: Invalid management port.\n");
                return;
        }

        do_write_running_config_to_terminal(
                sptr_cdb,
                retrieve_running_config_interface_management,
                NULL);
}


void show_packet_inerror_detect (struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        sptr_cdb->dont_go_next = 1;

        print_port_type[sptr_cdb->ui_port] = ANY_PORT_TYPE;

        cu_show_packet_inerror_detect (1, ((sptr_cdb->mode==CONFIG_MIF) ? sptr_cdb->mif_port_mask : 0), NEXT_PORT_INDEX_INVALID);
}


void cli_print_cmd_not_implemented_msg(struct cdb *sptr_cdb)
{
        sptr_cdb->dont_go_next = 1;
        if (sptr_cdb->config_gen == 0)
        {
                uprintf("Error: This CLI operation is invalid on this platform.\n");
        }
}

#ifdef SR_SWITCH_ONLY
void set_switch_ip_mtu(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (switch_ip_mtu_is_default())
                        return;
                ksprintf(cu_line_buf, "ip mtu %u\n", switch_ip_mtu_get());
                wr_config(sptr_cdb, cu_line_buf);
        }
        else
        {
              if (sptr_cdb->no)
                                        switch_ip_mtu_set_default();
                          else
                          {
                       if (!valid_integer1_value_range(sptr_cdb, IP_MIN_MTU, switch_ip_mtu_get_max()))
                                return;
                        switch_ip_mtu_set(sptr_cdb->integer1);
                }
        }
}

void check_switch_no_ip_mtu(struct cdb *sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
                
                if (sptr_cdb->help)
                {
                        /* dynamically change the help string to reflect the valid range
                         * for the expected decimal input.
                         */
                        UINT32 max_mtu = g_ip_max_ethernet_mtu;
                        UINT32 def_mtu = g_ip_default_ethernet_mtu;

                        ksnprintf(ip_mtu_help_string,
                                        sizeof(ip_mtu_help_string),
                                        "IP MTU valid range <%d - %d>, default:%d",
                                        IP_MIN_MTU, max_mtu, def_mtu);
                        return;
                }

                if (end_of_token(sptr_cdb->token) != '\0')
                                return;

        if (sptr_cdb->no)
        {
                switch_ip_mtu_set_default();
                sptr_cdb->dont_go_next = 1;
        }
}
#endif /* SR_SWITCH_ONLY */


#ifdef LICENSE_SOFTWARE   // For licensing software nanthu
#ifndef FINI_LINUX
#include <stdlib.h>
#endif
#include <sys/time.h>
#include <sys/times.h>
#include <time.h>
#include "monitor.h"

void dm_syscall_ascii(void)
{
        char str1[] = "123456nanthu";
        char str2[] = "78912345n12n";
        uprintf("\n atoi: %d\n", atoi(str1));
        uprintf("\n atol: %d\n", atol(str2));
        uprintf("\n\n");
}


void dm_syscall_memtest_int(void)
{
        int *p;
        int *c;
        int *r;
        uprintf("\ndm_syscall_memtest_int\n");

        p = (int *)malloc(10);
        uprintf("\np = %x\n", p);
        *p = 100;
        uprintf("\n*p = %d\n", *p);
        c = (int *)calloc(1,1);
        uprintf("\nc = %x\n", c);
        *c = 200;
        uprintf("\n*c = %d\n", *c);
        realloc(c,sizeof(int));
        uprintf("\nc = %x\n", c);
        *c = 300;
        uprintf("\n*c = %d\n", *c);


        uprintf("memcmp: %d",memcmp(p,c,10));
        memcpy(p,c,10);
        uprintf("\n*p = %d\n", *p);
        uprintf("\n*c = %d\n", *c);

        free(c);
        uprintf("\nc after free = %x\n", c);



}
void dm_syscall_memtest_char(void)
{
        char *p;
        char *c;
        uprintf("\ndm_syscall_memtest_char\n");

        p = malloc(10);
        uprintf("\np = %x\n", p);
        *p = 'c';
        uprintf("\np = %c\n", *p);

        c = calloc(1,sizeof(char));
        uprintf("\nc = %x\n", c);
        *c = 'd';
        uprintf("\n*c = %c\n", *c);

}
void dm_syscall_memtest_long(void)
{
        long *p;
        long *c;
        uprintf("\ndm_syscall_memtest_long\n");

        p = malloc(sizeof(long));
        uprintf("\np = %x\n", p);
        *p = 500;
        uprintf("\n*p = %d\n", *p);

        c = calloc(1,sizeof(long));
        uprintf("\nc = %x\n", c);
        *c = 600;
        uprintf("\n*c = %d\n", *c);
}

void dm_syscall_memtest_short(void)
{
        short *p;
        short *c;
        uprintf("\ndm_syscall_memtest_short\n");

        p = malloc(sizeof(short));
        uprintf("\np = %x\n", p);
        *p = 5000;
        uprintf("\n*p = %d\n", *p);

        c = calloc(1,sizeof(short));
        uprintf("\nc = %x\n", c);
        *c = 600;
        uprintf("\n*c = %d\n", *c);

}
void dm_syscall_memtest_memcmp(void)
{
        char *p = "Nanthakumar";
        char *c = "Nanthakumar";
        //uprintf("\n%d\n", memcmp(p,c,12));
}

void dm_syscall_memtest_memcpy(void)
{
        char  *p = "Nanthakumar";
        void *c = "Iyer Nanthakumar";
        //uprintf("\n%d\n", memcpy(p,c,12));
}

void dm_syscall_memtest_memmove(void)
{
        char  *p = "Nanthakumar";
        void *c = "Iyer Nanthakumar";
        //uprintf("\n%d\n", memcpy(p,c,12));
}

void dm_syscall_filetest(void)
{

        FILE *test_file;
        int c;
        char *s;
        void *buffer;

        uprintf("\ndm_syscall_filetest.... \n");

        sys_fcreat("test.txt");
        /*fopen */
        test_file = fopen("test.txt", "rw");
        /*fgetc */
        uprintf("\nfgetc =%d\n",fgetc(test_file));
        /*fgets*/
        uprintf("\nfgets =%s\n",fgets(s,10,test_file));
        /*fputc*/
        uprintf("\nfputc =%d\n", fputc(10,test_file));
        /*fprintf*/
        uprintf("\nfprintf =%d\n", fprintf(test_file,"Hi, this is nanthu"));
        /*fread*/
        uprintf("\nfread = %d\n",fread(buffer,100,100,test_file));
        /*fseek*/
        uprintf("\nfseek = %d\n",fseek(test_file,200,0));
        /*ftell*/
        uprintf("\nftell = %d\n",ftell(test_file));
        /*fwrite*/
        uprintf("\nfwrite = %d\n",fwrite(buffer,100,100,test_file));
        /*fflush*/
        uprintf("\nfflush = %d\n",fflush(test_file));

}


void dm_syscall_strtest(void)
{

        char f_name[] = "Nanthakumar";
        char l_name[] = "Iyer";
        char m_name[] = "";
        char c_name[] = "";


        const struct timespec t_req, t_rem;
        /*strlen */
        uprintf("\nf_name len: %d\n",strlen(f_name));
        uprintf("\nl_name len: %d\n",strlen(l_name));
        uprintf("\nm_name len: %d\n",strlen(m_name));
        /*strcpy*/
        uprintf("\nm_name :%s\n", strcpy(m_name, "Hello!"));
        /*strncpy*/
        uprintf("\nm_name :%s\n", strncpy(m_name, "Hello!",20));


        uprintf("\nf_name :%s\n", strcpy(f_name, "World!"));
        /*strcat*/
        strcat(c_name, f_name);
        uprintf("\nc_name :%s f_name :%s\n",c_name,f_name);
        /*strncat*/
        strncat(c_name, f_name, 12);
        uprintf("\nc_name :%s\n",c_name );
        /*strchr*/
        strchr(c_name, 10);
        uprintf("\nc_name :%s\n",c_name );

        sleep(1);;


}

void dm_syscall_timetest(void)
{

        struct timeval *tv;
        struct timezone *tz;

        struct tm *gm, *lt, *ltr, *ltr_result, *mkt;
        const unsigned int gm_timer, *lt_timer, *ltr_timer;
        unsigned int mk_timer;
        unsigned long n_time, r_time;

        clock_t clk; struct tms t_tms;
        /*gettimeofday */
        uprintf("gettimeofday :%x\n",gettimeofday(tv,tz));

        /*gmtime*/
        gm = gmtime(&gm_timer);
        uprintf("\ngmtime: Complete\n");
        /*localtime*/
        lt = localtime(lt_timer);
        uprintf("\nlocaltime: Complete\n");
        /*localtime_r*/
        //ltr = localtime_r(ltr_timer, ltr_result);
        //uprintf("\nlocaltime_r: Complete\n");
        /*mktime*/
        //mk_timer = mktime(mkt);
        uprintf("\nmktime: Complete\n");

        //n_time = time(&r_time);
        uprintf("\ntime: Complete\n");

//      clk = times(&t_tms);
        uprintf("\ntime: Complete\n");

        //sleep(1);
        //exit(1);

}

void dm_syscall_system(void)
{

        uprintf("\n%d\n",system("Nanthakumar"));
        return;

}
char h_name[100];
void dm_syscall_gethost(void)
{
        //uprintf("\ndm_syscall_gethost: %u\n", h_name);
        gethostname(h_name,100);
        uprintf("\nhost name :%s\n\n",h_name);
        return;

}

void dm_syscall_randtest(void)
{
        uprintf("\nrandon no: %d\n",rand());
        srand(100);
        return;

}

#endif

#ifdef SR_SWITCH_ROUTER
void
set_ip_subnet_broadcast_response(struct cdb *sptr_cdb)
{
        extern enum BOOLEAN allow_ip_subnet_broadcast_response;
        extern ip_subnet_broadcast_resonse(enum BOOLEAN enable);

        if (sptr_cdb->config_gen)
        {
                if (allow_ip_subnet_broadcast_response == FALSE)
                        wr_config(sptr_cdb, "no ipv4-subnet-response\n");
                return;
        }

        ip_subnet_broadcast_response(sptr_cdb->no ? FALSE : TRUE);
}
#endif /* SR_SWITCH_ROUTER */


#ifdef HITLESS_USR_ENABLE

UINT8 g_hitless_failover_enable = 0;

enum BOOLEAN
is_hitless_failover_enable(void)
{
        return g_hitless_failover_enable ? TRUE : FALSE ;
}

void cu_set_hitless_failover_enable(UINT8 en)
{
        if(g_hitless_failover_enable == en)
                return;
        g_hitless_failover_enable = en;
        enable_disable_hitless_failover();
}

#ifndef NO_HITLESS_FAILOVER_DEFAULT
void cu_do_enable_hitless_failover(BOOL en)
{
        /* TR491696 */
        if ((g_stacking.mailbox_me.bootup_role == STACK_ROLE_MASTER) ||
                (g_stacking.mailbox_me.bootup_role == STACK_ROLE_NONE) ||
                (!g_sw_sys.init_in_progress && (STACK_AM_I_MASTER || STACK_AM_I_STANDBY)))
        {
                if (!g_stacking.stack_management_mac)
                {
                        MAC_ADDRESS stack_mac;
                        
                        if (!g_stacking.master)
                        {
                                stack_mac._ulong = g_hw_info.base_port_mac_addr._ulong;
                                stack_mac._ushort = g_hw_info.base_port_mac_addr._ushort;
                                cu_set_stack_mac_address(&stack_mac, TRUE);
                        }
                        else
                        {
                                cu_set_stack_mac_address(&g_stacking.master_mac_address, TRUE);
                        }
#if 0
                        uprintf("Default stack MAC address mgmt_mac_addr %m assigned\n", &g_hw_info.mgmt_mac_addr);
                        uprintf("Default stack MAC address base_port_mac_addr %m assigned\n", &g_hw_info.base_port_mac_addr);
                        uprintf("Default stack MAC address stack_management_mac %s \n", g_stacking.stack_management_mac ? "True":"False");
                        uprintf("Default stack MAC address master_mac_address %m assigned\n", &g_stacking.master_mac_address);
#endif
                }
        }
        else
        {
                if  (!g_stacking.stack_management_mac)
                {
                        uprintf("Assign a stack MAC before enabling the hitless failover command\n");
                }
        }
        cu_set_hitless_failover_enable(en);
}

void
cli_enable_hitless_failover(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (STACK_AM_I_MEMBER)
                {
                        return;
                }
                if (is_hitless_failover_enable())
                {
                        wr_config(sptr_cdb, "hitless-failover enable\n");
                }
                else
                {
                        if (!is_hitless_failover_enable())
                        {
                                if (g_stacking.stacking_enable == STACKING_STATE_ENABLED)
                                {
                                        wr_config(sptr_cdb, "no hitless-failover enable\n");
//                                      wr_config(sptr_cdb, "hitless-failover disable\n");
                                }
                        }
                        else
                        {
                                if (g_major_version >= 8)
                                {
                                        wr_config(sptr_cdb, "no hitless-failover enable\n");
                                }
                                
                        }
                }
                return;
        }
//      uprintf("DEBUG: SW Major = %u, Minor = %u Maint = %u\n", g_major_version, g_minor_version, g_maintenance_version);

        if (sptr_cdb->no)
        {
                cu_set_hitless_failover_enable(FALSE);
        }
        else
        {
                cu_do_enable_hitless_failover(TRUE);
        }

}
#else
void
cli_enable_hitless_failover(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        {
                if (is_hitless_failover_enable())
                {
                        wr_config(sptr_cdb, "hitless-failover enable\n");
                }
                return;
        }

        if (sptr_cdb->no)
        {
                cu_set_hitless_failover_enable(0);
        }
        else
        {
#if 0 // persistent_mac_timer
                if (g_stacking_debug_flags & DEBUG_PERSISTENT_MAC)
                {
                        debug_uprintf("cli_enable_hitless_failover %s master %u role %s\n", (g_hitless_failover_enable)? "EN":"DI", g_stacking.master, stacking_elected_type[g_stacking.mailbox_me.bootup_role]);
                        debug_uprintf("g_sw_sys.init_in_progress = %s, master = %s\n", g_sw_sys.init_in_progress ? "Yes":"No", STACK_AM_I_MASTER ? "Yes":"No");
                }
#endif
                /* TR491696 */
                if ((g_stacking.mailbox_me.bootup_role == STACK_ROLE_MASTER) || (!g_sw_sys.init_in_progress && (STACK_AM_I_MASTER || STACK_AM_I_STANDBY)))
                {
                        if (!g_stacking.stack_persistent_mac_enable && !g_stacking.stack_management_mac)
                        {
                                MAC_ADDRESS stack_mac;
                                
                                if (g_stacking_debug_flags & DEBUG_PERSISTENT_MAC)
                                {
                                        debug_uprintf("cli_enable_hitless_failover calling cu_set_stack_mac_address %m\n", &g_hw_info.mgmt_mac_addr);
                                }
//                              if (!IS_ZERO_MAC(&g_stacking.master_mac_address)) /* if stacking MAC is not set, use base MAC address with local bit set */
                                if (!g_stacking.stack_management_mac)
                                {
                                        stack_mac._ulong = g_hw_info.base_port_mac_addr._ulong;
                                        stack_mac._ushort = g_hw_info.base_port_mac_addr._ushort;
                                        cu_set_stack_mac_address(&stack_mac, TRUE);
                                }
                                else
                                {
                                        cu_set_stack_mac_address(&g_stacking.master_mac_address, TRUE);
                                }
                                uprintf("Default stack MAC address %m assigned\n", &g_hw_info.mgmt_mac_addr);
                        }
                }
                else
                {
                        if (!g_stacking.stack_persistent_mac_enable && !g_stacking.stack_management_mac)
                        {
                                uprintf("Assign a stack MAC before enabling the hitless failover command\n");
                        }
                }
                cu_set_hitless_failover_enable(1);
        }

}
#endif NO_HITLESS_FAILOVER_DEFAULT

#endif HITLESS_USR_ENABLE

/**************** RAS ENHANCEMENT **************************/
void cli_show_tech_memory(struct cdb* sptr_cdb)
{
    struct cdb* show_tech = sptr_cdb;
    int skip_page_enable = 0;

    if (sptr_cdb->config_gen)
                return;
    if (end_of_token(sptr_cdb->token) == '\0')//Coverity defect 21793
    {
            sptr_cdb->dont_go_next = 1;
    }

    if(!g_skip_page_mode) /* if skip page is disabled, enable it */
    {
        g_skip_page_mode = 1;
        skip_page_enable = 1;
    }
        show_tech_in_progress = GT_TRUE;        
        show_tech_time_stamp_header(GT_TRUE, "show memory", "DRAM", sptr_cdb->ui_port);
        
    uprintf("\nMEMORY Related Information :\n");

    show_system_stacking_memory_info(FALSE);

    uprintf("\nFLASH Related Information :\n");
    show_tech_flash(show_tech);

    if (mem_leak_debug)
    {
        uprintf("\n DM-Memory Related Information  :\n");
        mem_leak_show_resource();
    }
        show_tech_time_stamp_header(GT_FALSE, "show memory", NULL, GT_ERROR);   
        show_tech_in_progress = GT_FALSE;

        if(skip_page_enable)
        g_skip_page_mode = 0;

}

void cli_show_tech_license(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;

        if ( sptr_cdb->mode == USER_EXEC )
        {
                uprintf("User is not in the privileged mode.\n");
                return;
        }
        if (g_uprintf_dest != 0)
        {
                //g_saved_show_tech_dest = g_uprintf_dest;
                io_cb[g_uprintf_dest].application_in_use = 1;
                //debug_uprintf("saved show tech dest %d", g_saved_show_tech_dest);
        }
        show_tech_in_progress = GT_TRUE;        
        show_tech_time_stamp_header(GT_TRUE, "show license", "LICENSE", sptr_cdb->ui_port);
        uprintf("\nLicense Information\n");
        uprintf("===================\n");
        cu_show_license(0);             
        show_tech_time_stamp_header(GT_FALSE, "show license", NULL, GT_ERROR);  
        show_tech_in_progress = GT_FALSE;

}
void cli_show_tech_stack(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
        return;

        if ( sptr_cdb->mode == USER_EXEC )
                {
                        uprintf("User is not in the privileged mode.\n");
                        return;
                }
        if (g_uprintf_dest != 0)
        {
                //g_saved_show_tech_dest = g_uprintf_dest;
                io_cb[g_uprintf_dest].application_in_use = 1;
                //debug_uprintf("saved show tech dest %d", g_saved_show_tech_dest);
        }

        cu_show_tech_stk(sptr_cdb);


}

void cli_show_tech_l2(struct cdb* sptr_cdb)
{
        struct cdb* show_tech = sptr_cdb;

        if (sptr_cdb->config_gen)
                return;

        if ( sptr_cdb->mode == USER_EXEC )
                {
                        uprintf("User is not in the privileged mode.\n");
                        return;
                }
        if (g_uprintf_dest != 0)
        {
                //g_saved_show_tech_dest = g_uprintf_dest;
                io_cb[g_uprintf_dest].application_in_use = 1;
                //debug_uprintf("saved show tech dest %d", g_saved_show_tech_dest);
        }
        cu_show_tech_l2(show_tech);

}

#ifdef INCLUDE_MCT
void cli_show_tech_cluster(struct cdb* sptr_cdb)
{
        struct cdb* show_tech = sptr_cdb;

        if (sptr_cdb->config_gen)
                return;

        if ( sptr_cdb->mode == USER_EXEC )
                {
                        uprintf("User is not in the privileged mode.\n");
                        return;
                }
        if (g_uprintf_dest != 0)
        {
                //g_saved_show_tech_dest = g_uprintf_dest;
                io_cb[g_uprintf_dest].application_in_use = 1;
                //debug_uprintf("saved show tech dest %d", g_saved_show_tech_dest);
        }
        cu_show_tech_cluster(show_tech);

}
#endif //INCLUDE_MCT

void show_tech_flash(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
          return;

        if (end_of_token(sptr_cdb->token) != '\0')
                return; /* cmd not for me */

        /* Don't process the next token. */
        sptr_cdb->dont_go_next = 1;

        if ((SHOW_BUF = sv_buf_alloc()) != NULL)
                redirect_output_to_display_buf();

        cli_show_stacking_flash();

        if (SHOW_BUF != NULL)
                sv_buf_display();
}

void cli_show_tech_multicast(struct cdb* sptr_cdb)
{
    struct cdb* show_tech = sptr_cdb;

    if (sptr_cdb->config_gen)
                return;
    if (end_of_token(sptr_cdb->token) == '\0')//Coverity defect 21794
    {
            sptr_cdb->dont_go_next = 1;
    }

    g_skip_page_mode = 1;
    uprintf("\nMulticast VLAN information  \n");
    show_ip_igmp_snoop_all_vlan_summary_page_mode(1, 0, 0x8000);

    uprintf("\nMulticast Group Table information  \n");
        if(sptr_cdb->integer8)
                igmp_snoop_cu_show_group(1, 0, 0x8000);
        else
                igmp_snoop_cu_show_group(1, 0, 0);

    uprintf("\nMulticast Cache information  \n");
    igmp_snoop_cu_show_ip_multicast_igmp_snoop_cache(1, NULL, 0);

    g_skip_page_mode = 0;

}
void cli_show_tech_vlan( void )
{

        VLAN_MASK vlanmask;
        UINT16 vlan_id;
        PORT_ID port_number;
        UINT32  vlan_index, count, index;

        vlanmask_clear_all(&vlanmask);
        count = 0;

        for (vlan_id = MIN_VLAN_ID; vlan_id <= MAX_VLAN_ID; vlan_id++)
        {
                if(vlan_id==g_cpu_vlan_id) // 78838
                        continue;

                vlan_index = VLAN_IDX_FROM_VLAN_ID(vlan_id);

                if ( (vlan_index!= VLAN_INDEX_INVALID) && (g_sptr_vlan_db+vlan_index)->vlan_inuse )
                {
                        VLAN_MASK_SET(vlanmask, vlan_id);
                        count++;
                }
        }
        vlanmask_to_string(&vlanmask, cu_line_buf, CU_LINE_BUF_SIZE);

        index = cu_get_sys_param_index("vlan");
        if ((index != 0) && (index < cu_get_sys_param_table_size()))
        {
                uprintf("\nSystem-max vlan Params: Max(%d) Default(%d) Current(%d)\n",
                                fndry_system_parameters[index].max, fndry_system_parameters[index].def,
                                fndry_system_parameters[index].current);
        }
        uprintf("Default vlan Id :%d\n", SW_DFLT_VLAN_ID);
        uprintf("Total Number of Vlan Configured :%d\n", count);
        uprintf("VLANs Configured :%s\n\n", cu_line_buf);


}
void cli_show_tech_pvlan(void )
{
        VLAN_ENTRY *primary_vlan_ptr;
        VLAN_INDEX primary_vlan_id;
        VLAN_INDEX vlan_id, vlan_index;

        for (vlan_id = 1; vlan_id <= MAX_VLAN_ID; vlan_id++)
        {
                vlan_index = VLAN_IDX_FROM_VLAN_ID(vlan_id);
                if (vlan_index != VLAN_INDEX_INVALID)
                {
                        primary_vlan_ptr = g_sptr_vlan_db+vlan_index;
                        primary_vlan_id = primary_vlan_ptr->vlan_config.vlan_id;
                        if (primary_vlan_ptr->pvlan_type == PVLAN_TYPE_NONE)
                                continue;
                        cu_show_pvlan(vlan_id, FALSE);
                }

        }


}

void cli_show_tech_la(struct cdb* sptr_cdb)
{
        UINT8 token;
        UINT32 count =0;  //BUG:88476

        LACP_ENABLED_PORT_LIST *tmp_ptr;

  if (!g_lacp_ports) {
    uprintf("No LACP enabled port exists.\n");
	if(show_tech_in_progress)
	{
		show_tech_time_stamp_header(GT_FALSE, "show lag", NULL, GT_ERROR);
    	release_page_mode();
	}
    return;
  }
  else {
    count = 0;
    tmp_ptr = g_lacp_ports;
    while (tmp_ptr != NULL) {
      count++;
      tmp_ptr = tmp_ptr->next;
    }
    show_link_aggregate_page(TRUE, 0, count);

        }
}

void cli_show_tech_cpu(struct cdb* sptr_cdb)
{
    struct cdb* show_tech = sptr_cdb;
    UINT32 saved_count,i;

    if (sptr_cdb->config_gen)
                return;
    if (end_of_token(sptr_cdb->token) == '\0')//Coverity defect 21792
    {
            sptr_cdb->dont_go_next = 1;
    }

    g_skip_page_mode = 1;
        show_tech_in_progress = GT_TRUE;
        
        show_tech_time_stamp_header(GT_TRUE, "show cpu tasks", "CPU/TASK", sptr_cdb->ui_port);
        
    uprintf("\nCPU Usage Information\n");
    show_cpu_info_new(FALSE);

    uprintf("\nCPU Utilization information.\n");
    for (i=1 ;  i <= 5 ; i++)
    {
                saved_count = (g_time_counter - cpu_cnt[sptr_cdb->ui_port].cpuu_start_time)/10;

                //uprintf("%d/100 busy, from %d sec ago\n", get_cpu_utilization(1), saved_count);

        if (1)
        {
                SYS_TASK_INFO tinfo;
                UINT8 counter_string[32];

                if (is_linux_based_system()) {
                      sys_get_task_info(sys_get_task_handle("appl"), &tinfo, 0);                                                                                                                                        uprintf("appl-task pid %u tid 0x%x cpu usage %u%s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization, "%");                                                                                           sys_get_task_info(sys_get_task_handle("console"), &tinfo, 0);
                      uprintf("console-task pid %u tid 0x%x cpu usage %u%s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization, "%");
                      sys_get_task_info(sys_get_task_handle("FlashTsk"), &tinfo, 0);                                                                                                                                    uprintf("flash-task pid %u tid 0x%x cpu usage %u%s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization, "%");                                                                                          sys_get_task_info(sys_get_task_handle("TimerTsk"), &tinfo, 0);
                      uprintf("sys-tmr-task pid %u tid 0x%x cpu usage %u%s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization, "%");
#ifndef FI_TIMER_LIB_IMPL
                      sys_get_task_info(sys_get_task_handle("tmr"), &tinfo, 0);
                      uprintf("tmr-task pid %u tid 0x%x cpu usage %u%s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization, "%");
#endif
                      sys_get_task_info(sys_get_task_handle("itc"), &tinfo, 0);
                      uprintf("itc-task pid %u tid 0x%x cpu usage %u%s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization, "%");
                } else {
                sys_get_task_info(sys_get_task_handle("$(idle)"), &tinfo, 9);//use 9 so app won't interfere with OS' "sh task" command
                cu_print_counter64(counter_string, tinfo.cpu_usage_count);
                uprintf("idle pid %u id %u cpu %u usage %20s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization/10000, counter_string);
                sys_get_task_info(sys_get_task_handle("main"), &tinfo, 9);//use 9 so app won't interfere with OS' "sh task" command
                cu_print_counter64(counter_string, tinfo.cpu_usage_count);
                uprintf("main pid %u id %u cpu %u usage %20s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization/10000, counter_string);
                sys_get_task_info(sys_get_task_handle("$flash"), &tinfo, 9);//use 9 so app won't interfere with OS' "sh task" command
                cu_print_counter64(counter_string, tinfo.cpu_usage_count);
                uprintf("flash pid %u id %u cpu %u usage %20s\n", tinfo.pid, tinfo.id, tinfo.cpu_utilization/10000, counter_string);
                }
        }

                uprintf("%d/100 busy, from %d sec ago\n", get_cpu_hist(1,1), saved_count);
#ifdef KATARA_PROFILE_ENABLE
                show_main_loop_prof_data();
#endif /* KATARA_PROFILE_ENABLE */
                start_cpu_utilization();


        uprintf("\n");
        uprintf("\n");
    }

#ifdef __PROC_CPU_UTIL__
    uprintf("\nCPU(per process) usage  Information.\n");
    show_proc_cpu_util();
#endif
        
        show_tech_time_stamp_header(GT_FALSE, "show cpu tasks", NULL, GT_ERROR);
        show_tech_in_progress = GT_FALSE;
    g_skip_page_mode = 0;

}
void cli_show_tech_packet_loss(struct cdb* sptr_cdb)
{
    struct cdb* show_tech = sptr_cdb;
    UINT32 device;

    if (sptr_cdb->config_gen)
                return;
    if (end_of_token(sptr_cdb->token) == '\0')//Coverity defect 21795
    {
            sptr_cdb->dont_go_next = 1;
    }
    g_skip_page_mode = 1;

    uprintf("\nTotal Tx statistics :\n");
    pp_show_tx_total_counters (1);

    uprintf("\n Port Statistics.\n");
    if (sptr_cdb->mode == CONFIG_MIF)
                cu_show_statistics_page(1, sptr_cdb->mif_port_mask, NEXT_PORT_INDEX_INVALID);
    else
                cu_show_statistics_brief(NULL);


    g_skip_page_mode = 0;

}
void show_tech_l3_v4_uc(struct cdb* sptr_cdb)
{
    if (sptr_cdb->config_gen)
                return;
if (!(end_of_token(sptr_cdb->token)) == '\0')
        return;
else
    sptr_cdb->dont_go_next = 1;
if ( sptr_cdb->mode == USER_EXEC )
        {
        uprintf("User is not in the privileged mode.\n");
        return;

        }

   cu_set_tech_cb_state (sptr_cdb->ui_port, 0);
#ifdef SR_SWITCH_ROUTER
    cu_show_tech_l3_support(sptr_cdb);
#endif

}
void show_tech_l3_v6_uc(struct cdb* sptr_cdb)
{

    if (sptr_cdb->config_gen)
                return;
if (!(end_of_token(sptr_cdb->token)) == '\0')
        return;
else
    sptr_cdb->dont_go_next = 1;

    if ( sptr_cdb->mode == USER_EXEC )
        {
        uprintf("User is not in the privileged mode.\n");
        return;

        }


    cu_set_tech_cb_state (sptr_cdb->ui_port,CB_STATE);
#ifdef SR_SWITCH_ROUTER
    cu_show_tech_l3_support(sptr_cdb);
#endif

}
void show_tech_l3_mc(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (!(end_of_token(sptr_cdb->token)) == '\0')
                return;
        else
                sptr_cdb->dont_go_next = 1;

        if ( sptr_cdb->mode == USER_EXEC )
        {
                uprintf("User is not in the privileged mode.\n");
                return;
        }
        cu_set_tech_cb_state (sptr_cdb->ui_port, 0);

        cu_show_tech_l3_mc_support(sptr_cdb);
}

void show_tech_l3_v6_mc(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (!(end_of_token(sptr_cdb->token)) == '\0')
                return;
        else
                sptr_cdb->dont_go_next = 1;

        if ( sptr_cdb->mode == USER_EXEC )
        {
                uprintf("User is not in the privileged mode.\n");
                return;
        }
        cu_set_tech_cb_state (sptr_cdb->ui_port, 16);

        cu_show_tech_l3_mc_support(sptr_cdb);
}

void show_ip_traffic(struct cdb*);

#ifdef FIOFL_INCLUDE

void show_tech_of(struct cdb* sptr_cdb)
{
        if (sptr_cdb->config_gen)
                return;
        if (!(end_of_token(sptr_cdb->token)) == '\0')
                return;
        else
                sptr_cdb->dont_go_next = 1;

        if ( sptr_cdb->mode == USER_EXEC )
        {
                uprintf("User is not in the privileged mode.\n");
                return;
        }
        cu_set_tech_cb_state (sptr_cdb->ui_port, 0);

        cu_show_tech_openflow_support(sptr_cdb);
}

#endif 

#ifdef SR_SWITCH_ROUTER
void show_tech_l3_uc_ip(struct cdb* sptr_cdb)
{
                VRF_INDEX vrf_index;
                IPVRF_CB *vrf_cb;

        if(STACK_AM_I_SLAVE)
                return;

                uprintf("\n\nIP Interfaces:\n--------------\n");
        ip_show_all_interfaces();  //interfaces

                if (is_vrf_support_enabled())
                        uprintf ("\nIPv4 Unicast Tables for Default VRF\n-----------------------------------\n");
                
        uprintf("\nARP Information:\n----------------\n");
                cu_show_arp_resource(); // arp resource print

                uprintf ("\nARP Table Entries\n-----------------\n");
                ip.arp.arp_cu_vrf_index[g_uprintf_dest] = IPVRF_DEFAULT_VRF_IDX;
                arp_print_table_page(1, TRUE, 0); // print arp for default VRF

                uprintf("\nIP Cache:\n--------\n");
                DISPLAY_SET_SAFI(IP_UNICAST_SAFI);
                DISPLAY_SET_VRF_INDEX(IPVRF_DEFAULT_VRF_IDX);
                fpip_show_route_cache(0xFFFFFFFF);   //cache for default VRF

                
                uprintf("\nIP Routing Summary:\n-----------------\n");
                rtmvrf_ipv4_show_routing_table_summary(IP_UNICAST_SAFI, IPVRF_DEFAULT_VRF_IDX);  //routing summary fpor default VRF
                uprintf ("\nIP Routing Table:\n-----------------\n");
                rtmvrf_ipv4_show_routing_table(IP_UNICAST_SAFI, IPVRF_DEFAULT_VRF_IDX); // routing table for default VRF
        
                
                if (is_vrf_support_enabled())
                {
                        for (vrf_index = IPVRF_MIN_VRF_IDX; vrf_index <= IPVRF_MAX_VRF_IDX; vrf_index++)
                        {
                                vrf_cb = IPVRF_GET_CB(vrf_index);
                                if (!vrf_cb || !vrf_cb->ipv4.init)
                                        continue;

                                uprintf ("\n\nIPv4 Unicast Table for VRF %s\n---------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                uprintf ("\nARP Table Entries: VRF %s:\n------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                ip.arp.arp_cu_vrf_index[g_uprintf_dest] = vrf_index;
                                arp_print_table_page(1, TRUE, 0); // print arp for non default VRF

                                uprintf ("\nCache Table Entries: VRF %s:\n-----------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                DISPLAY_SET_VRF_INDEX(vrf_index);
                                fpip_show_route_cache(0xFFFFFFFF);   //cache for non default VRF

                                uprintf ("\nIP Routing Summary: VRF %s:\n---------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                DISPLAY_SET_VRF_INDEX(vrf_index);
                                rtmvrf_ipv4_show_routing_table_summary(IP_UNICAST_SAFI, vrf_index);   //routing summary for non default VRF
                                uprintf ("\nIP Routing Table: VRF %s:\n--------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                rtmvrf_ipv4_show_routing_table(IP_UNICAST_SAFI, vrf_index);  //routing table for non default VRF
                        }
                }
                DISPLAY_SET_VRF_INDEX(IPVRF_DEFAULT_VRF_IDX);

        uprintf("\nIP Traffic :\n----------\n");
        cu_show_tech_ip_traffic();

        uprintf("\n");
}

#ifdef __OSPF__
void show_tech_l3_uc_ospf(struct cdb* sptr_cdb)
{
        OSPF_CLASS *ospf;

        uprintf ("\nOSPF summary\n------------\n");
        
        show_ip_ospf_summary_page(1, TRUE, 0); // summary of all ospf instances

        OSPF_INSTANCES_LIST(ospf)
        {
                if (ospf->protocol_enabled)
                {
                        uprintf ("\nOSPF Information for VRF %s\n---------------------------------\n", ipvrf_api_get_vrf_name(ospf->of_vrf_index));
                        sptr_cdb->vrf_idx = ospf->of_vrf_index;

                        pre_show_ip_ospf_area(sptr_cdb);
                        show_ip_ospf_database(sptr_cdb);
                        show_ip_ospf_neighbor_extensive(sptr_cdb);
                        pre_show_ip_ospf_traffic(sptr_cdb);
        pre_show_ip_ospf_vir_link(sptr_cdb);
        pre_show_ip_ospf_vir_neighbor(sptr_cdb);
                        
                }
        } OSPF_INSTANCES_LIST_END(ospf);

        uprintf ("\n");

        sptr_cdb->vrf_idx = IPVRF_DEFAULT_VRF_IDX; // reset vrf in cdb structure

}
#endif __OSPF__

void show_tech_l3_uc_rip(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index;
        IPVRF_CB *vrf_cb;
        RIP_CLASS_VRF *rip;

        rip = RIP_GET_VRF_CLASS_PTR(IPVRF_DEFAULT_VRF_IDX);
        if (rip)
        {
                uprintf ("\nRIP Information for Default VRF\n-------------------------------\n");
                rip_show_interface(rip);
        }

        if (is_vrf_support_enabled())
        {
                for (vrf_index = IPVRF_MIN_VRF_IDX; vrf_index <= IPVRF_MAX_VRF_IDX; vrf_index++)
                {
                        vrf_cb = IPVRF_GET_CB(vrf_index);
                        if (!vrf_cb || !vrf_cb->ipv4.init)
                                continue;

                        rip = RIP_GET_VRF_CLASS_PTR(vrf_index);
                        if (rip)
                        {
                                uprintf ("\nRIP Information: VRF %s:\n--------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                rip_show_interface(rip);
                        }
                }
        }
        uprintf ("\n");

        
}

#ifdef __FOUNDRY_BGP__
void  show_tech_l3_uc_bgp(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index;
        IPVRF_CB *vrf_cb;
        BGP_CLASS_VRF *bgp;

        bgp = BGP_GET_VRF_CLASS(IPVRF_DEFAULT_VRF_IDX);
        if (bgp && bgp->vr_global && bgp->vr_global->bgp_application_enabled)
        {
                uprintf ("\nBGP Information for Default VRF\n-------------------------------\n");
                uprintf("IP BGP Neighbors:\n-----------------\n");
                bgp_show_all_bgp_neighbors(bgp, BGP_IPV4_AFI, BGP_UNICAST_SAFI);
                uprintf("IP BGP Routes :\n-------------\n");
                bgp_show_all_bgp_routes(bgp, sptr_cdb->safi);
                uprintf("IP BGP Best Routes :\n------------------\n");
                bgp_show_all_bgp_routes_new(bgp, sptr_cdb->safi);
                uprintf("IP BGP Summary:\n---------------\n");
                bgp_show_bgp_summary(bgp, BGP_IPV4_AFI, BGP_UNICAST_SAFI);
                uprintf("\n");
        }

        if (is_vrf_support_enabled())
        {
                for (vrf_index = IPVRF_MIN_VRF_IDX; vrf_index <= IPVRF_MAX_VRF_IDX; vrf_index++)
                {
                        vrf_cb = IPVRF_GET_CB(vrf_index);
                        if (!vrf_cb || !vrf_cb->ipv4.init)
                                continue;

                        bgp = BGP_GET_VRF_CLASS(vrf_index);
                        if (bgp && bgp->vr_global && bgp->vr_global->bgp_application_enabled)
                        {
                                uprintf ("\nBGP Information for VRF %s\n-----------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                uprintf("IP BGP Neighbors:\n-----------------\n");
                                bgp_show_all_bgp_neighbors(bgp, BGP_IPV4_AFI, BGP_UNICAST_SAFI);
                                uprintf("IP BGP Routes :\n-------------\n");
                                bgp_show_all_bgp_routes(bgp, sptr_cdb->safi);
                                uprintf("IP BGP Best Routes :\n------------------\n");
                                bgp_show_all_bgp_routes_new(bgp, sptr_cdb->safi);
                                uprintf("IP BGP Summary:\n---------------\n");
                                bgp_show_bgp_summary(bgp, BGP_IPV4_AFI, BGP_UNICAST_SAFI);
                                uprintf("\n");
                        }
                }
        }
}
#endif __FOUNDRY_BGP__

void  show_tech_l3_uc_vrrp(struct cdb* sptr_cdb)
{
#ifndef __BASE_L3__
#ifndef __NO_VRRPE__

        if (sptr_cdb->afi == IP_IPV4_AFI)
        {
                uprintf("VRRP v4 Brief :\n-------------\n");
                show_tech_ipv4_vrrp_brief(sptr_cdb);
        }
        else
        {
                uprintf("VRRP v6 Brief :\n-------------\n");
                show_tech_ipv6_vrrp_brief(sptr_cdb);
        }

#endif __BASE_L3__
#endif __NO_VRRPE__

        uprintf("\n");
}
void show_tech_l3_uc_v6_ip(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index;
        IPVRF_CB *vrf_cb;
        
        uprintf("\n\nIPV6 Interfaces:\n----------------\n");
        ipv6_show_all_interfaces(); //interface info

        if (is_vrf_support_enabled())
                        uprintf ("\nIPV6 Unicast Tables for Default VRF\n-----------------------------------\n");
        
        uprintf("\nIPV6 Routing Summary:\n---------------------\n");
        ipv6_show_routing_table_summary(IP_UNICAST_SAFI, IPVRF_DEFAULT_VRF_IDX);// routing summary
        uprintf("\nIPV6 Routing Table:\n-------------------\n");
        ipv6_show_routing_table(IP_UNICAST_SAFI, IPVRF_DEFAULT_VRF_IDX); //routes info
        uprintf("\nIPV6 Cache:\n-----------\n");
        ipv6_show_route_cache(IPVRF_DEFAULT_VRF_IDX);//cache info
        uprintf("\nIPV6 Neighbor:\n--------------\n");
        ipv6_neighbor_print_table_by_vrf(IPVRF_DEFAULT_VRF_IDX);//neighbor details
        uprintf("\n");

        if (is_vrf_support_enabled())
        {
                for (vrf_index = IPVRF_MIN_VRF_IDX; vrf_index <= IPVRF_MAX_VRF_IDX; vrf_index++)
                {
                        vrf_cb = IPVRF_GET_CB(vrf_index);
                        if (!vrf_cb || !vrf_cb->ipv6.init)
                                continue;

                        uprintf ("\nIPv6 Unicast Tables for VRF %s\n-------------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
        
                        uprintf("\nIPV6 Routing Summary for VRF %s:\n--------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                        ipv6_show_routing_table_summary(IP_UNICAST_SAFI, vrf_index);// routing summary
                        uprintf("\nIPV6 Routing Table for VRF %s:\n------------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                        ipv6_show_routing_table(IP_UNICAST_SAFI, vrf_index); //routes info
                        uprintf("\nIPV6 Cache for VRF %s:\n----------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                        ipv6_show_route_cache(vrf_index);//cache info
                        uprintf("\nIPV6 Neighbor for VRF %s:\n-------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                        ipv6_neighbor_print_table_by_vrf(vrf_index);//neighbor details
                }

                uprintf("\n");
        }
}

#ifdef __OSPFV3__
void show_tech_l3_uc_v6_ospf(struct cdb* sptr_cdb)
{
        OSPF6_CLASS *sptr_ospf6_vrf;

        uprintf ("\nOSPFV3 summary\n--------------\n");
        show_ipv6_ospf_summary_page(1, TRUE, 0); // Summary of all ospfv3 instances
        uprintf("IPV6 OSPF Memory:\n----------------\n");       // TR000462983
        show_ospf6_memory(sptr_cdb);     // ospf memory         // TR000462983

        OSPF6_INSTANCES_LIST(sptr_ospf6_vrf)
        {
                if (!IS_OSPF6_OPERATIONAL(sptr_ospf6_vrf))
                        continue;

                uprintf ("\nOSPFV3 Information for VRF %s\n-------------------------------------\n", ipvrf_api_get_vrf_name(sptr_ospf6_vrf->ospf6_vrf_index));
                sptr_cdb->vrf_idx = sptr_ospf6_vrf->ospf6_vrf_index;

                pre_show_ospf6_area(sptr_cdb);
                pre_show_ospf6_database(sptr_cdb);
                show_ospf6_neighbor_detail(sptr_cdb);
                pre_show_ospf6_vir_link_detail(sptr_cdb);
                pre_show_ospf6_vir_neighbor_detail(sptr_cdb);
                
        }OSPF6_INSTANCES_LIST_END(sptr_ospf6_vrf);

        uprintf ("\n");
        sptr_cdb->vrf_idx = IPVRF_DEFAULT_VRF_IDX;      
}
#endif


#ifdef __RIPNG__
void show_tech_l3_uc_v6_rip(struct cdb* sptr_cdb)
{
        uprintf("\nIPV6 RIP Route:\n---------------\n");
        ipv6_show_ipv6_rip_route();//ipv6 rip routing
    uprintf ("\n");
}
#endif __RIPNG__

#ifdef __FOUNDRY_BGP__
void  show_tech_l3_uc_v6_bgp(struct cdb* sptr_cdb)
{
        BGP_CLASS_VRF *bgp;

        bgp = BGP_GET_VRF_CLASS(IPVRF_DEFAULT_VRF_IDX);
        if (bgp && bgp->vr_global && bgp->vr_global->bgp_application_enabled)
        {
                uprintf ("\nBGP Information for Default VRF\n-------------------------------\n");
                uprintf("IPV6 BGP Neighbors:\n-----------------\n");
                bgp_show_all_bgp_neighbors(bgp, BGP_IPV6_AFI, BGP_IPV6_UNICAST_SAFI);
                uprintf("IPV6 BGP Summary:\n---------------\n");
                bgp_show_bgp_summary(bgp, BGP_IPV6_AFI, BGP_IPV6_UNICAST_SAFI);
                uprintf("\n");
        }
}
#endif __FOUNDRY_BGP__
#endif SR_SWITCH_ROUTER

#ifdef SR_SWITCH_ROUTER
#ifdef PIM_SM
void show_tech_l3_mc_pim(struct cdb* sptr_cdb)
{
        VRF_INDEX vrf_index;                                                                                                                                                                                                                                             
        
        if(PIM_GET_INSTANCE_FROM_VRFINDEX(sptr_cdb->afi, IPVRF_DEFAULT_VRF_IDX) != NULL) 
                {
                        sptr_cdb->vrf_idx = IPVRF_DEFAULT_VRF_IDX;               
                        uprintf("# PIM Group for Default VRF:\n-------------------------\n"); 
                        if(sptr_cdb->afi == IP_IPV4_AFI) 
                                show_ip_pim_group(sptr_cdb);  //Pim group
                        else 
                                show_ip6_pim_group(sptr_cdb); //Pim group
                        uprintf("# PIM Neighbor for Default VRF:\n-------------------------\n"); 
                    show_ip_pim_nbr(sptr_cdb);    //Pim neighbor 
                        uprintf("# PIM Cache for Default VRF:\n-------------------------\n"); 
                        pre_show_ip_pim_mcache(sptr_cdb); //Pim mcache     
                        uprintf("# PIM Resources for Default VRF:\n-------------------------\n");
                        show_ip_pim_resource(sptr_cdb); 
                        uprintf("# PIM Hw-Resources for Default VRF:\n-------------------------\n");
                        show_ip_pim_hw_resource(sptr_cdb); 
                }       
 
                if (is_vrf_support_enabled())                                                                                                                                                                                                                                    
                {                                                                                                                                                                                                                                                                
                        for (vrf_index = IPVRF_MIN_VRF_IDX; vrf_index <= IPVRF_MAX_VRF_IDX; vrf_index++)                                                                                                                                                                      
                        {                                                                                                                                                                                                                                                        
                        if (!is_vrf_active(vrf_index, sptr_cdb->afi)) 
                                continue; 

                        if(PIM_GET_INSTANCE_FROM_VRFINDEX(sptr_cdb->afi, vrf_index) == NULL) 
                                                 continue; 

                                sptr_cdb->vrf_idx = vrf_index; 
                                uprintf("# PIM Group for VRF %s:\n-------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                if(sptr_cdb->afi == IP_IPV4_AFI) 
                                        show_ip_pim_group(sptr_cdb);  //Pim group
                                else 
                                        show_ip6_pim_group(sptr_cdb); //Pim group
                                uprintf("# PIM Neighbor for VRF %s:\n-------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                show_ip_pim_nbr(sptr_cdb);    //Pim neighbor 
                                uprintf("# PIM Cache for VRF %s:\n----------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                pre_show_ip_pim_mcache(sptr_cdb); //Pim mcache     
                                uprintf("# PIM Resources for VRF %s:\n-------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                show_ip_pim_resource(sptr_cdb); 
                                uprintf("# PIM Hw-Resources for VRF %s:\n-------------------------\n", ipvrf_api_get_vrf_name(vrf_index));
                                show_ip_pim_hw_resource(sptr_cdb); 
                        }     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                uprintf("\n"); 
      }                                                                        
                
}
#endif PIM_SM
#endif SR_SWITCH_ROUTER

#ifdef SR_SWITCH_ROUTER
void cu_show_tech_ip_traffic(void)
{
        RIP_CLASS_VRF *rip = (RIP_CLASS_VRF * )RIP_GET_VRF_CLASS_PTR(IPVRF_DEFAULT_VRF_IDX);

        uprintf("IP Statistics\n");

        ip_update_mib_statistics();

        uprintf("  %u received, %u sent, %u forwarded\n",
                        ip.mib.ipInReceives,
                        ip.mib.ipOutRequests,
                        ip.mib.ipForwDatagrams);

        uprintf("  %u filtered, %u fragmented, %u reassembled, %u bad header\n",
                        ip.mib.ipFiltered,
                        ip.mib.ipFragOKs,
                        ip.mib.ipReasmOKs,
                        ip.mib.ipInHdrErrors);

        uprintf("  %u no route, %u unknown proto, %u no buffer, %u other errors\n",
                        ip.mib.ipOutNoRoutes,
                        ip.mib.ipInUnknownProtos,
                        ip.mib.ipNoFreeBuffers,
                        ip.mib.ipRoutingDiscards);


        /*
         *  * ARP stat
         *   */
#ifndef SR_KEEP_ARP_STAT
        uprintf("\nARP Statistics\n");

        uprintf("  %u total recv, %u req recv, %u req sent, %u rep sent\n",
                        ip.arp.statistics.total_number_of_packets_received,
                        ip.arp.statistics.total_number_of_incoming_requests,
                        ip.arp.statistics.total_number_of_requests_sent,
                        ip.arp.statistics.total_number_of_replies_sent);


        uprintf("  %u pending drop, %u invalid source, %u invalid dest\n",
                        ip.arp.statistics.total_number_of_pending_packets_discarded,
                        ip.arp.statistics.total_number_of_packets_with_invalid_sender_protocol_address,
                        ip.arp.statistics.total_number_of_packets_with_invalid_target_protocol_address);

#endif

        /*
         *  * ICMP stat
         *   */
        uprintf("\nICMP Statistics\n");

        uprintf("Received:\n");

        uprintf("  %u total, %u errors, %u unreachable, %u time exceed\n",
                        ip.icmp.mib.icmpInMsgs,
                        ip.icmp.mib.icmpInErrors,
                        ip.icmp.mib.icmpInDestUnreachs,
                        ip.icmp.mib.icmpInTimeExcds);


        uprintf("  %u parameter, %u source quench, %u redirect, %u echo, \n",
                        ip.icmp.mib.icmpInParmProbs,
                        ip.icmp.mib.icmpInSrcQuenchs,
                        ip.icmp.mib.icmpInRedirects,
                        ip.icmp.mib.icmpInEchos);


        uprintf("  %u echo reply, %u timestamp, %u timestamp reply, %u addr mask\n",
                        ip.icmp.mib.icmpInEchoReps,
                        ip.icmp.mib.icmpInTimestamps,
                        ip.icmp.mib.icmpInTimestampReps,
                        ip.icmp.mib.icmpInAddrMasks);


        uprintf("  %u addr mask reply, %u irdp advertisement, %u irdp solicitation\n",
                        ip.icmp.mib.icmpInAddrMaskReps,
                        ip.icmp.mib.icmpInRouterAdvertisement,
                        ip.icmp.mib.icmpInRouterSolicitation);


        uprintf("Sent:\n");

        uprintf("  %u total, %u errors, %u unreachable, %u time exceed\n",
                        ip.icmp.mib.icmpOutMsgs,
                        ip.icmp.mib.icmpOutErrors,
                        ip.icmp.mib.icmpOutDestUnreachs,
                        ip.icmp.mib.icmpOutTimeExcds);


        uprintf("  %u parameter, %u source quench, %u redirect, %u echo, \n",
                        ip.icmp.mib.icmpOutParmProbs,
                        ip.icmp.mib.icmpOutSrcQuenchs,
                        ip.icmp.mib.icmpOutRedirects,
                        ip.icmp.mib.icmpOutEchos);


        uprintf("  %u echo reply, %u timestamp, %u timestamp reply, %u addr mask\n",
                        ip.icmp.mib.icmpOutEchoReps,
                        ip.icmp.mib.icmpOutTimestamps,
                        ip.icmp.mib.icmpOutTimestampReps,
                        ip.icmp.mib.icmpOutAddrMasks);


        uprintf("  %u addr mask reply, %u irdp advertisement, %u irdp solicitation\n",
                        ip.icmp.mib.icmpOutAddrMaskReps,
                        ip.icmp.mib.icmpOutRouterAdvertisement,
                        ip.icmp.mib.icmpOutRouterSolicitation);


        /*
         *  * UDP and TCP, etc, to be added
         *   */
        uprintf("\nUDP Statistics\n");

        uprintf("  %u received, %u sent, %u no port, %u input errors\n",
                        ip.udp.mib.udpInDatagrams,
                        ip.udp.mib.udpOutDatagrams,
                        ip.udp.mib.udpNoPorts,
                        ip.udp.mib.udpInErrors);


        uprintf("\nTCP Statistics\n");

        uprintf("  %u active opens, %u passive opens, %u failed attempts\n",
                        tcp.mib.tcpActiveOpens,
                        tcp.mib.tcpPassiveOpens,
                        tcp.mib.tcpAttemptFails);


        uprintf("  %u active resets, %u passive resets, %u input errors\n",
                        tcp.mib.tcpOutRsts,
                        tcp.mib.tcpEstabResets,
                        tcp.mib.tcpInErrs);


        uprintf("  %u in segments, %u out segments, %u retransmission\n",
                        tcp.mib.tcpInSegs,
                        tcp.mib.tcpOutSegs,
                        tcp.mib.tcpRetransSegs);


        /*
         *  * RIP stat
         *   */
        uprintf("\nRIP Statistics\n");

        uprintf("  %u requests sent, %u requests received\n",
                        rip->statistics.number_of_request_packets_sent,
                        rip->statistics.number_of_request_packets_received);


        uprintf("  %u responses sent, %u responses received\n",
                        rip->statistics.number_of_response_packets_sent,
                        rip->statistics.number_of_response_packets_received);


        uprintf("  %u unrecognized, %u bad version, %u bad addr family, %u bad req format\n",
                        rip->statistics.number_of_unrecongnized_packets_received,
                        rip->statistics.number_of_bad_versions,
                        rip->statistics.number_of_bad_address_families,
                        rip->statistics.number_of_bad_request_formats);


        uprintf("  %u bad metrics, %u bad resp format, %u resp not from rip port\n",
                        rip->statistics.number_of_bad_metrics,
                        rip->statistics.number_of_bad_response_formats,
                        rip->statistics.number_of_responses_not_from_rip_port);

        uprintf("  %u resp from loopback, %u packets rejected\n",
                        rip->statistics.number_of_responses_received_from_loopback_interface,
                        rip->statistics.number_of_packets_rejected);


}
#endif
#ifdef SR_SWITCH_ROUTER
#ifndef __BASE_L3__
#ifndef __NO_VRRPE__
void show_tech_ipv4_vrrp_brief(struct cdb* sptr_cdb)
{
        int i, j, k, num_vrrps=0;
        UINT16 port_number;
        VRRP_VIR_ROUTER *sptr_vrtr_entry;
        VRRP_VIR_ROUTER *sptr_vrtr_array[VRRP_MAX_VRID_PER_INTERFACE];
        UINT8 port_str[16];
        IP_PORT_DB_ENTRY *portP;


        for (portP = ip_port_db_list_head; portP != NULL; portP = portP->next)
        {
                port_number = portP->port_number;
                if (!IP_PORT_DB(port_number)->vrrp_port_class.number_of_vrids)
                        continue;

                sptr_vrtr_entry = IP_PORT_DB(port_number)->vrrp_port_class.sptr_vrtr_entry_link;
                for (k=0; k<IP_PORT_DB(port_number)->vrrp_port_class.number_of_vrids; k++)
                {
                        if (sptr_vrtr_entry && !sptr_vrtr_entry->number_of_ips)
                                continue;
                        num_vrrps++;
                        sptr_vrtr_entry = sptr_vrtr_entry->next_vrtr_entry_link;
                }
        }

#ifndef __NO_VRRPE__
        uprintf("Total number of %s routers defined: %u\n",
                        IS_VRRP_ENABLED ? "VRRP" : "VRRP-Extended",
                        num_vrrps);

        uprintf("Short-Path-Fwd Codes - ER: Enabled with revertible option, RT: reverted, NR: not reverted\n");


#else
        uprintf("Total number of VRRP routers defined: %u\n",
                        g_vrrp_class.number_of_vrtr_entries[VRRP_AFI_TO_INDEX(IP_IPV4_AFI)]);
#endif __NO_VRRPE__


        if (!g_vrrp_class.number_of_vrtr_entries[VRRP_AFI_TO_INDEX(IP_IPV4_AFI)])
        {


                return;
        }

        uprintf("%-14s%-5s%-7s%-2s%-7s%-16s%-16s%-15s%-16s\n",
                        "Interface", "VRID", "CurPri", "P", "State", "Master addr", "Backup addr", "VIP", "Short-Path-Fwd");




        for (portP = ip_port_db_list_head; portP != NULL; portP = portP->next)
        {
                port_number = portP->port_number;
                if (!IP_PORT_DB(port_number)->vrrp_port_class.number_of_vrids)
                {
                        continue;
                }

                sptr_vrtr_entry = IP_PORT_DB(port_number)->vrrp_port_class.sptr_vrtr_entry_link;
                for (k=0; k<IP_PORT_DB(port_number)->vrrp_port_class.number_of_vrids; k++)
                {
                        sptr_vrtr_array[k] = sptr_vrtr_entry;
                        sptr_vrtr_entry = sptr_vrtr_entry->next_vrtr_entry_link;
                }

                vrrp_qsort(sptr_vrtr_array, 0,
                                IP_PORT_DB(port_number)->vrrp_port_class.number_of_vrids-1);


                for (k=0; k<IP_PORT_DB(port_number)->vrrp_port_class.number_of_vrids; k++)
                {
                        sptr_vrtr_entry = sptr_vrtr_array[k];
                        if (!sptr_vrtr_entry->number_of_ips)
                                continue;

                        /* We display first and last trunk ports under Interface coulmn. We need at most 14 character width port_str like x/x/xx*y/y/yy */
                        ksnprintf(port_str, sizeof(port_str),"%P", port_number);
                        uprintf("%-14s%-5u%-7u%-2s",
                                        port_str,
                                        sptr_vrtr_entry->vrid,
                                        sptr_vrtr_entry->current_priority,
                                        sptr_vrtr_entry->preempt_mode ? "P" : " ");



                        if (sptr_vrtr_entry->state == VRRP_MASTER_STATE)
                        {
                                uprintf("%-7s%-16s", "Master", "Local");

                                if (sptr_vrtr_entry->backup_addr[0].ipv4_address)
                                        uprintf("%-16I", sptr_vrtr_entry->backup_addr[0].ipv4_address);
                                else
                                        uprintf("%-16s", "Unknown");

                        }
                        else
                                if (sptr_vrtr_entry->state == VRRP_BACKUP_STATE)
                                {
                                        uprintf("%-7s%-16I%-16s", "Backup", sptr_vrtr_entry->master_ip_addr.ipv4_address, "Local");

                                }
                                else
                                {
                                        uprintf("%-7s%-16s%-16s", "Init", "Unknown", "Unknown");

                                }

                        uprintf("%-15I", sptr_vrtr_entry->ip_addr[0].ipv4_address);


                        if(sptr_vrtr_entry->short_path_revertable)
                        {
                                if(sptr_vrtr_entry->state == VRRP_BACKUP_STATE)
                                {
                                        uprintf("ER P-%d, %s\n",
                                                        sptr_vrtr_entry->short_path_revert_priority,
                                                        (sptr_vrtr_entry->current_priority < sptr_vrtr_entry->short_path_revert_priority) ? "RT" : "NR");
                                }
                                else
                                {
                                        uprintf("ER P-%d, %s\n",
                                                        sptr_vrtr_entry->short_path_revert_priority, "NR");
                                }
                        }
                        else
                        {
                                uprintf("%s\n", sptr_vrtr_entry->short_path_fwd_enabled ? "Enabled" : "Disabled");

                        }




                }
        }


}
void show_tech_ipv6_vrrp_brief(struct cdb* sptr_cdb)
{
        int i, j, k, num_vrrps=0;
        UINT16 port_number;
        VRRP_VIR_ROUTER *sptr_vrtr_entry;
        VRRP_VIR_ROUTER *sptr_vrtr_array[VRRP_MAX_VRID_PER_INTERFACE];
        UINT8 port_str[16];



        for (port_number = 0; port_number < ip6.number_of_ports; port_number++)
        {
                if (IP6_PORT_DB_CONFIG(port_number)->ip6_enabled == FALSE)
                        continue;

                if (!IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.number_of_vrids)
                        continue;

                sptr_vrtr_entry = IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.sptr_vrtr_entry_link;
                for (k=0; k<IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.number_of_vrids; k++)
                {
                        if (sptr_vrtr_entry && !sptr_vrtr_entry->number_of_ips)
                                continue;
                        num_vrrps++;
                        sptr_vrtr_entry = sptr_vrtr_entry->next_vrtr_entry_link;
                }
        }

#ifndef __NO_VRRPE__
        uprintf("Total number of %s routers defined: %u\n",
                        IS_VRRP_ENABLED ? "VRRP" : "VRRP-Extended", num_vrrps);
#else
        uprintf("Total number of VRRP routers defined: %u\n",
                        g_vrrp_class.number_of_vrtr_entries[VRRP_AFI_TO_INDEX(IP_IPV6_AFI)]);
#endif __NO_VRRPE__


        if (!g_vrrp_class.number_of_vrtr_entries[VRRP_AFI_TO_INDEX(IP_IPV6_AFI)])
        {
                return;
        }

        uprintf("%-14s%-5s%-7s%-2s%-7s%-40s\n%32s%s\n%32s%s\n",
                        "Interface", "VRID", "CurPri", "P", "State", "Master addr", "", "Backup addr", "", "VIP");


        for (port_number=0; port_number < ip6.number_of_ports; port_number++)
        {
                if (IP6_PORT_DB_CONFIG(port_number)->ip6_enabled == FALSE)
                        continue;

                if (!IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.number_of_vrids)
                {
                        continue;
                }

                sptr_vrtr_entry = IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.sptr_vrtr_entry_link;
                for (k=0; k<IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.number_of_vrids; k++)
                {
                        sptr_vrtr_array[k] = sptr_vrtr_entry;
                        sptr_vrtr_entry = sptr_vrtr_entry->next_vrtr_entry_link;
                }

                vrrp_qsort(sptr_vrtr_array, 0,
                                IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.number_of_vrids-1);


                for (k=0; k<IP6_PORT_DB_CONFIG(port_number)->vrrp_port_class.number_of_vrids; k++)
                {
                        sptr_vrtr_entry = sptr_vrtr_array[k];
                        if (!sptr_vrtr_entry->number_of_ips)
                                continue;

                        /* We display first and last trunk ports under Interface coulmn. We need at most 14 character width port_str like x/x/xx*y/y/yy */
                        ksnprintf(port_str, sizeof(port_str),"%P", port_number);
                        uprintf("%-14s%-5u%-7u%-2s",
                                        port_str,
                                        sptr_vrtr_entry->vrid,
                                        sptr_vrtr_entry->current_priority,
                                        sptr_vrtr_entry->preempt_mode ? "P" : " ");



                        if (sptr_vrtr_entry->state == VRRP_MASTER_STATE)
                        {
                                uprintf("%-7sMaster addr: %-40s", "Master", "Local");

                                if (!IP6_IS_ADDRESS_UNSPECIFIED(sptr_vrtr_entry->backup_addr[0].ipv6_address.address))
                                        uprintf("\n%-35sBackup addr: %-40s", "", ipv6_address_to_string(&sptr_vrtr_entry->backup_addr[0].ipv6_address, NULL));
                                else
                                        uprintf("\n%-35sBackup addr: %-40s", "", "Unknown");

                        }
                        else
                                if (sptr_vrtr_entry->state == VRRP_BACKUP_STATE)
                                {
                                        uprintf("%-7sMaster addr: %-40s\n%-35sBackup addr: %-40s", "Backup", ipv6_address_to_string(&sptr_vrtr_entry->master_ip_addr.ipv6_address, NULL), "", "Local");

                                }
                                else
                                {
                                        uprintf("%-7sMaster addr: %-40s\n%-35sBackup addr: %-40s", "Init", "Unknown", "", "Unknown");

                                }

                        uprintf("\n%-35sVIP        : %-40s\n", "", ipv6_address_to_string(&sptr_vrtr_entry->ip_addr[0].ipv6_address, NULL));

                }
        }

}
#endif
#endif
#endif

#ifdef SIDEWINDER_LINUX

extern void dm_cpld_read(struct cdb* sptr_cdb)
{
    cpld_t cpld_id;
    UINT8 data;
        
    sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->num_of_integer != 2)
    {
        uprintf("Wrong number of parameters\n");
        uprintf("Usage: dm cpld-read <cpld_id> <regOffset>\n");
        return;
    }

    switch(sptr_cdb->integer1)
    {
        case 0: cpld_id = SYS_CPLD;
                break;

        case 1: cpld_id = CPLD1;
                break;

        case 2: cpld_id = CPLD2;
                break;

        case 3: cpld_id = CPLD3;
                break;    
                
        case 4: cpld_id = CPLD_48C;
                break;                            
		default:
			return;
    }

    if (hal_cpld_read_reg(cpld_id, sptr_cdb->integer2, &data))
    {
        uprintf("Error in reading the cpld\n");
        return;
    }

    uprintf("The value read is : 0x%x\n", data);
    return;    

}

extern void dm_cpld_write(struct cdb* sptr_cdb)
{
    cpld_t cpld_id;
    UINT8 data;
        
    sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->num_of_integer != 3)
    {
        uprintf("Wrong number of parameters\n");
        uprintf("Usage: dm cpld-write <cpld_id> <regOffset> <value>\n");
        return;
    }

    switch(sptr_cdb->integer1)
    {
        case 0: cpld_id = SYS_CPLD;
                break;

        case 1: cpld_id = CPLD1;
                break;

        case 2: cpld_id = CPLD2;
                break;

        case 3: cpld_id = CPLD3;
                break;     
                
        case 4: cpld_id = CPLD_48C;
                break;                           
		default:
			return;
    }

    data = sptr_cdb->integer3;
    if (hal_cpld_write_reg(cpld_id, sptr_cdb->integer2, data))
    {
        uprintf("Error in writing to the cpld\n");
        return;
    }

    uprintf("Write to cpld register successful\n");
    return;    

}

#endif

#ifdef FI_LINUX

extern int sil_platform_gpio_read(int pin);
extern int sil_platform_gpio_write(int pin, int data);
extern int sil_platform_gpio_set_direction(int pin, int dir);
void dm_gpio_read(struct cdb* sptr_cdb)
{
	int pin, value;
	sptr_cdb->dont_go_next = 1;
	pin = sptr_cdb->integer1;

	value =  sil_platform_gpio_read(pin);

	uprintf("pin%d is %d \n", pin, value);


}

void dm_gpio_write(struct cdb* sptr_cdb)
{
	int pin, value, ret= 0;
	sptr_cdb->dont_go_next = 1;
	pin = sptr_cdb->integer1;
	value = !!(sptr_cdb->integer2); /* Binary value*/
	ret |=sil_platform_gpio_set_direction(pin, 1);
	ret |=  sil_platform_gpio_write(pin, value);

	uprintf("write %s\n", ret ? "failure": "success");


}
static void dm_do_i2c_read(int repeat, int bus, int dev, UINT8 wbuff)
{
	UINT8 *rbuff = NULL;
	int i;

	if(!repeat)
	{
		uprintf("Repeat count can't be 0 \n");
		return;
	}

	rbuff = malloc(sizeof(UINT8) * repeat);
	if(!rbuff)
	{
		uprintf("%s: Unable to  allocate the memory \n", __FUNCTION__);
		return;
	}

	/* will read repeat bytes from the offset specified in wbuff */
	if (sys_send_i2c_command(bus, dev, &wbuff, 1, rbuff, repeat, 0) != I2C_STATUS_OK)
	{
		uprintf("Error reading i2c device:%d\n", dev);
		goto error;
	}


	for (i = 0; i < repeat; i++)
		uprintf("0x%x \t", rbuff[i]);
	uprintf("\n");

error:
	free(rbuff);
}

void dm_i2c_read1(struct cdb* sptr_cdb)
{
    int bus;
    int dev;
    UINT8 wbuff;
    int repeat;

    sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->num_of_integer != 4)
    {
        uprintf("Wrong number of parameters\n");
        uprintf("Usage: dm i2c-read <bus_id> <i2cDevAddr> <regOffset> [repeatCount]\n");
        return;
    }

    bus = sptr_cdb->integer1;
    dev = sptr_cdb->integer2;
    wbuff  = sptr_cdb->integer3;
    repeat = sptr_cdb->integer4;
    return dm_do_i2c_read(repeat, bus, dev, wbuff);
}

void dm_i2c_read(struct cdb* sptr_cdb)
{
    int bus;
    int dev;
    UINT8 wbuff;

    if (end_of_token(sptr_cdb->token) != '\0')
            return;

    sptr_cdb->dont_go_next = 1;


    if (sptr_cdb->num_of_integer != 3)
    {
        uprintf("Wrong number of parameters\n");
        uprintf("Usage: dm i2c-read <bus_id> <i2cDevAddr> <regOffset> [repeatCount]\n");
        return;
    }

    bus = sptr_cdb->integer1;
    dev = sptr_cdb->integer2;
    wbuff = sptr_cdb->integer3;
    return dm_do_i2c_read(1, bus, dev, wbuff);
}



static void dm_do_i2c_write(int repeat, int bus, int dev, UINT8 *wbuff)
{
    int i;

    if(IS_MINIONS() &&  (dev == SFP_PHY_ADDR) && (bus==1))
     {
     	/* GBIC writes Word only*/	
        if (sys_send_i2c_command(bus, dev, wbuff, 3, NULL, 0, 0) != I2C_STATUS_OK)
        {
            uprintf("Error writing i2c device:%d\n", i);
        }else
	{
	
                uprintf("Write successful\n");
		
	}


     
     }else
     {
    for (i=1; i<=repeat; i++)
        if (sys_send_i2c_command(bus, dev, wbuff, 2, NULL, 0, 0) != I2C_STATUS_OK)
        {
            uprintf("Error writing i2c device:%d\n", i);
        }
        else
        {
            if (repeat < 2)    
                uprintf("Write successful\n");
        }
}
}

void dm_i2c_write1(struct cdb* sptr_cdb)
{
    int bus;
    int dev;
//    UINT8 wbuff[2];
    UINT8 *wbuff;
    int repeat;
    int size;
    sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->num_of_integer != 5)
    {
        uprintf("Wrong number of parameters\n");
        uprintf("Usage: dm i2c-write <bus_id> <i2cDevAddr> <regOffset> <data> [repeatCount]\n");
        return;
    }

    bus = sptr_cdb->integer1;
    dev = sptr_cdb->integer2;
    if(IS_MINIONS() && (dev == SFP_PHY_ADDR) &&( bus == 1))
    {
	    size = 3;
    }else
    {
	    size = 2;
    }
    wbuff = malloc(size);
    if(!wbuff)
    {
	    uprintf("Not enough memory \n"); 
	    return ;	
    }


    wbuff[0] = sptr_cdb->integer3;
    if(IS_MINIONS() && (dev == SFP_PHY_ADDR) && ( bus == 1))
    {
    	wbuff[1] = sptr_cdb->integer4 & 0xff;
    	wbuff[2] = (sptr_cdb->integer4 >> 8)& 0xff;
	
    
    }else
    {
		   
    	wbuff[1] = sptr_cdb->integer4;
    }
    repeat   = sptr_cdb->integer5;
     dm_do_i2c_write(repeat, bus, dev, wbuff);

     free(wbuff);
}

void dm_i2c_write(struct cdb* sptr_cdb)
{
    int bus;
    int dev;
    UINT8 *wbuff;
    int size;
    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

    if (sptr_cdb->num_of_integer != 4)
    {
        uprintf("Wrong number of parameters\n");
        uprintf("Usage: dm i2c-write <bus_id> <i2cDevAddr> <regOffset> <data> [repeatCount]\n");
        return;
    }

    bus = sptr_cdb->integer1;
    dev = sptr_cdb->integer2;
    if(IS_MINIONS() && (dev == SFP_PHY_ADDR) &&( bus == 1))
    {
	    size = 3;
    }else
    {
	    size = 2;
    }
    wbuff = malloc(size);
    if(!wbuff)
    {
	    uprintf("Not enough memory \n"); 
	    return ;	
    }


    wbuff[0] = sptr_cdb->integer3;
    if(IS_MINIONS() && (dev == SFP_PHY_ADDR) && ( bus == 1))
    {
    	wbuff[1] = sptr_cdb->integer4 & 0xff;
    	wbuff[2] = (sptr_cdb->integer4 >> 8)& 0xff;
	
    
    }else
    {
		   
    	wbuff[1] = sptr_cdb->integer4;
    }
     dm_do_i2c_write(1, bus, dev, wbuff);
     free(wbuff);
}
#endif
#ifdef SIDEWINDER_LINUX
extern void cli_apply_qos_scheduler_profile_port(struct cdb* sptr_cdb);
extern void cli_apply_qos_egress_profile_port(struct cdb* sptr_cdb);
#if PER_PORT_PFC
extern void cli_pfc_port_enable (struct cdb* sptr_cdb);
#endif

void mif_apply_qos_scheduler_profile_port(struct cdb * sptr_cdb)
{
    set_mif(sptr_cdb, TRUE, (void *)cli_apply_qos_scheduler_profile_port);
}
void mif_apply_qos_egress_profile_port(struct cdb* sptr_cdb)
{
    set_mif(sptr_cdb, TRUE, (void *)cli_apply_qos_egress_profile_port);
}
void mif_apply_qos_ingress_profile_port(struct cdb* sptr_cdb)
{
    set_mif(sptr_cdb, TRUE, (void *)cli_apply_qos_ingress_profile_port);
}
#if PER_PORT_PFC
void mif_pfc_port_enable(struct cdb* sptr_cdb)
{
   set_mif(sptr_cdb, TRUE, (void *)cli_pfc_port_enable);
}
#endif
#endif

UINT8 g_stats_reset_timestamp_enable = 0;
enum BOOLEAN is_stats_reset_timestamp_enable(void)
{
  return g_stats_reset_timestamp_enable ? TRUE: FALSE;
}

void cu_set_stats_reset_timestamp_enable(UINT8 enable)
{
   if(g_stats_reset_timestamp_enable == enable)
      return;
   g_stats_reset_timestamp_enable = enable;
}

void cli_enable_port_stats_reset_timestamp(struct cdb* sptr_cdb)
{
   if (sptr_cdb->config_gen)
   {
      if(is_stats_reset_timestamp_enable())
      {
         wr_config(sptr_cdb, "port-statistics-reset-timestamp enable\n");
      }
      return;
   } 
   if(end_of_token(sptr_cdb->token) != '\0')
      return;
   sptr_cdb->dont_go_next = 1;
   if (sptr_cdb->no)
     cu_set_stats_reset_timestamp_enable(0);
   else
     cu_set_stats_reset_timestamp_enable(1);
}

void validate_pre_shared_key_cmd ( struct cdb* sptr_cdb)
{
#ifdef __FI_IPSEC_IKE__
    if (sptr_cdb->mode == CONFIG_IKE_AUTH)
    {
        sptr_cdb->dont_go_next = 1;
    }
#endif /* __FI_IPSEC_IKE__ */
}

extern int retrieve_running_config_ztp(struct cdb* sptr_cdb);
/*
 * Name   : cli_show_ztp
 * Desc   : Function used to show the zero touch port list
 * Params : sptr_cdb
 * Return : void 
 */
void cli_show_ztp(struct cdb *sptr_cdb)
{
	if( sptr_cdb->no || sptr_cdb->config_gen )
		return;

	if( end_of_token(sptr_cdb->token) != '\0' )
		return;
	
	sptr_cdb->dont_go_next = 1;
	do_write_running_config_to_terminal( sptr_cdb, retrieve_running_config_ztp, NULL);
}

extern void hal_show_lrm_adapters(void);
extern void hal_show_lrm_adapter_on_port(PORT_ID port);
extern void hal_show_lrm_adapter_on_stack_port(PORT_ID port);

void show_lrm_adapter_on_port(struct cdb* sptr_cdb)
{
	PORT_ID port = INTERFACE_TO_PORT_ID(sptr_cdb->if1);
	int stackId = PORT_TO_STACK_ID(port);

	if(!IS_PORT_DB_VALID(port))
		return;

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

	if(!is_fluffy_supported(port))
	{
		uprintf("LRM Adapter not Supoorted on port:%p\n",port);
		return; 
	}

	if(!SPTR_PORT_DB(port)->platform_port.is_fluffy_present)
	{
		uprintf("LRM Adapter not present on port:%p\n",port);
		return; 
	}

	if(stackId == MY_BOOTUP_STACK_ID) 
		hal_show_lrm_adapter_on_port(port);
	else
		hal_show_lrm_adapter_on_stack_port(port);

	return;
}

void show_lrm_adapters(struct cdb* sptr_cdb)
{

    if (end_of_token(sptr_cdb->token) != '\0')
        return;

    sptr_cdb->dont_go_next = 1;

	hal_show_lrm_adapters();	
	return;
}


#ifndef FI_EEE_MGMT
UINT32 eee_idle_threshold = 0;
extern int is_port_eee_capable(PORT_ID config_port);
extern void cu_show_mif_eee_statistics(PORT_MASK *port_mask, UINT32 port_index);
extern int pp_link_eee_set(PORT_ID port, int enable, int idle_threshold);
extern void cu_show_mif_power_savings_statistics(PORT_MASK *port_mask, UINT32 port_index);

void eee_util_syslog(char *str, PORT_ID port)

{

         ksprintf ((char*)cu_line_buf,"%s for port %p\n",str,port);
         cu_logging_generic(cu_line_buf, TRUE, CU_LOGGING_TYPE_INFORMATIONAL);
}


int cu_get_port_eee_idle_threshold(PORT_ID port, UINT32 *idle_threshold)
{
        *idle_threshold = (SPTR_PORT_DB(port))->port_config.eee_idle_threshold;
        return CU_OK;
}

//extern void set_port_stack_eee_idle_threshold(UINT32 eee_idle_threshold, PORT_ID port);
//EEE_TODO
void set_port_stack_eee_idle_threshold(UINT32 idle_threshold, PORT_ID port)
{
        (SPTR_PORT_DB(port))->port_config.eee_idle_threshold = idle_threshold;
}



void cli_set_port_eee_idle_threshold_default(struct cdb *sptr_cdb)
{
    PORT_ID port_id=INTERFACE_TO_PORT_ID(sptr_cdb->if_num);
    UINT32 idle_threshold;
        int stackId = PORT_TO_STACK_ID(port_id);

    if(!IS_PORT_DB_VALID(port_id))
        return;

    if (sptr_cdb->config_gen == 0)
    {
        if (end_of_token(sptr_cdb->token) != '\0')
            return;
        sptr_cdb->dont_go_next = 1;

        if(!IS_PORT_DB_VALID(port_id))
            return;

		if(check_is_virtual(port_id,"EEE")){
			return;
		}
		
        if(hal_is_pp_link_fiber_port(port_id) || is_pp_link_x40g_port(port_id) || is_pp_link_2_5gig_port(port_id)
			|| is_port_stack_enabled(port_id))
        {
            uprintf("EEE feature not supported on port %p\n",port_id);
                    return;
        }

        if(IS_MGMT_PORT(port_id))
            return;

        if(!is_port_eee_capable(port_id))
            return;

		if(IS_SPX_PORT(port_id))
        {
            uprintf("EEE feature not supported on spx-port %p\n",port_id);
			return;
        }

            if(IS_PP_GIG_COPPER_PORT(port_id) && 
                        (((SPTR_PORT_DB(port_id))->port_oper_info.speed == SPEED_10) || ((SPTR_PORT_DB(port_id))->port_config.speed == SPEED_10)
						|| ((SPTR_PORT_DB(port_id))->port_oper_info.hdx_fdx == PORT_HDX) || ((SPTR_PORT_DB(port_id))->port_config.hdx_fdx == PORT_HDX)))
            {
				(SPTR_PORT_DB(port_id))->port_config.eee_enabled = FALSE;
                if(!sptr_cdb->no)
                   uprintf("EEE cannot be supported on port %p for the current speed config \n", port_id);
                return;
            }


        if (sptr_cdb->no)
        {
            if(!((SPTR_PORT_DB(port_id))->port_config.eee_enabled))
            {
				if(IS_CHASSIS_STACK_EXIST(stackId))
                	uprintf("EEE Feature Already Disabled on port %p\n",port_id);
                return;
            }

			/*Initialize eee_idle_threshold when EEE is enabled globally and disabled for some ports
			  when EEE feature is  not enabled eee_idle_threshold will be 0. This is to differentiate
			  if EEE featue is enabled on port based on the threshold value and used ito configure EEE
			  feature when a unit joins the stack for the first time.
			*/
            (SPTR_PORT_DB(port_id))->port_config.eee_idle_threshold = 0xFF;
            (SPTR_PORT_DB(port_id))->port_config.eee_enabled = FALSE;
            SPTR_PORT_DB(port_id)->port_oper_info.eee_capable = FALSE;
            uprintf("EEE Feature Disabled on port %p\n",port_id);
            pp_link_eee_set(port_id, 0, (SPTR_PORT_DB(port_id))->port_config.eee_idle_threshold);

       }
        else
        {
            if(!is_port_eee_capable(port_id))
                return;

            if((SPTR_PORT_DB(port_id))->port_config.eee_enabled)
            {
				if(IS_CHASSIS_STACK_EXIST(stackId))
                	uprintf("EEE Feature Already Enabled on port %p\n",port_id);
                return;
            }

            if(hal_is_pp_link_x10g_copper_port(port_id)) 
                (SPTR_PORT_DB(port_id))->port_config.eee_idle_threshold = EEE_IDLE_THRESHOLD_10G_VAL;
            else
                (SPTR_PORT_DB(port_id))->port_config.eee_idle_threshold = EEE_IDLE_THRESHOLD_1G_VAL;

            (SPTR_PORT_DB(port_id))->port_config.eee_enabled = TRUE;
            SPTR_PORT_DB(port_id)->port_oper_info.eee_capable = TRUE;
            uprintf("EEE Feature Enabled on port %p\n",port_id);
            pp_link_eee_set(port_id, 1, (SPTR_PORT_DB(port_id))->port_config.eee_idle_threshold);
         
        }
    }
    else
    {
        sptr_cdb->dont_go_next = 1;
        if((stackId != MY_BOOTUP_STACK_ID) && (!is_port_eee_capable (port_id)))
            return;
        if(hal_is_pp_link_fiber_port(port_id) || is_pp_link_x40g_port(port_id))
            return;

        if(IS_MGMT_PORT(port_id))
            return;

        if(!is_port_eee_capable(port_id)) 
            return;

		if(IS_SPX_PORT((UINT16)port_id))
			return;

        if (cu_get_port_eee_idle_threshold(port_id, &idle_threshold) != CU_OK) {
            uprintf("Error:cli_set_port_eee_idle_threshold_default: cu_get_port_eee_idle_threshold() failed\n");
            return;
        }

		if(IS_PP_GIG_COPPER_PORT(port_id) && idle_threshold && 
			(((SPTR_PORT_DB(port_id))->port_oper_info.speed == SPEED_10) || ((SPTR_PORT_DB(port_id))->port_oper_info.hdx_fdx == PORT_HDX)))
		{
			//Initialize eee_idle_threshold to 0XFF for non-supported ports 
           	(SPTR_PORT_DB(port_id))->port_config.eee_idle_threshold = 0xFF;
           	(SPTR_PORT_DB(port_id))->port_config.eee_enabled = FALSE;
           	SPTR_PORT_DB(port_id)->port_oper_info.eee_capable = FALSE;
			idle_threshold =0;
		}

        if(eee_idle_threshold != 0)
        {       //  Global setting enabled
            if(idle_threshold == 0xFF)
            {
                if(!g_sw_sys.init_in_progress)
                {

               		ksprintf(cu_line_buf, " no eee\n");
                	wr_config(sptr_cdb, cu_line_buf);
            	}
        	}
        }
        else
        {
            if (idle_threshold)
            {
                if(!g_sw_sys.init_in_progress)
                {
                	ksprintf(cu_line_buf, " eee\n");
                	wr_config(sptr_cdb, cu_line_buf);
            	}
        	}

        }
            if(hal_is_pp_link_fiber_port(port_id) || is_pp_link_x40g_port(port_id) || is_pp_link_x100g_port (port_id))
                return;
    }

}

void mif_set_port_eee_idle_threshold_default(struct cdb* sptr_cdb)
{
        set_mif(sptr_cdb, TRUE, (void *)cli_set_port_eee_idle_threshold_default);
}

void cli_set_eee_idle_threshold_default(struct cdb *sptr_cdb)
{
    if (sptr_cdb->config_gen == 0)
    {
        if (end_of_token(sptr_cdb->token) != '\0')
            return;

        sptr_cdb->dont_go_next = 1;

                if(CONFIG_MGMT_IF == sptr_cdb->mode) 
                {
                        uprintf("EEE Feature not supported on mgmt port\n");
                        return;
                }

        if (sptr_cdb->no)
        {
            eee_idle_threshold = 0;
            uprintf("EEE Feature Disabled\n");
        }
        else
        {
                        //Initializing the threshold value to EEE_IDLE_THRESHOLD_1G_VAL by default, Actual init will be done 
                        //inside the function cu_set_all_port_eee_idle_threshold() 
            eee_idle_threshold = EEE_IDLE_THRESHOLD_1G_VAL;
            uprintf("EEE Feature Enabled\n");
        }
        if (cu_set_all_port_eee_idle_threshold(eee_idle_threshold) != CU_OK)
            uprintf("Error:cu_set_all_port_eee_idle_threshold()  failed \n");
    }
    else
    {
        sptr_cdb->dont_go_next = 1;
        if (eee_idle_threshold != 0)
        {
            ksprintf(cu_line_buf, "eee\n");
            wr_config(sptr_cdb, cu_line_buf);
        }
    }
}

void show_eee_statistics(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);    

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->mode == CONFIG_MIF)
                cu_show_mif_eee_statistics(sptr_cdb->mif_port_mask, NEXT_PORT_INDEX_INVALID);
        else
                cu_show_mif_eee_statistics(NULL, NEXT_PORT_INDEX_INVALID);
}

void clear_eee_statistics(struct cdb* sptr_cdb)
{
        set_physical_view(sptr_cdb);    

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->mode == CONFIG_MIF)
                cu_clear_mif_eee_statistics(sptr_cdb->mif_port_mask, NEXT_PORT_INDEX_INVALID);
        else
                cu_clear_mif_eee_statistics(NULL, NEXT_PORT_INDEX_INVALID);

}

void show_power_savings_statistics(struct cdb* sptr_cdb)
{

        set_physical_view(sptr_cdb);    

        if (end_of_token(sptr_cdb->token) != '\0')
                return;

        sptr_cdb->dont_go_next = 1;

        if (sptr_cdb->mode == CONFIG_MIF)
                cu_show_mif_power_savings_statistics(sptr_cdb->mif_port_mask, NEXT_PORT_INDEX_INVALID);
        else
                cu_show_mif_power_savings_statistics(NULL, NEXT_PORT_INDEX_INVALID);


}
#endif

void get_fanless_mode_unit_num_string(char* str)
{
	int start = -1, end = 0;
	int i, len=0;

	for(i = 1; i <= MAX_SYS_UNIT_NUM; i++)
	{
		/* Allowing for configured unit and existing unit */
		if(IS_CHASSIS_STACK_EXIST(i) && g_fanless_mode_enable[i])
		{
			if(start == -1)
				start = i;
			end = i;
		}
		else
		{
			if(start != -1)
			{
				if(start == end)
					len += ksnprintf(str+len, sizeof("%u,"), "%u,", start);
				else
					len += ksnprintf(str+len, sizeof("%u-%u,"), "%u-%u,", start, end);
				start = -1;
			}
		}
	}
	if(start != -1)
	{
		if(start == end)
			len += ksnprintf(str+len, sizeof("%u,"), "%u,", start);
		else
			len += ksnprintf(str+len, sizeof("%u-%u,"), "%u-%u,", start, end);
	}
	/* Removing extra ',' at the end of string */
	if(len > 1)
	{
		str[len-1] = 0;
		len -= 1;
	}
	/* If none of units enabled fanless mode then printing with "None" */
	if(len == 0)
	{
		len += ksnprintf(str+len, sizeof("None"), "None");
	}

	return;
}

void cli_enable_fanless_mode_per_unit(struct cdb* sptr_cdb)
{
	int enable = TRUE;
	int i, stack_id = sptr_cdb->integer1;

	if(sptr_cdb->config_gen)
	{
		sptr_cdb->dont_go_next = 1;

		if(is_fanless_mode_enabled_globally())
		{
			ksprintf(cu_line_buf, "chassis fanless all\n");
			wr_config(sptr_cdb, cu_line_buf);
		}
		else
		{
			for(stack_id = 1; stack_id <= MAX_SYS_UNIT_NUM ; stack_id++)
			{
				if(IS_STACK_LOGICAL(stack_id))
					continue;
				if (g_fanless_mode_enable[stack_id] && IS_CHASSIS_STACK_EXIST(stack_id))
				{
					ksprintf(cu_line_buf, "chassis fanless %d\n", stack_id);
					wr_config(sptr_cdb, cu_line_buf);
				}
			}
		}
		return;
	}
	
	if(!valid_integer1_value_range(sptr_cdb, 1, MAX_SYS_UNIT_NUM))
		return;

	if(sptr_cdb->no)
	{
		enable = FALSE;
		/* Clearing the global config flag if fanless mode configured globally */
		if(g_fanless_mode_enable[0] && is_fanless_mode_supported(stack_id))
		{
			/* FANLESS_MODE_TODO: Here ask for user input (yes/no) to remove 
			 * global config before removing global config and changing to per unit
			 * config if fanless mode disabled in any of member unit
			 * */
			uprintf("\"chassis fanless all\" user config "
				"has been \nremoved and changed to \"chassis fanless "
				"<unit id>\"\n as fanless mode disabled in unit %d\n", stack_id);

			g_fanless_mode_enable[0] = enable;
		}
	}

	if(g_fanless_mode_enable[stack_id] == enable)
		return;

	g_fanless_mode_enable[stack_id] = enable;
	chassisStackSetFanlessMode(stack_id, enable);
	return;
}


void cli_enable_fanless_mode_all(struct cdb* sptr_cdb)
{
	int enable = TRUE;
	int stack_id;
	char str[MAX_SYS_UNIT_NUM*3] = {0};

	if(sptr_cdb->config_gen)
		return;

	if(sptr_cdb->no)
		enable = FALSE;
	
	if(enable == TRUE)
	{
		if(is_fanless_mode_enabled_globally() == enable)
			return;

		/* Setting global flag */
		g_fanless_mode_enable[0] = enable;
		for(stack_id = 1; stack_id <= MAX_SYS_UNIT_NUM ; stack_id++){
			if(IS_STACK_LOGICAL(stack_id))
				continue;

			if(g_fanless_mode_enable[stack_id] == enable)
			{
				continue;
			}
			else
			{
				if(IS_CHASSIS_STACK_EXIST(stack_id))
				{
					g_fanless_mode_enable[stack_id] = enable;
					chassisStackSetFanlessMode(stack_id, enable);
				}
			}
		}
		get_fanless_mode_unit_num_string(str);
	}
	else
	{
		get_fanless_mode_unit_num_string(str);
		/* To block fanless mode disable messages for each individual units
		 * if fanless mode not configured globally but disabling fanless mode
		 * in all units using "no chassis fanless all"
		 * we are setting below variable here
		 * */
		g_fanless_mode_enable[0] = TRUE;
		for(stack_id = 1; stack_id <= MAX_SYS_UNIT_NUM ; stack_id++){

			if(g_fanless_mode_enable[stack_id] == enable)
			{
				continue;
			}
			else
			{
				if(IS_CHASSIS_STACK_EXIST(stack_id))
				{
					g_fanless_mode_enable[stack_id] = enable;
					chassisStackSetFanlessMode(stack_id, enable);
				}
			}
		}
		/* Clearing global flag */
		g_fanless_mode_enable[0] = enable;

	}
	
	if(STACK_AM_I_STANDALONE || STACK_AM_I_MASTER || STACK_AM_I_CB_AND_PE_NUM)
	{
		if(is_fanless_mode_enabled_globally())
			uprintf("Fanless mode enabled in unit(s): %s\n", str);
		else
			uprintf("Fanless mode disabled in unit(s): %s\n", str);
	}
	return;
}


